{
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonObject.java": {
    "add": "{\r\n    members.put(property, value \u003d\u003d null ? JsonNull.INSTANCE : value);\r\n}",
    "getAsJsonObject": "{\r\n    return (JsonObject) members.get(memberName);\r\n}",
    "entrySet": "{\r\n    return members.entrySet();\r\n}",
    "asMap": "{\r\n    // It is safe to expose the underlying map because it disallows null keys and values\r\n    return members;\r\n}",
    "isEmpty": "{\r\n    return members.size() \u003d\u003d 0;\r\n}",
    "addProperty": "{\r\n    add(property, value \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(value));\r\n}",
    "remove": "{\r\n    return members.remove(property);\r\n}",
    "deepCopy": "{\r\n    JsonObject result \u003d new JsonObject();\r\n    for (Map.Entry\u003cString, JsonElement\u003e entry : members.entrySet()) {\r\n        result.add(entry.getKey(), entry.getValue().deepCopy());\r\n    }\r\n    return result;\r\n}",
    "size": "{\r\n    return members.size();\r\n}",
    "getAsJsonArray": "{\r\n    return (JsonArray) members.get(memberName);\r\n}",
    "getAsJsonPrimitive": "{\r\n    return (JsonPrimitive) members.get(memberName);\r\n}",
    "hashCode": "{\r\n    return members.hashCode();\r\n}",
    "get": "{\r\n    return members.get(memberName);\r\n}",
    "equals": "{\r\n    return (o \u003d\u003d this) || (o instanceof JsonObject \u0026\u0026 ((JsonObject) o).members.equals(members));\r\n}",
    "has": "{\r\n    return members.containsKey(memberName);\r\n}",
    "keySet": "{\r\n    return members.keySet();\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\EnumClass.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\$Gson$Types.java": {
    "getMapKeyAndValueTypes": "{\r\n    /*\r\n     * Work around a problem with the declaration of java.util.Properties. That\r\n     * class should extend Hashtable\u003cString, String\u003e, but it\u0027s declared to\r\n     * extend Hashtable\u003cObject, Object\u003e.\r\n     */\r\n    if (context \u003d\u003d Properties.class) {\r\n        // TODO: test subclasses of Properties!\r\n        return new Type[] { String.class, String.class };\r\n    }\r\n    Type mapType \u003d getSupertype(context, contextRawType, Map.class);\r\n    // TODO: strip wildcards?\r\n    if (mapType instanceof ParameterizedType) {\r\n        ParameterizedType mapParameterizedType \u003d (ParameterizedType) mapType;\r\n        return mapParameterizedType.getActualTypeArguments();\r\n    }\r\n    return new Type[] { Object.class, Object.class };\r\n}",
    "getRawType": "{\r\n    return rawType;\r\n}",
    "hashCodeOrZero": "{\r\n    return o !\u003d null ? o.hashCode() : 0;\r\n}",
    "resolve": "{\r\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\r\n    TypeVariable\u003c?\u003e resolving \u003d null;\r\n    while (true) {\r\n        if (toResolve instanceof TypeVariable) {\r\n            TypeVariable\u003c?\u003e typeVariable \u003d (TypeVariable\u003c?\u003e) toResolve;\r\n            Type previouslyResolved \u003d visitedTypeVariables.get(typeVariable);\r\n            if (previouslyResolved !\u003d null) {\r\n                // cannot reduce due to infinite recursion\r\n                return (previouslyResolved \u003d\u003d Void.TYPE) ? toResolve : previouslyResolved;\r\n            }\r\n            // Insert a placeholder to mark the fact that we are in the process of resolving this type\r\n            visitedTypeVariables.put(typeVariable, Void.TYPE);\r\n            if (resolving \u003d\u003d null) {\r\n                resolving \u003d typeVariable;\r\n            }\r\n            toResolve \u003d resolveTypeVariable(context, contextRawType, typeVariable);\r\n            if (toResolve \u003d\u003d typeVariable) {\r\n                break;\r\n            }\r\n        } else if (toResolve instanceof Class \u0026\u0026 ((Class\u003c?\u003e) toResolve).isArray()) {\r\n            Class\u003c?\u003e original \u003d (Class\u003c?\u003e) toResolve;\r\n            Type componentType \u003d original.getComponentType();\r\n            Type newComponentType \u003d resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n            toResolve \u003d equal(componentType, newComponentType) ? original : arrayOf(newComponentType);\r\n            break;\r\n        } else if (toResolve instanceof GenericArrayType) {\r\n            GenericArrayType original \u003d (GenericArrayType) toResolve;\r\n            Type componentType \u003d original.getGenericComponentType();\r\n            Type newComponentType \u003d resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n            toResolve \u003d equal(componentType, newComponentType) ? original : arrayOf(newComponentType);\r\n            break;\r\n        } else if (toResolve instanceof ParameterizedType) {\r\n            ParameterizedType original \u003d (ParameterizedType) toResolve;\r\n            Type ownerType \u003d original.getOwnerType();\r\n            Type newOwnerType \u003d resolve(context, contextRawType, ownerType, visitedTypeVariables);\r\n            boolean changed \u003d !equal(newOwnerType, ownerType);\r\n            Type[] args \u003d original.getActualTypeArguments();\r\n            for (int t \u003d 0, length \u003d args.length; t \u003c length; t++) {\r\n                Type resolvedTypeArgument \u003d resolve(context, contextRawType, args[t], visitedTypeVariables);\r\n                if (!equal(resolvedTypeArgument, args[t])) {\r\n                    if (!changed) {\r\n                        args \u003d args.clone();\r\n                        changed \u003d true;\r\n                    }\r\n                    args[t] \u003d resolvedTypeArgument;\r\n                }\r\n            }\r\n            toResolve \u003d changed ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args) : original;\r\n            break;\r\n        } else if (toResolve instanceof WildcardType) {\r\n            WildcardType original \u003d (WildcardType) toResolve;\r\n            Type[] originalLowerBound \u003d original.getLowerBounds();\r\n            Type[] originalUpperBound \u003d original.getUpperBounds();\r\n            if (originalLowerBound.length \u003d\u003d 1) {\r\n                Type lowerBound \u003d resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\r\n                if (lowerBound !\u003d originalLowerBound[0]) {\r\n                    toResolve \u003d supertypeOf(lowerBound);\r\n                    break;\r\n                }\r\n            } else if (originalUpperBound.length \u003d\u003d 1) {\r\n                Type upperBound \u003d resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\r\n                if (upperBound !\u003d originalUpperBound[0]) {\r\n                    toResolve \u003d subtypeOf(upperBound);\r\n                    break;\r\n                }\r\n            }\r\n            toResolve \u003d original;\r\n            break;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // ensure that any in-process resolution gets updated with the final result\r\n    if (resolving !\u003d null) {\r\n        visitedTypeVariables.put(resolving, toResolve);\r\n    }\r\n    return toResolve;\r\n}",
    "getActualTypeArguments": "{\r\n    return typeArguments.clone();\r\n}",
    "getGenericSupertype": "{\r\n    if (supertype \u003d\u003d rawType) {\r\n        return context;\r\n    }\r\n    // we skip searching through interfaces if unknown is an interface\r\n    if (supertype.isInterface()) {\r\n        Class\u003c?\u003e[] interfaces \u003d rawType.getInterfaces();\r\n        for (int i \u003d 0, length \u003d interfaces.length; i \u003c length; i++) {\r\n            if (interfaces[i] \u003d\u003d supertype) {\r\n                return rawType.getGenericInterfaces()[i];\r\n            } else if (supertype.isAssignableFrom(interfaces[i])) {\r\n                return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], supertype);\r\n            }\r\n        }\r\n    }\r\n    // check our supertypes\r\n    if (!rawType.isInterface()) {\r\n        while (rawType !\u003d Object.class) {\r\n            Class\u003c?\u003e rawSupertype \u003d rawType.getSuperclass();\r\n            if (rawSupertype \u003d\u003d supertype) {\r\n                return rawType.getGenericSuperclass();\r\n            } else if (supertype.isAssignableFrom(rawSupertype)) {\r\n                return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, supertype);\r\n            }\r\n            rawType \u003d rawSupertype;\r\n        }\r\n    }\r\n    // we can\u0027t resolve this further\r\n    return supertype;\r\n}",
    "supertypeOf": "{\r\n    Type[] lowerBounds;\r\n    if (bound instanceof WildcardType) {\r\n        lowerBounds \u003d ((WildcardType) bound).getLowerBounds();\r\n    } else {\r\n        lowerBounds \u003d new Type[] { bound };\r\n    }\r\n    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\r\n}",
    "requiresOwnerType": "{\r\n    if (rawType instanceof Class\u003c?\u003e) {\r\n        Class\u003c?\u003e rawTypeAsClass \u003d (Class\u003c?\u003e) rawType;\r\n        return !Modifier.isStatic(rawTypeAsClass.getModifiers()) \u0026\u0026 rawTypeAsClass.getDeclaringClass() !\u003d null;\r\n    }\r\n    return false;\r\n}",
    "checkNotPrimitive": "{\r\n    checkArgument(!(type instanceof Class\u003c?\u003e) || !((Class\u003c?\u003e) type).isPrimitive());\r\n}",
    "getCollectionElementType": "{\r\n    Type collectionType \u003d getSupertype(context, contextRawType, Collection.class);\r\n    if (collectionType instanceof ParameterizedType) {\r\n        return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\r\n    }\r\n    return Object.class;\r\n}",
    "getGenericComponentType": "{\r\n    return componentType;\r\n}",
    "hashCode": "{\r\n    // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\r\n    return (lowerBound !\u003d null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());\r\n}",
    "getSupertype": "{\r\n    if (context instanceof WildcardType) {\r\n        // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\r\n        Type[] bounds \u003d ((WildcardType) context).getUpperBounds();\r\n        // Currently the JLS only permits one bound for wildcards so using first bound is safe\r\n        assert bounds.length \u003d\u003d 1;\r\n        context \u003d bounds[0];\r\n    }\r\n    checkArgument(supertype.isAssignableFrom(contextRawType));\r\n    return resolve(context, contextRawType, $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\r\n}",
    "indexOf": "{\r\n    for (int i \u003d 0, length \u003d array.length; i \u003c length; i++) {\r\n        if (toFind.equals(array[i])) {\r\n            return i;\r\n        }\r\n    }\r\n    throw new NoSuchElementException();\r\n}",
    "canonicalize": "{\r\n    if (type instanceof Class) {\r\n        Class\u003c?\u003e c \u003d (Class\u003c?\u003e) type;\r\n        return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType p \u003d (ParameterizedType) type;\r\n        return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments());\r\n    } else if (type instanceof GenericArrayType) {\r\n        GenericArrayType g \u003d (GenericArrayType) type;\r\n        return new GenericArrayTypeImpl(g.getGenericComponentType());\r\n    } else if (type instanceof WildcardType) {\r\n        WildcardType w \u003d (WildcardType) type;\r\n        return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\r\n    } else {\r\n        // type is either serializable as-is or unsupported\r\n        return type;\r\n    }\r\n}",
    "subtypeOf": "{\r\n    Type[] upperBounds;\r\n    if (bound instanceof WildcardType) {\r\n        upperBounds \u003d ((WildcardType) bound).getUpperBounds();\r\n    } else {\r\n        upperBounds \u003d new Type[] { bound };\r\n    }\r\n    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\r\n}",
    "arrayOf": "{\r\n    return new GenericArrayTypeImpl(componentType);\r\n}",
    "getLowerBounds": "{\r\n    return lowerBound !\u003d null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\r\n}",
    "newParameterizedTypeWithOwner": "{\r\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\r\n}",
    "getOwnerType": "{\r\n    return ownerType;\r\n}",
    "typeToString": "{\r\n    return type instanceof Class ? ((Class\u003c?\u003e) type).getName() : type.toString();\r\n}",
    "equal": "{\r\n    return Objects.equals(a, b);\r\n}",
    "declaringClassOf": "{\r\n    GenericDeclaration genericDeclaration \u003d typeVariable.getGenericDeclaration();\r\n    return genericDeclaration instanceof Class ? (Class\u003c?\u003e) genericDeclaration : null;\r\n}",
    "equals": "{\r\n    return other instanceof WildcardType \u0026\u0026 $Gson$Types.equals(this, (WildcardType) other);\r\n}",
    "toString": "{\r\n    if (lowerBound !\u003d null) {\r\n        return \"? super \" + typeToString(lowerBound);\r\n    } else if (upperBound \u003d\u003d Object.class) {\r\n        return \"?\";\r\n    } else {\r\n        return \"? extends \" + typeToString(upperBound);\r\n    }\r\n}",
    "getArrayComponentType": "{\r\n    return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class\u003c?\u003e) array).getComponentType();\r\n}",
    "resolveTypeVariable": "{\r\n    Class\u003c?\u003e declaredByRaw \u003d declaringClassOf(unknown);\r\n    // we can\u0027t reduce this further\r\n    if (declaredByRaw \u003d\u003d null) {\r\n        return unknown;\r\n    }\r\n    Type declaredBy \u003d getGenericSupertype(context, contextRawType, declaredByRaw);\r\n    if (declaredBy instanceof ParameterizedType) {\r\n        int index \u003d indexOf(declaredByRaw.getTypeParameters(), unknown);\r\n        return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\r\n    }\r\n    return unknown;\r\n}",
    "getUpperBounds": "{\r\n    return new Type[] { upperBound };\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithNoArgsConstructor.java": {},
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java": {
    "addType": "{\r\n    if (type \u003d\u003d null || instanceCreator \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    instanceCreators.put(type, instanceCreator);\r\n    return this;\r\n}",
    "createInstance": "{\r\n    Graph graph \u003d graphThreadLocal.get();\r\n    if (graph \u003d\u003d null || graph.nextCreate \u003d\u003d null) {\r\n        throw new IllegalStateException(\"Unexpected call to createInstance() for \" + type);\r\n    }\r\n    InstanceCreator\u003c?\u003e creator \u003d instanceCreators.get(type);\r\n    Object result \u003d creator.createInstance(type);\r\n    graph.nextCreate.value \u003d result;\r\n    graph.nextCreate \u003d null;\r\n    return result;\r\n}",
    "read": "{\r\n    if (graph.nextCreate !\u003d null) {\r\n        throw new IllegalStateException(\"Unexpected recursive call to read() for \" + id);\r\n    }\r\n    graph.nextCreate \u003d (Element\u003cObject\u003e) this;\r\n    value \u003d typeAdapter.fromJsonTree(element);\r\n    if (value \u003d\u003d null) {\r\n        throw new IllegalStateException(\"non-null value deserialized to null: \" + element);\r\n    }\r\n}",
    "registerOn": "{\r\n    Factory factory \u003d new Factory(instanceCreators);\r\n    gsonBuilder.registerTypeAdapterFactory(factory);\r\n    for (Map.Entry\u003cType, InstanceCreator\u003c?\u003e\u003e entry : instanceCreators.entrySet()) {\r\n        gsonBuilder.registerTypeAdapter(entry.getKey(), factory);\r\n    }\r\n}",
    "create": "{\r\n    if (!instanceCreators.containsKey(type.getType())) {\r\n        return null;\r\n    }\r\n    final TypeAdapter\u003cT\u003e typeAdapter \u003d gson.getDelegateAdapter(this, type);\r\n    final TypeAdapter\u003cJsonElement\u003e elementAdapter \u003d gson.getAdapter(JsonElement.class);\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            Graph graph \u003d graphThreadLocal.get();\r\n            boolean writeEntireGraph \u003d false;\r\n            /*\r\n           * We have one of two cases:\r\n           *  1. We\u0027ve encountered the first known object in this graph. Write\r\n           *     out the graph, starting with that object.\r\n           *  2. We\u0027ve encountered another graph object in the course of #1.\r\n           *     Just write out this object\u0027s name. We\u0027ll circle back to writing\r\n           *     out the object\u0027s value as a part of #1.\r\n           */\r\n            if (graph \u003d\u003d null) {\r\n                writeEntireGraph \u003d true;\r\n                graph \u003d new Graph(new IdentityHashMap\u003cObject, Element\u003c?\u003e\u003e());\r\n            }\r\n            // graph.map guarantees consistency between value and T\r\n            @SuppressWarnings(\"unchecked\")\r\n            Element\u003cT\u003e element \u003d (Element\u003cT\u003e) graph.map.get(value);\r\n            if (element \u003d\u003d null) {\r\n                element \u003d new Element\u003c\u003e(value, graph.nextName(), typeAdapter, null);\r\n                graph.map.put(value, element);\r\n                graph.queue.add(element);\r\n            }\r\n            if (writeEntireGraph) {\r\n                graphThreadLocal.set(graph);\r\n                try {\r\n                    out.beginObject();\r\n                    Element\u003c?\u003e current;\r\n                    while ((current \u003d graph.queue.poll()) !\u003d null) {\r\n                        out.name(current.id);\r\n                        current.write(out);\r\n                    }\r\n                    out.endObject();\r\n                } finally {\r\n                    graphThreadLocal.remove();\r\n                }\r\n            } else {\r\n                out.value(element.id);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            /*\r\n           * Again we have one of two cases:\r\n           *  1. We\u0027ve encountered the first known object in this graph. Read\r\n           *     the entire graph in as a map from names to their JsonElements.\r\n           *     Then convert the first JsonElement to its Java object.\r\n           *  2. We\u0027ve encountered another graph object in the course of #1.\r\n           *     Read in its name, then deserialize its value from the\r\n           *     JsonElement in our map. We need to do this lazily because we\r\n           *     don\u0027t know which TypeAdapter to use until a value is\r\n           *     encountered in the wild.\r\n           */\r\n            String currentName \u003d null;\r\n            Graph graph \u003d graphThreadLocal.get();\r\n            boolean readEntireGraph \u003d false;\r\n            if (graph \u003d\u003d null) {\r\n                graph \u003d new Graph(new HashMap\u003cObject, Element\u003c?\u003e\u003e());\r\n                readEntireGraph \u003d true;\r\n                // read the entire tree into memory\r\n                in.beginObject();\r\n                while (in.hasNext()) {\r\n                    String name \u003d in.nextName();\r\n                    if (currentName \u003d\u003d null) {\r\n                        currentName \u003d name;\r\n                    }\r\n                    JsonElement element \u003d elementAdapter.read(in);\r\n                    graph.map.put(name, new Element\u003c\u003e(null, name, typeAdapter, element));\r\n                }\r\n                in.endObject();\r\n            } else {\r\n                currentName \u003d in.nextString();\r\n            }\r\n            if (readEntireGraph) {\r\n                graphThreadLocal.set(graph);\r\n            }\r\n            try {\r\n                // graph.map guarantees consistency between value and T\r\n                @SuppressWarnings(\"unchecked\")\r\n                Element\u003cT\u003e element \u003d (Element\u003cT\u003e) graph.map.get(currentName);\r\n                // now that we know the typeAdapter for this name, go from JsonElement to \u0027T\u0027\r\n                if (element.value \u003d\u003d null) {\r\n                    element.typeAdapter \u003d typeAdapter;\r\n                    element.read(graph);\r\n                }\r\n                return element.value;\r\n            } finally {\r\n                if (readEntireGraph) {\r\n                    graphThreadLocal.remove();\r\n                }\r\n            }\r\n        }\r\n    };\r\n}",
    "write": "{\r\n    typeAdapter.write(out, value);\r\n}",
    "nextName": "{\r\n    return \"0x\" + Integer.toHexString(map.size() + 1);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\PrimitiveTypeAdapter.java": {
    "adaptType": "{\r\n    Class\u003c?\u003e aClass \u003d Primitives.wrap(to);\r\n    if (Primitives.isWrapperType(aClass)) {\r\n        if (aClass \u003d\u003d Character.class) {\r\n            String value \u003d from.toString();\r\n            if (value.length() \u003d\u003d 1) {\r\n                return (T) (Character) from.toString().charAt(0);\r\n            }\r\n            throw new JsonParseException(\"The value: \" + value + \" contains more than a character.\");\r\n        }\r\n        try {\r\n            Constructor\u003c?\u003e constructor \u003d aClass.getConstructor(String.class);\r\n            return (T) constructor.newInstance(from.toString());\r\n        } catch (NoSuchMethodException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (InstantiationException e) {\r\n            throw new JsonParseException(e);\r\n        }\r\n    } else if (Enum.class.isAssignableFrom(to)) {\r\n        // Case where the type being adapted to is an Enum\r\n        // We will try to convert from.toString() to the enum\r\n        try {\r\n            Method valuesMethod \u003d to.getMethod(\"valueOf\", String.class);\r\n            return (T) valuesMethod.invoke(null, from.toString());\r\n        } catch (NoSuchMethodException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    } else {\r\n        throw new JsonParseException(\"Can not adapt type \" + from.getClass() + \" to \" + to);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\sql\\SqlDateTypeAdapter.java": {
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String s \u003d in.nextString();\r\n    try {\r\n        Date utilDate;\r\n        synchronized (this) {\r\n            utilDate \u003d format.parse(s);\r\n        }\r\n        return new java.sql.Date(utilDate.getTime());\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as SQL Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "create": "{\r\n    return typeToken.getRawType() \u003d\u003d java.sql.Date.class ? (TypeAdapter\u003cT\u003e) new SqlDateTypeAdapter() : null;\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    String dateString;\r\n    synchronized (this) {\r\n        dateString \u003d format.format(value);\r\n    }\r\n    out.value(dateString);\r\n}"
  },
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\BagOfPrimitivesDeserializationBenchmark.java": {
    "timeBagOfPrimitivesStreaming": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginObject();\r\n        long longValue \u003d 0;\r\n        int intValue \u003d 0;\r\n        boolean booleanValue \u003d false;\r\n        String stringValue \u003d null;\r\n        while (jr.hasNext()) {\r\n            String name \u003d jr.nextName();\r\n            if (name.equals(\"longValue\")) {\r\n                longValue \u003d jr.nextLong();\r\n            } else if (name.equals(\"intValue\")) {\r\n                intValue \u003d jr.nextInt();\r\n            } else if (name.equals(\"booleanValue\")) {\r\n                booleanValue \u003d jr.nextBoolean();\r\n            } else if (name.equals(\"stringValue\")) {\r\n                stringValue \u003d jr.nextString();\r\n            } else {\r\n                throw new IOException(\"Unexpected name: \" + name);\r\n            }\r\n        }\r\n        jr.endObject();\r\n        new BagOfPrimitives(longValue, intValue, booleanValue, stringValue);\r\n    }\r\n}",
    "timeBagOfPrimitivesDefault": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        gson.fromJson(json, BagOfPrimitives.class);\r\n    }\r\n}",
    "setUp": "{\r\n    this.gson \u003d new Gson();\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives(10L, 1, false, \"foo\");\r\n    this.json \u003d gson.toJson(bag);\r\n}",
    "main": "{\r\n    NonUploadingCaliperRunner.run(BagOfPrimitivesDeserializationBenchmark.class, args);\r\n}",
    "timeBagOfPrimitivesReflectionStreaming": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginObject();\r\n        BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n        while (jr.hasNext()) {\r\n            String name \u003d jr.nextName();\r\n            for (Field field : BagOfPrimitives.class.getDeclaredFields()) {\r\n                if (field.getName().equals(name)) {\r\n                    Class\u003c?\u003e fieldType \u003d field.getType();\r\n                    if (fieldType.equals(long.class)) {\r\n                        field.setLong(bag, jr.nextLong());\r\n                    } else if (fieldType.equals(int.class)) {\r\n                        field.setInt(bag, jr.nextInt());\r\n                    } else if (fieldType.equals(boolean.class)) {\r\n                        field.setBoolean(bag, jr.nextBoolean());\r\n                    } else if (fieldType.equals(String.class)) {\r\n                        field.set(bag, jr.nextString());\r\n                    } else {\r\n                        throw new RuntimeException(\"Unexpected: type: \" + fieldType + \", name: \" + name);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        jr.endObject();\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\ConstructorConstructor.java": {
    "newDefaultConstructor": "{\r\n    // Cannot invoke constructor of abstract class\r\n    if (Modifier.isAbstract(rawType.getModifiers())) {\r\n        return null;\r\n    }\r\n    final Constructor\u003c? super T\u003e constructor;\r\n    try {\r\n        constructor \u003d rawType.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException e) {\r\n        return null;\r\n    }\r\n    boolean canAccess \u003d filterResult \u003d\u003d FilterResult.ALLOW || (ReflectionAccessFilterHelper.canAccess(constructor, null) \u0026\u0026 // Be a bit more lenient here for BLOCK_ALL; if constructor is accessible and public then allow calling it\r\n    (filterResult !\u003d FilterResult.BLOCK_ALL || Modifier.isPublic(constructor.getModifiers())));\r\n    if (!canAccess) {\r\n        final String message \u003d \"Unable to invoke no-args constructor of \" + rawType + \";\" + \" constructor is not accessible and ReflectionAccessFilter does not permit making\" + \" it accessible. Register an InstanceCreator or a TypeAdapter for this type, change\" + \" the visibility of the constructor or adjust the access filter.\";\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(message);\r\n            }\r\n        };\r\n    }\r\n    // Only try to make accessible if allowed; in all other cases checks above should\r\n    // have verified that constructor is accessible\r\n    if (filterResult \u003d\u003d FilterResult.ALLOW) {\r\n        final String exceptionMessage \u003d ReflectionHelper.tryMakeAccessible(constructor);\r\n        if (exceptionMessage !\u003d null) {\r\n            /*\r\n         * Create ObjectConstructor which throws exception.\r\n         * This keeps backward compatibility (compared to returning `null` which\r\n         * would then choose another way of creating object).\r\n         * And it supports types which are only serialized but not deserialized\r\n         * (compared to directly throwing exception here), e.g. when runtime type\r\n         * of object is inaccessible, but compile-time type is accessible.\r\n         */\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    // New exception is created every time to avoid keeping reference\r\n                    // to exception with potentially long stack trace, causing a\r\n                    // memory leak\r\n                    throw new JsonIOException(exceptionMessage);\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return new ObjectConstructor\u003cT\u003e() {\r\n\r\n        @Override\r\n        public T construct() {\r\n            try {\r\n                // T is the same raw type as is requested\r\n                @SuppressWarnings(\"unchecked\")\r\n                T newInstance \u003d (T) constructor.newInstance();\r\n                return newInstance;\r\n            }// Note: InstantiationException should be impossible because check at start of method made sure\r\n            //   that class is not abstract\r\n             catch (InstantiationException e) {\r\n                throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with no args\", e);\r\n            } catch (InvocationTargetException e) {\r\n                // TODO: don\u0027t wrap if cause is unchecked?\r\n                // TODO: JsonParseException ?\r\n                throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with no args\", e.getCause());\r\n            } catch (IllegalAccessException e) {\r\n                throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n            }\r\n        }\r\n    };\r\n}",
    "get": "{\r\n    final Type type \u003d typeToken.getType();\r\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    // first try an instance creator\r\n    // types must agree\r\n    @SuppressWarnings(\"unchecked\")\r\n    final InstanceCreator\u003cT\u003e typeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\r\n    if (typeCreator !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                return typeCreator.createInstance(type);\r\n            }\r\n        };\r\n    }\r\n    // Next try raw type match for instance creators\r\n    // types must agree\r\n    @SuppressWarnings(\"unchecked\")\r\n    final InstanceCreator\u003cT\u003e rawTypeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(rawType);\r\n    if (rawTypeCreator !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                return rawTypeCreator.createInstance(type);\r\n            }\r\n        };\r\n    }\r\n    // First consider special constructors before checking for no-args constructors\r\n    // below to avoid matching internal no-args constructors which might be added in\r\n    // future JDK versions\r\n    ObjectConstructor\u003cT\u003e specialConstructor \u003d newSpecialCollectionConstructor(type, rawType);\r\n    if (specialConstructor !\u003d null) {\r\n        return specialConstructor;\r\n    }\r\n    FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, rawType);\r\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType, filterResult);\r\n    if (defaultConstructor !\u003d null) {\r\n        return defaultConstructor;\r\n    }\r\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\r\n    if (defaultImplementation !\u003d null) {\r\n        return defaultImplementation;\r\n    }\r\n    // Check whether type is instantiable; otherwise ReflectionAccessFilter recommendation\r\n    // of adjusting filter suggested below is irrelevant since it would not solve the problem\r\n    final String exceptionMessage \u003d checkInstantiable(rawType);\r\n    if (exceptionMessage !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(exceptionMessage);\r\n            }\r\n        };\r\n    }\r\n    // Consider usage of Unsafe as reflection, so don\u0027t use if BLOCK_ALL\r\n    // Additionally, since it is not calling any constructor at all, don\u0027t use if BLOCK_INACCESSIBLE\r\n    if (filterResult \u003d\u003d FilterResult.ALLOW) {\r\n        // finally try unsafe\r\n        return newUnsafeAllocator(rawType);\r\n    } else {\r\n        final String message \u003d \"Unable to create instance of \" + rawType + \"; ReflectionAccessFilter\" + \" does not permit using reflection or Unsafe. Register an InstanceCreator or a TypeAdapter\" + \" for this type or adjust the access filter to allow using reflection.\";\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(message);\r\n            }\r\n        };\r\n    }\r\n}",
    "checkInstantiable": "{\r\n    int modifiers \u003d c.getModifiers();\r\n    if (Modifier.isInterface(modifiers)) {\r\n        return \"Interfaces can\u0027t be instantiated! Register an InstanceCreator\" + \" or a TypeAdapter for this type. Interface name: \" + c.getName();\r\n    }\r\n    if (Modifier.isAbstract(modifiers)) {\r\n        // R8 performs aggressive optimizations where it removes the default constructor of a class\r\n        // and makes the class `abstract`; check for that here explicitly\r\n        /*\r\n       * Note: Ideally should only show this R8-specific message when it is clear that R8 was\r\n       * used (e.g. when `c.getDeclaredConstructors().length \u003d\u003d 0`), but on Android where this\r\n       * issue with R8 occurs most, R8 seems to keep some constructors for some reason while\r\n       * still making the class abstract\r\n       */\r\n        return \"Abstract classes can\u0027t be instantiated! Adjust the R8 configuration or register\" + \" an InstanceCreator or a TypeAdapter for this type. Class name: \" + c.getName() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"r8-abstract-class\");\r\n    }\r\n    return null;\r\n}",
    "toString": "{\r\n    return instanceCreators.toString();\r\n}",
    "construct": "{\r\n    throw new JsonIOException(exceptionMessageF);\r\n}",
    "newDefaultImplementationConstructor": "{\r\n    /*\r\n     * IMPORTANT: Must only create instances for classes with public no-args constructor.\r\n     * For classes with special constructors / factory methods (e.g. EnumSet)\r\n     * `newSpecialCollectionConstructor` defined above must be used, to avoid no-args\r\n     * constructor check (which is called before this method) detecting internal no-args\r\n     * constructors which might be added in a future JDK version\r\n     */\r\n    if (Collection.class.isAssignableFrom(rawType)) {\r\n        if (SortedSet.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new TreeSet\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (Set.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedHashSet\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (Queue.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ArrayDeque\u003c\u003e();\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ArrayList\u003c\u003e();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    if (Map.class.isAssignableFrom(rawType)) {\r\n        if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ConcurrentSkipListMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ConcurrentHashMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (SortedMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new TreeMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (type instanceof ParameterizedType \u0026\u0026 !String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType())) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedHashMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedTreeMap\u003c\u003e();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}",
    "newSpecialCollectionConstructor": "{\r\n    if (EnumSet.class.isAssignableFrom(rawType)) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                if (type instanceof ParameterizedType) {\r\n                    Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                    if (elementType instanceof Class) {\r\n                        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n                        T set \u003d (T) EnumSet.noneOf((Class) elementType);\r\n                        return set;\r\n                    } else {\r\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n                    }\r\n                } else {\r\n                    throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n                }\r\n            }\r\n        };\r\n    } else // Only support creation of EnumMap, but not of custom subtypes; for them type parameters\r\n    // and constructor parameter might have completely different meaning\r\n    if (rawType \u003d\u003d EnumMap.class) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                if (type instanceof ParameterizedType) {\r\n                    Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                    if (elementType instanceof Class) {\r\n                        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n                        T map \u003d (T) new EnumMap((Class) elementType);\r\n                        return map;\r\n                    } else {\r\n                        throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\r\n                    }\r\n                } else {\r\n                    throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\r\n                }\r\n            }\r\n        };\r\n    }\r\n    return null;\r\n}",
    "newUnsafeAllocator": "{\r\n    if (useJdkUnsafe) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                try {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    T newInstance \u003d (T) UnsafeAllocator.INSTANCE.newInstance(rawType);\r\n                    return newInstance;\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException((\"Unable to create instance of \" + rawType + \".\" + \" Registering an InstanceCreator or a TypeAdapter for this type, or adding a no-args\" + \" constructor may fix this problem.\"), e);\r\n                }\r\n            }\r\n        };\r\n    } else {\r\n        String exceptionMessage \u003d \"Unable to create instance of \" + rawType + \"; usage of JDK Unsafe\" + \" is disabled. Registering an InstanceCreator or a TypeAdapter for this type, adding a no-args\" + \" constructor, or enabling usage of JDK Unsafe may fix this problem.\";\r\n        // Check if R8 removed all constructors\r\n        if (rawType.getDeclaredConstructors().length \u003d\u003d 0) {\r\n            // R8 with Unsafe disabled might not be common enough to warrant a separate Troubleshooting Guide entry\r\n            exceptionMessage +\u003d \" Or adjust your R8 configuration to keep the no-args constructor of the class.\";\r\n        }\r\n        // Explicit final variable to allow usage in the anonymous class below\r\n        final String exceptionMessageF \u003d exceptionMessage;\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(exceptionMessageF);\r\n            }\r\n        };\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ObjectTypeAdapter.java": {
    "tryBeginNesting": "{\r\n    switch(peeked) {\r\n        case BEGIN_ARRAY:\r\n            in.beginArray();\r\n            return new ArrayList\u003c\u003e();\r\n        case BEGIN_OBJECT:\r\n            in.beginObject();\r\n            return new LinkedTreeMap\u003c\u003e();\r\n        default:\r\n            return null;\r\n    }\r\n}",
    "read": "{\r\n    // Either List or Map\r\n    Object current;\r\n    JsonToken peeked \u003d in.peek();\r\n    current \u003d tryBeginNesting(in, peeked);\r\n    if (current \u003d\u003d null) {\r\n        return readTerminal(in, peeked);\r\n    }\r\n    Deque\u003cObject\u003e stack \u003d new ArrayDeque\u003c\u003e();\r\n    while (true) {\r\n        while (in.hasNext()) {\r\n            String name \u003d null;\r\n            // Name is only used for JSON object members\r\n            if (current instanceof Map) {\r\n                name \u003d in.nextName();\r\n            }\r\n            peeked \u003d in.peek();\r\n            Object value \u003d tryBeginNesting(in, peeked);\r\n            boolean isNesting \u003d value !\u003d null;\r\n            if (value \u003d\u003d null) {\r\n                value \u003d readTerminal(in, peeked);\r\n            }\r\n            if (current instanceof List) {\r\n                @SuppressWarnings(\"unchecked\")\r\n                List\u003cObject\u003e list \u003d (List\u003cObject\u003e) current;\r\n                list.add(value);\r\n            } else {\r\n                @SuppressWarnings(\"unchecked\")\r\n                Map\u003cString, Object\u003e map \u003d (Map\u003cString, Object\u003e) current;\r\n                map.put(name, value);\r\n            }\r\n            if (isNesting) {\r\n                stack.addLast(current);\r\n                current \u003d value;\r\n            }\r\n        }\r\n        // End current element\r\n        if (current instanceof List) {\r\n            in.endArray();\r\n        } else {\r\n            in.endObject();\r\n        }\r\n        if (stack.isEmpty()) {\r\n            return current;\r\n        } else {\r\n            // Continue with enclosing element\r\n            current \u003d stack.removeLast();\r\n        }\r\n    }\r\n}",
    "newFactory": "{\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            if (type.getRawType() \u003d\u003d Object.class) {\r\n                return (TypeAdapter\u003cT\u003e) new ObjectTypeAdapter(gson, toNumberStrategy);\r\n            }\r\n            return null;\r\n        }\r\n    };\r\n}",
    "readTerminal": "{\r\n    switch(peeked) {\r\n        case STRING:\r\n            return in.nextString();\r\n        case NUMBER:\r\n            return toNumberStrategy.readNumber(in);\r\n        case BOOLEAN:\r\n            return in.nextBoolean();\r\n        case NULL:\r\n            in.nextNull();\r\n            return null;\r\n        default:\r\n            // When read(JsonReader) is called with JsonReader in invalid state\r\n            throw new IllegalStateException(\"Unexpected token: \" + peeked);\r\n    }\r\n}",
    "create": "{\r\n    if (type.getRawType() \u003d\u003d Object.class) {\r\n        return (TypeAdapter\u003cT\u003e) new ObjectTypeAdapter(gson, toNumberStrategy);\r\n    }\r\n    return null;\r\n}",
    "getFactory": "{\r\n    if (toNumberStrategy \u003d\u003d ToNumberPolicy.DOUBLE) {\r\n        return DOUBLE_FACTORY;\r\n    } else {\r\n        return newFactory(toNumberStrategy);\r\n    }\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cObject\u003e typeAdapter \u003d (TypeAdapter\u003cObject\u003e) gson.getAdapter(value.getClass());\r\n    if (typeAdapter instanceof ObjectTypeAdapter) {\r\n        out.beginObject();\r\n        out.endObject();\r\n        return;\r\n    }\r\n    typeAdapter.write(out, value);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\Strictness.java": {},
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithHasArgsConstructor.java": {},
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\Main.java": {
    "testEnumSerializedName": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Enum SerializedName\", () -\u003e toJson(gson, EnumClassWithSerializedName.FIRST));\r\n    TestExecutor.run(outputConsumer, \"Read: Enum SerializedName\", () -\u003e fromJson(gson, \"\\\"two\\\"\", EnumClassWithSerializedName.class).toString());\r\n}",
    "testVersionAnnotations": "{\r\n    Gson gson \u003d new GsonBuilder().setVersion(1).create();\r\n    TestExecutor.run(outputConsumer, \"Write: Version annotations\", () -\u003e toJson(gson, new ClassWithVersionAnnotations()));\r\n}",
    "testTypeTokenWriteRead": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: TypeToken \" + description, () -\u003e gson.toJson(Arrays.asList(new ClassWithAdapter(1)), typeTokenSupplier.get().getType()));\r\n    TestExecutor.run(outputConsumer, \"Read: TypeToken \" + description, () -\u003e {\r\n        Object deserialized \u003d gson.fromJson(\"[{\\\"custom\\\": 3}]\", typeTokenSupplier.get());\r\n        return deserialized.toString();\r\n    });\r\n}",
    "testGenericClasses": "{\r\n    Gson gson \u003d new Gson();\r\n    TestExecutor.run(outputConsumer, \"Read: Generic TypeToken\", () -\u003e gson.fromJson(\"{\\\"t\\\": 1}\", new TypeToken\u003cGenericClass\u003cDummyClass\u003e\u003e() {\r\n    }).toString());\r\n    TestExecutor.run(outputConsumer, \"Read: Using Generic\", () -\u003e fromJson(gson, \"{\\\"g\\\": {\\\"t\\\": 1}}\", UsingGenericClass.class).toString());\r\n    TestExecutor.run(outputConsumer, \"Read: Using Generic TypeToken\", () -\u003e gson.fromJson(\"{\\\"g\\\": {\\\"t\\\": 1}}\", new TypeToken\u003cGenericUsingGenericClass\u003cDummyClass\u003e\u003e() {\r\n    }).toString());\r\n}",
    "testEnum": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Enum\", () -\u003e toJson(gson, EnumClass.FIRST));\r\n    TestExecutor.run(outputConsumer, \"Read: Enum\", () -\u003e fromJson(gson, \"\\\"SECOND\\\"\", EnumClass.class).toString());\r\n}",
    "toJson": "{\r\n    return gson.toJson(same(obj));\r\n}",
    "testNoJdkUnsafe": "{\r\n    Gson gson \u003d new GsonBuilder().disableJdkUnsafe().create();\r\n    TestExecutor.run(outputConsumer, \"Read: No JDK Unsafe; initial constructor value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n    TestExecutor.run(outputConsumer, \"Read: No JDK Unsafe; custom value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "testUnreferencedConstructorNoArgs": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    // No write because we\u0027re not referencing this class\u0027s constructor.\r\n    // This runs the no-args constructor.\r\n    TestExecutor.run(outputConsumer, \"Read: Unreferenced no args constructor; initial constructor value\", () -\u003e {\r\n        ClassWithUnreferencedNoArgsConstructor deserialized \u003d fromJson(gson, \"{}\", ClassWithUnreferencedNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n    TestExecutor.run(outputConsumer, \"Read: Unreferenced no args constructor; custom value\", () -\u003e {\r\n        ClassWithUnreferencedNoArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithUnreferencedNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "testUnreferencedConstructorHasArgs": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    // No write because we\u0027re not referencing this class\u0027s constructor.\r\n    // This most likely relies on JDK Unsafe (unless the shrinker rewrites the constructor in some way)\r\n    TestExecutor.run(outputConsumer, \"Read: Unreferenced constructor with args\", () -\u003e {\r\n        ClassWithUnreferencedHasArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithUnreferencedHasArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "testConstructorNoArgs": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: No args constructor\", () -\u003e toJson(gson, new ClassWithNoArgsConstructor()));\r\n    TestExecutor.run(outputConsumer, \"Read: No args constructor; initial constructor value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n    TestExecutor.run(outputConsumer, \"Read: No args constructor; custom value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "testJsonAdapterAnnotation": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: JsonAdapter on fields\", () -\u003e toJson(gson, new ClassWithJsonAdapterAnnotation(1, 2, 3, 4)));\r\n    String json \u003d \"{\\\"f1\\\": 1, \\\"f2\\\": 2, \\\"f3\\\": {\\\"s\\\": \\\"3\\\"}, \\\"f4\\\": 4}\";\r\n    TestExecutor.run(outputConsumer, \"Read: JsonAdapter on fields\", () -\u003e fromJson(gson, json, ClassWithJsonAdapterAnnotation.class).toString());\r\n}",
    "runTests": "{\r\n    // Create the TypeToken instances on demand because creation of them can fail when\r\n    // generic signatures were erased\r\n    testTypeTokenWriteRead(outputConsumer, \"anonymous\", () -\u003e new TypeToken\u003cList\u003cClassWithAdapter\u003e\u003e() {\r\n    });\r\n    testTypeTokenWriteRead(outputConsumer, \"manual\", () -\u003e TypeToken.getParameterized(List.class, ClassWithAdapter.class));\r\n    testNamedFields(outputConsumer);\r\n    testSerializedName(outputConsumer);\r\n    testConstructorNoArgs(outputConsumer);\r\n    testConstructorHasArgs(outputConsumer);\r\n    testUnreferencedConstructorNoArgs(outputConsumer);\r\n    testUnreferencedConstructorHasArgs(outputConsumer);\r\n    testNoJdkUnsafe(outputConsumer);\r\n    testEnum(outputConsumer);\r\n    testEnumSerializedName(outputConsumer);\r\n    testExposeAnnotation(outputConsumer);\r\n    testVersionAnnotations(outputConsumer);\r\n    testJsonAdapterAnnotation(outputConsumer);\r\n    testGenericClasses(outputConsumer);\r\n}",
    "testConstructorHasArgs": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Constructor with args\", () -\u003e toJson(gson, new ClassWithHasArgsConstructor(2)));\r\n    // This most likely relies on JDK Unsafe (unless the shrinker rewrites the constructor in some way)\r\n    TestExecutor.run(outputConsumer, \"Read: Constructor with args\", () -\u003e {\r\n        ClassWithHasArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithHasArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "fromJson": "{\r\n    return gson.fromJson(json, same(c));\r\n}",
    "testSerializedName": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: SerializedName\", () -\u003e toJson(gson, new ClassWithSerializedName(2)));\r\n    TestExecutor.run(outputConsumer, \"Read: SerializedName\", () -\u003e {\r\n        ClassWithSerializedName deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithSerializedName.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "testNamedFields": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Named fields\", () -\u003e toJson(gson, new ClassWithNamedFields(2)));\r\n    TestExecutor.run(outputConsumer, \"Read: Named fields\", () -\u003e {\r\n        ClassWithNamedFields deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithNamedFields.class);\r\n        return Integer.toString(deserialized.myField);\r\n    });\r\n}",
    "testExposeAnnotation": "{\r\n    Gson gson \u003d new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();\r\n    TestExecutor.run(outputConsumer, \"Write: @Expose\", () -\u003e toJson(gson, new ClassWithExposeAnnotation()));\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonIOException.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\sql\\SqlTypesSupport.java": {
    "deserialize": "{\r\n    return new Timestamp(date.getTime());\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java": {
    "createDuplicateFieldException": "{\r\n    throw new IllegalArgumentException(\"Class \" + declaringType.getName() + \" declares multiple JSON fields named \u0027\" + duplicateName + \"\u0027; conflict is caused\" + \" by fields \" + ReflectionHelper.fieldToString(field1) + \" and \" + ReflectionHelper.fieldToString(field2) + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\r\n}",
    "primitiveDefaults": "{\r\n    Map\u003cClass\u003c?\u003e, Object\u003e zeroes \u003d new HashMap\u003c\u003e();\r\n    zeroes.put(byte.class, (byte) 0);\r\n    zeroes.put(short.class, (short) 0);\r\n    zeroes.put(int.class, 0);\r\n    zeroes.put(long.class, 0L);\r\n    zeroes.put(float.class, 0F);\r\n    zeroes.put(double.class, 0D);\r\n    zeroes.put(char.class, \u0027\\0\u0027);\r\n    zeroes.put(boolean.class, false);\r\n    return zeroes;\r\n}",
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    A accumulator \u003d createAccumulator();\r\n    Map\u003cString, BoundField\u003e deserializedFields \u003d fieldsData.deserializedFields;\r\n    try {\r\n        in.beginObject();\r\n        while (in.hasNext()) {\r\n            String name \u003d in.nextName();\r\n            BoundField field \u003d deserializedFields.get(name);\r\n            if (field \u003d\u003d null) {\r\n                in.skipValue();\r\n            } else {\r\n                readField(accumulator, in, field);\r\n            }\r\n        }\r\n    } catch (IllegalStateException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IllegalAccessException e) {\r\n        throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n    }\r\n    in.endObject();\r\n    return finalize(accumulator);\r\n}",
    "checkAccessible": "{\r\n    if (!ReflectionAccessFilterHelper.canAccess(member, Modifier.isStatic(member.getModifiers()) ? null : object)) {\r\n        String memberDescription \u003d ReflectionHelper.getAccessibleObjectDescription(member, true);\r\n        throw new JsonIOException(memberDescription + \" is not accessible and ReflectionAccessFilter does not\" + \" permit making it accessible. Register a TypeAdapter for the declaring type, adjust the\" + \" access filter or increase the visibility of the element and its declaring type.\");\r\n    }\r\n}",
    "getFieldNames": "{\r\n    SerializedName annotation \u003d f.getAnnotation(SerializedName.class);\r\n    if (annotation \u003d\u003d null) {\r\n        String name \u003d fieldNamingPolicy.translateName(f);\r\n        return Collections.singletonList(name);\r\n    }\r\n    String serializedName \u003d annotation.value();\r\n    String[] alternates \u003d annotation.alternate();\r\n    if (alternates.length \u003d\u003d 0) {\r\n        return Collections.singletonList(serializedName);\r\n    }\r\n    List\u003cString\u003e fieldNames \u003d new ArrayList\u003c\u003e(alternates.length + 1);\r\n    fieldNames.add(serializedName);\r\n    Collections.addAll(fieldNames, alternates);\r\n    return fieldNames;\r\n}",
    "readIntoField": "{\r\n    Object fieldValue \u003d typeAdapter.read(reader);\r\n    if (fieldValue !\u003d null || !isPrimitive) {\r\n        if (blockInaccessible) {\r\n            checkAccessible(target, field);\r\n        } else if (isStaticFinalField) {\r\n            // Reflection does not permit setting value of `static final` field, even after calling `setAccessible`\r\n            // Handle this here to avoid causing IllegalAccessException when calling `Field.set`\r\n            String fieldDescription \u003d ReflectionHelper.getAccessibleObjectDescription(field, false);\r\n            throw new JsonIOException(\"Cannot set value of \u0027static final\u0027 \" + fieldDescription);\r\n        }\r\n        field.set(target, fieldValue);\r\n    }\r\n}",
    "readIntoArray": "{\r\n    Object fieldValue \u003d typeAdapter.read(reader);\r\n    if (fieldValue \u003d\u003d null \u0026\u0026 isPrimitive) {\r\n        throw new JsonParseException(\"null is not allowed as value for record component \u0027\" + fieldName + \"\u0027\" + \" of primitive type; at path \" + reader.getPath());\r\n    }\r\n    target[index] \u003d fieldValue;\r\n}",
    "createAccumulator": "{\r\n    return constructorArgsDefaults.clone();\r\n}",
    "includeField": "{\r\n    return !excluder.excludeClass(f.getType(), serialize) \u0026\u0026 !excluder.excludeField(f, serialize);\r\n}",
    "createBoundField": "{\r\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\r\n    int modifiers \u003d field.getModifiers();\r\n    final boolean isStaticFinalField \u003d Modifier.isStatic(modifiers) \u0026\u0026 Modifier.isFinal(modifiers);\r\n    JsonAdapter annotation \u003d field.getAnnotation(JsonAdapter.class);\r\n    TypeAdapter\u003c?\u003e mapped \u003d null;\r\n    if (annotation !\u003d null) {\r\n        // This is not safe; requires that user has specified correct adapter class for @JsonAdapter\r\n        mapped \u003d jsonAdapterFactory.getTypeAdapter(constructorConstructor, context, fieldType, annotation, false);\r\n    }\r\n    final boolean jsonAdapterPresent \u003d mapped !\u003d null;\r\n    if (mapped \u003d\u003d null)\r\n        mapped \u003d context.getAdapter(fieldType);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final TypeAdapter\u003cObject\u003e typeAdapter \u003d (TypeAdapter\u003cObject\u003e) mapped;\r\n    final TypeAdapter\u003cObject\u003e writeTypeAdapter;\r\n    if (serialize) {\r\n        writeTypeAdapter \u003d jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper\u003c\u003e(context, typeAdapter, fieldType.getType());\r\n    } else {\r\n        // Will never actually be used, but we set it to avoid confusing nullness-analysis tools\r\n        writeTypeAdapter \u003d typeAdapter;\r\n    }\r\n    return new BoundField(serializedName, field) {\r\n\r\n        @Override\r\n        void write(JsonWriter writer, Object source) throws IOException, IllegalAccessException {\r\n            if (blockInaccessible) {\r\n                if (accessor \u003d\u003d null) {\r\n                    checkAccessible(source, field);\r\n                } else {\r\n                    // Note: This check might actually be redundant because access check for canonical\r\n                    // constructor should have failed already\r\n                    checkAccessible(source, accessor);\r\n                }\r\n            }\r\n            Object fieldValue;\r\n            if (accessor !\u003d null) {\r\n                try {\r\n                    fieldValue \u003d accessor.invoke(source);\r\n                } catch (InvocationTargetException e) {\r\n                    String accessorDescription \u003d ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                    throw new JsonIOException(\"Accessor \" + accessorDescription + \" threw exception\", e.getCause());\r\n                }\r\n            } else {\r\n                fieldValue \u003d field.get(source);\r\n            }\r\n            if (fieldValue \u003d\u003d source) {\r\n                // avoid direct recursion\r\n                return;\r\n            }\r\n            writer.name(serializedName);\r\n            writeTypeAdapter.write(writer, fieldValue);\r\n        }\r\n\r\n        @Override\r\n        void readIntoArray(JsonReader reader, int index, Object[] target) throws IOException, JsonParseException {\r\n            Object fieldValue \u003d typeAdapter.read(reader);\r\n            if (fieldValue \u003d\u003d null \u0026\u0026 isPrimitive) {\r\n                throw new JsonParseException(\"null is not allowed as value for record component \u0027\" + fieldName + \"\u0027\" + \" of primitive type; at path \" + reader.getPath());\r\n            }\r\n            target[index] \u003d fieldValue;\r\n        }\r\n\r\n        @Override\r\n        void readIntoField(JsonReader reader, Object target) throws IOException, IllegalAccessException {\r\n            Object fieldValue \u003d typeAdapter.read(reader);\r\n            if (fieldValue !\u003d null || !isPrimitive) {\r\n                if (blockInaccessible) {\r\n                    checkAccessible(target, field);\r\n                } else if (isStaticFinalField) {\r\n                    // Reflection does not permit setting value of `static final` field, even after calling `setAccessible`\r\n                    // Handle this here to avoid causing IllegalAccessException when calling `Field.set`\r\n                    String fieldDescription \u003d ReflectionHelper.getAccessibleObjectDescription(field, false);\r\n                    throw new JsonIOException(\"Cannot set value of \u0027static final\u0027 \" + fieldDescription);\r\n                }\r\n                field.set(target, fieldValue);\r\n            }\r\n        }\r\n    };\r\n}",
    "readField": "{\r\n    // Obtain the component index from the name of the field backing it\r\n    Integer componentIndex \u003d componentIndices.get(field.fieldName);\r\n    if (componentIndex \u003d\u003d null) {\r\n        throw new IllegalStateException(\"Could not find the index in the constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" for field with name \u0027\" + field.fieldName + \"\u0027,\" + \" unable to determine which argument in the constructor the field corresponds\" + \" to. This is unexpected behavior, as we expect the RecordComponents to have the\" + \" same names as the fields in the Java class, and that the order of the\" + \" RecordComponents is the same as the order of the canonical constructor parameters.\");\r\n    }\r\n    field.readIntoArray(in, componentIndex, accumulator);\r\n}",
    "create": "{\r\n    Class\u003c? super T\u003e raw \u003d type.getRawType();\r\n    if (!Object.class.isAssignableFrom(raw)) {\r\n        // it\u0027s a primitive!\r\n        return null;\r\n    }\r\n    FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n    if (filterResult \u003d\u003d FilterResult.BLOCK_ALL) {\r\n        throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \". Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n    boolean blockInaccessible \u003d filterResult \u003d\u003d FilterResult.BLOCK_INACCESSIBLE;\r\n    // If the type is actually a Java Record, we need to use the RecordAdapter instead. This will always be false\r\n    // on JVMs that do not support records.\r\n    if (ReflectionHelper.isRecord(raw)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e adapter \u003d (TypeAdapter\u003cT\u003e) new RecordAdapter\u003c\u003e(raw, getBoundFields(gson, type, raw, blockInaccessible, true), blockInaccessible);\r\n        return adapter;\r\n    }\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(type);\r\n    return new FieldReflectionAdapter\u003c\u003e(constructor, getBoundFields(gson, type, raw, blockInaccessible, false));\r\n}",
    "finalize": "{\r\n    try {\r\n        return constructor.newInstance(accumulator);\r\n    } catch (IllegalAccessException e) {\r\n        throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n    }// Note: InstantiationException should be impossible because record class is not abstract;\r\n    //  IllegalArgumentException should not be possible unless a bad adapter returns objects of the wrong type\r\n     catch (InstantiationException | IllegalArgumentException e) {\r\n        throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with args \" + Arrays.toString(accumulator), e);\r\n    } catch (InvocationTargetException e) {\r\n        // TODO: JsonParseException ?\r\n        throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with args \" + Arrays.toString(accumulator), e.getCause());\r\n    }\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginObject();\r\n    try {\r\n        for (BoundField boundField : fieldsData.serializedFields) {\r\n            boundField.write(out, value);\r\n        }\r\n    } catch (IllegalAccessException e) {\r\n        throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n    }\r\n    out.endObject();\r\n}",
    "getBoundFields": "{\r\n    if (raw.isInterface()) {\r\n        return FieldsData.EMPTY;\r\n    }\r\n    Map\u003cString, BoundField\u003e deserializedFields \u003d new LinkedHashMap\u003c\u003e();\r\n    // For serialized fields use a Map to track duplicate field names; otherwise this could be a List\u003cBoundField\u003e instead\r\n    Map\u003cString, BoundField\u003e serializedFields \u003d new LinkedHashMap\u003c\u003e();\r\n    Class\u003c?\u003e originalRaw \u003d raw;\r\n    while (raw !\u003d Object.class) {\r\n        Field[] fields \u003d raw.getDeclaredFields();\r\n        // For inherited fields, check if access to their declaring class is allowed\r\n        if (raw !\u003d originalRaw \u0026\u0026 fields.length \u003e 0) {\r\n            FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n            if (filterResult \u003d\u003d FilterResult.BLOCK_ALL) {\r\n                throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\" + \" or adjust the access filter.\");\r\n            }\r\n            blockInaccessible \u003d filterResult \u003d\u003d FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n        for (Field field : fields) {\r\n            boolean serialize \u003d includeField(field, true);\r\n            boolean deserialize \u003d includeField(field, false);\r\n            if (!serialize \u0026\u0026 !deserialize) {\r\n                continue;\r\n            }\r\n            // The accessor method is only used for records. If the type is a record, we will read out values\r\n            // via its accessor method instead of via reflection. This way we will bypass the accessible restrictions\r\n            Method accessor \u003d null;\r\n            if (isRecord) {\r\n                // If there is a static field on a record, there will not be an accessor. Instead we will use the default\r\n                // field serialization logic, but for deserialization the field is excluded for simplicity. Note that Gson\r\n                // ignores static fields by default, but GsonBuilder.excludeFieldsWithModifiers can overwrite this.\r\n                if (Modifier.isStatic(field.getModifiers())) {\r\n                    deserialize \u003d false;\r\n                } else {\r\n                    accessor \u003d ReflectionHelper.getAccessor(raw, field);\r\n                    // If blockInaccessible, skip and perform access check later\r\n                    if (!blockInaccessible) {\r\n                        ReflectionHelper.makeAccessible(accessor);\r\n                    }\r\n                    // @SerializedName can be placed on accessor method, but it is not supported there\r\n                    // If field and method have annotation it is not easily possible to determine if accessor method\r\n                    // is implicit and has inherited annotation, or if it is explicitly declared with custom annotation\r\n                    if (accessor.getAnnotation(SerializedName.class) !\u003d null \u0026\u0026 field.getAnnotation(SerializedName.class) \u003d\u003d null) {\r\n                        String methodDescription \u003d ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                        throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\r\n                    }\r\n                }\r\n            }\r\n            // If blockInaccessible, skip and perform access check later\r\n            // For Records if the accessor method is used the field does not have to be made accessible\r\n            if (!blockInaccessible \u0026\u0026 accessor \u003d\u003d null) {\r\n                ReflectionHelper.makeAccessible(field);\r\n            }\r\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\r\n            List\u003cString\u003e fieldNames \u003d getFieldNames(field);\r\n            String serializedName \u003d fieldNames.get(0);\r\n            BoundField boundField \u003d createBoundField(context, field, accessor, serializedName, TypeToken.get(fieldType), serialize, blockInaccessible);\r\n            if (deserialize) {\r\n                for (String name : fieldNames) {\r\n                    BoundField replaced \u003d deserializedFields.put(name, boundField);\r\n                    if (replaced !\u003d null) {\r\n                        throw createDuplicateFieldException(originalRaw, name, replaced.field, field);\r\n                    }\r\n                }\r\n            }\r\n            if (serialize) {\r\n                BoundField replaced \u003d serializedFields.put(serializedName, boundField);\r\n                if (replaced !\u003d null) {\r\n                    throw createDuplicateFieldException(originalRaw, serializedName, replaced.field, field);\r\n                }\r\n            }\r\n        }\r\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\r\n        raw \u003d type.getRawType();\r\n    }\r\n    return new FieldsData(deserializedFields, new ArrayList\u003c\u003e(serializedFields.values()));\r\n}"
  },
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\NonUploadingCaliperRunner.java": {
    "run": "{\r\n    // Disable result upload; Caliper uploads results to webapp by default, see https://github.com/google/caliper/issues/356\r\n    CaliperMain.main(c, concat(\"-Cresults.upload.options.url\u003d\", args));\r\n}",
    "concat": "{\r\n    if (others.length \u003d\u003d 0) {\r\n        return new String[] { first };\r\n    } else {\r\n        String[] result \u003d new String[others.length + 1];\r\n        result[0] \u003d first;\r\n        System.arraycopy(others, 0, result, 1, others.length);\r\n        return result;\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\ReflectionAccessFilterHelper.java": {
    "canAccess": "{\r\n    // Cannot determine whether object can be accessed, so assume it can be accessed\r\n    return true;\r\n}",
    "isAndroidType": "{\r\n    return className.startsWith(\"android.\") || className.startsWith(\"androidx.\") || isJavaType(className);\r\n}",
    "isAnyPlatformType": "{\r\n    String className \u003d c.getName();\r\n    return // Covers Android and Java\r\n    isAndroidType(className) || className.startsWith(\"kotlin.\") || className.startsWith(\"kotlinx.\") || className.startsWith(\"scala.\");\r\n}",
    "isJavaType": "{\r\n    return className.startsWith(\"java.\") || className.startsWith(\"javax.\");\r\n}",
    "getFilterResult": "{\r\n    for (ReflectionAccessFilter filter : reflectionFilters) {\r\n        FilterResult result \u003d filter.check(c);\r\n        if (result !\u003d FilterResult.INDECISIVE) {\r\n            return result;\r\n        }\r\n    }\r\n    return FilterResult.ALLOW;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\Excluder.java": {
    "isValidSince": "{\r\n    if (annotation !\u003d null) {\r\n        double annotationVersion \u003d annotation.value();\r\n        return version \u003e\u003d annotationVersion;\r\n    }\r\n    return true;\r\n}",
    "isStatic": "{\r\n    return (clazz.getModifiers() \u0026 Modifier.STATIC) !\u003d 0;\r\n}",
    "read": "{\r\n    if (skipDeserialize) {\r\n        in.skipValue();\r\n        return null;\r\n    }\r\n    return delegate().read(in);\r\n}",
    "excludeClassInStrategy": "{\r\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\r\n    for (ExclusionStrategy exclusionStrategy : list) {\r\n        if (exclusionStrategy.shouldSkipClass(clazz)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "disableInnerClassSerialization": "{\r\n    Excluder result \u003d clone();\r\n    result.serializeInnerClasses \u003d false;\r\n    return result;\r\n}",
    "withModifiers": "{\r\n    Excluder result \u003d clone();\r\n    result.modifiers \u003d 0;\r\n    for (int modifier : modifiers) {\r\n        result.modifiers |\u003d modifier;\r\n    }\r\n    return result;\r\n}",
    "withVersion": "{\r\n    Excluder result \u003d clone();\r\n    result.version \u003d ignoreVersionsAfter;\r\n    return result;\r\n}",
    "isValidUntil": "{\r\n    if (annotation !\u003d null) {\r\n        double annotationVersion \u003d annotation.value();\r\n        return version \u003c annotationVersion;\r\n    }\r\n    return true;\r\n}",
    "excludeField": "{\r\n    if ((modifiers \u0026 field.getModifiers()) !\u003d 0) {\r\n        return true;\r\n    }\r\n    if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\r\n        return true;\r\n    }\r\n    if (field.isSynthetic()) {\r\n        return true;\r\n    }\r\n    if (requireExpose) {\r\n        Expose annotation \u003d field.getAnnotation(Expose.class);\r\n        if (annotation \u003d\u003d null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(field.getType())) {\r\n        return true;\r\n    }\r\n    if (isAnonymousOrNonStaticLocal(field.getType())) {\r\n        return true;\r\n    }\r\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\r\n    if (!list.isEmpty()) {\r\n        FieldAttributes fieldAttributes \u003d new FieldAttributes(field);\r\n        for (ExclusionStrategy exclusionStrategy : list) {\r\n            if (exclusionStrategy.shouldSkipField(fieldAttributes)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "delegate": "{\r\n    TypeAdapter\u003cT\u003e d \u003d delegate;\r\n    return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\r\n}",
    "withExclusionStrategy": "{\r\n    Excluder result \u003d clone();\r\n    if (serialization) {\r\n        result.serializationStrategies \u003d new ArrayList\u003c\u003e(serializationStrategies);\r\n        result.serializationStrategies.add(exclusionStrategy);\r\n    }\r\n    if (deserialization) {\r\n        result.deserializationStrategies \u003d new ArrayList\u003c\u003e(deserializationStrategies);\r\n        result.deserializationStrategies.add(exclusionStrategy);\r\n    }\r\n    return result;\r\n}",
    "excludeClassChecks": "{\r\n    if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\r\n        return true;\r\n    }\r\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(clazz)) {\r\n        return true;\r\n    }\r\n    return isAnonymousOrNonStaticLocal(clazz);\r\n}",
    "clone": "{\r\n    try {\r\n        return (Excluder) super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}",
    "create": "{\r\n    Class\u003c?\u003e rawType \u003d type.getRawType();\r\n    boolean excludeClass \u003d excludeClassChecks(rawType);\r\n    final boolean skipSerialize \u003d excludeClass || excludeClassInStrategy(rawType, true);\r\n    final boolean skipDeserialize \u003d excludeClass || excludeClassInStrategy(rawType, false);\r\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\r\n        return null;\r\n    }\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        /**\r\n         * The delegate is lazily created because it may not be needed, and creating it may fail.\r\n         */\r\n        private TypeAdapter\u003cT\u003e delegate;\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            if (skipDeserialize) {\r\n                in.skipValue();\r\n                return null;\r\n            }\r\n            return delegate().read(in);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (skipSerialize) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            delegate().write(out, value);\r\n        }\r\n\r\n        private TypeAdapter\u003cT\u003e delegate() {\r\n            TypeAdapter\u003cT\u003e d \u003d delegate;\r\n            return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\r\n        }\r\n    };\r\n}",
    "excludeClass": "{\r\n    return excludeClassChecks(clazz) || excludeClassInStrategy(clazz, serialize);\r\n}",
    "isAnonymousOrNonStaticLocal": "{\r\n    return !Enum.class.isAssignableFrom(clazz) \u0026\u0026 !isStatic(clazz) \u0026\u0026 (clazz.isAnonymousClass() || clazz.isLocalClass());\r\n}",
    "write": "{\r\n    if (skipSerialize) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    delegate().write(out, value);\r\n}",
    "excludeFieldsWithoutExposeAnnotation": "{\r\n    Excluder result \u003d clone();\r\n    result.requireExpose \u003d true;\r\n    return result;\r\n}",
    "isInnerClass": "{\r\n    return clazz.isMemberClass() \u0026\u0026 !isStatic(clazz);\r\n}",
    "isValidVersion": "{\r\n    return isValidSince(since) \u0026\u0026 isValidUntil(until);\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\UtcDateTypeAdapter.java": {
    "parseInt": "{\r\n    if (beginIndex \u003c 0 || endIndex \u003e value.length() || beginIndex \u003e endIndex) {\r\n        throw new NumberFormatException(value);\r\n    }\r\n    // use same logic as in Integer.parseInt() but less generic we\u0027re not supporting negative values\r\n    int i \u003d beginIndex;\r\n    int result \u003d 0;\r\n    int digit;\r\n    if (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value);\r\n        }\r\n        result \u003d -digit;\r\n    }\r\n    while (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value);\r\n        }\r\n        result *\u003d 10;\r\n        result -\u003d digit;\r\n    }\r\n    return -result;\r\n}",
    "read": "{\r\n    try {\r\n        switch(in.peek()) {\r\n            case NULL:\r\n                in.nextNull();\r\n                return null;\r\n            default:\r\n                String date \u003d in.nextString();\r\n                // Instead of using iso8601Format.parse(value), we use Jackson\u0027s date parsing\r\n                // This is because Android doesn\u0027t support XXX because it is JDK 1.6\r\n                return parse(date, new ParsePosition(0));\r\n        }\r\n    } catch (ParseException e) {\r\n        throw new JsonParseException(e);\r\n    }\r\n}",
    "format": "{\r\n    Calendar calendar \u003d new GregorianCalendar(tz, Locale.US);\r\n    calendar.setTime(date);\r\n    // estimate capacity of buffer as close as we can (yeah, that\u0027s pedantic ;)\r\n    int capacity \u003d \"yyyy-MM-ddThh:mm:ss\".length();\r\n    capacity +\u003d millis ? \".sss\".length() : 0;\r\n    capacity +\u003d tz.getRawOffset() \u003d\u003d 0 ? \"Z\".length() : \"+hh:mm\".length();\r\n    StringBuilder formatted \u003d new StringBuilder(capacity);\r\n    padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\r\n    formatted.append(\u0027T\u0027);\r\n    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\r\n    if (millis) {\r\n        formatted.append(\u0027.\u0027);\r\n        padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\r\n    }\r\n    int offset \u003d tz.getOffset(calendar.getTimeInMillis());\r\n    if (offset !\u003d 0) {\r\n        int hours \u003d Math.abs((offset / (60 * 1000)) / 60);\r\n        int minutes \u003d Math.abs((offset / (60 * 1000)) % 60);\r\n        formatted.append(offset \u003c 0 ? \u0027-\u0027 : \u0027+\u0027);\r\n        padInt(formatted, hours, \"hh\".length());\r\n        formatted.append(\u0027:\u0027);\r\n        padInt(formatted, minutes, \"mm\".length());\r\n    } else {\r\n        formatted.append(\u0027Z\u0027);\r\n    }\r\n    return formatted.toString();\r\n}",
    "padInt": "{\r\n    String strValue \u003d Integer.toString(value);\r\n    for (int i \u003d length - strValue.length(); i \u003e 0; i--) {\r\n        buffer.append(\u00270\u0027);\r\n    }\r\n    buffer.append(strValue);\r\n}",
    "checkOffset": "{\r\n    return (offset \u003c value.length()) \u0026\u0026 (value.charAt(offset) \u003d\u003d expected);\r\n}",
    "parse": "{\r\n    Exception fail \u003d null;\r\n    try {\r\n        int offset \u003d pos.getIndex();\r\n        // extract year\r\n        int year \u003d parseInt(date, offset, offset +\u003d 4);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract month\r\n        int month \u003d parseInt(date, offset, offset +\u003d 2);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract day\r\n        int day \u003d parseInt(date, offset, offset +\u003d 2);\r\n        // default time value\r\n        int hour \u003d 0;\r\n        int minutes \u003d 0;\r\n        int seconds \u003d 0;\r\n        // always use 0 otherwise returned date will include millis of current time\r\n        int milliseconds \u003d 0;\r\n        if (checkOffset(date, offset, \u0027T\u0027)) {\r\n            // extract hours, minutes, seconds and milliseconds\r\n            hour \u003d parseInt(date, offset +\u003d 1, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            minutes \u003d parseInt(date, offset, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            // second and milliseconds can be optional\r\n            if (date.length() \u003e offset) {\r\n                char c \u003d date.charAt(offset);\r\n                if (c !\u003d \u0027Z\u0027 \u0026\u0026 c !\u003d \u0027+\u0027 \u0026\u0026 c !\u003d \u0027-\u0027) {\r\n                    seconds \u003d parseInt(date, offset, offset +\u003d 2);\r\n                    // milliseconds can be optional in the format\r\n                    if (checkOffset(date, offset, \u0027.\u0027)) {\r\n                        milliseconds \u003d parseInt(date, offset +\u003d 1, offset +\u003d 3);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // extract timezone\r\n        String timezoneId;\r\n        if (date.length() \u003c\u003d offset) {\r\n            throw new IllegalArgumentException(\"No time zone indicator\");\r\n        }\r\n        char timezoneIndicator \u003d date.charAt(offset);\r\n        if (timezoneIndicator \u003d\u003d \u0027+\u0027 || timezoneIndicator \u003d\u003d \u0027-\u0027) {\r\n            String timezoneOffset \u003d date.substring(offset);\r\n            timezoneId \u003d GMT_ID + timezoneOffset;\r\n            offset +\u003d timezoneOffset.length();\r\n        } else if (timezoneIndicator \u003d\u003d \u0027Z\u0027) {\r\n            timezoneId \u003d GMT_ID;\r\n            offset +\u003d 1;\r\n        } else {\r\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \" + timezoneIndicator);\r\n        }\r\n        TimeZone timezone \u003d TimeZone.getTimeZone(timezoneId);\r\n        if (!timezone.getID().equals(timezoneId)) {\r\n            throw new IndexOutOfBoundsException();\r\n        }\r\n        Calendar calendar \u003d new GregorianCalendar(timezone);\r\n        calendar.setLenient(false);\r\n        calendar.set(Calendar.YEAR, year);\r\n        calendar.set(Calendar.MONTH, month - 1);\r\n        calendar.set(Calendar.DAY_OF_MONTH, day);\r\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\r\n        calendar.set(Calendar.MINUTE, minutes);\r\n        calendar.set(Calendar.SECOND, seconds);\r\n        calendar.set(Calendar.MILLISECOND, milliseconds);\r\n        pos.setIndex(offset);\r\n        return calendar.getTime();\r\n        // If we get a ParseException it\u0027ll already have the right message/offset.\r\n        // Other exception types can convert here.\r\n    } catch (IndexOutOfBoundsException e) {\r\n        fail \u003d e;\r\n    } catch (NumberFormatException e) {\r\n        fail \u003d e;\r\n    } catch (IllegalArgumentException e) {\r\n        fail \u003d e;\r\n    }\r\n    String input \u003d (date \u003d\u003d null) ? null : (\"\u0027\" + date + \"\u0027\");\r\n    throw new ParseException(\"Failed to parse date [\" + input + \"]: \" + fail.getMessage(), pos.getIndex());\r\n}",
    "write": "{\r\n    if (date \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        String value \u003d format(date, true, UTC_TIME_ZONE);\r\n        out.value(value);\r\n    }\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\extras\\examples\\rawcollections\\RawCollectionsExample.java": {
    "toString": "{\r\n    return String.format(\"(name\u003d%s, source\u003d%s)\", name, source);\r\n}",
    "main": "{\r\n    Gson gson \u003d new Gson();\r\n    Collection collection \u003d new ArrayList();\r\n    collection.add(\"hello\");\r\n    collection.add(5);\r\n    collection.add(new Event(\"GREETINGS\", \"guest\"));\r\n    String json \u003d gson.toJson(collection);\r\n    System.out.println(\"Using Gson.toJson() on a raw collection: \" + json);\r\n    JsonArray array \u003d JsonParser.parseString(json).getAsJsonArray();\r\n    String message \u003d gson.fromJson(array.get(0), String.class);\r\n    int number \u003d gson.fromJson(array.get(1), int.class);\r\n    Event event \u003d gson.fromJson(array.get(2), Event.class);\r\n    System.out.printf(\"Using Gson.fromJson() to get: %s, %d, %s\", message, number, event);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\ToNumberPolicy.java": {
    "readNumber": "{\r\n    String value \u003d in.nextString();\r\n    try {\r\n        return new BigDecimal(value);\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonParseException(\"Cannot parse \" + value + \"; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java": {
    "tryBeginNesting": "{\r\n    switch(peeked) {\r\n        case BEGIN_ARRAY:\r\n            in.beginArray();\r\n            return new JsonArray();\r\n        case BEGIN_OBJECT:\r\n            in.beginObject();\r\n            return new JsonObject();\r\n        default:\r\n            return null;\r\n    }\r\n}",
    "read": "{\r\n    T1 result \u003d typeAdapter.read(in);\r\n    if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\r\n        throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n    }\r\n    return result;\r\n}",
    "newFactory": "{\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the \u0027T\u0027s equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n            Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n            return (rawType \u003d\u003d unboxed || rawType \u003d\u003d boxed) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[type\u003d\" + boxed.getName() + \"+\" + unboxed.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "readTerminal": "{\r\n    switch(peeked) {\r\n        case STRING:\r\n            return new JsonPrimitive(in.nextString());\r\n        case NUMBER:\r\n            String number \u003d in.nextString();\r\n            return new JsonPrimitive(new LazilyParsedNumber(number));\r\n        case BOOLEAN:\r\n            return new JsonPrimitive(in.nextBoolean());\r\n        case NULL:\r\n            in.nextNull();\r\n            return JsonNull.INSTANCE;\r\n        default:\r\n            // When read(JsonReader) is called with JsonReader in invalid state\r\n            throw new IllegalStateException(\"Unexpected token: \" + peeked);\r\n    }\r\n}",
    "newFactoryForMultipleTypes": "{\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the \u0027T\u0027s equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n            Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n            return (rawType \u003d\u003d base || rawType \u003d\u003d sub) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[type\u003d\" + base.getName() + \"+\" + sub.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "create": "{\r\n    final Class\u003c? super T2\u003e requestedType \u003d typeToken.getRawType();\r\n    if (!clazz.isAssignableFrom(requestedType)) {\r\n        return null;\r\n    }\r\n    return (TypeAdapter\u003cT2\u003e) new TypeAdapter\u003cT1\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T1 value) throws IOException {\r\n            typeAdapter.write(out, value);\r\n        }\r\n\r\n        @Override\r\n        public T1 read(JsonReader in) throws IOException {\r\n            T1 result \u003d typeAdapter.read(in);\r\n            if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\r\n                throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n}",
    "run": "{\r\n    Field[] fields \u003d classOfT.getDeclaredFields();\r\n    ArrayList\u003cField\u003e constantFieldsList \u003d new ArrayList\u003c\u003e(fields.length);\r\n    for (Field f : fields) {\r\n        if (f.isEnumConstant()) {\r\n            constantFieldsList.add(f);\r\n        }\r\n    }\r\n    Field[] constantFields \u003d constantFieldsList.toArray(new Field[0]);\r\n    AccessibleObject.setAccessible(constantFields, true);\r\n    return constantFields;\r\n}",
    "toString": "{\r\n    return \"Factory[typeHierarchy\u003d\" + clazz.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n}",
    "write": "{\r\n    typeAdapter.write(out, value);\r\n}",
    "newTypeHierarchyFactory": "{\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT2\u003e TypeAdapter\u003cT2\u003e create(Gson gson, TypeToken\u003cT2\u003e typeToken) {\r\n            final Class\u003c? super T2\u003e requestedType \u003d typeToken.getRawType();\r\n            if (!clazz.isAssignableFrom(requestedType)) {\r\n                return null;\r\n            }\r\n            return (TypeAdapter\u003cT2\u003e) new TypeAdapter\u003cT1\u003e() {\r\n\r\n                @Override\r\n                public void write(JsonWriter out, T1 value) throws IOException {\r\n                    typeAdapter.write(out, value);\r\n                }\r\n\r\n                @Override\r\n                public T1 read(JsonReader in) throws IOException {\r\n                    T1 result \u003d typeAdapter.read(in);\r\n                    if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\r\n                        throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[typeHierarchy\u003d\" + clazz.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithUnreferencedNoArgsConstructor.java": {},
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\EnumClassWithSerializedName.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ArrayTypeAdapter.java": {
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    ArrayList\u003cE\u003e list \u003d new ArrayList\u003c\u003e();\r\n    in.beginArray();\r\n    while (in.hasNext()) {\r\n        E instance \u003d componentTypeAdapter.read(in);\r\n        list.add(instance);\r\n    }\r\n    in.endArray();\r\n    int size \u003d list.size();\r\n    // Have to copy primitives one by one to primitive array\r\n    if (componentType.isPrimitive()) {\r\n        Object array \u003d Array.newInstance(componentType, size);\r\n        for (int i \u003d 0; i \u003c size; i++) {\r\n            Array.set(array, i, list.get(i));\r\n        }\r\n        return array;\r\n    } else // But for Object[] can use ArrayList.toArray\r\n    {\r\n        @SuppressWarnings(\"unchecked\")\r\n        E[] array \u003d (E[]) Array.newInstance(componentType, size);\r\n        return list.toArray(array);\r\n    }\r\n}",
    "create": "{\r\n    Type type \u003d typeToken.getType();\r\n    if (!(type instanceof GenericArrayType || (type instanceof Class \u0026\u0026 ((Class\u003c?\u003e) type).isArray()))) {\r\n        return null;\r\n    }\r\n    Type componentType \u003d $Gson$Types.getArrayComponentType(type);\r\n    TypeAdapter\u003c?\u003e componentTypeAdapter \u003d gson.getAdapter(TypeToken.get(componentType));\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e arrayAdapter \u003d new ArrayTypeAdapter(gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\r\n    return arrayAdapter;\r\n}",
    "write": "{\r\n    if (array \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginArray();\r\n    for (int i \u003d 0, length \u003d Array.getLength(array); i \u003c length; i++) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        E value \u003d (E) Array.get(array, i);\r\n        componentTypeAdapter.write(out, value);\r\n    }\r\n    out.endArray();\r\n}"
  },
  "google_json\\gson\\src\\main\\java-templates\\com\\google\\gson\\internal\\GsonBuildConfig.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonSyntaxException.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java": {
    "nextQuotedValue": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    StringBuilder builder \u003d null;\r\n    while (true) {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        int start \u003d p;\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            // In strict mode, throw an exception when meeting unescaped control characters (U+0000 through U+001F)\r\n            if (strictness \u003d\u003d Strictness.STRICT \u0026\u0026 c \u003c 0x20) {\r\n                throw syntaxError(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n            } else if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    return new String(buffer, start, len);\r\n                } else {\r\n                    builder.append(buffer, start, len);\r\n                    return builder.toString();\r\n                }\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    int estimatedLength \u003d (len + 1) * 2;\r\n                    builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n                }\r\n                builder.append(buffer, start, len);\r\n                builder.append(readEscapeCharacter());\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n                start \u003d p;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        if (builder \u003d\u003d null) {\r\n            int estimatedLength \u003d (p - start) * 2;\r\n            builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n        }\r\n        builder.append(buffer, start, p - start);\r\n        pos \u003d p;\r\n        if (!fillBuffer(1)) {\r\n            throw syntaxError(\"Unterminated string\");\r\n        }\r\n    }\r\n}",
    "syntaxError": "{\r\n    throw new MalformedJsonException(message + locationString() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"malformed-json\"));\r\n}",
    "isLenient": "{\r\n    return strictness \u003d\u003d Strictness.LENIENT;\r\n}",
    "skipTo": "{\r\n    int length \u003d toFind.length();\r\n    outer: for (; pos + length \u003c\u003d limit || fillBuffer(length); pos++) {\r\n        if (buffer[pos] \u003d\u003d \u0027\\n\u0027) {\r\n            lineNumber++;\r\n            lineStart \u003d pos + 1;\r\n            continue;\r\n        }\r\n        for (int c \u003d 0; c \u003c length; c++) {\r\n            if (buffer[pos + c] !\u003d toFind.charAt(c)) {\r\n                continue outer;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "readEscapeCharacter": "{\r\n    if (pos \u003d\u003d limit \u0026\u0026 !fillBuffer(1)) {\r\n        throw syntaxError(\"Unterminated escape sequence\");\r\n    }\r\n    char escaped \u003d buffer[pos++];\r\n    switch(escaped) {\r\n        case \u0027u\u0027:\r\n            if (pos + 4 \u003e limit \u0026\u0026 !fillBuffer(4)) {\r\n                throw syntaxError(\"Unterminated escape sequence\");\r\n            }\r\n            // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\r\n            int result \u003d 0;\r\n            for (int i \u003d pos, end \u003d i + 4; i \u003c end; i++) {\r\n                char c \u003d buffer[i];\r\n                result \u003c\u003c\u003d 4;\r\n                if (c \u003e\u003d \u00270\u0027 \u0026\u0026 c \u003c\u003d \u00279\u0027) {\r\n                    result +\u003d (c - \u00270\u0027);\r\n                } else if (c \u003e\u003d \u0027a\u0027 \u0026\u0026 c \u003c\u003d \u0027f\u0027) {\r\n                    result +\u003d (c - \u0027a\u0027 + 10);\r\n                } else if (c \u003e\u003d \u0027A\u0027 \u0026\u0026 c \u003c\u003d \u0027F\u0027) {\r\n                    result +\u003d (c - \u0027A\u0027 + 10);\r\n                } else {\r\n                    throw syntaxError(\"Malformed Unicode escape \\\\u\" + new String(buffer, pos, 4));\r\n                }\r\n            }\r\n            pos +\u003d 4;\r\n            return (char) result;\r\n        case \u0027t\u0027:\r\n            return \u0027\\t\u0027;\r\n        case \u0027b\u0027:\r\n            return \u0027\\b\u0027;\r\n        case \u0027n\u0027:\r\n            return \u0027\\n\u0027;\r\n        case \u0027r\u0027:\r\n            return \u0027\\r\u0027;\r\n        case \u0027f\u0027:\r\n            return \u0027\\f\u0027;\r\n        case \u0027\\n\u0027:\r\n            if (strictness \u003d\u003d Strictness.STRICT) {\r\n                throw syntaxError(\"Cannot escape a newline character in strict mode\");\r\n            }\r\n            lineNumber++;\r\n            lineStart \u003d pos;\r\n        // fall-through\r\n        case \u0027\\\u0027\u0027:\r\n            if (strictness \u003d\u003d Strictness.STRICT) {\r\n                throw syntaxError(\"Invalid escaped character \\\"\u0027\\\" in strict mode\");\r\n            }\r\n        case \u0027\"\u0027:\r\n        case \u0027\\\\\u0027:\r\n        case \u0027/\u0027:\r\n            return escaped;\r\n        default:\r\n            // throw error when none of the above cases are matched\r\n            throw syntaxError(\"Invalid escape sequence\");\r\n    }\r\n}",
    "endArray": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_END_ARRAY) {\r\n        stackSize--;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"END_ARRAY\");\r\n    }\r\n}",
    "nextString": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    String result;\r\n    if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n        result \u003d nextUnquotedValue();\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED) {\r\n        result \u003d nextQuotedValue(\u0027\\\u0027\u0027);\r\n    } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\r\n        result \u003d nextQuotedValue(\u0027\"\u0027);\r\n    } else if (p \u003d\u003d PEEKED_BUFFERED) {\r\n        result \u003d peekedString;\r\n        peekedString \u003d null;\r\n    } else if (p \u003d\u003d PEEKED_LONG) {\r\n        result \u003d Long.toString(peekedLong);\r\n    } else if (p \u003d\u003d PEEKED_NUMBER) {\r\n        result \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else {\r\n        throw unexpectedTokenError(\"a string\");\r\n    }\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "setLenient": "{\r\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\r\n}",
    "skipUnquotedValue": "{\r\n    do {\r\n        int i \u003d 0;\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    pos +\u003d i;\r\n                    return;\r\n            }\r\n        }\r\n        pos +\u003d i;\r\n    } while (fillBuffer(1));\r\n}",
    "beginArray": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_BEGIN_ARRAY) {\r\n        push(JsonScope.EMPTY_ARRAY);\r\n        pathIndices[stackSize - 1] \u003d 0;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"BEGIN_ARRAY\");\r\n    }\r\n}",
    "checkLenient": "{\r\n    if (strictness !\u003d Strictness.LENIENT) {\r\n        throw syntaxError(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON\");\r\n    }\r\n}",
    "skipQuotedValue": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    do {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                return;\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                char unused \u003d readEscapeCharacter();\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        pos \u003d p;\r\n    } while (fillBuffer(1));\r\n    throw syntaxError(\"Unterminated string\");\r\n}",
    "promoteNameToValue": "{\r\n    if (reader instanceof JsonTreeReader) {\r\n        ((JsonTreeReader) reader).promoteNameToValue();\r\n        return;\r\n    }\r\n    int p \u003d reader.peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d reader.doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\r\n        reader.peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\r\n        reader.peeked \u003d PEEKED_SINGLE_QUOTED;\r\n    } else if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\r\n        reader.peeked \u003d PEEKED_UNQUOTED;\r\n    } else {\r\n        throw reader.unexpectedTokenError(\"a name\");\r\n    }\r\n}",
    "fillBuffer": "{\r\n    char[] buffer \u003d this.buffer;\r\n    lineStart -\u003d pos;\r\n    if (limit !\u003d pos) {\r\n        limit -\u003d pos;\r\n        System.arraycopy(buffer, pos, buffer, 0, limit);\r\n    } else {\r\n        limit \u003d 0;\r\n    }\r\n    pos \u003d 0;\r\n    int total;\r\n    while ((total \u003d in.read(buffer, limit, buffer.length - limit)) !\u003d -1) {\r\n        limit +\u003d total;\r\n        // if this is the first read, consume an optional byte order mark (BOM) if it exists\r\n        if (lineNumber \u003d\u003d 0 \u0026\u0026 lineStart \u003d\u003d 0 \u0026\u0026 limit \u003e 0 \u0026\u0026 buffer[0] \u003d\u003d \u0027\\ufeff\u0027) {\r\n            pos++;\r\n            lineStart++;\r\n            minimum++;\r\n        }\r\n        if (limit \u003e\u003d minimum) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "getPath": "{\r\n    return getPath(false);\r\n}",
    "nextNonWhitespace": "{\r\n    /*\r\n     * This code uses ugly local variables \u0027p\u0027 and \u0027l\u0027 representing the \u0027pos\u0027\r\n     * and \u0027limit\u0027 fields respectively. Using locals rather than fields saves\r\n     * a few field reads for each whitespace character in a pretty-printed\r\n     * document, resulting in a 5% speedup. We need to flush \u0027p\u0027 to its field\r\n     * before any (potentially indirect) call to fillBuffer() and reread both\r\n     * \u0027p\u0027 and \u0027l\u0027 after any (potentially indirect) call to the same method.\r\n     */\r\n    char[] buffer \u003d this.buffer;\r\n    int p \u003d pos;\r\n    int l \u003d limit;\r\n    while (true) {\r\n        if (p \u003d\u003d l) {\r\n            pos \u003d p;\r\n            if (!fillBuffer(1)) {\r\n                break;\r\n            }\r\n            p \u003d pos;\r\n            l \u003d limit;\r\n        }\r\n        int c \u003d buffer[p++];\r\n        if (c \u003d\u003d \u0027\\n\u0027) {\r\n            lineNumber++;\r\n            lineStart \u003d p;\r\n            continue;\r\n        } else if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\t\u0027) {\r\n            continue;\r\n        }\r\n        if (c \u003d\u003d \u0027/\u0027) {\r\n            pos \u003d p;\r\n            if (p \u003d\u003d l) {\r\n                // push back \u0027/\u0027 so it\u0027s still in the buffer when this method returns\r\n                pos--;\r\n                boolean charsLoaded \u003d fillBuffer(2);\r\n                // consume the \u0027/\u0027 again\r\n                pos++;\r\n                if (!charsLoaded) {\r\n                    return c;\r\n                }\r\n            }\r\n            checkLenient();\r\n            char peek \u003d buffer[pos];\r\n            switch(peek) {\r\n                case \u0027*\u0027:\r\n                    // skip a /* c-style comment */\r\n                    pos++;\r\n                    if (!skipTo(\"*/\")) {\r\n                        throw syntaxError(\"Unterminated comment\");\r\n                    }\r\n                    p \u003d pos + 2;\r\n                    l \u003d limit;\r\n                    continue;\r\n                case \u0027/\u0027:\r\n                    // skip a // end-of-line comment\r\n                    pos++;\r\n                    skipToEndOfLine();\r\n                    p \u003d pos;\r\n                    l \u003d limit;\r\n                    continue;\r\n                default:\r\n                    return c;\r\n            }\r\n        } else if (c \u003d\u003d \u0027#\u0027) {\r\n            pos \u003d p;\r\n            /*\r\n         * Skip a # hash end-of-line comment. The JSON RFC doesn\u0027t\r\n         * specify this behaviour, but it\u0027s required to parse\r\n         * existing documents. See http://b/2571423.\r\n         */\r\n            checkLenient();\r\n            skipToEndOfLine();\r\n            p \u003d pos;\r\n            l \u003d limit;\r\n        } else {\r\n            pos \u003d p;\r\n            return c;\r\n        }\r\n    }\r\n    if (throwOnEof) {\r\n        throw new EOFException(\"End of input\" + locationString());\r\n    } else {\r\n        return -1;\r\n    }\r\n}",
    "nextBoolean": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_TRUE) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return true;\r\n    } else if (p \u003d\u003d PEEKED_FALSE) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return false;\r\n    }\r\n    throw unexpectedTokenError(\"a boolean\");\r\n}",
    "peekKeyword": "{\r\n    // Figure out which keyword we\u0027re matching against by its first character.\r\n    char c \u003d buffer[pos];\r\n    String keyword;\r\n    String keywordUpper;\r\n    int peeking;\r\n    // Look at the first letter to determine what keyword we are trying to match.\r\n    if (c \u003d\u003d \u0027t\u0027 || c \u003d\u003d \u0027T\u0027) {\r\n        keyword \u003d \"true\";\r\n        keywordUpper \u003d \"TRUE\";\r\n        peeking \u003d PEEKED_TRUE;\r\n    } else if (c \u003d\u003d \u0027f\u0027 || c \u003d\u003d \u0027F\u0027) {\r\n        keyword \u003d \"false\";\r\n        keywordUpper \u003d \"FALSE\";\r\n        peeking \u003d PEEKED_FALSE;\r\n    } else if (c \u003d\u003d \u0027n\u0027 || c \u003d\u003d \u0027N\u0027) {\r\n        keyword \u003d \"null\";\r\n        keywordUpper \u003d \"NULL\";\r\n        peeking \u003d PEEKED_NULL;\r\n    } else {\r\n        return PEEKED_NONE;\r\n    }\r\n    // Uppercased keywords are not allowed in STRICT mode\r\n    boolean allowsUpperCased \u003d strictness !\u003d Strictness.STRICT;\r\n    // Confirm that chars [0..length) match the keyword.\r\n    int length \u003d keyword.length();\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        if (pos + i \u003e\u003d limit \u0026\u0026 !fillBuffer(i + 1)) {\r\n            return PEEKED_NONE;\r\n        }\r\n        c \u003d buffer[pos + i];\r\n        boolean matched \u003d c \u003d\u003d keyword.charAt(i) || (allowsUpperCased \u0026\u0026 c \u003d\u003d keywordUpper.charAt(i));\r\n        if (!matched) {\r\n            return PEEKED_NONE;\r\n        }\r\n    }\r\n    if ((pos + length \u003c limit || fillBuffer(length + 1)) \u0026\u0026 isLiteral(buffer[pos + length])) {\r\n        // Don\u0027t match trues, falsey or nullsoft!\r\n        return PEEKED_NONE;\r\n    }\r\n    // We\u0027ve found the keyword followed either by EOF or by a non-literal character.\r\n    pos +\u003d length;\r\n    return peeked \u003d peeking;\r\n}",
    "close": "{\r\n    peeked \u003d PEEKED_NONE;\r\n    stack[0] \u003d JsonScope.CLOSED;\r\n    stackSize \u003d 1;\r\n    in.close();\r\n}",
    "doPeek": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (strictness \u003d\u003d Strictness.LENIENT) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}",
    "skipValue": "{\r\n    int count \u003d 0;\r\n    do {\r\n        int p \u003d peeked;\r\n        if (p \u003d\u003d PEEKED_NONE) {\r\n            p \u003d doPeek();\r\n        }\r\n        switch(p) {\r\n            case PEEKED_BEGIN_ARRAY:\r\n                push(JsonScope.EMPTY_ARRAY);\r\n                count++;\r\n                break;\r\n            case PEEKED_BEGIN_OBJECT:\r\n                push(JsonScope.EMPTY_OBJECT);\r\n                count++;\r\n                break;\r\n            case PEEKED_END_ARRAY:\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_END_OBJECT:\r\n                // Only update when object end is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    // Free the last path name so that it can be garbage collected\r\n                    pathNames[stackSize - 1] \u003d null;\r\n                }\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_UNQUOTED:\r\n                skipUnquotedValue();\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED:\r\n                skipQuotedValue(\u0027\\\u0027\u0027);\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED:\r\n                skipQuotedValue(\u0027\"\u0027);\r\n                break;\r\n            case PEEKED_UNQUOTED_NAME:\r\n                skipUnquotedValue();\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED_NAME:\r\n                skipQuotedValue(\u0027\\\u0027\u0027);\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED_NAME:\r\n                skipQuotedValue(\u0027\"\u0027);\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_NUMBER:\r\n                pos +\u003d peekedNumberLength;\r\n                break;\r\n            case PEEKED_EOF:\r\n                // Do nothing\r\n                return;\r\n        }\r\n        peeked \u003d PEEKED_NONE;\r\n    } while (count \u003e 0);\r\n    pathIndices[stackSize - 1]++;\r\n}",
    "skipToEndOfLine": "{\r\n    while (pos \u003c limit || fillBuffer(1)) {\r\n        char c \u003d buffer[pos++];\r\n        if (c \u003d\u003d \u0027\\n\u0027) {\r\n            lineNumber++;\r\n            lineStart \u003d pos;\r\n            break;\r\n        } else if (c \u003d\u003d \u0027\\r\u0027) {\r\n            break;\r\n        }\r\n    }\r\n}",
    "getPreviousPath": "{\r\n    return getPath(true);\r\n}",
    "nextUnquotedValue": "{\r\n    StringBuilder builder \u003d null;\r\n    int i \u003d 0;\r\n    findNonLiteralCharacter: while (true) {\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    break findNonLiteralCharacter;\r\n            }\r\n        }\r\n        // Attempt to load the entire literal into the buffer at once.\r\n        if (i \u003c buffer.length) {\r\n            if (fillBuffer(i + 1)) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // use a StringBuilder when the value is too long. This is too long to be a number!\r\n        if (builder \u003d\u003d null) {\r\n            builder \u003d new StringBuilder(Math.max(i, 16));\r\n        }\r\n        builder.append(buffer, pos, i);\r\n        pos +\u003d i;\r\n        i \u003d 0;\r\n        if (!fillBuffer(1)) {\r\n            break;\r\n        }\r\n    }\r\n    String result \u003d (null \u003d\u003d builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n    pos +\u003d i;\r\n    return result;\r\n}",
    "hasNext": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    return p !\u003d PEEKED_END_OBJECT \u0026\u0026 p !\u003d PEEKED_END_ARRAY \u0026\u0026 p !\u003d PEEKED_EOF;\r\n}",
    "nextInt": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    int result;\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        result \u003d (int) peekedLong;\r\n        if (peekedLong !\u003d result) {\r\n            // Make sure no precision was lost casting to \u0027int\u0027.\r\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\r\n        }\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return result;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED || p \u003d\u003d PEEKED_UNQUOTED) {\r\n        if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n            peekedString \u003d nextUnquotedValue();\r\n        } else {\r\n            peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n        }\r\n        try {\r\n            result \u003d Integer.parseInt(peekedString);\r\n            peeked \u003d PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        } catch (NumberFormatException ignored) {\r\n            // Fall back to parse as a double below.\r\n        }\r\n    } else {\r\n        throw unexpectedTokenError(\"an int\");\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double asDouble \u003d Double.parseDouble(peekedString);\r\n    result \u003d (int) asDouble;\r\n    if (result !\u003d asDouble) {\r\n        // Make sure no precision was lost casting to \u0027int\u0027.\r\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "nextLong": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return peekedLong;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED || p \u003d\u003d PEEKED_UNQUOTED) {\r\n        if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n            peekedString \u003d nextUnquotedValue();\r\n        } else {\r\n            peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n        }\r\n        try {\r\n            long result \u003d Long.parseLong(peekedString);\r\n            peeked \u003d PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        } catch (NumberFormatException ignored) {\r\n            // Fall back to parse as a double below.\r\n        }\r\n    } else {\r\n        throw unexpectedTokenError(\"a long\");\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double asDouble \u003d Double.parseDouble(peekedString);\r\n    long result \u003d (long) asDouble;\r\n    if (result !\u003d asDouble) {\r\n        // Make sure no precision was lost casting to \u0027long\u0027.\r\n        throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "getStrictness": "{\r\n    return strictness;\r\n}",
    "nextDouble": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return (double) peekedLong;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\r\n        peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n    } else if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n        peekedString \u003d nextUnquotedValue();\r\n    } else if (p !\u003d PEEKED_BUFFERED) {\r\n        throw unexpectedTokenError(\"a double\");\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double result \u003d Double.parseDouble(peekedString);\r\n    if (strictness !\u003d Strictness.LENIENT \u0026\u0026 (Double.isNaN(result) || Double.isInfinite(result))) {\r\n        throw syntaxError(\"JSON forbids NaN and infinities: \" + result);\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "push": "{\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        int newLength \u003d stackSize * 2;\r\n        stack \u003d Arrays.copyOf(stack, newLength);\r\n        pathIndices \u003d Arrays.copyOf(pathIndices, newLength);\r\n        pathNames \u003d Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}",
    "endObject": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_END_OBJECT) {\r\n        stackSize--;\r\n        // Free the last path name so that it can be garbage collected!\r\n        pathNames[stackSize] \u003d null;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"END_OBJECT\");\r\n    }\r\n}",
    "peek": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}",
    "peekNumber": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    int p \u003d pos;\r\n    int l \u003d limit;\r\n    // Negative to accommodate Long.MIN_VALUE more easily.\r\n    long value \u003d 0;\r\n    boolean negative \u003d false;\r\n    boolean fitsInLong \u003d true;\r\n    int last \u003d NUMBER_CHAR_NONE;\r\n    int i \u003d 0;\r\n    charactersOfNumber: for (; true; i++) {\r\n        if (p + i \u003d\u003d l) {\r\n            if (i \u003d\u003d buffer.length) {\r\n                // Though this looks like a well-formed number, it\u0027s too long to continue reading. Give up\r\n                // and let the application handle this as an unquoted literal.\r\n                return PEEKED_NONE;\r\n            }\r\n            if (!fillBuffer(i + 1)) {\r\n                break;\r\n            }\r\n            p \u003d pos;\r\n            l \u003d limit;\r\n        }\r\n        char c \u003d buffer[p + i];\r\n        switch(c) {\r\n            case \u0027-\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_NONE) {\r\n                    negative \u003d true;\r\n                    last \u003d NUMBER_CHAR_SIGN;\r\n                    continue;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_EXP_E) {\r\n                    last \u003d NUMBER_CHAR_EXP_SIGN;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case \u0027+\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_EXP_E) {\r\n                    last \u003d NUMBER_CHAR_EXP_SIGN;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case \u0027e\u0027:\r\n            case \u0027E\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_DIGIT || last \u003d\u003d NUMBER_CHAR_FRACTION_DIGIT) {\r\n                    last \u003d NUMBER_CHAR_EXP_E;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case \u0027.\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_DIGIT) {\r\n                    last \u003d NUMBER_CHAR_DECIMAL;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            default:\r\n                if (c \u003c \u00270\u0027 || c \u003e \u00279\u0027) {\r\n                    if (!isLiteral(c)) {\r\n                        break charactersOfNumber;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                }\r\n                if (last \u003d\u003d NUMBER_CHAR_SIGN || last \u003d\u003d NUMBER_CHAR_NONE) {\r\n                    value \u003d -(c - \u00270\u0027);\r\n                    last \u003d NUMBER_CHAR_DIGIT;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_DIGIT) {\r\n                    if (value \u003d\u003d 0) {\r\n                        // Leading \u00270\u0027 prefix is not allowed (since it could be octal).\r\n                        return PEEKED_NONE;\r\n                    }\r\n                    long newValue \u003d value * 10 - (c - \u00270\u0027);\r\n                    fitsInLong \u0026\u003d value \u003e MIN_INCOMPLETE_INTEGER || (value \u003d\u003d MIN_INCOMPLETE_INTEGER \u0026\u0026 newValue \u003c value);\r\n                    value \u003d newValue;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_DECIMAL) {\r\n                    last \u003d NUMBER_CHAR_FRACTION_DIGIT;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_EXP_E || last \u003d\u003d NUMBER_CHAR_EXP_SIGN) {\r\n                    last \u003d NUMBER_CHAR_EXP_DIGIT;\r\n                }\r\n        }\r\n    }\r\n    // We\u0027ve read a complete number. Decide if it\u0027s a PEEKED_LONG or a PEEKED_NUMBER.\r\n    // Don\u0027t store -0 as long; user might want to read it as double -0.0\r\n    // Don\u0027t try to convert Long.MIN_VALUE to positive long; it would overflow MAX_VALUE\r\n    if (last \u003d\u003d NUMBER_CHAR_DIGIT \u0026\u0026 fitsInLong \u0026\u0026 (value !\u003d Long.MIN_VALUE || negative) \u0026\u0026 (value !\u003d 0 || !negative)) {\r\n        peekedLong \u003d negative ? value : -value;\r\n        pos +\u003d i;\r\n        return peeked \u003d PEEKED_LONG;\r\n    } else if (last \u003d\u003d NUMBER_CHAR_DIGIT || last \u003d\u003d NUMBER_CHAR_FRACTION_DIGIT || last \u003d\u003d NUMBER_CHAR_EXP_DIGIT) {\r\n        peekedNumberLength \u003d i;\r\n        return peeked \u003d PEEKED_NUMBER;\r\n    } else {\r\n        return PEEKED_NONE;\r\n    }\r\n}",
    "isLiteral": "{\r\n    switch(c) {\r\n        case \u0027/\u0027:\r\n        case \u0027\\\\\u0027:\r\n        case \u0027;\u0027:\r\n        case \u0027#\u0027:\r\n        case \u0027\u003d\u0027:\r\n            // fall-through\r\n            checkLenient();\r\n        case \u0027{\u0027:\r\n        case \u0027}\u0027:\r\n        case \u0027[\u0027:\r\n        case \u0027]\u0027:\r\n        case \u0027:\u0027:\r\n        case \u0027,\u0027:\r\n        case \u0027 \u0027:\r\n        case \u0027\\t\u0027:\r\n        case \u0027\\f\u0027:\r\n        case \u0027\\r\u0027:\r\n        case \u0027\\n\u0027:\r\n            return false;\r\n        default:\r\n            return true;\r\n    }\r\n}",
    "beginObject": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_BEGIN_OBJECT) {\r\n        push(JsonScope.EMPTY_OBJECT);\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"BEGIN_OBJECT\");\r\n    }\r\n}",
    "locationString": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}",
    "consumeNonExecutePrefix": "{\r\n    // fast-forward through the leading whitespace\r\n    int unused \u003d nextNonWhitespace(true);\r\n    pos--;\r\n    if (pos + 5 \u003e limit \u0026\u0026 !fillBuffer(5)) {\r\n        return;\r\n    }\r\n    int p \u003d pos;\r\n    char[] buf \u003d buffer;\r\n    if (buf[p] !\u003d \u0027)\u0027 || buf[p + 1] !\u003d \u0027]\u0027 || buf[p + 2] !\u003d \u0027}\u0027 || buf[p + 3] !\u003d \u0027\\\u0027\u0027 || buf[p + 4] !\u003d \u0027\\n\u0027) {\r\n        // not a security token!\r\n        return;\r\n    }\r\n    // we consumed a security token!\r\n    pos +\u003d 5;\r\n}",
    "toString": "{\r\n    return getClass().getSimpleName() + locationString();\r\n}",
    "unexpectedTokenError": "{\r\n    JsonToken peeked \u003d peek();\r\n    String troubleshootingId \u003d peeked \u003d\u003d JsonToken.NULL ? \"adapter-not-null-safe\" : \"unexpected-json-structure\";\r\n    return new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString() + \"\\nSee \" + TroubleshootingGuide.createUrl(troubleshootingId));\r\n}",
    "setStrictness": "{\r\n    Objects.requireNonNull(strictness);\r\n    this.strictness \u003d strictness;\r\n}",
    "nextName": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    String result;\r\n    if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\r\n        result \u003d nextUnquotedValue();\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\r\n        result \u003d nextQuotedValue(\u0027\\\u0027\u0027);\r\n    } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\r\n        result \u003d nextQuotedValue(\u0027\"\u0027);\r\n    } else {\r\n        throw unexpectedTokenError(\"a name\");\r\n    }\r\n    peeked \u003d PEEKED_NONE;\r\n    pathNames[stackSize - 1] \u003d result;\r\n    return result;\r\n}",
    "nextNull": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_NULL) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n    } else {\r\n        throw unexpectedTokenError(\"null\");\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\Primitives.java": {
    "isWrapperType": "{\r\n    return type \u003d\u003d Integer.class || type \u003d\u003d Float.class || type \u003d\u003d Byte.class || type \u003d\u003d Double.class || type \u003d\u003d Long.class || type \u003d\u003d Character.class || type \u003d\u003d Boolean.class || type \u003d\u003d Short.class || type \u003d\u003d Void.class;\r\n}",
    "isPrimitive": "{\r\n    return type instanceof Class\u003c?\u003e \u0026\u0026 ((Class\u003c?\u003e) type).isPrimitive();\r\n}",
    "wrap": "{\r\n    if (type \u003d\u003d int.class)\r\n        return (Class\u003cT\u003e) Integer.class;\r\n    if (type \u003d\u003d float.class)\r\n        return (Class\u003cT\u003e) Float.class;\r\n    if (type \u003d\u003d byte.class)\r\n        return (Class\u003cT\u003e) Byte.class;\r\n    if (type \u003d\u003d double.class)\r\n        return (Class\u003cT\u003e) Double.class;\r\n    if (type \u003d\u003d long.class)\r\n        return (Class\u003cT\u003e) Long.class;\r\n    if (type \u003d\u003d char.class)\r\n        return (Class\u003cT\u003e) Character.class;\r\n    if (type \u003d\u003d boolean.class)\r\n        return (Class\u003cT\u003e) Boolean.class;\r\n    if (type \u003d\u003d short.class)\r\n        return (Class\u003cT\u003e) Short.class;\r\n    if (type \u003d\u003d void.class)\r\n        return (Class\u003cT\u003e) Void.class;\r\n    return type;\r\n}",
    "unwrap": "{\r\n    if (type \u003d\u003d Integer.class)\r\n        return (Class\u003cT\u003e) int.class;\r\n    if (type \u003d\u003d Float.class)\r\n        return (Class\u003cT\u003e) float.class;\r\n    if (type \u003d\u003d Byte.class)\r\n        return (Class\u003cT\u003e) byte.class;\r\n    if (type \u003d\u003d Double.class)\r\n        return (Class\u003cT\u003e) double.class;\r\n    if (type \u003d\u003d Long.class)\r\n        return (Class\u003cT\u003e) long.class;\r\n    if (type \u003d\u003d Character.class)\r\n        return (Class\u003cT\u003e) char.class;\r\n    if (type \u003d\u003d Boolean.class)\r\n        return (Class\u003cT\u003e) boolean.class;\r\n    if (type \u003d\u003d Short.class)\r\n        return (Class\u003cT\u003e) short.class;\r\n    if (type \u003d\u003d Void.class)\r\n        return (Class\u003cT\u003e) void.class;\r\n    return type;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonNull.java": {
    "hashCode": "{\r\n    return JsonNull.class.hashCode();\r\n}",
    "equals": "{\r\n    return other instanceof JsonNull;\r\n}",
    "deepCopy": "{\r\n    return INSTANCE;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\TroubleshootingGuide.java": {
    "createUrl": "{\r\n    return \"https://github.com/google/gson/blob/main/Troubleshooting.md#\" + id;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\MalformedJsonException.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonTreeReader.java": {
    "popStack": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}",
    "endArray": "{\r\n    expect(JsonToken.END_ARRAY);\r\n    // empty iterator\r\n    popStack();\r\n    // array\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}",
    "nextString": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.STRING \u0026\u0026 token !\u003d JsonToken.NUMBER) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\r\n    }\r\n    String result \u003d ((JsonPrimitive) popStack()).getAsString();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "beginArray": "{\r\n    expect(JsonToken.BEGIN_ARRAY);\r\n    JsonArray array \u003d (JsonArray) peekStack();\r\n    push(array.iterator());\r\n    pathIndices[stackSize - 1] \u003d 0;\r\n}",
    "nextJsonElement": "{\r\n    final JsonToken peeked \u003d peek();\r\n    if (peeked \u003d\u003d JsonToken.NAME || peeked \u003d\u003d JsonToken.END_ARRAY || peeked \u003d\u003d JsonToken.END_OBJECT || peeked \u003d\u003d JsonToken.END_DOCUMENT) {\r\n        throw new IllegalStateException(\"Unexpected \" + peeked + \" when reading a JsonElement.\");\r\n    }\r\n    final JsonElement element \u003d (JsonElement) peekStack();\r\n    skipValue();\r\n    return element;\r\n}",
    "promoteNameToValue": "{\r\n    expect(JsonToken.NAME);\r\n    Iterator\u003c?\u003e i \u003d (Iterator\u003c?\u003e) peekStack();\r\n    Map.Entry\u003c?, ?\u003e entry \u003d (Map.Entry\u003c?, ?\u003e) i.next();\r\n    push(entry.getValue());\r\n    push(new JsonPrimitive((String) entry.getKey()));\r\n}",
    "peekStack": "{\r\n    return stack[stackSize - 1];\r\n}",
    "getPath": "{\r\n    return getPath(false);\r\n}",
    "nextBoolean": "{\r\n    expect(JsonToken.BOOLEAN);\r\n    boolean result \u003d ((JsonPrimitive) popStack()).getAsBoolean();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "close": "{\r\n    stack \u003d new Object[] { SENTINEL_CLOSED };\r\n    stackSize \u003d 1;\r\n}",
    "skipValue": "{\r\n    JsonToken peeked \u003d peek();\r\n    switch(peeked) {\r\n        case NAME:\r\n            @SuppressWarnings(\"unused\")\r\n            String unused \u003d nextName(true);\r\n            break;\r\n        case END_ARRAY:\r\n            endArray();\r\n            break;\r\n        case END_OBJECT:\r\n            endObject();\r\n            break;\r\n        case END_DOCUMENT:\r\n            // Do nothing\r\n            break;\r\n        default:\r\n            popStack();\r\n            if (stackSize \u003e 0) {\r\n                pathIndices[stackSize - 1]++;\r\n            }\r\n            break;\r\n    }\r\n}",
    "read": "{\r\n    throw new AssertionError();\r\n}",
    "getPreviousPath": "{\r\n    return getPath(true);\r\n}",
    "hasNext": "{\r\n    JsonToken token \u003d peek();\r\n    return token !\u003d JsonToken.END_OBJECT \u0026\u0026 token !\u003d JsonToken.END_ARRAY \u0026\u0026 token !\u003d JsonToken.END_DOCUMENT;\r\n}",
    "nextInt": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    int result \u003d ((JsonPrimitive) peekStack()).getAsInt();\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "nextLong": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    long result \u003d ((JsonPrimitive) peekStack()).getAsLong();\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "nextDouble": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    double result \u003d ((JsonPrimitive) peekStack()).getAsDouble();\r\n    if (!isLenient() \u0026\u0026 (Double.isNaN(result) || Double.isInfinite(result))) {\r\n        throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result);\r\n    }\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "push": "{\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        int newLength \u003d stackSize * 2;\r\n        stack \u003d Arrays.copyOf(stack, newLength);\r\n        pathIndices \u003d Arrays.copyOf(pathIndices, newLength);\r\n        pathNames \u003d Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}",
    "endObject": "{\r\n    expect(JsonToken.END_OBJECT);\r\n    // Free the last path name so that it can be garbage collected\r\n    pathNames[stackSize - 1] \u003d null;\r\n    // empty iterator\r\n    popStack();\r\n    // object\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}",
    "peek": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}",
    "expect": "{\r\n    if (peek() !\u003d expected) {\r\n        throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString());\r\n    }\r\n}",
    "beginObject": "{\r\n    expect(JsonToken.BEGIN_OBJECT);\r\n    JsonObject object \u003d (JsonObject) peekStack();\r\n    push(object.entrySet().iterator());\r\n}",
    "locationString": "{\r\n    return \" at path \" + getPath();\r\n}",
    "toString": "{\r\n    return getClass().getSimpleName() + locationString();\r\n}",
    "nextName": "{\r\n    return nextName(false);\r\n}",
    "nextNull": "{\r\n    expect(JsonToken.NULL);\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\UnsafeAllocator.java": {
    "create": "{\r\n    // try JVM\r\n    // public class Unsafe {\r\n    //   public Object allocateInstance(Class\u003c?\u003e type);\r\n    // }\r\n    try {\r\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\r\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\r\n        f.setAccessible(true);\r\n        final Object unsafe \u003d f.get(null);\r\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\r\n        return new UnsafeAllocator() {\r\n\r\n            @Override\r\n            @SuppressWarnings(\"unchecked\")\r\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n                assertInstantiable(c);\r\n                return (T) allocateInstance.invoke(unsafe, c);\r\n            }\r\n        };\r\n    } catch (Exception ignored) {\r\n        // OK: try the next way\r\n    }\r\n    // try dalvikvm, post-gingerbread\r\n    // public class ObjectStreamClass {\r\n    //   private static native int getConstructorId(Class\u003c?\u003e c);\r\n    //   private static native Object newInstance(Class\u003c?\u003e instantiationClass, int methodId);\r\n    // }\r\n    try {\r\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\r\n        getConstructorId.setAccessible(true);\r\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\r\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\r\n        newInstance.setAccessible(true);\r\n        return new UnsafeAllocator() {\r\n\r\n            @Override\r\n            @SuppressWarnings(\"unchecked\")\r\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n                assertInstantiable(c);\r\n                return (T) newInstance.invoke(null, c, constructorId);\r\n            }\r\n        };\r\n    } catch (Exception ignored) {\r\n        // OK: try the next way\r\n    }\r\n    // try dalvikvm, pre-gingerbread\r\n    // public class ObjectInputStream {\r\n    //   private static native Object newInstance(\r\n    //     Class\u003c?\u003e instantiationClass, Class\u003c?\u003e constructorClass);\r\n    // }\r\n    try {\r\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\r\n        newInstance.setAccessible(true);\r\n        return new UnsafeAllocator() {\r\n\r\n            @Override\r\n            @SuppressWarnings(\"unchecked\")\r\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n                assertInstantiable(c);\r\n                return (T) newInstance.invoke(null, c, Object.class);\r\n            }\r\n        };\r\n    } catch (Exception ignored) {\r\n        // OK: try the next way\r\n    }\r\n    // give up\r\n    return new UnsafeAllocator() {\r\n\r\n        @Override\r\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\r\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c + \". Usage of JDK sun.misc.Unsafe is enabled, \" + \"but it could not be used. Make sure your runtime is configured correctly.\");\r\n        }\r\n    };\r\n}",
    "newInstance": "{\r\n    throw new UnsupportedOperationException(\"Cannot allocate \" + c + \". Usage of JDK sun.misc.Unsafe is enabled, \" + \"but it could not be used. Make sure your runtime is configured correctly.\");\r\n}",
    "assertInstantiable": "{\r\n    String exceptionMessage \u003d ConstructorConstructor.checkInstantiable(c);\r\n    if (exceptionMessage !\u003d null) {\r\n        throw new AssertionError(\"UnsafeAllocator is used for non-instantiable type: \" + exceptionMessage);\r\n    }\r\n}"
  },
  "google_json\\examples\\android-proguard-example\\src\\com\\google\\gson\\examples\\android\\GsonProguardExampleActivity.java": {
    "onCreate": "{\r\n    super.onCreate(icicle);\r\n    setContentView(R.layout.main);\r\n    TextView tv \u003d (TextView) findViewById(R.id.tv);\r\n    Gson gson \u003d new Gson();\r\n    Cart cart \u003d buildCart();\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\"Gson.toJson() example: \\n\");\r\n    sb.append(\"  Cart Object: \").append(cart).append(\"\\n\");\r\n    sb.append(\"  Cart JSON: \").append(gson.toJson(cart)).append(\"\\n\");\r\n    sb.append(\"\\n\\nGson.fromJson() example: \\n\");\r\n    String json \u003d \"{buyer:\u0027Happy Camper\u0027,creditCard:\u00274111-1111-1111-1111\u0027,\" + \"lineItems:[{name:\u0027nails\u0027,priceInMicros:100000,quantity:100,currencyCode:\u0027USD\u0027}]}\";\r\n    sb.append(\"Cart JSON: \").append(json).append(\"\\n\");\r\n    sb.append(\"Cart Object: \").append(gson.fromJson(json, Cart.class)).append(\"\\n\");\r\n    tv.setText(sb.toString());\r\n    tv.invalidate();\r\n}",
    "buildCart": "{\r\n    List\u003cLineItem\u003e lineItems \u003d new ArrayList\u003c\u003e();\r\n    lineItems.add(new LineItem(\"hammer\", 1, 12000000, \"USD\"));\r\n    return new Cart(lineItems, \"Happy Buyer\", \"4111-1111-1111-1111\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\LongSerializationPolicy.java": {
    "serialize": "{\r\n    if (value \u003d\u003d null) {\r\n        return JsonNull.INSTANCE;\r\n    }\r\n    return new JsonPrimitive(value.toString());\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\interceptors\\Intercept.java": {},
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithAdapter.java": {
    "read": "{\r\n    in.beginObject();\r\n    String name \u003d in.nextName();\r\n    if (!name.equals(\"custom\")) {\r\n        throw new IllegalArgumentException(\"Unexpected name: \" + name);\r\n    }\r\n    int i \u003d in.nextInt();\r\n    in.endObject();\r\n    return new ClassWithAdapter(i);\r\n}",
    "toString": "{\r\n    return \"ClassWithAdapter[\" + i + \"]\";\r\n}",
    "write": "{\r\n    out.beginObject();\r\n    out.name(\"custom\");\r\n    out.value(value.i);\r\n    out.endObject();\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\PostConstructAdapterFactory.java": {
    "read": "{\r\n    T result \u003d delegate.read(in);\r\n    if (result !\u003d null) {\r\n        try {\r\n            method.invoke(result);\r\n        } catch (IllegalAccessException e) {\r\n            throw new AssertionError();\r\n        } catch (InvocationTargetException e) {\r\n            if (e.getCause() instanceof RuntimeException)\r\n                throw (RuntimeException) e.getCause();\r\n            throw new RuntimeException(e.getCause());\r\n        }\r\n    }\r\n    return result;\r\n}",
    "create": "{\r\n    for (Class\u003c?\u003e t \u003d type.getRawType(); (t !\u003d Object.class) \u0026\u0026 (t.getSuperclass() !\u003d null); t \u003d t.getSuperclass()) {\r\n        for (Method m : t.getDeclaredMethods()) {\r\n            if (m.isAnnotationPresent(PostConstruct.class)) {\r\n                m.setAccessible(true);\r\n                TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n                return new PostConstructAdapter\u003c\u003e(delegate, m);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "write": "{\r\n    delegate.write(out, value);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\FormattingStyle.java": {
    "withSpaceAfterSeparators": "{\r\n    return new FormattingStyle(this.newline, this.indent, spaceAfterSeparators);\r\n}",
    "getIndent": "{\r\n    return this.indent;\r\n}",
    "withNewline": "{\r\n    return new FormattingStyle(newline, this.indent, this.spaceAfterSeparators);\r\n}",
    "usesSpaceAfterSeparators": "{\r\n    return this.spaceAfterSeparators;\r\n}",
    "withIndent": "{\r\n    return new FormattingStyle(this.newline, indent, this.spaceAfterSeparators);\r\n}",
    "getNewline": "{\r\n    return this.newline;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\TypeAdapterFactory.java": {},
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\interceptors\\JsonPostDeserializer.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java": {
    "buildUnexpectedTypeError": "{\r\n    // Build exception message\r\n    StringBuilder exceptionMessage \u003d new StringBuilder(\"Unexpected type. Expected one of: \");\r\n    for (Class\u003c?\u003e clazz : expected) {\r\n        exceptionMessage.append(clazz.getName()).append(\", \");\r\n    }\r\n    exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append(\u0027.\u0027);\r\n    return new AssertionError(exceptionMessage.toString());\r\n}",
    "getRawType": "{\r\n    return rawType;\r\n}",
    "getArray": "{\r\n    return new TypeToken\u003c\u003e($Gson$Types.arrayOf(componentType));\r\n}",
    "isAssignableFrom": "{\r\n    if (from \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (to.equals(from)) {\r\n        return true;\r\n    }\r\n    // First figure out the class and any type information.\r\n    Class\u003c?\u003e clazz \u003d $Gson$Types.getRawType(from);\r\n    ParameterizedType ptype \u003d null;\r\n    if (from instanceof ParameterizedType) {\r\n        ptype \u003d (ParameterizedType) from;\r\n    }\r\n    // Load up parameterized variable info if it was parameterized.\r\n    if (ptype !\u003d null) {\r\n        Type[] tArgs \u003d ptype.getActualTypeArguments();\r\n        TypeVariable\u003c?\u003e[] tParams \u003d clazz.getTypeParameters();\r\n        for (int i \u003d 0; i \u003c tArgs.length; i++) {\r\n            Type arg \u003d tArgs[i];\r\n            TypeVariable\u003c?\u003e var \u003d tParams[i];\r\n            while (arg instanceof TypeVariable\u003c?\u003e) {\r\n                TypeVariable\u003c?\u003e v \u003d (TypeVariable\u003c?\u003e) arg;\r\n                arg \u003d typeVarMap.get(v.getName());\r\n            }\r\n            typeVarMap.put(var.getName(), arg);\r\n        }\r\n        // check if they are equivalent under our current mapping.\r\n        if (typeEquals(ptype, to, typeVarMap)) {\r\n            return true;\r\n        }\r\n    }\r\n    for (Type itype : clazz.getGenericInterfaces()) {\r\n        if (isAssignableFrom(itype, to, new HashMap\u003c\u003e(typeVarMap))) {\r\n            return true;\r\n        }\r\n    }\r\n    // Interfaces didn\u0027t work, try the superclass.\r\n    Type sType \u003d clazz.getGenericSuperclass();\r\n    return isAssignableFrom(sType, to, new HashMap\u003c\u003e(typeVarMap));\r\n}",
    "matches": "{\r\n    return to.equals(from) || (from instanceof TypeVariable \u0026\u0026 to.equals(typeMap.get(((TypeVariable\u003c?\u003e) from).getName())));\r\n}",
    "getTypeTokenTypeArgument": "{\r\n    Type superclass \u003d getClass().getGenericSuperclass();\r\n    if (superclass instanceof ParameterizedType) {\r\n        ParameterizedType parameterized \u003d (ParameterizedType) superclass;\r\n        if (parameterized.getRawType() \u003d\u003d TypeToken.class) {\r\n            Type typeArgument \u003d $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\r\n            if (isCapturingTypeVariablesForbidden()) {\r\n                verifyNoTypeVariable(typeArgument);\r\n            }\r\n            return typeArgument;\r\n        }\r\n    } else // Check for raw TypeToken as superclass\r\n    if (superclass \u003d\u003d TypeToken.class) {\r\n        throw new IllegalStateException(\"TypeToken must be created with a type argument: new TypeToken\u003c...\u003e() {};\" + \" When using code shrinkers (ProGuard, R8, ...) make sure that generic signatures are preserved.\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"type-token-raw\"));\r\n    }\r\n    // User created subclass of subclass of TypeToken\r\n    throw new IllegalStateException(\"Must only create direct subclasses of TypeToken\");\r\n}",
    "getParameterized": "{\r\n    Objects.requireNonNull(rawType);\r\n    Objects.requireNonNull(typeArguments);\r\n    // Perform basic validation here because this is the only public API where users\r\n    // can create malformed parameterized types\r\n    if (!(rawType instanceof Class)) {\r\n        // See also https://bugs.openjdk.org/browse/JDK-8250659\r\n        throw new IllegalArgumentException(\"rawType must be of type Class, but was \" + rawType);\r\n    }\r\n    Class\u003c?\u003e rawClass \u003d (Class\u003c?\u003e) rawType;\r\n    TypeVariable\u003c?\u003e[] typeVariables \u003d rawClass.getTypeParameters();\r\n    int expectedArgsCount \u003d typeVariables.length;\r\n    int actualArgsCount \u003d typeArguments.length;\r\n    if (actualArgsCount !\u003d expectedArgsCount) {\r\n        throw new IllegalArgumentException(rawClass.getName() + \" requires \" + expectedArgsCount + \" type arguments, but got \" + actualArgsCount);\r\n    }\r\n    // For legacy reasons create a TypeToken(Class) if the type is not generic\r\n    if (typeArguments.length \u003d\u003d 0) {\r\n        return get(rawClass);\r\n    }\r\n    // Check for this here to avoid misleading exception thrown by ParameterizedTypeImpl\r\n    if ($Gson$Types.requiresOwnerType(rawType)) {\r\n        throw new IllegalArgumentException(\"Raw type \" + rawClass.getName() + \" is not supported because\" + \" it requires specifying an owner type\");\r\n    }\r\n    for (int i \u003d 0; i \u003c expectedArgsCount; i++) {\r\n        Type typeArgument \u003d Objects.requireNonNull(typeArguments[i], \"Type argument must not be null\");\r\n        Class\u003c?\u003e rawTypeArgument \u003d $Gson$Types.getRawType(typeArgument);\r\n        TypeVariable\u003c?\u003e typeVariable \u003d typeVariables[i];\r\n        for (Type bound : typeVariable.getBounds()) {\r\n            Class\u003c?\u003e rawBound \u003d $Gson$Types.getRawType(bound);\r\n            if (!rawBound.isAssignableFrom(rawTypeArgument)) {\r\n                throw new IllegalArgumentException(\"Type argument \" + typeArgument + \" does not satisfy bounds\" + \" for type variable \" + typeVariable + \" declared by \" + rawType);\r\n            }\r\n        }\r\n    }\r\n    return new TypeToken\u003c\u003e($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));\r\n}",
    "getType": "{\r\n    return type;\r\n}",
    "isCapturingTypeVariablesForbidden": "{\r\n    return !Objects.equals(System.getProperty(\"gson.allowCapturingTypeVariables\"), \"true\");\r\n}",
    "hashCode": "{\r\n    return this.hashCode;\r\n}",
    "equals": "{\r\n    return o instanceof TypeToken\u003c?\u003e \u0026\u0026 $Gson$Types.equals(type, ((TypeToken\u003c?\u003e) o).type);\r\n}",
    "get": "{\r\n    return new TypeToken\u003c\u003e(type);\r\n}",
    "toString": "{\r\n    return $Gson$Types.typeToString(type);\r\n}",
    "verifyNoTypeVariable": "{\r\n    if (type instanceof TypeVariable) {\r\n        TypeVariable\u003c?\u003e typeVariable \u003d (TypeVariable\u003c?\u003e) type;\r\n        throw new IllegalArgumentException(\"TypeToken type argument must not contain a type variable; captured type variable \" + typeVariable.getName() + \" declared by \" + typeVariable.getGenericDeclaration() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"typetoken-type-variable\"));\r\n    } else if (type instanceof GenericArrayType) {\r\n        verifyNoTypeVariable(((GenericArrayType) type).getGenericComponentType());\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType parameterizedType \u003d (ParameterizedType) type;\r\n        Type ownerType \u003d parameterizedType.getOwnerType();\r\n        if (ownerType !\u003d null) {\r\n            verifyNoTypeVariable(ownerType);\r\n        }\r\n        for (Type typeArgument : parameterizedType.getActualTypeArguments()) {\r\n            verifyNoTypeVariable(typeArgument);\r\n        }\r\n    } else if (type instanceof WildcardType) {\r\n        WildcardType wildcardType \u003d (WildcardType) type;\r\n        for (Type bound : wildcardType.getLowerBounds()) {\r\n            verifyNoTypeVariable(bound);\r\n        }\r\n        for (Type bound : wildcardType.getUpperBounds()) {\r\n            verifyNoTypeVariable(bound);\r\n        }\r\n    } else if (type \u003d\u003d null) {\r\n        // Occurs in Eclipse IDE and certain Java versions (e.g. Java 11.0.18) when capturing type variable\r\n        // declared by method of local class, see https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n        throw new IllegalArgumentException(\"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n    }\r\n}",
    "typeEquals": "{\r\n    if (from.getRawType().equals(to.getRawType())) {\r\n        Type[] fromArgs \u003d from.getActualTypeArguments();\r\n        Type[] toArgs \u003d to.getActualTypeArguments();\r\n        for (int i \u003d 0; i \u003c fromArgs.length; i++) {\r\n            if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\GenericClasses.java": {
    "read": "{\r\n    return new DummyClass(\"read-\" + in.nextInt());\r\n}",
    "toString": "{\r\n    return s;\r\n}",
    "write": "{\r\n    throw new UnsupportedOperationException();\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\JsonAdapter.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\Expose.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\MockExclusionStrategy.java": {
    "shouldSkipClass": "{\r\n    return skipClass;\r\n}",
    "shouldSkipField": "{\r\n    return skipField;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonDeserializer.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonDeserializationContext.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonPrimitive.java": {
    "getAsBigInteger": "{\r\n    return value instanceof BigInteger ? (BigInteger) value : isIntegral(this) ? BigInteger.valueOf(this.getAsNumber().longValue()) : new BigInteger(this.getAsString());\r\n}",
    "getAsFloat": "{\r\n    return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString());\r\n}",
    "getAsByte": "{\r\n    return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString());\r\n}",
    "getAsBigDecimal": "{\r\n    return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(getAsString());\r\n}",
    "isIntegral": "{\r\n    if (primitive.value instanceof Number) {\r\n        Number number \u003d (Number) primitive.value;\r\n        return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte;\r\n    }\r\n    return false;\r\n}",
    "getAsNumber": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}",
    "getAsCharacter": "{\r\n    String s \u003d getAsString();\r\n    if (s.isEmpty()) {\r\n        throw new UnsupportedOperationException(\"String value is empty\");\r\n    } else {\r\n        return s.charAt(0);\r\n    }\r\n}",
    "getAsString": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}",
    "getAsDouble": "{\r\n    return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString());\r\n}",
    "getAsInt": "{\r\n    return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString());\r\n}",
    "deepCopy": "{\r\n    return this;\r\n}",
    "isBoolean": "{\r\n    return value instanceof Boolean;\r\n}",
    "getAsLong": "{\r\n    return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString());\r\n}",
    "getAsBoolean": "{\r\n    if (isBoolean()) {\r\n        return (Boolean) value;\r\n    }\r\n    // Check to see if the value as a String is \"true\" in any case.\r\n    return Boolean.parseBoolean(getAsString());\r\n}",
    "isNumber": "{\r\n    return value instanceof Number;\r\n}",
    "hashCode": "{\r\n    if (value \u003d\u003d null) {\r\n        return 31;\r\n    }\r\n    // Using recommended hashing algorithm from Effective Java for longs and doubles\r\n    if (isIntegral(this)) {\r\n        long value \u003d getAsNumber().longValue();\r\n        return (int) (value ^ (value \u003e\u003e\u003e 32));\r\n    }\r\n    if (value instanceof Number) {\r\n        long value \u003d Double.doubleToLongBits(getAsNumber().doubleValue());\r\n        return (int) (value ^ (value \u003e\u003e\u003e 32));\r\n    }\r\n    return value.hashCode();\r\n}",
    "equals": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    JsonPrimitive other \u003d (JsonPrimitive) obj;\r\n    if (value \u003d\u003d null) {\r\n        return other.value \u003d\u003d null;\r\n    }\r\n    if (isIntegral(this) \u0026\u0026 isIntegral(other)) {\r\n        return (this.value instanceof BigInteger || other.value instanceof BigInteger) ? this.getAsBigInteger().equals(other.getAsBigInteger()) : this.getAsNumber().longValue() \u003d\u003d other.getAsNumber().longValue();\r\n    }\r\n    if (value instanceof Number \u0026\u0026 other.value instanceof Number) {\r\n        double a \u003d getAsNumber().doubleValue();\r\n        // Java standard types other than double return true for two NaN. So, need\r\n        // special handling for double.\r\n        double b \u003d other.getAsNumber().doubleValue();\r\n        return a \u003d\u003d b || (Double.isNaN(a) \u0026\u0026 Double.isNaN(b));\r\n    }\r\n    return value.equals(other.value);\r\n}",
    "isString": "{\r\n    return value instanceof String;\r\n}",
    "getAsShort": "{\r\n    return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString());\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\TypeAdapter.java": {
    "toJson": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    try {\r\n        toJson(stringWriter, value);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n    return stringWriter.toString();\r\n}",
    "read": "{\r\n    if (reader.peek() \u003d\u003d JsonToken.NULL) {\r\n        reader.nextNull();\r\n        return null;\r\n    }\r\n    return TypeAdapter.this.read(reader);\r\n}",
    "toJsonTree": "{\r\n    try {\r\n        JsonTreeWriter jsonWriter \u003d new JsonTreeWriter();\r\n        write(jsonWriter, value);\r\n        return jsonWriter.get();\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}",
    "fromJson": "{\r\n    return fromJson(new StringReader(json));\r\n}",
    "nullSafe": "{\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n            } else {\r\n                TypeAdapter.this.write(out, value);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader reader) throws IOException {\r\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\r\n                reader.nextNull();\r\n                return null;\r\n            }\r\n            return TypeAdapter.this.read(reader);\r\n        }\r\n    };\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        TypeAdapter.this.write(out, value);\r\n    }\r\n}",
    "fromJsonTree": "{\r\n    try {\r\n        JsonReader jsonReader \u003d new JsonTreeReader(jsonTree);\r\n        return read(jsonReader);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\FieldNamingStrategy.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\JsonReaderInternalAccess.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java": {
    "setFieldNamingPolicy": "{\r\n    return setFieldNamingStrategy(namingConvention);\r\n}",
    "enableComplexMapKeySerialization": "{\r\n    complexMapKeySerialization \u003d true;\r\n    return this;\r\n}",
    "disableInnerClassSerialization": "{\r\n    excluder \u003d excluder.disableInnerClassSerialization();\r\n    return this;\r\n}",
    "excludeFieldsWithModifiers": "{\r\n    Objects.requireNonNull(modifiers);\r\n    excluder \u003d excluder.withModifiers(modifiers);\r\n    return this;\r\n}",
    "setLenient": "{\r\n    return setStrictness(Strictness.LENIENT);\r\n}",
    "serializeNulls": "{\r\n    this.serializeNulls \u003d true;\r\n    return this;\r\n}",
    "disableJdkUnsafe": "{\r\n    this.useJdkUnsafe \u003d false;\r\n    return this;\r\n}",
    "generateNonExecutableJson": "{\r\n    this.generateNonExecutableJson \u003d true;\r\n    return this;\r\n}",
    "addSerializationExclusionStrategy": "{\r\n    Objects.requireNonNull(strategy);\r\n    excluder \u003d excluder.withExclusionStrategy(strategy, true, false);\r\n    return this;\r\n}",
    "registerTypeHierarchyAdapter": "{\r\n    Objects.requireNonNull(baseType);\r\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e || typeAdapter instanceof TypeAdapter\u003c?\u003e);\r\n    if (JsonElement.class.isAssignableFrom(baseType)) {\r\n        throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + baseType);\r\n    }\r\n    if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\r\n        hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\r\n    }\r\n    if (typeAdapter instanceof TypeAdapter\u003c?\u003e) {\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapterFactory factory \u003d TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter) typeAdapter);\r\n        factories.add(factory);\r\n    }\r\n    return this;\r\n}",
    "addDeserializationExclusionStrategy": "{\r\n    Objects.requireNonNull(strategy);\r\n    excluder \u003d excluder.withExclusionStrategy(strategy, false, true);\r\n    return this;\r\n}",
    "setLongSerializationPolicy": "{\r\n    this.longSerializationPolicy \u003d Objects.requireNonNull(serializationPolicy);\r\n    return this;\r\n}",
    "registerTypeAdapterFactory": "{\r\n    Objects.requireNonNull(factory);\r\n    factories.add(factory);\r\n    return this;\r\n}",
    "create": "{\r\n    List\u003cTypeAdapterFactory\u003e factories \u003d new ArrayList\u003c\u003e(this.factories.size() + this.hierarchyFactories.size() + 3);\r\n    factories.addAll(this.factories);\r\n    Collections.reverse(factories);\r\n    List\u003cTypeAdapterFactory\u003e hierarchyFactories \u003d new ArrayList\u003c\u003e(this.hierarchyFactories);\r\n    Collections.reverse(hierarchyFactories);\r\n    factories.addAll(hierarchyFactories);\r\n    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);\r\n    return new Gson(excluder, fieldNamingPolicy, new HashMap\u003c\u003e(instanceCreators), serializeNulls, complexMapKeySerialization, generateNonExecutableJson, escapeHtmlChars, formattingStyle, strictness, serializeSpecialFloatingPointValues, useJdkUnsafe, longSerializationPolicy, datePattern, dateStyle, timeStyle, new ArrayList\u003c\u003e(this.factories), new ArrayList\u003c\u003e(this.hierarchyFactories), factories, objectToNumberStrategy, numberToNumberStrategy, new ArrayList\u003c\u003e(reflectionFilters));\r\n}",
    "setFormattingStyle": "{\r\n    this.formattingStyle \u003d Objects.requireNonNull(formattingStyle);\r\n    return this;\r\n}",
    "disableHtmlEscaping": "{\r\n    this.escapeHtmlChars \u003d false;\r\n    return this;\r\n}",
    "addReflectionAccessFilter": "{\r\n    Objects.requireNonNull(filter);\r\n    reflectionFilters.addFirst(filter);\r\n    return this;\r\n}",
    "setDateFormat": "{\r\n    this.dateStyle \u003d dateStyle;\r\n    this.timeStyle \u003d timeStyle;\r\n    this.datePattern \u003d null;\r\n    return this;\r\n}",
    "setObjectToNumberStrategy": "{\r\n    this.objectToNumberStrategy \u003d Objects.requireNonNull(objectToNumberStrategy);\r\n    return this;\r\n}",
    "setVersion": "{\r\n    if (Double.isNaN(version) || version \u003c 0.0) {\r\n        throw new IllegalArgumentException(\"Invalid version: \" + version);\r\n    }\r\n    excluder \u003d excluder.withVersion(version);\r\n    return this;\r\n}",
    "setNumberToNumberStrategy": "{\r\n    this.numberToNumberStrategy \u003d Objects.requireNonNull(numberToNumberStrategy);\r\n    return this;\r\n}",
    "setFieldNamingStrategy": "{\r\n    this.fieldNamingPolicy \u003d Objects.requireNonNull(fieldNamingStrategy);\r\n    return this;\r\n}",
    "addTypeAdaptersForDate": "{\r\n    TypeAdapterFactory dateAdapterFactory;\r\n    boolean sqlTypesSupported \u003d SqlTypesSupport.SUPPORTS_SQL_TYPES;\r\n    TypeAdapterFactory sqlTimestampAdapterFactory \u003d null;\r\n    TypeAdapterFactory sqlDateAdapterFactory \u003d null;\r\n    if (datePattern !\u003d null \u0026\u0026 !datePattern.trim().isEmpty()) {\r\n        dateAdapterFactory \u003d DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(datePattern);\r\n        if (sqlTypesSupported) {\r\n            sqlTimestampAdapterFactory \u003d SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(datePattern);\r\n            sqlDateAdapterFactory \u003d SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(datePattern);\r\n        }\r\n    } else if (dateStyle !\u003d DateFormat.DEFAULT \u0026\u0026 timeStyle !\u003d DateFormat.DEFAULT) {\r\n        dateAdapterFactory \u003d DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(dateStyle, timeStyle);\r\n        if (sqlTypesSupported) {\r\n            sqlTimestampAdapterFactory \u003d SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);\r\n            sqlDateAdapterFactory \u003d SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);\r\n        }\r\n    } else {\r\n        return;\r\n    }\r\n    factories.add(dateAdapterFactory);\r\n    if (sqlTypesSupported) {\r\n        factories.add(sqlTimestampAdapterFactory);\r\n        factories.add(sqlDateAdapterFactory);\r\n    }\r\n}",
    "serializeSpecialFloatingPointValues": "{\r\n    this.serializeSpecialFloatingPointValues \u003d true;\r\n    return this;\r\n}",
    "setPrettyPrinting": "{\r\n    return setFormattingStyle(FormattingStyle.PRETTY);\r\n}",
    "registerTypeAdapter": "{\r\n    Objects.requireNonNull(type);\r\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e || typeAdapter instanceof InstanceCreator\u003c?\u003e || typeAdapter instanceof TypeAdapter\u003c?\u003e);\r\n    if (isTypeObjectOrJsonElement(type)) {\r\n        throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + type);\r\n    }\r\n    if (typeAdapter instanceof InstanceCreator\u003c?\u003e) {\r\n        instanceCreators.put(type, (InstanceCreator\u003c?\u003e) typeAdapter);\r\n    }\r\n    if (typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e) {\r\n        TypeToken\u003c?\u003e typeToken \u003d TypeToken.get(type);\r\n        factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));\r\n    }\r\n    if (typeAdapter instanceof TypeAdapter\u003c?\u003e) {\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapterFactory factory \u003d TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter) typeAdapter);\r\n        factories.add(factory);\r\n    }\r\n    return this;\r\n}",
    "isTypeObjectOrJsonElement": "{\r\n    return type instanceof Class \u0026\u0026 (type \u003d\u003d Object.class || JsonElement.class.isAssignableFrom((Class\u003c?\u003e) type));\r\n}",
    "setStrictness": "{\r\n    this.strictness \u003d Objects.requireNonNull(strictness);\r\n    return this;\r\n}",
    "excludeFieldsWithoutExposeAnnotation": "{\r\n    excluder \u003d excluder.excludeFieldsWithoutExposeAnnotation();\r\n    return this;\r\n}",
    "setExclusionStrategies": "{\r\n    Objects.requireNonNull(strategies);\r\n    for (ExclusionStrategy strategy : strategies) {\r\n        excluder \u003d excluder.withExclusionStrategy(strategy, true, true);\r\n    }\r\n    return this;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonToken.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\package-info.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\NonNullElementWrapperList.java": {
    "add": "{\r\n    delegate.add(index, nonNull(element));\r\n}",
    "set": "{\r\n    return delegate.set(index, nonNull(element));\r\n}",
    "clear": "{\r\n    delegate.clear();\r\n}",
    "remove": "{\r\n    return delegate.remove(o);\r\n}",
    "lastIndexOf": "{\r\n    return delegate.lastIndexOf(o);\r\n}",
    "removeAll": "{\r\n    return delegate.removeAll(c);\r\n}",
    "contains": "{\r\n    return delegate.contains(o);\r\n}",
    "size": "{\r\n    return delegate.size();\r\n}",
    "hashCode": "{\r\n    return delegate.hashCode();\r\n}",
    "get": "{\r\n    return delegate.get(index);\r\n}",
    "equals": "{\r\n    return delegate.equals(o);\r\n}",
    "toArray": "{\r\n    return delegate.toArray(a);\r\n}",
    "indexOf": "{\r\n    return delegate.indexOf(o);\r\n}",
    "nonNull": "{\r\n    if (element \u003d\u003d null) {\r\n        throw new NullPointerException(\"Element must be non-null\");\r\n    }\r\n    return element;\r\n}",
    "retainAll": "{\r\n    return delegate.retainAll(c);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonSerializer.java": {},
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithExposeAnnotation.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapterRuntimeTypeWrapper.java": {
    "read": "{\r\n    return delegate.read(in);\r\n}",
    "getRuntimeTypeIfMoreSpecific": "{\r\n    if (value !\u003d null \u0026\u0026 (type instanceof Class\u003c?\u003e || type instanceof TypeVariable\u003c?\u003e)) {\r\n        type \u003d value.getClass();\r\n    }\r\n    return type;\r\n}",
    "write": "{\r\n    // Order of preference for choosing type adapters\r\n    // First preference: a type adapter registered for the runtime type\r\n    // Second preference: a type adapter registered for the declared type\r\n    // Third preference: reflective type adapter for the runtime type (if it is a subclass of the declared type)\r\n    // Fourth preference: reflective type adapter for the declared type\r\n    TypeAdapter\u003cT\u003e chosen \u003d delegate;\r\n    Type runtimeType \u003d getRuntimeTypeIfMoreSpecific(type, value);\r\n    if (runtimeType !\u003d type) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e runtimeTypeAdapter \u003d (TypeAdapter\u003cT\u003e) context.getAdapter(TypeToken.get(runtimeType));\r\n        // For backward compatibility only check ReflectiveTypeAdapterFactory.Adapter here but not any other\r\n        // wrapping adapters, see https://github.com/google/gson/pull/1787#issuecomment-1222175189\r\n        if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {\r\n            // The user registered a type adapter for the runtime type, so we will use that\r\n            chosen \u003d runtimeTypeAdapter;\r\n        } else if (!isReflective(delegate)) {\r\n            // The user registered a type adapter for Base class, so we prefer it over the\r\n            // reflective type adapter for the runtime type\r\n            chosen \u003d delegate;\r\n        } else {\r\n            // Use the type adapter for runtime type\r\n            chosen \u003d runtimeTypeAdapter;\r\n        }\r\n    }\r\n    chosen.write(out, value);\r\n}",
    "isReflective": "{\r\n    // Run this in loop in case multiple delegating adapters are nested\r\n    while (typeAdapter instanceof SerializationDelegatingTypeAdapter) {\r\n        TypeAdapter\u003c?\u003e delegate \u003d ((SerializationDelegatingTypeAdapter\u003c?\u003e) typeAdapter).getSerializationDelegate();\r\n        // Break if adapter does not delegate serialization\r\n        if (delegate \u003d\u003d typeAdapter) {\r\n            break;\r\n        }\r\n        typeAdapter \u003d delegate;\r\n    }\r\n    return typeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\Streams.java": {
    "writerForAppendable": "{\r\n    return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\r\n}",
    "flush": "{\r\n}",
    "setChars": "{\r\n    this.chars \u003d chars;\r\n    this.cachedString \u003d null;\r\n}",
    "length": "{\r\n    return chars.length;\r\n}",
    "toString": "{\r\n    if (cachedString \u003d\u003d null) {\r\n        cachedString \u003d new String(chars);\r\n    }\r\n    return cachedString;\r\n}",
    "parse": "{\r\n    boolean isEmpty \u003d true;\r\n    try {\r\n        JsonToken unused \u003d reader.peek();\r\n        isEmpty \u003d false;\r\n        return TypeAdapters.JSON_ELEMENT.read(reader);\r\n    } catch (EOFException e) {\r\n        /*\r\n       * For compatibility with JSON 1.5 and earlier, we return a JsonNull for\r\n       * empty documents instead of throwing.\r\n       */\r\n        if (isEmpty) {\r\n            return JsonNull.INSTANCE;\r\n        }\r\n        // The stream ended prematurely so it is likely a syntax error.\r\n        throw new JsonSyntaxException(e);\r\n    } catch (MalformedJsonException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(e);\r\n    }\r\n}",
    "subSequence": "{\r\n    return new String(chars, start, end - start);\r\n}",
    "write": "{\r\n    // Appendable.append turns null -\u003e \"null\", which is not desired here\r\n    Objects.requireNonNull(str);\r\n    appendable.append(str, off, off + len);\r\n}",
    "close": "{\r\n}",
    "append": "{\r\n    appendable.append(csq, start, end);\r\n    return this;\r\n}",
    "charAt": "{\r\n    return chars[i];\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\NoSerializedNameMain.java": {
    "runTestHasArgsConstructor": "{\r\n    TestClassHasArgsConstructor deserialized \u003d new Gson().fromJson(\"{\\\"s\\\":\\\"value\\\"}\", same(TestClassHasArgsConstructor.class));\r\n    return deserialized.s;\r\n}",
    "runTestNoArgsConstructor": "{\r\n    TestClassNoArgsConstructor deserialized \u003d new Gson().fromJson(\"{\\\"s\\\":\\\"value\\\"}\", same(TestClassNoArgsConstructor.class));\r\n    return deserialized.s;\r\n}",
    "runTestNoJdkUnsafe": "{\r\n    Gson gson \u003d new GsonBuilder().disableJdkUnsafe().create();\r\n    TestClassNotAbstract deserialized \u003d gson.fromJson(\"{\\\"s\\\": \\\"value\\\"}\", same(TestClassNotAbstract.class));\r\n    return deserialized.s;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java": {
    "createAdapter": "{\r\n    // TODO: The exception messages created by ConstructorConstructor are currently written in the context of\r\n    // deserialization and for example suggest usage of TypeAdapter, which would not work for @JsonAdapter usage\r\n    return constructorConstructor.get(TypeToken.get(adapterClass)).construct();\r\n}",
    "getAnnotation": "{\r\n    return rawType.getAnnotation(JsonAdapter.class);\r\n}",
    "getTypeAdapter": "{\r\n    Object instance \u003d createAdapter(constructorConstructor, annotation.value());\r\n    TypeAdapter\u003c?\u003e typeAdapter;\r\n    boolean nullSafe \u003d annotation.nullSafe();\r\n    if (instance instanceof TypeAdapter) {\r\n        typeAdapter \u003d (TypeAdapter\u003c?\u003e) instance;\r\n    } else if (instance instanceof TypeAdapterFactory) {\r\n        TypeAdapterFactory factory \u003d (TypeAdapterFactory) instance;\r\n        if (isClassAnnotation) {\r\n            factory \u003d putFactoryAndGetCurrent(type.getRawType(), factory);\r\n        }\r\n        typeAdapter \u003d factory.create(gson, type);\r\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\r\n        JsonSerializer\u003c?\u003e serializer \u003d instance instanceof JsonSerializer ? (JsonSerializer\u003c?\u003e) instance : null;\r\n        JsonDeserializer\u003c?\u003e deserializer \u003d instance instanceof JsonDeserializer ? (JsonDeserializer\u003c?\u003e) instance : null;\r\n        // Uses dummy factory instances because TreeTypeAdapter needs a \u0027skipPast\u0027 factory for `Gson.getDelegateAdapter`\r\n        // call and has to differentiate there whether TreeTypeAdapter was created for @JsonAdapter on class or field\r\n        TypeAdapterFactory skipPast;\r\n        if (isClassAnnotation) {\r\n            skipPast \u003d TREE_TYPE_CLASS_DUMMY_FACTORY;\r\n        } else {\r\n            skipPast \u003d TREE_TYPE_FIELD_DUMMY_FACTORY;\r\n        }\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapter\u003c?\u003e tempAdapter \u003d new TreeTypeAdapter(serializer, deserializer, gson, type, skipPast, nullSafe);\r\n        typeAdapter \u003d tempAdapter;\r\n        // TreeTypeAdapter handles nullSafe; don\u0027t additionally call `nullSafe()`\r\n        nullSafe \u003d false;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \" + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString() + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\" + \" JsonSerializer or JsonDeserializer.\");\r\n    }\r\n    if (typeAdapter !\u003d null \u0026\u0026 nullSafe) {\r\n        typeAdapter \u003d typeAdapter.nullSafe();\r\n    }\r\n    return typeAdapter;\r\n}",
    "isClassJsonAdapterFactory": "{\r\n    Objects.requireNonNull(type);\r\n    Objects.requireNonNull(factory);\r\n    if (factory \u003d\u003d TREE_TYPE_CLASS_DUMMY_FACTORY) {\r\n        return true;\r\n    }\r\n    // Using raw type to match behavior of `create(Gson, TypeToken\u003cT\u003e)` above\r\n    Class\u003c?\u003e rawType \u003d type.getRawType();\r\n    TypeAdapterFactory existingFactory \u003d adapterFactoryMap.get(rawType);\r\n    if (existingFactory !\u003d null) {\r\n        // Checks for reference equality, like it is done by `Gson.getDelegateAdapter`\r\n        return existingFactory \u003d\u003d factory;\r\n    }\r\n    // If no factory has been created for the type yet check manually for a @JsonAdapter annotation\r\n    // which specifies a TypeAdapterFactory\r\n    // Otherwise behavior would not be consistent, depending on whether or not adapter had been requested\r\n    // before call to `isClassJsonAdapterFactory` was made\r\n    JsonAdapter annotation \u003d getAnnotation(rawType);\r\n    if (annotation \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    Class\u003c?\u003e adapterClass \u003d annotation.value();\r\n    if (!TypeAdapterFactory.class.isAssignableFrom(adapterClass)) {\r\n        return false;\r\n    }\r\n    Object adapter \u003d createAdapter(constructorConstructor, adapterClass);\r\n    TypeAdapterFactory newFactory \u003d (TypeAdapterFactory) adapter;\r\n    return putFactoryAndGetCurrent(rawType, newFactory) \u003d\u003d factory;\r\n}",
    "create": "{\r\n    Class\u003c? super T\u003e rawType \u003d targetType.getRawType();\r\n    JsonAdapter annotation \u003d getAnnotation(rawType);\r\n    if (annotation \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    return (TypeAdapter\u003cT\u003e) getTypeAdapter(constructorConstructor, gson, targetType, annotation, true);\r\n}",
    "putFactoryAndGetCurrent": "{\r\n    // Uses putIfAbsent in case multiple threads concurrently create factory\r\n    TypeAdapterFactory existingFactory \u003d adapterFactoryMap.putIfAbsent(rawType, factory);\r\n    return existingFactory !\u003d null ? existingFactory : factory;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonScope.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonSerializationContext.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\NumberTypeAdapter.java": {
    "read": "{\r\n    JsonToken jsonToken \u003d in.peek();\r\n    switch(jsonToken) {\r\n        case NULL:\r\n            in.nextNull();\r\n            return null;\r\n        case NUMBER:\r\n        case STRING:\r\n            return toNumberStrategy.readNumber(in);\r\n        default:\r\n            throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken + \"; at path \" + in.getPath());\r\n    }\r\n}",
    "newFactory": "{\r\n    final NumberTypeAdapter adapter \u003d new NumberTypeAdapter(toNumberStrategy);\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            return type.getRawType() \u003d\u003d Number.class ? (TypeAdapter\u003cT\u003e) adapter : null;\r\n        }\r\n    };\r\n}",
    "create": "{\r\n    return type.getRawType() \u003d\u003d Number.class ? (TypeAdapter\u003cT\u003e) adapter : null;\r\n}",
    "getFactory": "{\r\n    if (toNumberStrategy \u003d\u003d ToNumberPolicy.LAZILY_PARSED_NUMBER) {\r\n        return LAZILY_PARSED_NUMBER_FACTORY;\r\n    } else {\r\n        return newFactory(toNumberStrategy);\r\n    }\r\n}",
    "write": "{\r\n    out.value(value);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonTreeWriter.java": {
    "jsonValue": "{\r\n    throw new UnsupportedOperationException();\r\n}",
    "endArray": "{\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonArray) {\r\n        stack.remove(stack.size() - 1);\r\n        return this;\r\n    }\r\n    throw new IllegalStateException();\r\n}",
    "nullValue": "{\r\n    put(JsonNull.INSTANCE);\r\n    return this;\r\n}",
    "put": "{\r\n    if (pendingName !\u003d null) {\r\n        if (!value.isJsonNull() || getSerializeNulls()) {\r\n            JsonObject object \u003d (JsonObject) peek();\r\n            object.add(pendingName, value);\r\n        }\r\n        pendingName \u003d null;\r\n    } else if (stack.isEmpty()) {\r\n        product \u003d value;\r\n    } else {\r\n        JsonElement element \u003d peek();\r\n        if (element instanceof JsonArray) {\r\n            ((JsonArray) element).add(value);\r\n        } else {\r\n            throw new IllegalStateException();\r\n        }\r\n    }\r\n}",
    "peek": "{\r\n    return stack.get(stack.size() - 1);\r\n}",
    "endObject": "{\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonObject) {\r\n        stack.remove(stack.size() - 1);\r\n        return this;\r\n    }\r\n    throw new IllegalStateException();\r\n}",
    "beginArray": "{\r\n    JsonArray array \u003d new JsonArray();\r\n    put(array);\r\n    stack.add(array);\r\n    return this;\r\n}",
    "flush": "{\r\n}",
    "beginObject": "{\r\n    JsonObject object \u003d new JsonObject();\r\n    put(object);\r\n    stack.add(object);\r\n    return this;\r\n}",
    "get": "{\r\n    if (!stack.isEmpty()) {\r\n        throw new IllegalStateException(\"Expected one JSON element but was \" + stack);\r\n    }\r\n    return product;\r\n}",
    "name": "{\r\n    Objects.requireNonNull(name, \"name \u003d\u003d null\");\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException(\"Did not expect a name\");\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonObject) {\r\n        pendingName \u003d name;\r\n        return this;\r\n    }\r\n    throw new IllegalStateException(\"Please begin an object before writing a name.\");\r\n}",
    "write": "{\r\n    throw new AssertionError();\r\n}",
    "close": "{\r\n    if (!stack.isEmpty()) {\r\n        throw new IOException(\"Incomplete document\");\r\n    }\r\n    stack.add(SENTINEL_CLOSED);\r\n}",
    "value": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    if (!isLenient()) {\r\n        double d \u003d value.doubleValue();\r\n        if (Double.isNaN(d) || Double.isInfinite(d)) {\r\n            throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\r\n        }\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\CollectionTypeAdapterFactory.java": {
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    Collection\u003cE\u003e collection \u003d constructor.construct();\r\n    in.beginArray();\r\n    while (in.hasNext()) {\r\n        E instance \u003d elementTypeAdapter.read(in);\r\n        collection.add(instance);\r\n    }\r\n    in.endArray();\r\n    return collection;\r\n}",
    "create": "{\r\n    Type type \u003d typeToken.getType();\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    if (!Collection.class.isAssignableFrom(rawType)) {\r\n        return null;\r\n    }\r\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\r\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\r\n    // create() doesn\u0027t define a type parameter\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\r\n    return result;\r\n}",
    "write": "{\r\n    if (collection \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginArray();\r\n    for (E element : collection) {\r\n        elementTypeAdapter.write(out, element);\r\n    }\r\n    out.endArray();\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithVersionAnnotations.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\JavaVersion.java": {
    "determineMajorJavaVersion": "{\r\n    String javaVersion \u003d System.getProperty(\"java.version\");\r\n    return getMajorJavaVersion(javaVersion);\r\n}",
    "getMajorJavaVersion": "{\r\n    return majorJavaVersion;\r\n}",
    "parseDotted": "{\r\n    try {\r\n        String[] parts \u003d javaVersion.split(\"[._]\", 3);\r\n        int firstVer \u003d Integer.parseInt(parts[0]);\r\n        if (firstVer \u003d\u003d 1 \u0026\u0026 parts.length \u003e 1) {\r\n            return Integer.parseInt(parts[1]);\r\n        } else {\r\n            return firstVer;\r\n        }\r\n    } catch (NumberFormatException e) {\r\n        return -1;\r\n    }\r\n}",
    "isJava9OrLater": "{\r\n    return majorJavaVersion \u003e\u003d 9;\r\n}",
    "extractBeginningInt": "{\r\n    try {\r\n        StringBuilder num \u003d new StringBuilder();\r\n        for (int i \u003d 0; i \u003c javaVersion.length(); ++i) {\r\n            char c \u003d javaVersion.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                num.append(c);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return Integer.parseInt(num.toString());\r\n    } catch (NumberFormatException e) {\r\n        return -1;\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\reflect\\ReflectionHelper.java": {
    "getCanonicalRecordConstructor": "{\r\n    throw new UnsupportedOperationException(\"Records are not supported on this JVM, this method should not be called\");\r\n}",
    "appendExecutableParameters": "{\r\n    stringBuilder.append(\u0027(\u0027);\r\n    Class\u003c?\u003e[] parameters \u003d (executable instanceof Method) ? ((Method) executable).getParameterTypes() : ((Constructor\u003c?\u003e) executable).getParameterTypes();\r\n    for (int i \u003d 0; i \u003c parameters.length; i++) {\r\n        if (i \u003e 0) {\r\n            stringBuilder.append(\", \");\r\n        }\r\n        stringBuilder.append(parameters[i].getSimpleName());\r\n    }\r\n    stringBuilder.append(\u0027)\u0027);\r\n}",
    "isRecord": "{\r\n    return false;\r\n}",
    "createExceptionForUnexpectedIllegalAccess": "{\r\n    throw new RuntimeException(\"Unexpected IllegalAccessException occurred (Gson \" + GsonBuildConfig.VERSION + \").\" + \" Certain ReflectionAccessFilter features require Java \u003e\u003d 9 to work correctly. If you are not using\" + \" ReflectionAccessFilter, report this to the Gson maintainers.\", exception);\r\n}",
    "getAccessibleObjectDescription": "{\r\n    String description;\r\n    if (object instanceof Field) {\r\n        description \u003d \"field \u0027\" + fieldToString((Field) object) + \"\u0027\";\r\n    } else if (object instanceof Method) {\r\n        Method method \u003d (Method) object;\r\n        StringBuilder methodSignatureBuilder \u003d new StringBuilder(method.getName());\r\n        appendExecutableParameters(method, methodSignatureBuilder);\r\n        String methodSignature \u003d methodSignatureBuilder.toString();\r\n        description \u003d \"method \u0027\" + method.getDeclaringClass().getName() + \"#\" + methodSignature + \"\u0027\";\r\n    } else if (object instanceof Constructor) {\r\n        description \u003d \"constructor \u0027\" + constructorToString((Constructor\u003c?\u003e) object) + \"\u0027\";\r\n    } else {\r\n        description \u003d \"\u003cunknown AccessibleObject\u003e \" + object.toString();\r\n    }\r\n    if (uppercaseFirstLetter \u0026\u0026 Character.isLowerCase(description.charAt(0))) {\r\n        description \u003d Character.toUpperCase(description.charAt(0)) + description.substring(1);\r\n    }\r\n    return description;\r\n}",
    "fieldToString": "{\r\n    return field.getDeclaringClass().getName() + \"#\" + field.getName();\r\n}",
    "constructorToString": "{\r\n    StringBuilder stringBuilder \u003d new StringBuilder(constructor.getDeclaringClass().getName());\r\n    appendExecutableParameters(constructor, stringBuilder);\r\n    return stringBuilder.toString();\r\n}",
    "getInaccessibleTroubleshootingSuffix": "{\r\n    // Class was added in Java 9, therefore cannot use instanceof\r\n    if (e.getClass().getName().equals(\"java.lang.reflect.InaccessibleObjectException\")) {\r\n        String message \u003d e.getMessage();\r\n        String troubleshootingId \u003d message !\u003d null \u0026\u0026 message.contains(\"to module com.google.gson\") ? \"reflection-inaccessible-to-module-gson\" : \"reflection-inaccessible\";\r\n        return \"\\nSee \" + TroubleshootingGuide.createUrl(troubleshootingId);\r\n    }\r\n    return \"\";\r\n}",
    "getAccessor": "{\r\n    throw new UnsupportedOperationException(\"Records are not supported on this JVM, this method should not be called\");\r\n}",
    "createExceptionForRecordReflectionException": "{\r\n    throw new RuntimeException(\"Unexpected ReflectiveOperationException occurred\" + \" (Gson \" + GsonBuildConfig.VERSION + \").\" + \" To support Java records, reflection is utilized to read out information\" + \" about records. All these invocations happens after it is established\" + \" that records exist in the JVM. This exception is unexpected behavior.\", exception);\r\n}",
    "makeAccessible": "{\r\n    try {\r\n        object.setAccessible(true);\r\n    } catch (Exception exception) {\r\n        String description \u003d getAccessibleObjectDescription(object, false);\r\n        throw new JsonIOException(\"Failed making \" + description + \" accessible; either increase its visibility\" + \" or write a custom TypeAdapter for its declaring type.\" + getInaccessibleTroubleshootingSuffix(exception), exception);\r\n    }\r\n}",
    "tryMakeAccessible": "{\r\n    try {\r\n        constructor.setAccessible(true);\r\n        return null;\r\n    } catch (Exception exception) {\r\n        return \"Failed making constructor \u0027\" + constructorToString(constructor) + \"\u0027 accessible;\" + \" either increase its visibility or write a custom InstanceCreator or TypeAdapter for\" + // Include the message since it might contain more detailed information\r\n        \" its declaring type: \" + exception.getMessage() + getInaccessibleTroubleshootingSuffix(exception);\r\n    }\r\n}",
    "getRecordComponentNames": "{\r\n    throw new UnsupportedOperationException(\"Records are not supported on this JVM, this method should not be called\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonArray.java": {
    "getAsFloat": "{\r\n    return getAsSingleElement().getAsFloat();\r\n}",
    "getAsByte": "{\r\n    return getAsSingleElement().getAsByte();\r\n}",
    "getAsBigDecimal": "{\r\n    return getAsSingleElement().getAsBigDecimal();\r\n}",
    "getAsNumber": "{\r\n    return getAsSingleElement().getAsNumber();\r\n}",
    "getAsCharacter": "{\r\n    return getAsSingleElement().getAsCharacter();\r\n}",
    "getAsString": "{\r\n    return getAsSingleElement().getAsString();\r\n}",
    "remove": "{\r\n    return elements.remove(index);\r\n}",
    "getAsInt": "{\r\n    return getAsSingleElement().getAsInt();\r\n}",
    "asList": "{\r\n    return new NonNullElementWrapperList\u003c\u003e(elements);\r\n}",
    "iterator": "{\r\n    return elements.iterator();\r\n}",
    "getAsLong": "{\r\n    return getAsSingleElement().getAsLong();\r\n}",
    "hashCode": "{\r\n    return elements.hashCode();\r\n}",
    "get": "{\r\n    return elements.get(i);\r\n}",
    "add": "{\r\n    if (element \u003d\u003d null) {\r\n        element \u003d JsonNull.INSTANCE;\r\n    }\r\n    elements.add(element);\r\n}",
    "getAsBigInteger": "{\r\n    return getAsSingleElement().getAsBigInteger();\r\n}",
    "set": "{\r\n    return elements.set(index, element \u003d\u003d null ? JsonNull.INSTANCE : element);\r\n}",
    "isEmpty": "{\r\n    return elements.isEmpty();\r\n}",
    "getAsDouble": "{\r\n    return getAsSingleElement().getAsDouble();\r\n}",
    "getAsSingleElement": "{\r\n    int size \u003d elements.size();\r\n    if (size \u003d\u003d 1) {\r\n        return elements.get(0);\r\n    }\r\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\r\n}",
    "deepCopy": "{\r\n    if (!elements.isEmpty()) {\r\n        JsonArray result \u003d new JsonArray(elements.size());\r\n        for (JsonElement element : elements) {\r\n            result.add(element.deepCopy());\r\n        }\r\n        return result;\r\n    }\r\n    return new JsonArray();\r\n}",
    "contains": "{\r\n    return elements.contains(element);\r\n}",
    "size": "{\r\n    return elements.size();\r\n}",
    "addAll": "{\r\n    elements.addAll(array.elements);\r\n}",
    "getAsBoolean": "{\r\n    return getAsSingleElement().getAsBoolean();\r\n}",
    "equals": "{\r\n    return (o \u003d\u003d this) || (o instanceof JsonArray \u0026\u0026 ((JsonArray) o).elements.equals(elements));\r\n}",
    "getAsShort": "{\r\n    return getAsSingleElement().getAsShort();\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\sql\\SqlTimeTypeAdapter.java": {
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String s \u003d in.nextString();\r\n    try {\r\n        synchronized (this) {\r\n            Date date \u003d format.parse(s);\r\n            return new Time(date.getTime());\r\n        }\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as SQL Time; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "create": "{\r\n    return typeToken.getRawType() \u003d\u003d Time.class ? (TypeAdapter\u003cT\u003e) new SqlTimeTypeAdapter() : null;\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    String timeString;\r\n    synchronized (this) {\r\n        timeString \u003d format.format(value);\r\n    }\r\n    out.value(timeString);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\MapTypeAdapterFactory.java": {
    "getKeyAdapter": "{\r\n    return (keyType \u003d\u003d boolean.class || keyType \u003d\u003d Boolean.class) ? TypeAdapters.BOOLEAN_AS_STRING : context.getAdapter(TypeToken.get(keyType));\r\n}",
    "keyToString": "{\r\n    if (keyElement.isJsonPrimitive()) {\r\n        JsonPrimitive primitive \u003d keyElement.getAsJsonPrimitive();\r\n        if (primitive.isNumber()) {\r\n            return String.valueOf(primitive.getAsNumber());\r\n        } else if (primitive.isBoolean()) {\r\n            return Boolean.toString(primitive.getAsBoolean());\r\n        } else if (primitive.isString()) {\r\n            return primitive.getAsString();\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (keyElement.isJsonNull()) {\r\n        return \"null\";\r\n    } else {\r\n        throw new AssertionError();\r\n    }\r\n}",
    "read": "{\r\n    JsonToken peek \u003d in.peek();\r\n    if (peek \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    Map\u003cK, V\u003e map \u003d constructor.construct();\r\n    if (peek \u003d\u003d JsonToken.BEGIN_ARRAY) {\r\n        in.beginArray();\r\n        while (in.hasNext()) {\r\n            // entry array\r\n            in.beginArray();\r\n            K key \u003d keyTypeAdapter.read(in);\r\n            V value \u003d valueTypeAdapter.read(in);\r\n            V replaced \u003d map.put(key, value);\r\n            if (replaced !\u003d null) {\r\n                throw new JsonSyntaxException(\"duplicate key: \" + key);\r\n            }\r\n            in.endArray();\r\n        }\r\n        in.endArray();\r\n    } else {\r\n        in.beginObject();\r\n        while (in.hasNext()) {\r\n            JsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\r\n            K key \u003d keyTypeAdapter.read(in);\r\n            V value \u003d valueTypeAdapter.read(in);\r\n            V replaced \u003d map.put(key, value);\r\n            if (replaced !\u003d null) {\r\n                throw new JsonSyntaxException(\"duplicate key: \" + key);\r\n            }\r\n        }\r\n        in.endObject();\r\n    }\r\n    return map;\r\n}",
    "create": "{\r\n    Type type \u003d typeToken.getType();\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    if (!Map.class.isAssignableFrom(rawType)) {\r\n        return null;\r\n    }\r\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawType);\r\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\r\n    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e // we don\u0027t define a type parameter for the key or value types\r\n    result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\r\n    return result;\r\n}",
    "write": "{\r\n    if (map \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    if (!complexMapKeySerialization) {\r\n        out.beginObject();\r\n        for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) {\r\n            out.name(String.valueOf(entry.getKey()));\r\n            valueTypeAdapter.write(out, entry.getValue());\r\n        }\r\n        out.endObject();\r\n        return;\r\n    }\r\n    boolean hasComplexKeys \u003d false;\r\n    List\u003cJsonElement\u003e keys \u003d new ArrayList\u003c\u003e(map.size());\r\n    List\u003cV\u003e values \u003d new ArrayList\u003c\u003e(map.size());\r\n    for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) {\r\n        JsonElement keyElement \u003d keyTypeAdapter.toJsonTree(entry.getKey());\r\n        keys.add(keyElement);\r\n        values.add(entry.getValue());\r\n        hasComplexKeys |\u003d keyElement.isJsonArray() || keyElement.isJsonObject();\r\n    }\r\n    if (hasComplexKeys) {\r\n        out.beginArray();\r\n        for (int i \u003d 0, size \u003d keys.size(); i \u003c size; i++) {\r\n            // entry array\r\n            out.beginArray();\r\n            Streams.write(keys.get(i), out);\r\n            valueTypeAdapter.write(out, values.get(i));\r\n            out.endArray();\r\n        }\r\n        out.endArray();\r\n    } else {\r\n        out.beginObject();\r\n        for (int i \u003d 0, size \u003d keys.size(); i \u003c size; i++) {\r\n            JsonElement keyElement \u003d keys.get(i);\r\n            out.name(keyToString(keyElement));\r\n            valueTypeAdapter.write(out, values.get(i));\r\n        }\r\n        out.endObject();\r\n    }\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithNamedFields.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\sql\\SqlTimestampTypeAdapter.java": {
    "read": "{\r\n    Date date \u003d dateTypeAdapter.read(in);\r\n    return date !\u003d null ? new Timestamp(date.getTime()) : null;\r\n}",
    "create": "{\r\n    if (typeToken.getRawType() \u003d\u003d Timestamp.class) {\r\n        final TypeAdapter\u003cDate\u003e dateTypeAdapter \u003d gson.getAdapter(Date.class);\r\n        return (TypeAdapter\u003cT\u003e) new SqlTimestampTypeAdapter(dateTypeAdapter);\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "write": "{\r\n    dateTypeAdapter.write(out, value);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\$Gson$Preconditions.java": {
    "checkNotNull": "{\r\n    if (obj \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return obj;\r\n}",
    "checkArgument": "{\r\n    if (!condition) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LazilyParsedNumber.java": {
    "intValue": "{\r\n    try {\r\n        return Integer.parseInt(value);\r\n    } catch (NumberFormatException e) {\r\n        try {\r\n            return (int) Long.parseLong(value);\r\n        } catch (NumberFormatException nfe) {\r\n            return new BigDecimal(value).intValue();\r\n        }\r\n    }\r\n}",
    "hashCode": "{\r\n    return value.hashCode();\r\n}",
    "equals": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof LazilyParsedNumber) {\r\n        LazilyParsedNumber other \u003d (LazilyParsedNumber) obj;\r\n        return value.equals(other.value);\r\n    }\r\n    return false;\r\n}",
    "floatValue": "{\r\n    return Float.parseFloat(value);\r\n}",
    "toString": "{\r\n    return value;\r\n}",
    "doubleValue": "{\r\n    return Double.parseDouble(value);\r\n}",
    "writeReplace": "{\r\n    return new BigDecimal(value);\r\n}",
    "longValue": "{\r\n    try {\r\n        return Long.parseLong(value);\r\n    } catch (NumberFormatException e) {\r\n        return new BigDecimal(value).longValue();\r\n    }\r\n}",
    "readObject": "{\r\n    // Don\u0027t permit directly deserializing this class; writeReplace() should have written a replacement\r\n    throw new InvalidObjectException(\"Deserialization is unsupported\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java": {
    "next": "{\r\n    return nextNode().key;\r\n}",
    "compare": "{\r\n    return a.compareTo(b);\r\n}",
    "rotateLeft": "{\r\n    Node\u003cK, V\u003e left \u003d root.left;\r\n    Node\u003cK, V\u003e pivot \u003d root.right;\r\n    Node\u003cK, V\u003e pivotLeft \u003d pivot.left;\r\n    Node\u003cK, V\u003e pivotRight \u003d pivot.right;\r\n    // move the pivot\u0027s left child to the root\u0027s right\r\n    root.right \u003d pivotLeft;\r\n    if (pivotLeft !\u003d null) {\r\n        pivotLeft.parent \u003d root;\r\n    }\r\n    replaceInParent(root, pivot);\r\n    // move the root to the pivot\u0027s left\r\n    pivot.left \u003d root;\r\n    root.parent \u003d pivot;\r\n    // fix heights\r\n    root.height \u003d Math.max(left !\u003d null ? left.height : 0, pivotLeft !\u003d null ? pivotLeft.height : 0) + 1;\r\n    pivot.height \u003d Math.max(root.height, pivotRight !\u003d null ? pivotRight.height : 0) + 1;\r\n}",
    "writeReplace": "{\r\n    return new LinkedHashMap\u003c\u003e(this);\r\n}",
    "put": "{\r\n    if (key \u003d\u003d null) {\r\n        throw new NullPointerException(\"key \u003d\u003d null\");\r\n    }\r\n    if (value \u003d\u003d null \u0026\u0026 !allowNullValues) {\r\n        throw new NullPointerException(\"value \u003d\u003d null\");\r\n    }\r\n    Node\u003cK, V\u003e created \u003d find(key, true);\r\n    V result \u003d created.value;\r\n    created.value \u003d value;\r\n    return result;\r\n}",
    "remove": "{\r\n    return removeInternalByKey(key) !\u003d null;\r\n}",
    "rebalance": "{\r\n    for (Node\u003cK, V\u003e node \u003d unbalanced; node !\u003d null; node \u003d node.parent) {\r\n        Node\u003cK, V\u003e left \u003d node.left;\r\n        Node\u003cK, V\u003e right \u003d node.right;\r\n        int leftHeight \u003d left !\u003d null ? left.height : 0;\r\n        int rightHeight \u003d right !\u003d null ? right.height : 0;\r\n        int delta \u003d leftHeight - rightHeight;\r\n        if (delta \u003d\u003d -2) {\r\n            Node\u003cK, V\u003e rightLeft \u003d right.left;\r\n            Node\u003cK, V\u003e rightRight \u003d right.right;\r\n            int rightRightHeight \u003d rightRight !\u003d null ? rightRight.height : 0;\r\n            int rightLeftHeight \u003d rightLeft !\u003d null ? rightLeft.height : 0;\r\n            int rightDelta \u003d rightLeftHeight - rightRightHeight;\r\n            if (rightDelta \u003d\u003d -1 || (rightDelta \u003d\u003d 0 \u0026\u0026 !insert)) {\r\n                // AVL right right\r\n                rotateLeft(node);\r\n            } else {\r\n                assert (rightDelta \u003d\u003d 1);\r\n                // AVL right left\r\n                rotateRight(right);\r\n                rotateLeft(node);\r\n            }\r\n            if (insert) {\r\n                // no further rotations will be necessary\r\n                break;\r\n            }\r\n        } else if (delta \u003d\u003d 2) {\r\n            Node\u003cK, V\u003e leftLeft \u003d left.left;\r\n            Node\u003cK, V\u003e leftRight \u003d left.right;\r\n            int leftRightHeight \u003d leftRight !\u003d null ? leftRight.height : 0;\r\n            int leftLeftHeight \u003d leftLeft !\u003d null ? leftLeft.height : 0;\r\n            int leftDelta \u003d leftLeftHeight - leftRightHeight;\r\n            if (leftDelta \u003d\u003d 1 || (leftDelta \u003d\u003d 0 \u0026\u0026 !insert)) {\r\n                // AVL left left\r\n                rotateRight(node);\r\n            } else {\r\n                assert (leftDelta \u003d\u003d -1);\r\n                // AVL left right\r\n                rotateLeft(left);\r\n                rotateRight(node);\r\n            }\r\n            if (insert) {\r\n                // no further rotations will be necessary\r\n                break;\r\n            }\r\n        } else if (delta \u003d\u003d 0) {\r\n            // leftHeight \u003d\u003d rightHeight\r\n            node.height \u003d leftHeight + 1;\r\n            if (insert) {\r\n                // the insert caused balance, so rebalancing is done!\r\n                break;\r\n            }\r\n        } else {\r\n            assert (delta \u003d\u003d -1 || delta \u003d\u003d 1);\r\n            node.height \u003d Math.max(leftHeight, rightHeight) + 1;\r\n            if (!insert) {\r\n                // the height hasn\u0027t changed, so rebalancing is done!\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}",
    "iterator": "{\r\n    return new LinkedTreeMapIterator\u003cK\u003e() {\r\n\r\n        @Override\r\n        public K next() {\r\n            return nextNode().key;\r\n        }\r\n    };\r\n}",
    "findByEntry": "{\r\n    Node\u003cK, V\u003e mine \u003d findByObject(entry.getKey());\r\n    boolean valuesEqual \u003d mine !\u003d null \u0026\u0026 equal(mine.value, entry.getValue());\r\n    return valuesEqual ? mine : null;\r\n}",
    "find": "{\r\n    Comparator\u003c? super K\u003e comparator \u003d this.comparator;\r\n    Node\u003cK, V\u003e nearest \u003d root;\r\n    int comparison \u003d 0;\r\n    if (nearest !\u003d null) {\r\n        // Micro-optimization: avoid polymorphic calls to Comparator.compare().\r\n        // Throws a ClassCastException below if there\u0027s trouble.\r\n        @SuppressWarnings(\"unchecked\")\r\n        Comparable\u003cObject\u003e comparableKey \u003d (comparator \u003d\u003d NATURAL_ORDER) ? (Comparable\u003cObject\u003e) key : null;\r\n        while (true) {\r\n            comparison \u003d (comparableKey !\u003d null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key, nearest.key);\r\n            // We found the requested key.\r\n            if (comparison \u003d\u003d 0) {\r\n                return nearest;\r\n            }\r\n            // If it exists, the key is in a subtree. Go deeper.\r\n            Node\u003cK, V\u003e child \u003d (comparison \u003c 0) ? nearest.left : nearest.right;\r\n            if (child \u003d\u003d null) {\r\n                break;\r\n            }\r\n            nearest \u003d child;\r\n        }\r\n    }\r\n    // The key doesn\u0027t exist in this tree.\r\n    if (!create) {\r\n        return null;\r\n    }\r\n    // Create the node and add it to the tree or the table.\r\n    Node\u003cK, V\u003e header \u003d this.header;\r\n    Node\u003cK, V\u003e created;\r\n    if (nearest \u003d\u003d null) {\r\n        // Check that the value is comparable if we didn\u0027t do any comparisons.\r\n        if (comparator \u003d\u003d NATURAL_ORDER \u0026\u0026 !(key instanceof Comparable)) {\r\n            throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\r\n        }\r\n        created \u003d new Node\u003c\u003e(allowNullValues, nearest, key, header, header.prev);\r\n        root \u003d created;\r\n    } else {\r\n        created \u003d new Node\u003c\u003e(allowNullValues, nearest, key, header, header.prev);\r\n        if (comparison \u003c 0) {\r\n            // nearest.key is higher\r\n            nearest.left \u003d created;\r\n        } else {\r\n            // comparison \u003e 0, nearest.key is lower\r\n            nearest.right \u003d created;\r\n        }\r\n        rebalance(nearest, true);\r\n    }\r\n    size++;\r\n    modCount++;\r\n    return created;\r\n}",
    "hashCode": "{\r\n    return (key \u003d\u003d null ? 0 : key.hashCode()) ^ (value \u003d\u003d null ? 0 : value.hashCode());\r\n}",
    "get": "{\r\n    Node\u003cK, V\u003e node \u003d findByObject(key);\r\n    return node !\u003d null ? node.value : null;\r\n}",
    "removeInternal": "{\r\n    if (unlink) {\r\n        node.prev.next \u003d node.next;\r\n        node.next.prev \u003d node.prev;\r\n    }\r\n    Node\u003cK, V\u003e left \u003d node.left;\r\n    Node\u003cK, V\u003e right \u003d node.right;\r\n    Node\u003cK, V\u003e originalParent \u003d node.parent;\r\n    if (left !\u003d null \u0026\u0026 right !\u003d null) {\r\n        /*\r\n       * To remove a node with both left and right subtrees, move an\r\n       * adjacent node from one of those subtrees into this node\u0027s place.\r\n       *\r\n       * Removing the adjacent node may change this node\u0027s subtrees. This\r\n       * node may no longer have two subtrees once the adjacent node is\r\n       * gone!\r\n       */\r\n        Node\u003cK, V\u003e adjacent \u003d (left.height \u003e right.height) ? left.last() : right.first();\r\n        // takes care of rebalance and size--\r\n        removeInternal(adjacent, false);\r\n        int leftHeight \u003d 0;\r\n        left \u003d node.left;\r\n        if (left !\u003d null) {\r\n            leftHeight \u003d left.height;\r\n            adjacent.left \u003d left;\r\n            left.parent \u003d adjacent;\r\n            node.left \u003d null;\r\n        }\r\n        int rightHeight \u003d 0;\r\n        right \u003d node.right;\r\n        if (right !\u003d null) {\r\n            rightHeight \u003d right.height;\r\n            adjacent.right \u003d right;\r\n            right.parent \u003d adjacent;\r\n            node.right \u003d null;\r\n        }\r\n        adjacent.height \u003d Math.max(leftHeight, rightHeight) + 1;\r\n        replaceInParent(node, adjacent);\r\n        return;\r\n    } else if (left !\u003d null) {\r\n        replaceInParent(node, left);\r\n        node.left \u003d null;\r\n    } else if (right !\u003d null) {\r\n        replaceInParent(node, right);\r\n        node.right \u003d null;\r\n    } else {\r\n        replaceInParent(node, null);\r\n    }\r\n    rebalance(originalParent, false);\r\n    size--;\r\n    modCount++;\r\n}",
    "keySet": "{\r\n    KeySet result \u003d keySet;\r\n    return result !\u003d null ? result : (keySet \u003d new KeySet());\r\n}",
    "getKey": "{\r\n    return key;\r\n}",
    "rotateRight": "{\r\n    Node\u003cK, V\u003e pivot \u003d root.left;\r\n    Node\u003cK, V\u003e right \u003d root.right;\r\n    Node\u003cK, V\u003e pivotLeft \u003d pivot.left;\r\n    Node\u003cK, V\u003e pivotRight \u003d pivot.right;\r\n    // move the pivot\u0027s right child to the root\u0027s left\r\n    root.left \u003d pivotRight;\r\n    if (pivotRight !\u003d null) {\r\n        pivotRight.parent \u003d root;\r\n    }\r\n    replaceInParent(root, pivot);\r\n    // move the root to the pivot\u0027s right\r\n    pivot.right \u003d root;\r\n    root.parent \u003d pivot;\r\n    // fixup heights\r\n    root.height \u003d Math.max(right !\u003d null ? right.height : 0, pivotRight !\u003d null ? pivotRight.height : 0) + 1;\r\n    pivot.height \u003d Math.max(root.height, pivotLeft !\u003d null ? pivotLeft.height : 0) + 1;\r\n}",
    "last": "{\r\n    Node\u003cK, V\u003e node \u003d this;\r\n    Node\u003cK, V\u003e child \u003d node.right;\r\n    while (child !\u003d null) {\r\n        node \u003d child;\r\n        child \u003d node.right;\r\n    }\r\n    return node;\r\n}",
    "entrySet": "{\r\n    EntrySet result \u003d entrySet;\r\n    return result !\u003d null ? result : (entrySet \u003d new EntrySet());\r\n}",
    "containsKey": "{\r\n    return findByObject(key) !\u003d null;\r\n}",
    "clear": "{\r\n    LinkedTreeMap.this.clear();\r\n}",
    "removeInternalByKey": "{\r\n    Node\u003cK, V\u003e node \u003d findByObject(key);\r\n    if (node !\u003d null) {\r\n        removeInternal(node, true);\r\n    }\r\n    return node;\r\n}",
    "hasNext": "{\r\n    return next !\u003d header;\r\n}",
    "findByObject": "{\r\n    try {\r\n        return key !\u003d null ? find((K) key, false) : null;\r\n    } catch (ClassCastException e) {\r\n        return null;\r\n    }\r\n}",
    "readObject": "{\r\n    // Don\u0027t permit directly deserializing this class; writeReplace() should have written a replacement\r\n    throw new InvalidObjectException(\"Deserialization is unsupported\");\r\n}",
    "equal": "{\r\n    return Objects.equals(a, b);\r\n}",
    "getValue": "{\r\n    return value;\r\n}",
    "contains": "{\r\n    return containsKey(o);\r\n}",
    "size": "{\r\n    return size;\r\n}",
    "nextNode": "{\r\n    Node\u003cK, V\u003e e \u003d next;\r\n    if (e \u003d\u003d header) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    if (modCount !\u003d expectedModCount) {\r\n        throw new ConcurrentModificationException();\r\n    }\r\n    next \u003d e.next;\r\n    return lastReturned \u003d e;\r\n}",
    "setValue": "{\r\n    if (value \u003d\u003d null \u0026\u0026 !allowNullValue) {\r\n        throw new NullPointerException(\"value \u003d\u003d null\");\r\n    }\r\n    V oldValue \u003d this.value;\r\n    this.value \u003d value;\r\n    return oldValue;\r\n}",
    "equals": "{\r\n    if (o instanceof Entry) {\r\n        Entry\u003c?, ?\u003e other \u003d (Entry\u003c?, ?\u003e) o;\r\n        return (key \u003d\u003d null ? other.getKey() \u003d\u003d null : key.equals(other.getKey())) \u0026\u0026 (value \u003d\u003d null ? other.getValue() \u003d\u003d null : value.equals(other.getValue()));\r\n    }\r\n    return false;\r\n}",
    "replaceInParent": "{\r\n    Node\u003cK, V\u003e parent \u003d node.parent;\r\n    node.parent \u003d null;\r\n    if (replacement !\u003d null) {\r\n        replacement.parent \u003d parent;\r\n    }\r\n    if (parent !\u003d null) {\r\n        if (parent.left \u003d\u003d node) {\r\n            parent.left \u003d replacement;\r\n        } else {\r\n            assert parent.right \u003d\u003d node;\r\n            parent.right \u003d replacement;\r\n        }\r\n    } else {\r\n        root \u003d replacement;\r\n    }\r\n}",
    "toString": "{\r\n    return key + \"\u003d\" + value;\r\n}",
    "first": "{\r\n    Node\u003cK, V\u003e node \u003d this;\r\n    Node\u003cK, V\u003e child \u003d node.left;\r\n    while (child !\u003d null) {\r\n        node \u003d child;\r\n        child \u003d node.left;\r\n    }\r\n    return node;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\ReflectionAccessFilter.java": {
    "check": "{\r\n    return ReflectionAccessFilterHelper.isAnyPlatformType(rawClass) ? FilterResult.BLOCK_ALL : FilterResult.INDECISIVE;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\package-info.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\DefaultDateTypeAdapter.java": {
    "createAdapterFactory": "{\r\n    return createFactory(new DefaultDateTypeAdapter\u003c\u003e(this, dateStyle, timeStyle));\r\n}",
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    Date date \u003d deserializeToDate(in);\r\n    return dateType.deserialize(date);\r\n}",
    "deserializeToDate": "{\r\n    String s \u003d in.nextString();\r\n    synchronized (dateFormats) {\r\n        for (DateFormat dateFormat : dateFormats) {\r\n            try {\r\n                return dateFormat.parse(s);\r\n            } catch (ParseException ignored) {\r\n                // OK: try the next format\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return ISO8601Utils.parse(s, new ParsePosition(0));\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "toString": "{\r\n    DateFormat defaultFormat \u003d dateFormats.get(0);\r\n    if (defaultFormat instanceof SimpleDateFormat) {\r\n        return SIMPLE_NAME + \u0027(\u0027 + ((SimpleDateFormat) defaultFormat).toPattern() + \u0027)\u0027;\r\n    } else {\r\n        return SIMPLE_NAME + \u0027(\u0027 + defaultFormat.getClass().getSimpleName() + \u0027)\u0027;\r\n    }\r\n}",
    "createFactory": "{\r\n    return TypeAdapters.newFactory(dateClass, adapter);\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    DateFormat dateFormat \u003d dateFormats.get(0);\r\n    String dateFormatAsString;\r\n    synchronized (dateFormats) {\r\n        dateFormatAsString \u003d dateFormat.format(value);\r\n    }\r\n    out.value(dateFormatAsString);\r\n}",
    "deserialize": "{\r\n    return date;\r\n}",
    "createDefaultsAdapterFactory": "{\r\n    return createFactory(new DefaultDateTypeAdapter\u003c\u003e(this, DateFormat.DEFAULT, DateFormat.DEFAULT));\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonStreamParser.java": {
    "next": "{\r\n    if (!hasNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    try {\r\n        return Streams.parse(parser);\r\n    } catch (StackOverflowError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\r\n    } catch (OutOfMemoryError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\r\n    }\r\n}",
    "hasNext": "{\r\n    synchronized (lock) {\r\n        try {\r\n            return parser.peek() !\u003d JsonToken.END_DOCUMENT;\r\n        } catch (MalformedJsonException e) {\r\n            throw new JsonSyntaxException(e);\r\n        } catch (IOException e) {\r\n            throw new JsonIOException(e);\r\n        }\r\n    }\r\n}",
    "remove": "{\r\n    throw new UnsupportedOperationException();\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\FieldNamingPolicy.java": {
    "separateCamelCase": "{\r\n    StringBuilder translation \u003d new StringBuilder();\r\n    for (int i \u003d 0, length \u003d name.length(); i \u003c length; i++) {\r\n        char character \u003d name.charAt(i);\r\n        if (Character.isUpperCase(character) \u0026\u0026 translation.length() !\u003d 0) {\r\n            translation.append(separator);\r\n        }\r\n        translation.append(character);\r\n    }\r\n    return translation.toString();\r\n}",
    "translateName": "{\r\n    return separateCamelCase(f.getName(), \u0027.\u0027).toLowerCase(Locale.ENGLISH);\r\n}",
    "upperCaseFirstLetter": "{\r\n    int length \u003d s.length();\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        char c \u003d s.charAt(i);\r\n        if (Character.isLetter(c)) {\r\n            if (Character.isUpperCase(c)) {\r\n                return s;\r\n            }\r\n            char uppercased \u003d Character.toUpperCase(c);\r\n            // For leading letter only need one substring\r\n            if (i \u003d\u003d 0) {\r\n                return uppercased + s.substring(1);\r\n            } else {\r\n                return s.substring(0, i) + uppercased + s.substring(i + 1);\r\n            }\r\n        }\r\n    }\r\n    return s;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\ExclusionStrategy.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\package-info.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonParseException.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TreeTypeAdapter.java": {
    "delegate": "{\r\n    // A race might lead to `delegate` being assigned by multiple threads but the last assignment will stick\r\n    TypeAdapter\u003cT\u003e d \u003d delegate;\r\n    return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(skipPastForGetDelegateAdapter, typeToken));\r\n}",
    "serialize": "{\r\n    return gson.toJsonTree(src, typeOfSrc);\r\n}",
    "read": "{\r\n    if (deserializer \u003d\u003d null) {\r\n        return delegate().read(in);\r\n    }\r\n    JsonElement value \u003d Streams.parse(in);\r\n    if (nullSafe \u0026\u0026 value.isJsonNull()) {\r\n        return null;\r\n    }\r\n    return deserializer.deserialize(value, typeToken.getType(), context);\r\n}",
    "newFactory": "{\r\n    return new SingleTypeFactory(typeAdapter, exactType, false, null);\r\n}",
    "getSerializationDelegate": "{\r\n    return serializer !\u003d null ? this : delegate();\r\n}",
    "create": "{\r\n    boolean matches \u003d exactType !\u003d null ? exactType.equals(type) || (matchRawType \u0026\u0026 exactType.getType() \u003d\u003d type.getRawType()) : hierarchyType.isAssignableFrom(type.getRawType());\r\n    return matches ? new TreeTypeAdapter\u003c\u003e((JsonSerializer\u003cT\u003e) serializer, (JsonDeserializer\u003cT\u003e) deserializer, gson, type, this) : null;\r\n}",
    "newFactoryWithMatchRawType": "{\r\n    // only bother matching raw types if exact type is a raw type\r\n    boolean matchRawType \u003d exactType.getType() \u003d\u003d exactType.getRawType();\r\n    return new SingleTypeFactory(typeAdapter, exactType, matchRawType, null);\r\n}",
    "write": "{\r\n    if (serializer \u003d\u003d null) {\r\n        delegate().write(out, value);\r\n        return;\r\n    }\r\n    if (nullSafe \u0026\u0026 value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    JsonElement tree \u003d serializer.serialize(value, typeToken.getType(), context);\r\n    Streams.write(tree, out);\r\n}",
    "newTypeHierarchyFactory": "{\r\n    return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);\r\n}",
    "deserialize": "{\r\n    return gson.fromJson(json, typeOfT);\r\n}"
  },
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\BagOfPrimitives.java": {
    "getExpectedJson": "{\r\n    return \"{\" + \"\\\"longValue\\\":\" + longValue + \",\" + \"\\\"intValue\\\":\" + intValue + \",\" + \"\\\"booleanValue\\\":\" + booleanValue + \",\" + \"\\\"stringValue\\\":\\\"\" + stringValue + \"\\\"\" + \"}\";\r\n}",
    "getIntValue": "{\r\n    return intValue;\r\n}",
    "hashCode": "{\r\n    final int prime \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d prime * result + (booleanValue ? 1231 : 1237);\r\n    result \u003d prime * result + intValue;\r\n    result \u003d prime * result + (int) (longValue ^ (longValue \u003e\u003e\u003e 32));\r\n    result \u003d prime * result + ((stringValue \u003d\u003d null) ? 0 : stringValue.hashCode());\r\n    return result;\r\n}",
    "equals": "{\r\n    if (this \u003d\u003d o) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof BagOfPrimitives)) {\r\n        return false;\r\n    }\r\n    BagOfPrimitives that \u003d (BagOfPrimitives) o;\r\n    return longValue \u003d\u003d that.longValue \u0026\u0026 intValue \u003d\u003d that.intValue \u0026\u0026 booleanValue \u003d\u003d that.booleanValue \u0026\u0026 Objects.equal(stringValue, that.stringValue);\r\n}",
    "toString": "{\r\n    return String.format(\"(longValue\u003d%d,intValue\u003d%d,booleanValue\u003d%b,stringValue\u003d%s)\", longValue, intValue, booleanValue, stringValue);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\Gson.java": {
    "excluder": "{\r\n    return excluder;\r\n}",
    "assertFullConsumption": "{\r\n    try {\r\n        if (obj !\u003d null \u0026\u0026 reader.peek() !\u003d JsonToken.END_DOCUMENT) {\r\n            throw new JsonSyntaxException(\"JSON document was not fully consumed.\");\r\n        }\r\n    } catch (MalformedJsonException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}",
    "longAdapter": "{\r\n    if (longSerializationPolicy \u003d\u003d LongSerializationPolicy.DEFAULT) {\r\n        return TypeAdapters.LONG;\r\n    }\r\n    return new TypeAdapter\u003cNumber\u003e() {\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return in.nextLong();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            out.value(value.toString());\r\n        }\r\n    };\r\n}",
    "atomicLongArrayAdapter": "{\r\n    return new TypeAdapter\u003cAtomicLongArray\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, AtomicLongArray value) throws IOException {\r\n            out.beginArray();\r\n            for (int i \u003d 0, length \u003d value.length(); i \u003c length; i++) {\r\n                longAdapter.write(out, value.get(i));\r\n            }\r\n            out.endArray();\r\n        }\r\n\r\n        @Override\r\n        public AtomicLongArray read(JsonReader in) throws IOException {\r\n            List\u003cLong\u003e list \u003d new ArrayList\u003c\u003e();\r\n            in.beginArray();\r\n            while (in.hasNext()) {\r\n                long value \u003d longAdapter.read(in).longValue();\r\n                list.add(value);\r\n            }\r\n            in.endArray();\r\n            int length \u003d list.size();\r\n            AtomicLongArray array \u003d new AtomicLongArray(length);\r\n            for (int i \u003d 0; i \u003c length; ++i) {\r\n                array.set(i, list.get(i));\r\n            }\r\n            return array;\r\n        }\r\n    }.nullSafe();\r\n}",
    "doubleAdapter": "{\r\n    if (serializeSpecialFloatingPointValues) {\r\n        return TypeAdapters.DOUBLE;\r\n    }\r\n    return new TypeAdapter\u003cNumber\u003e() {\r\n\r\n        @Override\r\n        public Double read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return in.nextDouble();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            double doubleValue \u003d value.doubleValue();\r\n            checkValidFloatingPoint(doubleValue);\r\n            out.value(doubleValue);\r\n        }\r\n    };\r\n}",
    "delegate": "{\r\n    TypeAdapter\u003cT\u003e delegate \u003d this.delegate;\r\n    if (delegate \u003d\u003d null) {\r\n        // Can occur when adapter is leaked to other thread or when adapter is used for (de-)serialization\r\n        // directly within the TypeAdapterFactory which requested it\r\n        throw new IllegalStateException(\"Adapter for type with cyclic dependency has been used\" + \" before dependency has been resolved\");\r\n    }\r\n    return delegate;\r\n}",
    "serializeNulls": "{\r\n    return serializeNulls;\r\n}",
    "fieldNamingStrategy": "{\r\n    return fieldNamingStrategy;\r\n}",
    "atomicLongAdapter": "{\r\n    return new TypeAdapter\u003cAtomicLong\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, AtomicLong value) throws IOException {\r\n            longAdapter.write(out, value.get());\r\n        }\r\n\r\n        @Override\r\n        public AtomicLong read(JsonReader in) throws IOException {\r\n            Number value \u003d longAdapter.read(in);\r\n            return new AtomicLong(value.longValue());\r\n        }\r\n    }.nullSafe();\r\n}",
    "newJsonWriter": "{\r\n    if (generateNonExecutableJson) {\r\n        writer.write(JSON_NON_EXECUTABLE_PREFIX);\r\n    }\r\n    JsonWriter jsonWriter \u003d new JsonWriter(writer);\r\n    jsonWriter.setFormattingStyle(formattingStyle);\r\n    jsonWriter.setHtmlSafe(htmlSafe);\r\n    jsonWriter.setStrictness(strictness \u003d\u003d null ? Strictness.LEGACY_STRICT : strictness);\r\n    jsonWriter.setSerializeNulls(serializeNulls);\r\n    return jsonWriter;\r\n}",
    "toJsonTree": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    toJson(src, typeOfSrc, writer);\r\n    return writer.get();\r\n}",
    "write": "{\r\n    delegate().write(out, value);\r\n}",
    "getDelegateAdapter": "{\r\n    Objects.requireNonNull(skipPast, \"skipPast must not be null\");\r\n    Objects.requireNonNull(type, \"type must not be null\");\r\n    if (jsonAdapterFactory.isClassJsonAdapterFactory(type, skipPast)) {\r\n        skipPast \u003d jsonAdapterFactory;\r\n    }\r\n    boolean skipPastFound \u003d false;\r\n    for (TypeAdapterFactory factory : factories) {\r\n        if (!skipPastFound) {\r\n            if (factory \u003d\u003d skipPast) {\r\n                skipPastFound \u003d true;\r\n            }\r\n            continue;\r\n        }\r\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\r\n        if (candidate !\u003d null) {\r\n            return candidate;\r\n        }\r\n    }\r\n    if (skipPastFound) {\r\n        throw new IllegalArgumentException(\"GSON cannot serialize or deserialize \" + type);\r\n    } else {\r\n        // Probably a factory from @JsonAdapter on a field\r\n        return getAdapter(type);\r\n    }\r\n}",
    "getAdapter": "{\r\n    return getAdapter(TypeToken.get(type));\r\n}",
    "read": "{\r\n    return delegate().read(in);\r\n}",
    "floatAdapter": "{\r\n    if (serializeSpecialFloatingPointValues) {\r\n        return TypeAdapters.FLOAT;\r\n    }\r\n    return new TypeAdapter\u003cNumber\u003e() {\r\n\r\n        @Override\r\n        public Float read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return (float) in.nextDouble();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            float floatValue \u003d value.floatValue();\r\n            checkValidFloatingPoint(floatValue);\r\n            // For backward compatibility don\u0027t call `JsonWriter.value(float)` because that method has\r\n            // been newly added and not all custom JsonWriter implementations might override it yet\r\n            Number floatNumber \u003d value instanceof Float ? value : floatValue;\r\n            out.value(floatNumber);\r\n        }\r\n    };\r\n}",
    "checkValidFloatingPoint": "{\r\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\r\n        throw new IllegalArgumentException(value + \" is not a valid double value as per JSON specification. To override this\" + \" behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.\");\r\n    }\r\n}",
    "newBuilder": "{\r\n    return new GsonBuilder(this);\r\n}",
    "newJsonReader": "{\r\n    JsonReader jsonReader \u003d new JsonReader(reader);\r\n    jsonReader.setStrictness(strictness \u003d\u003d null ? Strictness.LEGACY_STRICT : strictness);\r\n    return jsonReader;\r\n}",
    "setDelegate": "{\r\n    if (delegate !\u003d null) {\r\n        throw new AssertionError(\"Delegate is already set\");\r\n    }\r\n    delegate \u003d typeAdapter;\r\n}",
    "toJson": "{\r\n    Strictness oldStrictness \u003d writer.getStrictness();\r\n    boolean oldHtmlSafe \u003d writer.isHtmlSafe();\r\n    boolean oldSerializeNulls \u003d writer.getSerializeNulls();\r\n    writer.setHtmlSafe(htmlSafe);\r\n    writer.setSerializeNulls(serializeNulls);\r\n    if (this.strictness !\u003d null) {\r\n        writer.setStrictness(this.strictness);\r\n    } else if (writer.getStrictness() !\u003d Strictness.STRICT) {\r\n        writer.setStrictness(Strictness.LENIENT);\r\n    }\r\n    try {\r\n        Streams.write(jsonElement, writer);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    } catch (AssertionError e) {\r\n        throw new AssertionError(\"AssertionError (GSON \" + GsonBuildConfig.VERSION + \"): \" + e.getMessage(), e);\r\n    } finally {\r\n        writer.setStrictness(oldStrictness);\r\n        writer.setHtmlSafe(oldHtmlSafe);\r\n        writer.setSerializeNulls(oldSerializeNulls);\r\n    }\r\n}",
    "getSerializationDelegate": "{\r\n    return delegate();\r\n}",
    "fromJson": "{\r\n    if (json \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    return fromJson(new JsonTreeReader(json), typeOfT);\r\n}",
    "toString": "{\r\n    return \"{serializeNulls:\" + serializeNulls + \",factories:\" + factories + \",instanceCreators:\" + constructorConstructor + \"}\";\r\n}",
    "htmlSafe": "{\r\n    return htmlSafe;\r\n}"
  },
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\SerializationBenchmark.java": {
    "timeObjectSerialization": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        gson.toJson(bag);\r\n    }\r\n}",
    "setUp": "{\r\n    this.gson \u003d pretty ? new GsonBuilder().setPrettyPrinting().create() : new Gson();\r\n    this.bag \u003d new BagOfPrimitives(10L, 1, false, \"foo\");\r\n}",
    "main": "{\r\n    NonUploadingCaliperRunner.run(SerializationBenchmark.class, args);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\DateTypeAdapter.java": {
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return deserializeToDate(in);\r\n}",
    "deserializeToDate": "{\r\n    String s \u003d in.nextString();\r\n    synchronized (dateFormats) {\r\n        for (DateFormat dateFormat : dateFormats) {\r\n            try {\r\n                return dateFormat.parse(s);\r\n            } catch (ParseException ignored) {\r\n                // OK: try the next format\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return ISO8601Utils.parse(s, new ParsePosition(0));\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "create": "{\r\n    return typeToken.getRawType() \u003d\u003d Date.class ? (TypeAdapter\u003cT\u003e) new DateTypeAdapter() : null;\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    DateFormat dateFormat \u003d dateFormats.get(0);\r\n    String dateFormatAsString;\r\n    synchronized (dateFormats) {\r\n        dateFormatAsString \u003d dateFormat.format(value);\r\n    }\r\n    out.value(dateFormatAsString);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\ToNumberStrategy.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java": {
    "parseInt": "{\r\n    if (beginIndex \u003c 0 || endIndex \u003e value.length() || beginIndex \u003e endIndex) {\r\n        throw new NumberFormatException(value);\r\n    }\r\n    // use same logic as in Integer.parseInt() but less generic we\u0027re not supporting negative values\r\n    int i \u003d beginIndex;\r\n    int result \u003d 0;\r\n    int digit;\r\n    if (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result \u003d -digit;\r\n    }\r\n    while (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result *\u003d 10;\r\n        result -\u003d digit;\r\n    }\r\n    return -result;\r\n}",
    "format": "{\r\n    Calendar calendar \u003d new GregorianCalendar(tz, Locale.US);\r\n    calendar.setTime(date);\r\n    // estimate capacity of buffer as close as we can (yeah, that\u0027s pedantic ;)\r\n    int capacity \u003d \"yyyy-MM-ddThh:mm:ss\".length();\r\n    capacity +\u003d millis ? \".sss\".length() : 0;\r\n    capacity +\u003d tz.getRawOffset() \u003d\u003d 0 ? \"Z\".length() : \"+hh:mm\".length();\r\n    StringBuilder formatted \u003d new StringBuilder(capacity);\r\n    padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\r\n    formatted.append(\u0027T\u0027);\r\n    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\r\n    if (millis) {\r\n        formatted.append(\u0027.\u0027);\r\n        padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\r\n    }\r\n    int offset \u003d tz.getOffset(calendar.getTimeInMillis());\r\n    if (offset !\u003d 0) {\r\n        int hours \u003d Math.abs((offset / (60 * 1000)) / 60);\r\n        int minutes \u003d Math.abs((offset / (60 * 1000)) % 60);\r\n        formatted.append(offset \u003c 0 ? \u0027-\u0027 : \u0027+\u0027);\r\n        padInt(formatted, hours, \"hh\".length());\r\n        formatted.append(\u0027:\u0027);\r\n        padInt(formatted, minutes, \"mm\".length());\r\n    } else {\r\n        formatted.append(\u0027Z\u0027);\r\n    }\r\n    return formatted.toString();\r\n}",
    "padInt": "{\r\n    String strValue \u003d Integer.toString(value);\r\n    for (int i \u003d length - strValue.length(); i \u003e 0; i--) {\r\n        buffer.append(\u00270\u0027);\r\n    }\r\n    buffer.append(strValue);\r\n}",
    "checkOffset": "{\r\n    return (offset \u003c value.length()) \u0026\u0026 (value.charAt(offset) \u003d\u003d expected);\r\n}",
    "parse": "{\r\n    Exception fail \u003d null;\r\n    try {\r\n        int offset \u003d pos.getIndex();\r\n        // extract year\r\n        int year \u003d parseInt(date, offset, offset +\u003d 4);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract month\r\n        int month \u003d parseInt(date, offset, offset +\u003d 2);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract day\r\n        int day \u003d parseInt(date, offset, offset +\u003d 2);\r\n        // default time value\r\n        int hour \u003d 0;\r\n        int minutes \u003d 0;\r\n        int seconds \u003d 0;\r\n        // always use 0 otherwise returned date will include millis of current time\r\n        int milliseconds \u003d 0;\r\n        // if the value has no time component (and no time zone), we are done\r\n        boolean hasT \u003d checkOffset(date, offset, \u0027T\u0027);\r\n        if (!hasT \u0026\u0026 (date.length() \u003c\u003d offset)) {\r\n            Calendar calendar \u003d new GregorianCalendar(year, month - 1, day);\r\n            calendar.setLenient(false);\r\n            pos.setIndex(offset);\r\n            return calendar.getTime();\r\n        }\r\n        if (hasT) {\r\n            // extract hours, minutes, seconds and milliseconds\r\n            hour \u003d parseInt(date, offset +\u003d 1, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            minutes \u003d parseInt(date, offset, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            // second and milliseconds can be optional\r\n            if (date.length() \u003e offset) {\r\n                char c \u003d date.charAt(offset);\r\n                if (c !\u003d \u0027Z\u0027 \u0026\u0026 c !\u003d \u0027+\u0027 \u0026\u0026 c !\u003d \u0027-\u0027) {\r\n                    seconds \u003d parseInt(date, offset, offset +\u003d 2);\r\n                    // truncate up to 3 leap seconds\r\n                    if (seconds \u003e 59 \u0026\u0026 seconds \u003c 63)\r\n                        seconds \u003d 59;\r\n                    // milliseconds can be optional in the format\r\n                    if (checkOffset(date, offset, \u0027.\u0027)) {\r\n                        offset +\u003d 1;\r\n                        // assume at least one digit\r\n                        int endOffset \u003d indexOfNonDigit(date, offset + 1);\r\n                        // parse up to 3 digits\r\n                        int parseEndOffset \u003d Math.min(endOffset, offset + 3);\r\n                        int fraction \u003d parseInt(date, offset, parseEndOffset);\r\n                        // compensate for \"missing\" digits\r\n                        switch(// number of digits parsed\r\n                        parseEndOffset - offset) {\r\n                            case 2:\r\n                                milliseconds \u003d fraction * 10;\r\n                                break;\r\n                            case 1:\r\n                                milliseconds \u003d fraction * 100;\r\n                                break;\r\n                            default:\r\n                                milliseconds \u003d fraction;\r\n                        }\r\n                        offset \u003d endOffset;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // extract timezone\r\n        if (date.length() \u003c\u003d offset) {\r\n            throw new IllegalArgumentException(\"No time zone indicator\");\r\n        }\r\n        TimeZone timezone \u003d null;\r\n        char timezoneIndicator \u003d date.charAt(offset);\r\n        if (timezoneIndicator \u003d\u003d \u0027Z\u0027) {\r\n            timezone \u003d TIMEZONE_UTC;\r\n            offset +\u003d 1;\r\n        } else if (timezoneIndicator \u003d\u003d \u0027+\u0027 || timezoneIndicator \u003d\u003d \u0027-\u0027) {\r\n            String timezoneOffset \u003d date.substring(offset);\r\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\r\n            timezoneOffset \u003d timezoneOffset.length() \u003e\u003d 5 ? timezoneOffset : timezoneOffset + \"00\";\r\n            offset +\u003d timezoneOffset.length();\r\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\r\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\r\n                timezone \u003d TIMEZONE_UTC;\r\n            } else {\r\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\r\n                //    not sure why, but that\u0027s the way it looks. Further, Javadocs for\r\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\r\n                //    custom timezones... odd.\r\n                String timezoneId \u003d \"GMT\" + timezoneOffset;\r\n                //                    String timezoneId \u003d \"UTC\" + timezoneOffset;\r\n                timezone \u003d TimeZone.getTimeZone(timezoneId);\r\n                String act \u003d timezone.getID();\r\n                if (!act.equals(timezoneId)) {\r\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\r\n                         *    one without. If so, don\u0027t sweat.\r\n                         *   Yes, very inefficient. Hopefully not hit often.\r\n                         *   If it becomes a perf problem, add \u0027loose\u0027 comparison instead.\r\n                         */\r\n                    String cleaned \u003d act.replace(\":\", \"\");\r\n                    if (!cleaned.equals(timezoneId)) {\r\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \u0027\" + timezoneIndicator + \"\u0027\");\r\n        }\r\n        Calendar calendar \u003d new GregorianCalendar(timezone);\r\n        calendar.setLenient(false);\r\n        calendar.set(Calendar.YEAR, year);\r\n        calendar.set(Calendar.MONTH, month - 1);\r\n        calendar.set(Calendar.DAY_OF_MONTH, day);\r\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\r\n        calendar.set(Calendar.MINUTE, minutes);\r\n        calendar.set(Calendar.SECOND, seconds);\r\n        calendar.set(Calendar.MILLISECOND, milliseconds);\r\n        pos.setIndex(offset);\r\n        return calendar.getTime();\r\n        // If we get a ParseException it\u0027ll already have the right message/offset.\r\n        // Other exception types can convert here.\r\n    } catch (IndexOutOfBoundsException e) {\r\n        fail \u003d e;\r\n    } catch (NumberFormatException e) {\r\n        fail \u003d e;\r\n    } catch (IllegalArgumentException e) {\r\n        fail \u003d e;\r\n    }\r\n    String input \u003d (date \u003d\u003d null) ? null : (\u0027\"\u0027 + date + \u0027\"\u0027);\r\n    String msg \u003d fail.getMessage();\r\n    if (msg \u003d\u003d null || msg.isEmpty()) {\r\n        msg \u003d \"(\" + fail.getClass().getName() + \")\";\r\n    }\r\n    ParseException ex \u003d new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\r\n    ex.initCause(fail);\r\n    throw ex;\r\n}",
    "indexOfNonDigit": "{\r\n    for (int i \u003d offset; i \u003c string.length(); i++) {\r\n        char c \u003d string.charAt(i);\r\n        if (c \u003c \u00270\u0027 || c \u003e \u00279\u0027)\r\n            return i;\r\n    }\r\n    return string.length();\r\n}"
  },
  "google_json\\examples\\android-proguard-example\\src\\com\\google\\gson\\examples\\android\\model\\LineItem.java": {
    "getCurrencyCode": "{\r\n    return currencyCode;\r\n}",
    "getName": "{\r\n    return name;\r\n}",
    "getQuantity": "{\r\n    return quantity;\r\n}",
    "getPriceInMicros": "{\r\n    return priceInMicros;\r\n}",
    "toString": "{\r\n    return String.format(\"(item: %s, qty: %s, price: %.2f %s)\", name, quantity, priceInMicros / 1000000d, currencyCode);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonParser.java": {
    "parseReader": "{\r\n    Strictness strictness \u003d reader.getStrictness();\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    try {\r\n        return Streams.parse(reader);\r\n    } catch (StackOverflowError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source: \" + reader + \" to Json\", e);\r\n    } catch (OutOfMemoryError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source: \" + reader + \" to Json\", e);\r\n    } finally {\r\n        reader.setStrictness(strictness);\r\n    }\r\n}",
    "parseString": "{\r\n    return parseReader(new StringReader(json));\r\n}",
    "parse": "{\r\n    return parseReader(json);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\package-info.java": {},
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\ParseBenchmark.java": {
    "getResourceFile": "{\r\n    URL url \u003d ParseBenchmark.class.getResource(path);\r\n    if (url \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Resource \" + path + \" does not exist\");\r\n    }\r\n    File file \u003d new File(url.toURI());\r\n    if (!file.isFile()) {\r\n        throw new IllegalArgumentException(\"Resource \" + path + \" is not a file\");\r\n    }\r\n    return file;\r\n}",
    "timeParse": "{\r\n    for (int i \u003d 0; i \u003c reps; i++) {\r\n        parser.parse(text, document);\r\n    }\r\n}",
    "readToken": "{\r\n    while (true) {\r\n        switch(reader.peek()) {\r\n            case BEGIN_ARRAY:\r\n                reader.beginArray();\r\n                break;\r\n            case END_ARRAY:\r\n                reader.endArray();\r\n                break;\r\n            case BEGIN_OBJECT:\r\n                reader.beginObject();\r\n                break;\r\n            case END_OBJECT:\r\n                reader.endObject();\r\n                break;\r\n            case NAME:\r\n                reader.nextName();\r\n                break;\r\n            case BOOLEAN:\r\n                reader.nextBoolean();\r\n                break;\r\n            case NULL:\r\n                reader.nextNull();\r\n                break;\r\n            case NUMBER:\r\n                reader.nextLong();\r\n                break;\r\n            case STRING:\r\n                reader.nextString();\r\n                break;\r\n            case END_DOCUMENT:\r\n                return;\r\n            default:\r\n                throw new IllegalArgumentException(\"Unexpected token\" + reader.peek());\r\n        }\r\n    }\r\n}",
    "setUp": "{\r\n    text \u003d resourceToString(document.name() + \".json\").toCharArray();\r\n    parser \u003d api.newParser();\r\n}",
    "main": "{\r\n    NonUploadingCaliperRunner.run(ParseBenchmark.class, args);\r\n}",
    "toString": "{\r\n    return userId;\r\n}",
    "newParser": "{\r\n    return new GsonBindParser();\r\n}",
    "parse": "{\r\n    mapper.readValue(new CharArrayReader(data), document.jacksonType);\r\n}",
    "resourceToString": "{\r\n    ZipFile zipFile \u003d new ZipFile(getResourceFile(\"/ParseBenchmarkData.zip\"));\r\n    try {\r\n        ZipEntry zipEntry \u003d zipFile.getEntry(fileName);\r\n        Reader reader \u003d new InputStreamReader(zipFile.getInputStream(zipEntry), StandardCharsets.UTF_8);\r\n        char[] buffer \u003d new char[8192];\r\n        StringWriter writer \u003d new StringWriter();\r\n        int count;\r\n        while ((count \u003d reader.read(buffer)) !\u003d -1) {\r\n            writer.write(buffer, 0, count);\r\n        }\r\n        reader.close();\r\n        return writer.toString();\r\n    } finally {\r\n        zipFile.close();\r\n    }\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\interceptors\\InterceptorFactory.java": {
    "read": "{\r\n    T result \u003d delegate.read(in);\r\n    postDeserializer.postDeserialize(result);\r\n    return result;\r\n}",
    "create": "{\r\n    Intercept intercept \u003d type.getRawType().getAnnotation(Intercept.class);\r\n    if (intercept \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n    return new InterceptorAdapter\u003c\u003e(delegate, intercept);\r\n}",
    "write": "{\r\n    delegate.write(out, value);\r\n}"
  },
  "google_json\\examples\\android-proguard-example\\src\\com\\google\\gson\\examples\\android\\model\\Cart.java": {
    "getSimpleTypeName": "{\r\n    if (type \u003d\u003d null) {\r\n        return \"null\";\r\n    }\r\n    if (type instanceof Class) {\r\n        return ((Class) type).getSimpleName();\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType pType \u003d (ParameterizedType) type;\r\n        StringBuilder sb \u003d new StringBuilder(getSimpleTypeName(pType.getRawType()));\r\n        sb.append(\u0027\u003c\u0027);\r\n        boolean first \u003d true;\r\n        for (Type argumentType : pType.getActualTypeArguments()) {\r\n            if (first) {\r\n                first \u003d false;\r\n            } else {\r\n                sb.append(\u0027,\u0027);\r\n            }\r\n            sb.append(getSimpleTypeName(argumentType));\r\n        }\r\n        sb.append(\u0027\u003e\u0027);\r\n        return sb.toString();\r\n    } else if (type instanceof WildcardType) {\r\n        return \"?\";\r\n    }\r\n    return type.toString();\r\n}",
    "getBuyerName": "{\r\n    return buyerName;\r\n}",
    "getCreditCard": "{\r\n    return creditCard;\r\n}",
    "toString": "{\r\n    StringBuilder itemsText \u003d new StringBuilder();\r\n    boolean first \u003d true;\r\n    if (lineItems !\u003d null) {\r\n        try {\r\n            Class\u003c?\u003e fieldType \u003d Cart.class.getField(\"lineItems\").getType();\r\n            System.out.println(\"LineItems CLASS: \" + getSimpleTypeName(fieldType));\r\n        } catch (SecurityException e) {\r\n        } catch (NoSuchFieldException e) {\r\n        }\r\n        for (LineItem item : lineItems) {\r\n            if (first) {\r\n                first \u003d false;\r\n            } else {\r\n                itemsText.append(\"; \");\r\n            }\r\n            itemsText.append(item);\r\n        }\r\n    }\r\n    return \"[BUYER: \" + buyerName + \"; CC: \" + creditCard + \"; \" + \"LINE_ITEMS: \" + itemsText.toString() + \"]\";\r\n}",
    "getLineItems": "{\r\n    return lineItems;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\package-info.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\common\\MoreAsserts.java": {
    "getMethodSignature": "{\r\n    StringBuilder builder \u003d new StringBuilder(method.getName());\r\n    builder.append(\u0027(\u0027);\r\n    String sep \u003d \"\";\r\n    for (Class\u003c?\u003e paramType : method.getParameterTypes()) {\r\n        builder.append(sep).append(paramType.getName());\r\n        sep \u003d \",\";\r\n    }\r\n    builder.append(\u0027)\u0027);\r\n    return builder.toString();\r\n}",
    "assertEqualsAndHashCode": "{\r\n    Assert.assertTrue(a.equals(b));\r\n    Assert.assertTrue(b.equals(a));\r\n    Assert.assertEquals(a.hashCode(), b.hashCode());\r\n    Assert.assertFalse(a.equals(null));\r\n    Assert.assertFalse(a.equals(new Object()));\r\n}",
    "isProtectedOrPublic": "{\r\n    int modifiers \u003d method.getModifiers();\r\n    return Modifier.isProtected(modifiers) || Modifier.isPublic(modifiers);\r\n}",
    "assertOverridesMethods": "{\r\n    Set\u003cString\u003e requiredOverriddenMethods \u003d new LinkedHashSet\u003c\u003e();\r\n    for (Method method : baseClass.getDeclaredMethods()) {\r\n        // Note: Do not filter out `final` methods; maybe they should not be `final` and subclass needs\r\n        // to override them\r\n        if (isProtectedOrPublic(method)) {\r\n            requiredOverriddenMethods.add(getMethodSignature(method));\r\n        }\r\n    }\r\n    for (Method method : subClass.getDeclaredMethods()) {\r\n        requiredOverriddenMethods.remove(getMethodSignature(method));\r\n    }\r\n    for (String ignoredMethod : ignoredMethods) {\r\n        boolean foundIgnored \u003d requiredOverriddenMethods.remove(ignoredMethod);\r\n        if (!foundIgnored) {\r\n            throw new IllegalArgumentException(\"Method \u0027\" + ignoredMethod + \"\u0027 does not exist or is already overridden\");\r\n        }\r\n    }\r\n    if (!requiredOverriddenMethods.isEmpty()) {\r\n        Assert.fail(subClass.getSimpleName() + \" must override these methods: \" + requiredOverriddenMethods);\r\n    }\r\n}",
    "assertContains": "{\r\n    for (T entry : collection) {\r\n        if (entry.equals(value)) {\r\n            return;\r\n        }\r\n    }\r\n    Assert.fail(value + \" not present in \" + collection);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\SerializedName.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\InstanceCreator.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\Until.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java": {
    "replaceTop": "{\r\n    stack[stackSize - 1] \u003d topOfStack;\r\n}",
    "string": "{\r\n    String[] replacements \u003d htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\r\n    out.write(\u0027\\\"\u0027);\r\n    int last \u003d 0;\r\n    int length \u003d value.length();\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        char c \u003d value.charAt(i);\r\n        String replacement;\r\n        if (c \u003c 128) {\r\n            replacement \u003d replacements[c];\r\n            if (replacement \u003d\u003d null) {\r\n                continue;\r\n            }\r\n        } else if (c \u003d\u003d \u0027\\u2028\u0027) {\r\n            replacement \u003d \"\\\\u2028\";\r\n        } else if (c \u003d\u003d \u0027\\u2029\u0027) {\r\n            replacement \u003d \"\\\\u2029\";\r\n        } else {\r\n            continue;\r\n        }\r\n        if (last \u003c i) {\r\n            out.write(value, last, i - last);\r\n        }\r\n        out.write(replacement);\r\n        last \u003d i + 1;\r\n    }\r\n    if (last \u003c length) {\r\n        out.write(value, last, length - last);\r\n    }\r\n    out.write(\u0027\\\"\u0027);\r\n}",
    "beforeValue": "{\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (strictness !\u003d Strictness.LENIENT) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(formattedComma);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(formattedColon);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}",
    "isLenient": "{\r\n    return strictness \u003d\u003d Strictness.LENIENT;\r\n}",
    "jsonValue": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.append(value);\r\n    return this;\r\n}",
    "endArray": "{\r\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \u0027]\u0027);\r\n}",
    "setLenient": "{\r\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\r\n}",
    "nullValue": "{\r\n    if (deferredName !\u003d null) {\r\n        if (serializeNulls) {\r\n            writeDeferredName();\r\n        } else {\r\n            deferredName \u003d null;\r\n            // skip the name and the value\r\n            return this;\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.write(\"null\");\r\n    return this;\r\n}",
    "beforeName": "{\r\n    int context \u003d peek();\r\n    if (context \u003d\u003d NONEMPTY_OBJECT) {\r\n        // first in object\r\n        out.write(formattedComma);\r\n    } else if (context !\u003d EMPTY_OBJECT) {\r\n        // not in an object!\r\n        throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n    newline();\r\n    replaceTop(DANGLING_NAME);\r\n}",
    "newline": "{\r\n    if (usesEmptyNewlineAndIndent) {\r\n        return;\r\n    }\r\n    out.write(formattingStyle.getNewline());\r\n    for (int i \u003d 1, size \u003d stackSize; i \u003c size; i++) {\r\n        out.write(formattingStyle.getIndent());\r\n    }\r\n}",
    "beginArray": "{\r\n    writeDeferredName();\r\n    return open(EMPTY_ARRAY, \u0027[\u0027);\r\n}",
    "flush": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        throw new IllegalStateException(\"JsonWriter is closed.\");\r\n    }\r\n    out.flush();\r\n}",
    "setIndent": "{\r\n    if (indent.isEmpty()) {\r\n        setFormattingStyle(FormattingStyle.COMPACT);\r\n    } else {\r\n        setFormattingStyle(FormattingStyle.PRETTY.withIndent(indent));\r\n    }\r\n}",
    "setFormattingStyle": "{\r\n    this.formattingStyle \u003d Objects.requireNonNull(formattingStyle);\r\n    this.formattedComma \u003d \",\";\r\n    if (this.formattingStyle.usesSpaceAfterSeparators()) {\r\n        this.formattedColon \u003d \": \";\r\n        // Only add space if no newline is written\r\n        if (this.formattingStyle.getNewline().isEmpty()) {\r\n            this.formattedComma \u003d \", \";\r\n        }\r\n    } else {\r\n        this.formattedColon \u003d \":\";\r\n    }\r\n    this.usesEmptyNewlineAndIndent \u003d this.formattingStyle.getNewline().isEmpty() \u0026\u0026 this.formattingStyle.getIndent().isEmpty();\r\n}",
    "writeDeferredName": "{\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}",
    "close": "{\r\n    out.close();\r\n    int size \u003d stackSize;\r\n    if (size \u003e 1 || (size \u003d\u003d 1 \u0026\u0026 stack[size - 1] !\u003d NONEMPTY_DOCUMENT)) {\r\n        throw new IOException(\"Incomplete document\");\r\n    }\r\n    stackSize \u003d 0;\r\n}",
    "value": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    String string \u003d value.toString();\r\n    if (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\")) {\r\n        if (strictness !\u003d Strictness.LENIENT) {\r\n            throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + string);\r\n        }\r\n    } else {\r\n        Class\u003c? extends Number\u003e numberClass \u003d value.getClass();\r\n        // Validate that string is valid before writing it directly to JSON output\r\n        if (!isTrustedNumberType(numberClass) \u0026\u0026 !VALID_JSON_NUMBER_PATTERN.matcher(string).matches()) {\r\n            throw new IllegalArgumentException(\"String created by \" + numberClass + \" is not a valid JSON number: \" + string);\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.append(string);\r\n    return this;\r\n}",
    "setSerializeNulls": "{\r\n    this.serializeNulls \u003d serializeNulls;\r\n}",
    "setHtmlSafe": "{\r\n    this.htmlSafe \u003d htmlSafe;\r\n}",
    "getFormattingStyle": "{\r\n    return formattingStyle;\r\n}",
    "getStrictness": "{\r\n    return strictness;\r\n}",
    "push": "{\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        stack \u003d Arrays.copyOf(stack, stackSize * 2);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}",
    "endObject": "{\r\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \u0027}\u0027);\r\n}",
    "peek": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        throw new IllegalStateException(\"JsonWriter is closed.\");\r\n    }\r\n    return stack[stackSize - 1];\r\n}",
    "isTrustedNumberType": "{\r\n    // Note: Don\u0027t consider LazilyParsedNumber trusted because it could contain\r\n    // an arbitrary malformed string\r\n    return c \u003d\u003d Integer.class || c \u003d\u003d Long.class || c \u003d\u003d Double.class || c \u003d\u003d Float.class || c \u003d\u003d Byte.class || c \u003d\u003d Short.class || c \u003d\u003d BigDecimal.class || c \u003d\u003d BigInteger.class || c \u003d\u003d AtomicInteger.class || c \u003d\u003d AtomicLong.class;\r\n}",
    "beginObject": "{\r\n    writeDeferredName();\r\n    return open(EMPTY_OBJECT, \u0027{\u0027);\r\n}",
    "getSerializeNulls": "{\r\n    return serializeNulls;\r\n}",
    "name": "{\r\n    Objects.requireNonNull(name, \"name \u003d\u003d null\");\r\n    if (deferredName !\u003d null) {\r\n        throw new IllegalStateException(\"Already wrote a name, expecting a value.\");\r\n    }\r\n    int context \u003d peek();\r\n    if (context !\u003d EMPTY_OBJECT \u0026\u0026 context !\u003d NONEMPTY_OBJECT) {\r\n        throw new IllegalStateException(\"Please begin an object before writing a name.\");\r\n    }\r\n    deferredName \u003d name;\r\n    return this;\r\n}",
    "isHtmlSafe": "{\r\n    return htmlSafe;\r\n}",
    "setStrictness": "{\r\n    this.strictness \u003d Objects.requireNonNull(strictness);\r\n}",
    "open": "{\r\n    beforeValue();\r\n    push(empty);\r\n    out.write(openBracket);\r\n    return this;\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithUnreferencedHasArgsConstructor.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonElement.java": {
    "getAsFloat": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsBigInteger": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsByte": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsJsonObject": "{\r\n    if (isJsonObject()) {\r\n        return (JsonObject) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Object: \" + this);\r\n}",
    "getAsJsonNull": "{\r\n    if (isJsonNull()) {\r\n        return (JsonNull) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Null: \" + this);\r\n}",
    "getAsBigDecimal": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "isJsonNull": "{\r\n    return this instanceof JsonNull;\r\n}",
    "getAsNumber": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsCharacter": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsString": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "isJsonArray": "{\r\n    return this instanceof JsonArray;\r\n}",
    "getAsDouble": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsInt": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "isJsonPrimitive": "{\r\n    return this instanceof JsonPrimitive;\r\n}",
    "getAsLong": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsJsonArray": "{\r\n    if (isJsonArray()) {\r\n        return (JsonArray) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Array: \" + this);\r\n}",
    "isJsonObject": "{\r\n    return this instanceof JsonObject;\r\n}",
    "getAsJsonPrimitive": "{\r\n    if (isJsonPrimitive()) {\r\n        return (JsonPrimitive) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Primitive: \" + this);\r\n}",
    "getAsBoolean": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "toString": "{\r\n    try {\r\n        StringWriter stringWriter \u003d new StringWriter();\r\n        JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n        // Make writer lenient because toString() must not fail, even if for example JsonPrimitive contains NaN\r\n        jsonWriter.setStrictness(Strictness.LENIENT);\r\n        Streams.write(this, jsonWriter);\r\n        return stringWriter.toString();\r\n    } catch (IOException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}",
    "getAsShort": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\ObjectConstructor.java": {},
  "google_json\\proto\\src\\main\\java\\com\\google\\gson\\protobuf\\ProtoTypeAdapter.java": {
    "addSerializedNameExtension": "{\r\n    serializedNameExtensions.add(requireNonNull(serializedNameExtension));\r\n    return this;\r\n}",
    "getCachedMethod": "{\r\n    ConcurrentMap\u003cClass\u003c?\u003e, Method\u003e mapOfMethods \u003d mapOfMapOfMethods.get(methodName);\r\n    if (mapOfMethods \u003d\u003d null) {\r\n        mapOfMethods \u003d new MapMaker().makeMap();\r\n        ConcurrentMap\u003cClass\u003c?\u003e, Method\u003e previous \u003d mapOfMapOfMethods.putIfAbsent(methodName, mapOfMethods);\r\n        mapOfMethods \u003d previous \u003d\u003d null ? mapOfMethods : previous;\r\n    }\r\n    Method method \u003d mapOfMethods.get(clazz);\r\n    if (method \u003d\u003d null) {\r\n        method \u003d clazz.getMethod(methodName, methodParamTypes);\r\n        mapOfMethods.putIfAbsent(clazz, method);\r\n        // NB: it doesn\u0027t matter which method we return in the event of a race.\r\n    }\r\n    return method;\r\n}",
    "getEnumValue": "{\r\n    if (enumSerialization \u003d\u003d EnumSerialization.NAME) {\r\n        return getCustSerializedEnumValue(enumDesc.getOptions(), enumDesc.getName());\r\n    } else {\r\n        return enumDesc.getNumber();\r\n    }\r\n}",
    "newBuilder": "{\r\n    return new Builder(EnumSerialization.NAME, CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_CAMEL);\r\n}",
    "serialize": "{\r\n    JsonObject ret \u003d new JsonObject();\r\n    final Map\u003cFieldDescriptor, Object\u003e fields \u003d src.getAllFields();\r\n    for (Map.Entry\u003cFieldDescriptor, Object\u003e fieldPair : fields.entrySet()) {\r\n        final FieldDescriptor desc \u003d fieldPair.getKey();\r\n        String name \u003d getCustSerializedName(desc.getOptions(), desc.getName());\r\n        if (desc.getType() \u003d\u003d ENUM_TYPE) {\r\n            // Enum collections are also returned as ENUM_TYPE\r\n            if (fieldPair.getValue() instanceof Collection) {\r\n                // Build the array to avoid infinite loop\r\n                JsonArray array \u003d new JsonArray();\r\n                @SuppressWarnings(\"unchecked\")\r\n                Collection\u003cEnumValueDescriptor\u003e enumDescs \u003d (Collection\u003cEnumValueDescriptor\u003e) fieldPair.getValue();\r\n                for (EnumValueDescriptor enumDesc : enumDescs) {\r\n                    array.add(context.serialize(getEnumValue(enumDesc)));\r\n                    ret.add(name, array);\r\n                }\r\n            } else {\r\n                EnumValueDescriptor enumDesc \u003d ((EnumValueDescriptor) fieldPair.getValue());\r\n                ret.add(name, context.serialize(getEnumValue(enumDesc)));\r\n            }\r\n        } else {\r\n            ret.add(name, context.serialize(fieldPair.getValue()));\r\n        }\r\n    }\r\n    return ret;\r\n}",
    "findValueByNameAndExtension": "{\r\n    if (enumSerialization \u003d\u003d EnumSerialization.NAME) {\r\n        // With enum name\r\n        for (EnumValueDescriptor enumDesc : desc.getValues()) {\r\n            String enumValue \u003d getCustSerializedEnumValue(enumDesc.getOptions(), enumDesc.getName());\r\n            if (enumValue.equals(jsonElement.getAsString())) {\r\n                return enumDesc;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(String.format(\"Unrecognized enum name: %s\", jsonElement.getAsString()));\r\n    } else {\r\n        // With enum value\r\n        EnumValueDescriptor fieldValue \u003d desc.findValueByNumber(jsonElement.getAsInt());\r\n        if (fieldValue \u003d\u003d null) {\r\n            throw new IllegalArgumentException(String.format(\"Unrecognized enum value: %d\", jsonElement.getAsInt()));\r\n        }\r\n        return fieldValue;\r\n    }\r\n}",
    "build": "{\r\n    return new ProtoTypeAdapter(enumSerialization, protoFormat, jsonFormat, serializedNameExtensions, serializedEnumValueExtensions);\r\n}",
    "setFieldNameSerializationFormat": "{\r\n    this.protoFormat \u003d fromFieldNameFormat;\r\n    this.jsonFormat \u003d toFieldNameFormat;\r\n    return this;\r\n}",
    "getCustSerializedEnumValue": "{\r\n    for (Extension\u003cEnumValueOptions, String\u003e extension : serializedEnumValueExtensions) {\r\n        if (options.hasExtension(extension)) {\r\n            return options.getExtension(extension);\r\n        }\r\n    }\r\n    return defaultValue;\r\n}",
    "getCustSerializedName": "{\r\n    for (Extension\u003cFieldOptions, String\u003e extension : serializedNameExtensions) {\r\n        if (options.hasExtension(extension)) {\r\n            return options.getExtension(extension);\r\n        }\r\n    }\r\n    return protoFormat.to(jsonFormat, defaultName);\r\n}",
    "setEnumSerialization": "{\r\n    this.enumSerialization \u003d requireNonNull(enumSerialization);\r\n    return this;\r\n}",
    "addSerializedEnumValueExtension": "{\r\n    serializedEnumValueExtensions.add(requireNonNull(serializedEnumValueExtension));\r\n    return this;\r\n}",
    "deserialize": "{\r\n    try {\r\n        JsonObject jsonObject \u003d json.getAsJsonObject();\r\n        @SuppressWarnings(\"unchecked\")\r\n        Class\u003c? extends Message\u003e protoClass \u003d (Class\u003c? extends Message\u003e) typeOfT;\r\n        if (DynamicMessage.class.isAssignableFrom(protoClass)) {\r\n            throw new IllegalStateException(\"only generated messages are supported\");\r\n        }\r\n        try {\r\n            // Invoke the ProtoClass.newBuilder() method\r\n            Message.Builder protoBuilder \u003d (Message.Builder) getCachedMethod(protoClass, \"newBuilder\").invoke(null);\r\n            Message defaultInstance \u003d (Message) getCachedMethod(protoClass, \"getDefaultInstance\").invoke(null);\r\n            Descriptor protoDescriptor \u003d (Descriptor) getCachedMethod(protoClass, \"getDescriptor\").invoke(null);\r\n            // Call setters on all of the available fields\r\n            for (FieldDescriptor fieldDescriptor : protoDescriptor.getFields()) {\r\n                String jsonFieldName \u003d getCustSerializedName(fieldDescriptor.getOptions(), fieldDescriptor.getName());\r\n                JsonElement jsonElement \u003d jsonObject.get(jsonFieldName);\r\n                if (jsonElement !\u003d null \u0026\u0026 !jsonElement.isJsonNull()) {\r\n                    // Do not reuse jsonFieldName here, it might have a custom value\r\n                    Object fieldValue;\r\n                    if (fieldDescriptor.getType() \u003d\u003d ENUM_TYPE) {\r\n                        if (jsonElement.isJsonArray()) {\r\n                            // Handling array\r\n                            Collection\u003cEnumValueDescriptor\u003e enumCollection \u003d new ArrayList\u003c\u003e(jsonElement.getAsJsonArray().size());\r\n                            for (JsonElement element : jsonElement.getAsJsonArray()) {\r\n                                enumCollection.add(findValueByNameAndExtension(fieldDescriptor.getEnumType(), element));\r\n                            }\r\n                            fieldValue \u003d enumCollection;\r\n                        } else {\r\n                            // No array, just a plain value\r\n                            fieldValue \u003d findValueByNameAndExtension(fieldDescriptor.getEnumType(), jsonElement);\r\n                        }\r\n                        protoBuilder.setField(fieldDescriptor, fieldValue);\r\n                    } else if (fieldDescriptor.isRepeated()) {\r\n                        // If the type is an array, then we have to grab the type from the class.\r\n                        // protobuf java field names are always lower camel case\r\n                        String protoArrayFieldName \u003d protoFormat.to(CaseFormat.LOWER_CAMEL, fieldDescriptor.getName()) + \"_\";\r\n                        Field protoArrayField \u003d protoClass.getDeclaredField(protoArrayFieldName);\r\n                        Type protoArrayFieldType \u003d protoArrayField.getGenericType();\r\n                        fieldValue \u003d context.deserialize(jsonElement, protoArrayFieldType);\r\n                        protoBuilder.setField(fieldDescriptor, fieldValue);\r\n                    } else {\r\n                        Object field \u003d defaultInstance.getField(fieldDescriptor);\r\n                        fieldValue \u003d context.deserialize(jsonElement, field.getClass());\r\n                        protoBuilder.setField(fieldDescriptor, fieldValue);\r\n                    }\r\n                }\r\n            }\r\n            return protoBuilder.build();\r\n        } catch (SecurityException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (NoSuchMethodException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (IllegalArgumentException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new JsonParseException(e);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new JsonParseException(\"Error while parsing proto\", e);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\PreJava9DateFormatProvider.java": {
    "getDatePartOfDateTimePattern": "{\r\n    switch(dateStyle) {\r\n        case DateFormat.SHORT:\r\n            return \"M/d/yy\";\r\n        case DateFormat.MEDIUM:\r\n            return \"MMM d, yyyy\";\r\n        case DateFormat.LONG:\r\n            return \"MMMM d, yyyy\";\r\n        case DateFormat.FULL:\r\n            return \"EEEE, MMMM d, yyyy\";\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown DateFormat style: \" + dateStyle);\r\n    }\r\n}",
    "getUSDateFormat": "{\r\n    return new SimpleDateFormat(getDateFormatPattern(style), Locale.US);\r\n}",
    "getTimePartOfDateTimePattern": "{\r\n    switch(timeStyle) {\r\n        case DateFormat.SHORT:\r\n            return \"h:mm a\";\r\n        case DateFormat.MEDIUM:\r\n            return \"h:mm:ss a\";\r\n        case DateFormat.FULL:\r\n        case DateFormat.LONG:\r\n            return \"h:mm:ss a z\";\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown DateFormat style: \" + timeStyle);\r\n    }\r\n}",
    "getUSDateTimeFormat": "{\r\n    String pattern \u003d getDatePartOfDateTimePattern(dateStyle) + \" \" + getTimePartOfDateTimePattern(timeStyle);\r\n    return new SimpleDateFormat(pattern, Locale.US);\r\n}",
    "getDateFormatPattern": "{\r\n    switch(style) {\r\n        case DateFormat.SHORT:\r\n            return \"M/d/yy\";\r\n        case DateFormat.MEDIUM:\r\n            return \"MMM d, y\";\r\n        case DateFormat.LONG:\r\n            return \"MMMM d, y\";\r\n        case DateFormat.FULL:\r\n            return \"EEEE, MMMM d, y\";\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown DateFormat style: \" + style);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\SerializationDelegatingTypeAdapter.java": {},
  "google_json\\shrinker-test\\src\\test\\java\\com\\google\\gson\\it\\ShrinkingIT.java": {
    "testNoSerializedName_NoArgsConstructor": "{\r\n    runTest(\"com.example.NoSerializedNameMain\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTestNoArgsConstructor\");\r\n        if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\r\n            Object result \u003d m.invoke(null);\r\n            assertThat(result).isEqualTo(\"value\");\r\n        } else {\r\n            // R8 performs more aggressive optimizations\r\n            Exception e \u003d assertThrows(InvocationTargetException.class, () -\u003e m.invoke(null));\r\n            assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Abstract classes can\u0027t be instantiated! Adjust the R8 configuration or register an InstanceCreator\" + \" or a TypeAdapter for this type. Class name: com.example.NoSerializedNameMain$TestClassNoArgsConstructor\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#r8-abstract-class\");\r\n        }\r\n    });\r\n}",
    "testNoSerializedName_NoArgsConstructorNoJdkUnsafe": "{\r\n    runTest(\"com.example.NoSerializedNameMain\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTestNoJdkUnsafe\");\r\n        if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\r\n            Object result \u003d m.invoke(null);\r\n            assertThat(result).isEqualTo(\"value\");\r\n        } else {\r\n            // R8 performs more aggressive optimizations\r\n            Exception e \u003d assertThrows(InvocationTargetException.class, () -\u003e m.invoke(null));\r\n            assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Unable to create instance of class com.example.NoSerializedNameMain$TestClassNotAbstract;\" + \" usage of JDK Unsafe is disabled. Registering an InstanceCreator or a TypeAdapter for this type,\" + \" adding a no-args constructor, or enabling usage of JDK Unsafe may fix this problem. Or adjust\" + \" your R8 configuration to keep the no-args constructor of the class.\");\r\n        }\r\n    });\r\n}",
    "jarsToTest": "{\r\n    return Arrays.asList(PROGUARD_RESULT_PATH, R8_RESULT_PATH);\r\n}",
    "verifyJarExists": "{\r\n    if (!Files.isRegularFile(jarToTest)) {\r\n        fail(\"JAR file \" + jarToTest + \" does not exist; run this test with `mvn clean verify`\");\r\n    }\r\n}",
    "test": "{\r\n    StringBuilder output \u003d new StringBuilder();\r\n    runTest(\"com.example.Main\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTests\", BiConsumer.class);\r\n        m.invoke(null, (BiConsumer\u003cString, String\u003e) (name, content) -\u003e output.append(name + \"\\n\" + content + \"\\n\u003d\u003d\u003d\\n\"));\r\n    });\r\n    assertThat(output.toString()).isEqualTo(String.join(\"\\n\", \"Write: TypeToken anonymous\", \"[\", \"  {\", \"    \\\"custom\\\": 1\", \"  }\", \"]\", \"\u003d\u003d\u003d\", \"Read: TypeToken anonymous\", \"[ClassWithAdapter[3]]\", \"\u003d\u003d\u003d\", \"Write: TypeToken manual\", \"[\", \"  {\", \"    \\\"custom\\\": 1\", \"  }\", \"]\", \"\u003d\u003d\u003d\", \"Read: TypeToken manual\", \"[ClassWithAdapter[3]]\", \"\u003d\u003d\u003d\", \"Write: Named fields\", \"{\", \"  \\\"myField\\\": 2,\", \"  \\\"notAccessedField\\\": -1\", \"}\", \"\u003d\u003d\u003d\", \"Read: Named fields\", \"3\", \"\u003d\u003d\u003d\", \"Write: SerializedName\", \"{\", \"  \\\"myField\\\": 2,\", \"  \\\"notAccessed\\\": -1\", \"}\", \"\u003d\u003d\u003d\", \"Read: SerializedName\", \"3\", \"\u003d\u003d\u003d\", \"Write: No args constructor\", \"{\", \"  \\\"myField\\\": -3\", \"}\", \"\u003d\u003d\u003d\", \"Read: No args constructor; initial constructor value\", \"-3\", \"\u003d\u003d\u003d\", \"Read: No args constructor; custom value\", \"3\", \"\u003d\u003d\u003d\", \"Write: Constructor with args\", \"{\", \"  \\\"myField\\\": 2\", \"}\", \"\u003d\u003d\u003d\", \"Read: Constructor with args\", \"3\", \"\u003d\u003d\u003d\", \"Read: Unreferenced no args constructor; initial constructor value\", \"-3\", \"\u003d\u003d\u003d\", \"Read: Unreferenced no args constructor; custom value\", \"3\", \"\u003d\u003d\u003d\", \"Read: Unreferenced constructor with args\", \"3\", \"\u003d\u003d\u003d\", \"Read: No JDK Unsafe; initial constructor value\", \"-3\", \"\u003d\u003d\u003d\", \"Read: No JDK Unsafe; custom value\", \"3\", \"\u003d\u003d\u003d\", \"Write: Enum\", \"\\\"FIRST\\\"\", \"\u003d\u003d\u003d\", \"Read: Enum\", \"SECOND\", \"\u003d\u003d\u003d\", \"Write: Enum SerializedName\", \"\\\"one\\\"\", \"\u003d\u003d\u003d\", \"Read: Enum SerializedName\", \"SECOND\", \"\u003d\u003d\u003d\", \"Write: @Expose\", \"{\\\"i\\\":0}\", \"\u003d\u003d\u003d\", \"Write: Version annotations\", \"{\\\"i1\\\":0,\\\"i4\\\":0}\", \"\u003d\u003d\u003d\", \"Write: JsonAdapter on fields\", \"{\", \"  \\\"f\\\": \\\"adapter-null\\\",\", \"  \\\"f1\\\": \\\"adapter-1\\\",\", \"  \\\"f2\\\": \\\"factory-2\\\",\", \"  \\\"f3\\\": \\\"serializer-3\\\",\", // For f4 only a JsonDeserializer is registered, so serialization falls back to reflection\r\n    \"  \\\"f4\\\": {\", \"    \\\"s\\\": \\\"4\\\"\", \"  }\", \"}\", \"\u003d\u003d\u003d\", \"Read: JsonAdapter on fields\", // For f3 only a JsonSerializer is registered, so for deserialization value is read as is using reflection\r\n    \"ClassWithJsonAdapterAnnotation[f1\u003dadapter-1, f2\u003dfactory-2, f3\u003d3, f4\u003ddeserializer-4]\", \"\u003d\u003d\u003d\", \"Read: Generic TypeToken\", \"{t\u003dread-1}\", \"\u003d\u003d\u003d\", \"Read: Using Generic\", \"{g\u003d{t\u003dread-1}}\", \"\u003d\u003d\u003d\", \"Read: Using Generic TypeToken\", \"{g\u003d{t\u003dread-1}}\", \"\u003d\u003d\u003d\", \"\"));\r\n}",
    "testNoSerializedName_HasArgsConstructor": "{\r\n    runTest(\"com.example.NoSerializedNameMain\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTestHasArgsConstructor\");\r\n        if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\r\n            Object result \u003d m.invoke(null);\r\n            assertThat(result).isEqualTo(\"value\");\r\n        } else {\r\n            // R8 performs more aggressive optimizations\r\n            Exception e \u003d assertThrows(InvocationTargetException.class, () -\u003e m.invoke(null));\r\n            assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Abstract classes can\u0027t be instantiated! Adjust the R8 configuration or register an InstanceCreator\" + \" or a TypeAdapter for this type. Class name: com.example.NoSerializedNameMain$TestClassHasArgsConstructor\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#r8-abstract-class\");\r\n        }\r\n    });\r\n}",
    "runTest": "{\r\n    // Use bootstrap class loader; load all custom classes from JAR and not\r\n    // from dependencies of this test\r\n    ClassLoader classLoader \u003d null;\r\n    // Load the shrunken and obfuscated JARs with a separate class loader, then load\r\n    // the main test class from it and let the test action invoke its test methods\r\n    try (URLClassLoader loader \u003d new URLClassLoader(new URL[] { jarToTest.toUri().toURL() }, classLoader)) {\r\n        Class\u003c?\u003e c \u003d loader.loadClass(className);\r\n        testAction.run(c);\r\n    }\r\n}",
    "testUnusedClassRemoved": "{\r\n    // For some reason this test only works for R8 but not for ProGuard; ProGuard keeps the unused class\r\n    assumeTrue(jarToTest.equals(R8_RESULT_PATH));\r\n    String className \u003d UnusedClass.class.getName();\r\n    ClassNotFoundException e \u003d assertThrows(ClassNotFoundException.class, () -\u003e {\r\n        runTest(className, c -\u003e {\r\n            fail(\"Class should have been removed during shrinking: \" + c);\r\n        });\r\n    });\r\n    assertThat(e).hasMessageThat().contains(className);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\Since.java": {},
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithSerializedName.java": {},
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\CollectionsDeserializationBenchmark.java": {
    "timeCollectionsDefault": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        gson.fromJson(json, LIST_TYPE_TOKEN);\r\n    }\r\n}",
    "setUp": "{\r\n    this.gson \u003d new Gson();\r\n    List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c 100; ++i) {\r\n        bags.add(new BagOfPrimitives(10L, 1, false, \"foo\"));\r\n    }\r\n    this.json \u003d gson.toJson(bags, LIST_TYPE);\r\n}",
    "main": "{\r\n    NonUploadingCaliperRunner.run(CollectionsDeserializationBenchmark.class, args);\r\n}",
    "timeCollectionsStreaming": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginArray();\r\n        List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n        while (jr.hasNext()) {\r\n            jr.beginObject();\r\n            long longValue \u003d 0;\r\n            int intValue \u003d 0;\r\n            boolean booleanValue \u003d false;\r\n            String stringValue \u003d null;\r\n            while (jr.hasNext()) {\r\n                String name \u003d jr.nextName();\r\n                if (name.equals(\"longValue\")) {\r\n                    longValue \u003d jr.nextLong();\r\n                } else if (name.equals(\"intValue\")) {\r\n                    intValue \u003d jr.nextInt();\r\n                } else if (name.equals(\"booleanValue\")) {\r\n                    booleanValue \u003d jr.nextBoolean();\r\n                } else if (name.equals(\"stringValue\")) {\r\n                    stringValue \u003d jr.nextString();\r\n                } else {\r\n                    throw new IOException(\"Unexpected name: \" + name);\r\n                }\r\n            }\r\n            jr.endObject();\r\n            bags.add(new BagOfPrimitives(longValue, intValue, booleanValue, stringValue));\r\n        }\r\n        jr.endArray();\r\n    }\r\n}",
    "timeCollectionsReflectionStreaming": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginArray();\r\n        List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n        while (jr.hasNext()) {\r\n            jr.beginObject();\r\n            BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n            while (jr.hasNext()) {\r\n                String name \u003d jr.nextName();\r\n                for (Field field : BagOfPrimitives.class.getDeclaredFields()) {\r\n                    if (field.getName().equals(name)) {\r\n                        Class\u003c?\u003e fieldType \u003d field.getType();\r\n                        if (fieldType.equals(long.class)) {\r\n                            field.setLong(bag, jr.nextLong());\r\n                        } else if (fieldType.equals(int.class)) {\r\n                            field.setInt(bag, jr.nextInt());\r\n                        } else if (fieldType.equals(boolean.class)) {\r\n                            field.setBoolean(bag, jr.nextBoolean());\r\n                        } else if (fieldType.equals(String.class)) {\r\n                            field.set(bag, jr.nextString());\r\n                        } else {\r\n                            throw new RuntimeException(\"Unexpected: type: \" + fieldType + \", name: \" + name);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            jr.endObject();\r\n            bags.add(bag);\r\n        }\r\n        jr.endArray();\r\n    }\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithJsonAdapterAnnotation.java": {
    "serialize": "{\r\n    return new JsonPrimitive(\"serializer-\" + src.s);\r\n}",
    "read": "{\r\n    return new DummyClass(\"factory-\" + in.nextInt());\r\n}",
    "create": "{\r\n    // the code below is not type-safe, but does not matter for this test\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cT\u003e r \u003d (TypeAdapter\u003cT\u003e) new TypeAdapter\u003cDummyClass\u003e() {\r\n\r\n        @Override\r\n        public DummyClass read(JsonReader in) throws IOException {\r\n            return new DummyClass(\"factory-\" + in.nextInt());\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, DummyClass value) throws IOException {\r\n            out.value(\"factory-\" + value.s);\r\n        }\r\n    };\r\n    return r;\r\n}",
    "toString": "{\r\n    return s;\r\n}",
    "write": "{\r\n    out.value(\"factory-\" + value.s);\r\n}",
    "deserialize": "{\r\n    return new DummyClass(\"deserializer-\" + json.getAsInt());\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\ParameterizedTypeFixtures.java": {
    "getValue": "{\r\n    return value;\r\n}",
    "serialize": "{\r\n    JsonObject json \u003d new JsonObject();\r\n    T value \u003d src.getValue();\r\n    json.add(value.getClass().getSimpleName(), context.serialize(value));\r\n    return json;\r\n}",
    "createInstance": "{\r\n    return new MyParameterizedType\u003c\u003e(instanceOfT);\r\n}",
    "getExpectedJson": "{\r\n    Class\u003cT\u003e clazz \u003d (Class\u003cT\u003e) obj.value.getClass();\r\n    boolean addQuotes \u003d !clazz.isArray() \u0026\u0026 !Primitives.unwrap(clazz).isPrimitive();\r\n    StringBuilder sb \u003d new StringBuilder(\"{\\\"\");\r\n    sb.append(obj.value.getClass().getSimpleName()).append(\"\\\":\");\r\n    if (addQuotes) {\r\n        sb.append(\"\\\"\");\r\n    }\r\n    sb.append(obj.value.toString());\r\n    if (addQuotes) {\r\n        sb.append(\"\\\"\");\r\n    }\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "hashCode": "{\r\n    return value \u003d\u003d null ? 0 : value.hashCode();\r\n}",
    "equals": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof MyParameterizedType\u003c?\u003e)) {\r\n        return false;\r\n    }\r\n    MyParameterizedType\u003c?\u003e that \u003d (MyParameterizedType\u003c?\u003e) obj;\r\n    return Objects.equal(getValue(), that.getValue());\r\n}",
    "deserialize": "{\r\n    Type genericClass \u003d ((ParameterizedType) typeOfT).getActualTypeArguments()[0];\r\n    Class\u003c?\u003e rawType \u003d $Gson$Types.getRawType(genericClass);\r\n    String className \u003d rawType.getSimpleName();\r\n    JsonElement jsonElement \u003d json.getAsJsonObject().get(className);\r\n    T value;\r\n    if (genericClass \u003d\u003d Integer.class) {\r\n        value \u003d (T) Integer.valueOf(jsonElement.getAsInt());\r\n    } else if (genericClass \u003d\u003d String.class) {\r\n        value \u003d (T) jsonElement.getAsString();\r\n    } else {\r\n        value \u003d (T) jsonElement;\r\n    }\r\n    if (Primitives.isPrimitive(genericClass)) {\r\n        PrimitiveTypeAdapter typeAdapter \u003d new PrimitiveTypeAdapter();\r\n        value \u003d (T) typeAdapter.adaptType(value, rawType);\r\n    }\r\n    return new MyParameterizedType\u003c\u003e(value);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\module-info.java": {},
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java": {
    "read": "{\r\n    JsonElement jsonElement \u003d jsonElementAdapter.read(in);\r\n    JsonElement labelJsonElement;\r\n    if (maintainType) {\r\n        labelJsonElement \u003d jsonElement.getAsJsonObject().get(typeFieldName);\r\n    } else {\r\n        labelJsonElement \u003d jsonElement.getAsJsonObject().remove(typeFieldName);\r\n    }\r\n    if (labelJsonElement \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n    }\r\n    String label \u003d labelJsonElement.getAsString();\r\n    // registration requires that subtype extends T\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) labelToDelegate.get(label);\r\n    if (delegate \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n    }\r\n    return delegate.fromJsonTree(jsonElement);\r\n}",
    "of": "{\r\n    return new RuntimeTypeAdapterFactory\u003c\u003e(baseType, \"type\", false);\r\n}",
    "recognizeSubtypes": "{\r\n    this.recognizeSubtypes \u003d true;\r\n    return this;\r\n}",
    "create": "{\r\n    if (type \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    Class\u003c?\u003e rawType \u003d type.getRawType();\r\n    boolean handle \u003d recognizeSubtypes ? baseType.isAssignableFrom(rawType) : baseType.equals(rawType);\r\n    if (!handle) {\r\n        return null;\r\n    }\r\n    final TypeAdapter\u003cJsonElement\u003e jsonElementAdapter \u003d gson.getAdapter(JsonElement.class);\r\n    final Map\u003cString, TypeAdapter\u003c?\u003e\u003e labelToDelegate \u003d new LinkedHashMap\u003c\u003e();\r\n    final Map\u003cClass\u003c?\u003e, TypeAdapter\u003c?\u003e\u003e subtypeToDelegate \u003d new LinkedHashMap\u003c\u003e();\r\n    for (Map.Entry\u003cString, Class\u003c?\u003e\u003e entry : labelToSubtype.entrySet()) {\r\n        TypeAdapter\u003c?\u003e delegate \u003d gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));\r\n        labelToDelegate.put(entry.getKey(), delegate);\r\n        subtypeToDelegate.put(entry.getValue(), delegate);\r\n    }\r\n    return new TypeAdapter\u003cR\u003e() {\r\n\r\n        @Override\r\n        public R read(JsonReader in) throws IOException {\r\n            JsonElement jsonElement \u003d jsonElementAdapter.read(in);\r\n            JsonElement labelJsonElement;\r\n            if (maintainType) {\r\n                labelJsonElement \u003d jsonElement.getAsJsonObject().get(typeFieldName);\r\n            } else {\r\n                labelJsonElement \u003d jsonElement.getAsJsonObject().remove(typeFieldName);\r\n            }\r\n            if (labelJsonElement \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n            }\r\n            String label \u003d labelJsonElement.getAsString();\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) labelToDelegate.get(label);\r\n            if (delegate \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n            }\r\n            return delegate.fromJsonTree(jsonElement);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, R value) throws IOException {\r\n            Class\u003c?\u003e srcType \u003d value.getClass();\r\n            String label \u003d subtypeToLabel.get(srcType);\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) subtypeToDelegate.get(srcType);\r\n            if (delegate \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n            }\r\n            JsonObject jsonObject \u003d delegate.toJsonTree(value).getAsJsonObject();\r\n            if (maintainType) {\r\n                jsonElementAdapter.write(out, jsonObject);\r\n                return;\r\n            }\r\n            JsonObject clone \u003d new JsonObject();\r\n            if (jsonObject.has(typeFieldName)) {\r\n                throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \" because it already defines a field named \" + typeFieldName);\r\n            }\r\n            clone.add(typeFieldName, new JsonPrimitive(label));\r\n            for (Map.Entry\u003cString, JsonElement\u003e e : jsonObject.entrySet()) {\r\n                clone.add(e.getKey(), e.getValue());\r\n            }\r\n            jsonElementAdapter.write(out, clone);\r\n        }\r\n    }.nullSafe();\r\n}",
    "registerSubtype": "{\r\n    return registerSubtype(type, type.getSimpleName());\r\n}",
    "write": "{\r\n    Class\u003c?\u003e srcType \u003d value.getClass();\r\n    String label \u003d subtypeToLabel.get(srcType);\r\n    // registration requires that subtype extends T\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) subtypeToDelegate.get(srcType);\r\n    if (delegate \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n    }\r\n    JsonObject jsonObject \u003d delegate.toJsonTree(value).getAsJsonObject();\r\n    if (maintainType) {\r\n        jsonElementAdapter.write(out, jsonObject);\r\n        return;\r\n    }\r\n    JsonObject clone \u003d new JsonObject();\r\n    if (jsonObject.has(typeFieldName)) {\r\n        throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \" because it already defines a field named \" + typeFieldName);\r\n    }\r\n    clone.add(typeFieldName, new JsonPrimitive(label));\r\n    for (Map.Entry\u003cString, JsonElement\u003e e : jsonObject.entrySet()) {\r\n        clone.add(e.getKey(), e.getValue());\r\n    }\r\n    jsonElementAdapter.write(out, clone);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\FieldAttributes.java": {
    "getDeclaringClass": "{\r\n    return field.getDeclaringClass();\r\n}",
    "getName": "{\r\n    return field.getName();\r\n}",
    "getAnnotation": "{\r\n    return field.getAnnotation(annotation);\r\n}",
    "hasModifier": "{\r\n    return (field.getModifiers() \u0026 modifier) !\u003d 0;\r\n}",
    "getDeclaredType": "{\r\n    return field.getGenericType();\r\n}",
    "getDeclaredClass": "{\r\n    return field.getType();\r\n}",
    "toString": "{\r\n    return field.toString();\r\n}",
    "getAnnotations": "{\r\n    return Arrays.asList(field.getAnnotations());\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\UnusedClass.java": {}
}