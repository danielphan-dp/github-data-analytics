{
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\TypeHierarchyAdapterTest.java": {
    "serialize": "{\r\n    JsonObject result \u003d new JsonObject();\r\n    result.add(\"userid\", context.serialize(employee.userid, String.class));\r\n    result.add(\"startDate\", context.serialize(employee.startDate, long.class));\r\n    if (employee instanceof Manager) {\r\n        result.add(\"minions\", context.serialize(((Manager) employee).minions, Employee[].class));\r\n        if (employee instanceof CEO) {\r\n            result.add(\"assistant\", context.serialize(((CEO) employee).assistant, Employee.class));\r\n        }\r\n    }\r\n    return result;\r\n}",
    "testRegisterSuperTypeFirst": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter()).registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter()).create();\r\n    Manager manager \u003d new Manager();\r\n    manager.userid \u003d \"inder\";\r\n    String json \u003d gson.toJson(manager, Manager.class);\r\n    assertThat(json).isEqualTo(\"\\\"inder\\\"\");\r\n    Manager copied \u003d gson.fromJson(json, Manager.class);\r\n    assertThat(copied.userid).isEqualTo(manager.userid);\r\n}",
    "testRegisterSubTypeFirstAllowed": "{\r\n    Gson unused \u003d new GsonBuilder().registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter()).registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter()).create();\r\n}",
    "testTypeHierarchy": "{\r\n    Manager andy \u003d new Manager();\r\n    andy.userid \u003d \"andy\";\r\n    andy.startDate \u003d 2005;\r\n    andy.minions \u003d new Employee[] { new Employee(\"inder\", 2007), new Employee(\"joel\", 2006), new Employee(\"jesse\", 2006) };\r\n    CEO eric \u003d new CEO();\r\n    eric.userid \u003d \"eric\";\r\n    eric.startDate \u003d 2001;\r\n    eric.assistant \u003d new Employee(\"jerome\", 2006);\r\n    eric.minions \u003d new Employee[] { new Employee(\"larry\", 1998), new Employee(\"sergey\", 1998), andy };\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter()).setPrettyPrinting().create();\r\n    Company company \u003d new Company();\r\n    company.ceo \u003d eric;\r\n    String json \u003d gson.toJson(company, Company.class);\r\n    assertThat(json).isEqualTo(\"{\\n\" + \"  \\\"ceo\\\": {\\n\" + \"    \\\"userid\\\": \\\"eric\\\",\\n\" + \"    \\\"startDate\\\": 2001,\\n\" + \"    \\\"minions\\\": [\\n\" + \"      {\\n\" + \"        \\\"userid\\\": \\\"larry\\\",\\n\" + \"        \\\"startDate\\\": 1998\\n\" + \"      },\\n\" + \"      {\\n\" + \"        \\\"userid\\\": \\\"sergey\\\",\\n\" + \"        \\\"startDate\\\": 1998\\n\" + \"      },\\n\" + \"      {\\n\" + \"        \\\"userid\\\": \\\"andy\\\",\\n\" + \"        \\\"startDate\\\": 2005,\\n\" + \"        \\\"minions\\\": [\\n\" + \"          {\\n\" + \"            \\\"userid\\\": \\\"inder\\\",\\n\" + \"            \\\"startDate\\\": 2007\\n\" + \"          },\\n\" + \"          {\\n\" + \"            \\\"userid\\\": \\\"joel\\\",\\n\" + \"            \\\"startDate\\\": 2006\\n\" + \"          },\\n\" + \"          {\\n\" + \"            \\\"userid\\\": \\\"jesse\\\",\\n\" + \"            \\\"startDate\\\": 2006\\n\" + \"          }\\n\" + \"        ]\\n\" + \"      }\\n\" + \"    ],\\n\" + \"    \\\"assistant\\\": {\\n\" + \"      \\\"userid\\\": \\\"jerome\\\",\\n\" + \"      \\\"startDate\\\": 2006\\n\" + \"    }\\n\" + \"  }\\n\" + \"}\");\r\n    Company copied \u003d gson.fromJson(json, Company.class);\r\n    assertThat(gson.toJson(copied, Company.class)).isEqualTo(json);\r\n    assertThat(company.ceo.userid).isEqualTo(copied.ceo.userid);\r\n    assertThat(company.ceo.assistant.userid).isEqualTo(copied.ceo.assistant.userid);\r\n    assertThat(company.ceo.minions[0].userid).isEqualTo(copied.ceo.minions[0].userid);\r\n    assertThat(company.ceo.minions[1].userid).isEqualTo(copied.ceo.minions[1].userid);\r\n    assertThat(company.ceo.minions[2].userid).isEqualTo(copied.ceo.minions[2].userid);\r\n    assertThat(((Manager) company.ceo.minions[2]).minions[0].userid).isEqualTo(((Manager) copied.ceo.minions[2]).minions[0].userid);\r\n    assertThat(((Manager) company.ceo.minions[2]).minions[1].userid).isEqualTo(((Manager) copied.ceo.minions[2]).minions[1].userid);\r\n}",
    "deserialize": "{\r\n    JsonObject object \u003d json.getAsJsonObject();\r\n    Employee result \u003d null;\r\n    // if the employee has an assistant, she must be the CEO\r\n    JsonElement assistant \u003d object.get(\"assistant\");\r\n    if (assistant !\u003d null) {\r\n        result \u003d new CEO();\r\n        ((CEO) result).assistant \u003d context.deserialize(assistant, Employee.class);\r\n    }\r\n    // only managers have minions\r\n    JsonElement minons \u003d object.get(\"minions\");\r\n    if (minons !\u003d null) {\r\n        if (result \u003d\u003d null) {\r\n            result \u003d new Manager();\r\n        }\r\n        ((Manager) result).minions \u003d context.deserialize(minons, Employee[].class);\r\n    }\r\n    if (result \u003d\u003d null) {\r\n        result \u003d new Employee();\r\n    }\r\n    result.userid \u003d context.deserialize(object.get(\"userid\"), String.class);\r\n    result.startDate \u003d context.\u003cLong\u003edeserialize(object.get(\"startDate\"), long.class);\r\n    return result;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\MapTest.java": {
    "testWriteMapsWithEmptyStringKey": "{\r\n    Map\u003cString, Boolean\u003e map \u003d new HashMap\u003c\u003e();\r\n    map.put(\"\", true);\r\n    assertThat(gson.toJson(map)).isEqualTo(\"{\\\"\\\":true}\");\r\n}",
    "testMapSerializationWithNullValueButSerializeNulls": "{\r\n    gson \u003d new GsonBuilder().serializeNulls().create();\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"abc\", null);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).isEqualTo(\"{\\\"abc\\\":null}\");\r\n}",
    "testMapDeserializationWithLongKeys": "{\r\n    long longValue \u003d 9876543210L;\r\n    String json \u003d String.format(\"{\\\"%d\\\":\\\"456\\\"}\", longValue);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cLong, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cLong, String\u003e map \u003d gson.fromJson(json, typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(longValue);\r\n    assertThat(map.get(longValue)).isEqualTo(\"456\");\r\n}",
    "testInterfaceTypeMapWithSerializer": "{\r\n    MapClass element \u003d new MapClass();\r\n    TestTypes.Sub subType \u003d new TestTypes.Sub();\r\n    element.addBase(\"Test\", subType);\r\n    element.addSub(\"Test\", subType);\r\n    Gson tempGson \u003d new Gson();\r\n    String subTypeJson \u003d tempGson.toJson(subType);\r\n    final JsonElement baseTypeJsonElement \u003d tempGson.toJsonTree(subType, TestTypes.Base.class);\r\n    String baseTypeJson \u003d tempGson.toJson(baseTypeJsonElement);\r\n    String expected \u003d \"{\\\"bases\\\":{\\\"Test\\\":\" + baseTypeJson + \"},\" + \"\\\"subs\\\":{\\\"Test\\\":\" + subTypeJson + \"}}\";\r\n    JsonSerializer\u003cTestTypes.Base\u003e baseTypeAdapter \u003d new JsonSerializer\u003cTestTypes.Base\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(TestTypes.Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return baseTypeJsonElement;\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().registerTypeAdapter(TestTypes.Base.class, baseTypeAdapter).create();\r\n    String json \u003d gson.toJson(element);\r\n    assertThat(json).isEqualTo(expected);\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(TestTypes.Base.class, baseTypeAdapter).create();\r\n    json \u003d gson.toJson(element);\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "testNumberKeyDeserialization": "{\r\n    String json \u003d \"{\u00272.3\u0027:\u0027a\u0027,\u00275.7\u0027:\u0027b\u0027}\";\r\n    Map\u003cDouble, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(2.3, \"a\");\r\n    map.put(5.7, \"b\");\r\n    assertThat(map).isEqualTo(gson.fromJson(json, new TypeToken\u003cMap\u003cDouble, String\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "testGeneralMapField": "{\r\n    MapWithGeneralMapParameters map \u003d new MapWithGeneralMapParameters();\r\n    map.map.put(\"string\", \"testString\");\r\n    map.map.put(\"stringArray\", new String[] { \"one\", \"two\" });\r\n    map.map.put(\"objectArray\", new Object[] { 1, 2L, \"three\" });\r\n    String expected \u003d \"{\\\"map\\\":{\\\"string\\\":\\\"testString\\\",\\\"stringArray\\\":\" + \"[\\\"one\\\",\\\"two\\\"],\\\"objectArray\\\":[1,2,\\\"three\\\"]}}\";\r\n    assertThat(gson.toJson(map)).isEqualTo(expected);\r\n    gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    assertThat(gson.toJson(map)).isEqualTo(expected);\r\n}",
    "testMapSerializationWithNullValuesSerialized": "{\r\n    Gson gson \u003d new GsonBuilder().serializeNulls().create();\r\n    ClassWithAMap target \u003d new ClassWithAMap();\r\n    target.map.put(\"name1\", null);\r\n    target.map.put(\"name2\", \"value2\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"name1\");\r\n    assertThat(json).contains(\"name2\");\r\n}",
    "testMapDeserializationWithWildcardValues": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, ? extends Long\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, ? extends Long\u003e map \u003d gson.fromJson(\"{\\\"test\\\":123}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"test\")).isEqualTo(123L);\r\n}",
    "testMapDeserializationWithIntegerKeys": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n}",
    "addBase": "{\r\n    bases.put(name, value);\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testMapDeserializationWithNullKey": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Integer\u003e map \u003d gson.fromJson(\"{\\\"null\\\":123}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"null\")).isEqualTo(123);\r\n    assertThat(map.get(null)).isNull();\r\n    map \u003d gson.fromJson(\"{null:123}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"null\")).isEqualTo(123);\r\n    assertThat(map.get(null)).isNull();\r\n}",
    "testComplexKeysSerialization": "{\r\n    Map\u003cPoint, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(new Point(2, 3), \"a\");\r\n    map.put(new Point(5, 7), \"b\");\r\n    String json \u003d \"{\\\"2,3\\\":\\\"a\\\",\\\"5,7\\\":\\\"b\\\"}\";\r\n    assertThat(gson.toJson(map, new TypeToken\u003cMap\u003cPoint, String\u003e\u003e() {\r\n    }.getType())).isEqualTo(json);\r\n    assertThat(gson.toJson(map, Map.class)).isEqualTo(json);\r\n}",
    "testComplexKeysDeserialization": "{\r\n    String json \u003d \"{\u00272,3\u0027:\u0027a\u0027,\u00275,7\u0027:\u0027b\u0027}\";\r\n    try {\r\n        gson.fromJson(json, new TypeToken\u003cMap\u003cPoint, String\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testMapSerialization": "{\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", 1);\r\n    map.put(\"b\", 2);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).contains(\"\\\"a\\\":1\");\r\n    assertThat(json).contains(\"\\\"b\\\":2\");\r\n}",
    "testMapSerializationEmpty": "{\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n}",
    "testMapSubclassSerialization": "{\r\n    MyMap map \u003d new MyMap();\r\n    map.put(\"a\", \"b\");\r\n    String json \u003d gson.toJson(map, MyMap.class);\r\n    assertThat(json).contains(\"\\\"a\\\":\\\"b\\\"\");\r\n}",
    "testInterfaceTypeMap": "{\r\n    MapClass element \u003d new MapClass();\r\n    TestTypes.Sub subType \u003d new TestTypes.Sub();\r\n    element.addBase(\"Test\", subType);\r\n    element.addSub(\"Test\", subType);\r\n    String subTypeJson \u003d new Gson().toJson(subType);\r\n    String expected \u003d \"{\\\"bases\\\":{\\\"Test\\\":\" + subTypeJson + \"},\" + \"\\\"subs\\\":{\\\"Test\\\":\" + subTypeJson + \"}}\";\r\n    Gson gsonWithComplexKeys \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    String json \u003d gsonWithComplexKeys.toJson(element);\r\n    assertThat(json).isEqualTo(expected);\r\n    Gson gson \u003d new Gson();\r\n    json \u003d gson.toJson(element);\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "createInstance": "{\r\n    return new MyMap();\r\n}",
    "testDeerializeMapOfMaps": "{\r\n    Type type \u003d new TypeToken\u003cMap\u003cString, Map\u003cString, String\u003e\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Map\u003cString, String\u003e\u003e map \u003d newMap(\"a\", newMap(\"ka1\", \"va1\", \"ka2\", \"va2\"), \"b\", newMap(\"kb1\", \"vb1\", \"kb2\", \"vb2\"));\r\n    String json \u003d \"{\u0027a\u0027:{\u0027ka1\u0027:\u0027va1\u0027,\u0027ka2\u0027:\u0027va2\u0027},\u0027b\u0027:{\u0027kb1\u0027:\u0027vb1\u0027,\u0027kb2\u0027:\u0027vb2\u0027}}\";\r\n    assertThat(map).isEqualTo(gson.fromJson(json, type));\r\n}",
    "testMapSubclassDeserialization": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(MyMap.class, new InstanceCreator\u003cMyMap\u003e() {\r\n\r\n        @Override\r\n        public MyMap createInstance(Type type) {\r\n            return new MyMap();\r\n        }\r\n    }).create();\r\n    String json \u003d \"{\\\"a\\\":1,\\\"b\\\":2}\";\r\n    MyMap map \u003d gson.fromJson(json, MyMap.class);\r\n    assertThat(map.get(\"a\")).isEqualTo(\"1\");\r\n    assertThat(map.get(\"b\")).isEqualTo(\"2\");\r\n}",
    "serialize": "{\r\n    return baseTypeJsonElement;\r\n}",
    "testMapSerializationWithNullValues": "{\r\n    ClassWithAMap target \u003d new ClassWithAMap();\r\n    target.map.put(\"name1\", null);\r\n    target.map.put(\"name2\", \"value2\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"name1\");\r\n    assertThat(json).contains(\"name2\");\r\n}",
    "testMapWithQuotes": "{\r\n    Map\u003cString, String\u003e map \u003d new HashMap\u003c\u003e();\r\n    map.put(\"a\\\"b\", \"c\\\"d\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"a\\\\\\\"b\\\":\\\"c\\\\\\\"d\\\"}\");\r\n}",
    "testMapStandardSubclassDeserialization": "{\r\n    String json \u003d \"{a:\u00271\u0027,b:\u00272\u0027}\";\r\n    Type type \u003d new TypeToken\u003cLinkedHashMap\u003cString, String\u003e\u003e() {\r\n    }.getType();\r\n    LinkedHashMap\u003cString, String\u003e map \u003d gson.fromJson(json, type);\r\n    assertThat(map).containsEntry(\"a\", \"1\");\r\n    assertThat(map).containsEntry(\"b\", \"2\");\r\n}",
    "testMapDeserializationWithUnquotedLongKeys": "{\r\n    long longKey \u003d 9876543210L;\r\n    String json \u003d String.format(\"{%d:\\\"456\\\"}\", longKey);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cLong, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cLong, String\u003e map \u003d gson.fromJson(json, typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(longKey);\r\n    assertThat(map.get(longKey)).isEqualTo(\"456\");\r\n}",
    "testSerializeMapOfMaps": "{\r\n    Type type \u003d new TypeToken\u003cMap\u003cString, Map\u003cString, String\u003e\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Map\u003cString, String\u003e\u003e map \u003d newMap(\"a\", newMap(\"ka1\", \"va1\", \"ka2\", \"va2\"), \"b\", newMap(\"kb1\", \"vb1\", \"kb2\", \"vb2\"));\r\n    assertThat(gson.toJson(map, type).replace(\u0027\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027a\u0027:{\u0027ka1\u0027:\u0027va1\u0027,\u0027ka2\u0027:\u0027va2\u0027},\u0027b\u0027:{\u0027kb1\u0027:\u0027vb1\u0027,\u0027kb2\u0027:\u0027vb2\u0027}}\");\r\n}",
    "testMapSerializationWithNullKey": "{\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(null, 123);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).isEqualTo(\"{\\\"null\\\":123}\");\r\n}",
    "testReadMapsWithEmptyStringKey": "{\r\n    Map\u003cString, Boolean\u003e map \u003d gson.fromJson(\"{\\\"\\\":true}\", new TypeToken\u003cMap\u003cString, Boolean\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(map.get(\"\")).isEqualTo(Boolean.TRUE);\r\n}",
    "testObjectMapSerialization": "{\r\n    Map\u003cString, Object\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", 1);\r\n    map.put(\"b\", \"string\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).contains(\"\\\"a\\\":1\");\r\n    assertThat(json).contains(\"\\\"b\\\":\\\"string\\\"\");\r\n}",
    "testConcurrentNavigableMap": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cConcurrentNavigableMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    ConcurrentNavigableMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"123\\\":\\\"456\\\"}\");\r\n}",
    "hashCode": "{\r\n    return x * 37 + y;\r\n}",
    "testMapOfMapDeserialization": "{\r\n    String json \u003d \"{nestedMap:{\u00272\u0027:\u00272\u0027,\u00271\u0027:\u00271\u0027}}\";\r\n    Type type \u003d new TypeToken\u003cMap\u003cString, Map\u003cString, String\u003e\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Map\u003cString, String\u003e\u003e map \u003d gson.fromJson(json, type);\r\n    Map\u003cString, String\u003e nested \u003d map.get(\"nestedMap\");\r\n    assertThat(nested.get(\"1\")).isEqualTo(\"1\");\r\n    assertThat(nested.get(\"2\")).isEqualTo(\"2\");\r\n}",
    "testStringKeyDeserialization": "{\r\n    String json \u003d \"{\u00272,3\u0027:\u0027a\u0027,\u00275,7\u0027:\u0027b\u0027}\";\r\n    Map\u003cString, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"2,3\", \"a\");\r\n    map.put(\"5,7\", \"b\");\r\n    assertThat(map).isEqualTo(gson.fromJson(json, new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "testMapDeserializationWithNullValue": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Integer\u003e map \u003d gson.fromJson(\"{\\\"abc\\\":null}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"abc\")).isNull();\r\n}",
    "testMapDeserializationWithUnquotedIntegerKeys": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cInteger, String\u003e map \u003d gson.fromJson(\"{123:\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n}",
    "testConcurrentHashMap": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cConcurrentHashMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    ConcurrentHashMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"123\\\":\\\"456\\\"}\");\r\n}",
    "testMapNamePromotionWithJsonElementReader": "{\r\n    String json \u003d \"{\u00272.3\u0027:\u0027a\u0027}\";\r\n    Map\u003cDouble, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(2.3, \"a\");\r\n    JsonElement tree \u003d JsonParser.parseString(json);\r\n    assertThat(map).isEqualTo(gson.fromJson(tree, new TypeToken\u003cMap\u003cDouble, String\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "testMapDeserializationWithDuplicateKeys": "{\r\n    try {\r\n        gson.fromJson(\"{\u0027a\u0027:1,\u0027a\u0027:2}\", new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testMapSerializationWithNullValue": "{\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"abc\", null);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    // Maps are represented as JSON objects, so ignoring null field\r\n    assertThat(json).isEqualTo(\"{}\");\r\n}",
    "newMap": "{\r\n    Map\u003cK, V\u003e result \u003d new LinkedHashMap\u003c\u003e();\r\n    result.put(key1, value1);\r\n    result.put(key2, value2);\r\n    return result;\r\n}",
    "testMapSerializationWithIntegerKeys": "{\r\n    Map\u003cInteger, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(123, \"456\");\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).isEqualTo(\"{\\\"123\\\":\\\"456\\\"}\");\r\n}",
    "addSub": "{\r\n    subs.put(name, value);\r\n}",
    "testMapOfMapSerialization": "{\r\n    Map\u003cString, Map\u003cString, String\u003e\u003e map \u003d new HashMap\u003c\u003e();\r\n    Map\u003cString, String\u003e nestedMap \u003d new HashMap\u003c\u003e();\r\n    nestedMap.put(\"1\", \"1\");\r\n    nestedMap.put(\"2\", \"2\");\r\n    map.put(\"nestedMap\", nestedMap);\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).contains(\"nestedMap\");\r\n    assertThat(json).contains(\"\\\"1\\\":\\\"1\\\"\");\r\n    assertThat(json).contains(\"\\\"2\\\":\\\"2\\\"\");\r\n}",
    "testSortedMap": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cSortedMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    SortedMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n}",
    "testConcurrentMap": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cConcurrentMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    ConcurrentMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"123\\\":\\\"456\\\"}\");\r\n}",
    "testMapDeserialization": "{\r\n    String json \u003d \"{\\\"a\\\":1,\\\"b\\\":2}\";\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Integer\u003e target \u003d gson.fromJson(json, typeOfMap);\r\n    assertThat(target.get(\"a\")).isEqualTo(1);\r\n    assertThat(target.get(\"b\")).isEqualTo(2);\r\n}",
    "testMapDeserializationEmpty": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Integer\u003e map \u003d gson.fromJson(\"{}\", typeOfMap);\r\n    assertThat(map).isEmpty();\r\n}",
    "testMapSerializationWithWildcardValues": "{\r\n    Map\u003cString, ? extends Collection\u003c? extends Integer\u003e\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"test\", null);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, ? extends Collection\u003c? extends Integer\u003e\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n}",
    "testCustomSerializerForSpecificMapType": "{\r\n    Type type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, Map.class, String.class, Long.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(type, new JsonSerializer\u003cMap\u003cString, Long\u003e\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Map\u003cString, Long\u003e src, Type typeOfSrc, JsonSerializationContext context) {\r\n            JsonArray array \u003d new JsonArray();\r\n            for (long value : src.values()) {\r\n                array.add(new JsonPrimitive(value));\r\n            }\r\n            return array;\r\n        }\r\n    }).create();\r\n    Map\u003cString, Long\u003e src \u003d new LinkedHashMap\u003c\u003e();\r\n    src.put(\"one\", 1L);\r\n    src.put(\"two\", 2L);\r\n    src.put(\"three\", 3L);\r\n    assertThat(gson.toJson(src, type)).isEqualTo(\"[1,2,3]\");\r\n}",
    "equals": "{\r\n    return o instanceof Point \u0026\u0026 x \u003d\u003d ((Point) o).x \u0026\u0026 y \u003d\u003d ((Point) o).y;\r\n}",
    "testParameterizedMapSubclassSerialization": "{\r\n    MyParameterizedMap\u003cString, String\u003e map \u003d new MyParameterizedMap\u003c\u003e(10);\r\n    map.put(\"a\", \"b\");\r\n    Type type \u003d new TypeToken\u003cMyParameterizedMap\u003cString, String\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, type);\r\n    assertThat(json).contains(\"\\\"a\\\":\\\"b\\\"\");\r\n}",
    "testHashMapDeserialization": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cHashMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    HashMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n}",
    "testConcurrentSkipListMap": "{\r\n    Type typeOfMap \u003d new TypeToken\u003cConcurrentSkipListMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    ConcurrentSkipListMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"123\\\":\\\"456\\\"}\");\r\n}",
    "toString": "{\r\n    return x + \",\" + y;\r\n}",
    "testBooleanKeyDeserialization": "{\r\n    String json \u003d \"{\u0027true\u0027:\u0027a\u0027,\u0027false\u0027:\u0027b\u0027}\";\r\n    Map\u003cBoolean, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(true, \"a\");\r\n    map.put(false, \"b\");\r\n    assertThat(map).isEqualTo(gson.fromJson(json, new TypeToken\u003cMap\u003cBoolean, String\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "testSerializeMaps": "{\r\n    Map\u003cString, Object\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", 12);\r\n    map.put(\"b\", null);\r\n    LinkedHashMap\u003cString, Object\u003e innerMap \u003d new LinkedHashMap\u003c\u003e();\r\n    innerMap.put(\"test\", 1);\r\n    innerMap.put(\"TestStringArray\", new String[] { \"one\", \"two\" });\r\n    map.put(\"c\", innerMap);\r\n    assertThat(new GsonBuilder().serializeNulls().create().toJson(map)).isEqualTo(\"{\\\"a\\\":12,\\\"b\\\":null,\\\"c\\\":{\\\"test\\\":1,\\\"TestStringArray\\\":[\\\"one\\\",\\\"two\\\"]}}\");\r\n    assertThat(new GsonBuilder().setPrettyPrinting().serializeNulls().create().toJson(map)).isEqualTo(\"{\\n  \\\"a\\\": 12,\\n  \\\"b\\\": null,\\n  \\\"c\\\": \" + \"{\\n    \\\"test\\\": 1,\\n    \\\"TestStringArray\\\": \" + \"[\\n      \\\"one\\\",\\n      \\\"two\\\"\\n    ]\\n  }\\n}\");\r\n    assertThat(new GsonBuilder().create().toJson(map)).isEqualTo(\"{\\\"a\\\":12,\\\"c\\\":{\\\"test\\\":1,\\\"TestStringArray\\\":[\\\"one\\\",\\\"two\\\"]}}\");\r\n    assertThat(new GsonBuilder().setPrettyPrinting().create().toJson(map)).isEqualTo(\"{\\n  \\\"a\\\": 12,\\n  \\\"c\\\": \" + \"{\\n    \\\"test\\\": 1,\\n    \\\"TestStringArray\\\": \" + \"[\\n      \\\"one\\\",\\n      \\\"two\\\"\\n    ]\\n  }\\n}\");\r\n    innerMap.put(\"d\", \"e\");\r\n    assertThat(new Gson().toJson(map)).isEqualTo(\"{\\\"a\\\":12,\\\"c\\\":{\\\"test\\\":1,\\\"TestStringArray\\\":[\\\"one\\\",\\\"two\\\"],\\\"d\\\":\\\"e\\\"}}\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\sql\\SqlTypesSupportTest.java": {
    "testSupported": "{\r\n    assertThat(SqlTypesSupport.SUPPORTS_SQL_TYPES).isTrue();\r\n    assertThat(SqlTypesSupport.DATE_DATE_TYPE).isNotNull();\r\n    assertThat(SqlTypesSupport.TIMESTAMP_DATE_TYPE).isNotNull();\r\n    assertThat(SqlTypesSupport.DATE_FACTORY).isNotNull();\r\n    assertThat(SqlTypesSupport.TIME_FACTORY).isNotNull();\r\n    assertThat(SqlTypesSupport.TIMESTAMP_FACTORY).isNotNull();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\VersioningTest.java": {
    "testVersionedClassesSerialization": "{\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    String json1 \u003d gson.toJson(new Version1());\r\n    String json2 \u003d gson.toJson(new Version1_1());\r\n    assertThat(json2).isEqualTo(json1);\r\n}",
    "testVersionedClassesDeserialization": "{\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    String json \u003d \"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5}\";\r\n    Version1 version1 \u003d gson.fromJson(json, Version1.class);\r\n    assertThat(version1.a).isEqualTo(3);\r\n    assertThat(version1.b).isEqualTo(4);\r\n    Version1_1 version1_1 \u003d gson.fromJson(json, Version1_1.class);\r\n    assertThat(version1_1.a).isEqualTo(3);\r\n    assertThat(version1_1.b).isEqualTo(4);\r\n    assertThat(version1_1.c).isEqualTo(C);\r\n}",
    "testIgnoreLaterVersionClassSerialization": "{\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    assertThat(gson.toJson(new Version1_2())).isEqualTo(\"null\");\r\n}",
    "testVersionedGsonMixingSinceAndUntilDeserialization": "{\r\n    String json \u003d \"{\\\"a\\\":5,\\\"b\\\":6}\";\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    SinceUntilMixing result \u003d gson.fromJson(json, SinceUntilMixing.class);\r\n    assertThat(result.a).isEqualTo(5);\r\n    assertThat(result.b).isEqualTo(B);\r\n    gson \u003d gsonWithVersion(1.2);\r\n    result \u003d gson.fromJson(json, SinceUntilMixing.class);\r\n    assertThat(result.a).isEqualTo(5);\r\n    assertThat(result.b).isEqualTo(6);\r\n    gson \u003d gsonWithVersion(1.3);\r\n    result \u003d gson.fromJson(json, SinceUntilMixing.class);\r\n    assertThat(result.a).isEqualTo(5);\r\n    assertThat(result.b).isEqualTo(B);\r\n    gson \u003d gsonWithVersion(1.4);\r\n    result \u003d gson.fromJson(json, SinceUntilMixing.class);\r\n    assertThat(result.a).isEqualTo(5);\r\n    assertThat(result.b).isEqualTo(B);\r\n}",
    "gsonWithVersion": "{\r\n    return new GsonBuilder().setVersion(version).create();\r\n}",
    "testVersionedUntilSerialization": "{\r\n    Version1 target \u003d new Version1();\r\n    Gson gson \u003d gsonWithVersion(1.29);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"a\\\":\" + A);\r\n    gson \u003d gsonWithVersion(1.3);\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"\\\"a\\\":\" + A);\r\n    gson \u003d gsonWithVersion(1.31);\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"\\\"a\\\":\" + A);\r\n}",
    "testVersionedGsonMixingSinceAndUntilSerialization": "{\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    SinceUntilMixing target \u003d new SinceUntilMixing();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"\\\"b\\\":\" + B);\r\n    gson \u003d gsonWithVersion(1.2);\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"b\\\":\" + B);\r\n    gson \u003d gsonWithVersion(1.3);\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"\\\"b\\\":\" + B);\r\n    gson \u003d gsonWithVersion(1.4);\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"\\\"b\\\":\" + B);\r\n}",
    "testVersionedUntilDeserialization": "{\r\n    String json \u003d \"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5}\";\r\n    Gson gson \u003d gsonWithVersion(1.29);\r\n    Version1 version1 \u003d gson.fromJson(json, Version1.class);\r\n    assertThat(version1.a).isEqualTo(3);\r\n    gson \u003d gsonWithVersion(1.3);\r\n    version1 \u003d gson.fromJson(json, Version1.class);\r\n    assertThat(version1.a).isEqualTo(A);\r\n    gson \u003d gsonWithVersion(1.31);\r\n    version1 \u003d gson.fromJson(json, Version1.class);\r\n    assertThat(version1.a).isEqualTo(A);\r\n}",
    "testIgnoreLaterVersionClassDeserialization": "{\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    String json \u003d \"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5,\\\"d\\\":6}\";\r\n    Version1_2 version1_2 \u003d gson.fromJson(json, Version1_2.class);\r\n    // Since the class is versioned to be after 1.0, we expect null\r\n    // This is the new behavior in Gson 2.0\r\n    assertThat(version1_2).isNull();\r\n}",
    "testVersionedGsonWithUnversionedClassesSerialization": "{\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    BagOfPrimitives target \u003d new BagOfPrimitives(10, 20, false, \"stringValue\");\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "testVersionedGsonWithUnversionedClassesDeserialization": "{\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    String json \u003d \"{\\\"longValue\\\":10,\\\"intValue\\\":20,\\\"booleanValue\\\":false}\";\r\n    BagOfPrimitives expected \u003d new BagOfPrimitives();\r\n    expected.longValue \u003d 10;\r\n    expected.intValue \u003d 20;\r\n    expected.booleanValue \u003d false;\r\n    BagOfPrimitives actual \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\GsonVersionDiagnosticsTest.java": {
    "testVersionPattern": "{\r\n    assertThat(\"(GSON 2.8.5)\").matches(GSON_VERSION_PATTERN);\r\n    assertThat(\"(GSON 2.8.5-SNAPSHOT)\").matches(GSON_VERSION_PATTERN);\r\n}",
    "read": "{\r\n    throw new AssertionError(\"Expected during deserialization\");\r\n}",
    "testAssertionErrorInDeserializationPrintsVersion": "{\r\n    AssertionError e \u003d assertThrows(AssertionError.class, () -\u003e gson.fromJson(\"{\u0027a\u0027:\u0027abc\u0027}\", TestType.class));\r\n    ensureAssertionErrorPrintsGsonVersion(e);\r\n}",
    "testAssertionErrorInSerializationPrintsVersion": "{\r\n    AssertionError e \u003d assertThrows(AssertionError.class, () -\u003e gson.toJson(new TestType()));\r\n    ensureAssertionErrorPrintsGsonVersion(e);\r\n}",
    "setUp": "{\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(TestType.class, new TypeAdapter\u003cTestType\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, TestType value) {\r\n            throw new AssertionError(\"Expected during serialization\");\r\n        }\r\n\r\n        @Override\r\n        public TestType read(JsonReader in) {\r\n            throw new AssertionError(\"Expected during deserialization\");\r\n        }\r\n    }).create();\r\n}",
    "write": "{\r\n    throw new AssertionError(\"Expected during serialization\");\r\n}",
    "ensureAssertionErrorPrintsGsonVersion": "{\r\n    String msg \u003d expected.getMessage();\r\n    // System.err.println(msg);\r\n    int start \u003d msg.indexOf(\"(GSON\");\r\n    assertThat(start \u003e 0).isTrue();\r\n    int end \u003d msg.indexOf(\"):\") + 1;\r\n    assertThat(end \u003e 0 \u0026\u0026 end \u003e start + 6).isTrue();\r\n    String version \u003d msg.substring(start, end);\r\n    // System.err.println(version);\r\n    assertThat(version).matches(GSON_VERSION_PATTERN);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\DefaultInetAddressTypeAdapterTest.java": {
    "testInetAddressSerializationAndDeserialization": "{\r\n    // we really do want this method\r\n    @SuppressWarnings(\"AddressSelection\")\r\n    InetAddress address \u003d InetAddress.getByName(\"8.8.8.8\");\r\n    String jsonAddress \u003d gson.toJson(address);\r\n    assertThat(jsonAddress).isEqualTo(\"\\\"8.8.8.8\\\"\");\r\n    InetAddress value \u003d gson.fromJson(jsonAddress, InetAddress.class);\r\n    assertThat(address).isEqualTo(value);\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithNoArgsConstructor.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ObjectTest.java": {
    "testInnerClassSerialization": "{\r\n    Parent p \u003d new Parent();\r\n    Parent.Child c \u003d p.new Child();\r\n    String json \u003d gson.toJson(c);\r\n    assertThat(json).contains(\"value2\");\r\n    assertThat(json).doesNotContain(\"value1\");\r\n}",
    "testSingletonLists": "{\r\n    Gson gson \u003d new Gson();\r\n    Product product \u003d new Product();\r\n    assertThat(gson.toJson(product)).isEqualTo(\"{\\\"attributes\\\":[],\\\"departments\\\":[]}\");\r\n    Product unused1 \u003d gson.fromJson(gson.toJson(product), Product.class);\r\n    product.departments.add(new Department());\r\n    assertThat(gson.toJson(product)).isEqualTo(\"{\\\"attributes\\\":[],\\\"departments\\\":[{\\\"name\\\":\\\"abc\\\",\\\"code\\\":\\\"123\\\"}]}\");\r\n    Product unused2 \u003d gson.fromJson(gson.toJson(product), Product.class);\r\n    product.attributes.add(\"456\");\r\n    assertThat(gson.toJson(product)).isEqualTo(\"{\\\"attributes\\\":[\\\"456\\\"],\\\"departments\\\":[{\\\"name\\\":\\\"abc\\\",\\\"code\\\":\\\"123\\\"}]}\");\r\n    Product unused3 \u003d gson.fromJson(gson.toJson(product), Product.class);\r\n}",
    "testStringFieldWithEmptyValueSerialization": "{\r\n    ClassWithEmptyStringFields target \u003d new ClassWithEmptyStringFields();\r\n    target.a \u003d \"5794749\";\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"a\\\":\\\"5794749\\\"\");\r\n    assertThat(json).contains(\"\\\"b\\\":\\\"\\\"\");\r\n    assertThat(json).contains(\"\\\"c\\\":\\\"\\\"\");\r\n}",
    "testObjectFieldNamesWithoutQuotesDeserialization": "{\r\n    String json \u003d \"{longValue:1,\u0027booleanValue\u0027:true,\\\"stringValue\\\":\u0027bar\u0027}\";\r\n    BagOfPrimitives bag \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(bag.longValue).isEqualTo(1);\r\n    assertThat(bag.booleanValue).isTrue();\r\n    assertThat(bag.stringValue).isEqualTo(\"bar\");\r\n}",
    "testClassWithTransientFieldsSerialization": "{\r\n    ClassWithTransientFields\u003cLong\u003e target \u003d new ClassWithTransientFields\u003c\u003e(1L);\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "testTruncatedDeserialization": "{\r\n    try {\r\n        gson.fromJson(\"[\\\"a\\\", \\\"b\\\",\", new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testArrayOfObjectsAsFields": "{\r\n    ClassWithObjects classWithObjects \u003d new ClassWithObjects();\r\n    BagOfPrimitives bagOfPrimitives \u003d new BagOfPrimitives();\r\n    String stringValue \u003d \"someStringValueInArray\";\r\n    String classWithObjectsJson \u003d gson.toJson(classWithObjects);\r\n    String bagOfPrimitivesJson \u003d gson.toJson(bagOfPrimitives);\r\n    ClassWithArray classWithArray \u003d new ClassWithArray(new Object[] { stringValue, classWithObjects, bagOfPrimitives });\r\n    String json \u003d gson.toJson(classWithArray);\r\n    assertThat(json).contains(classWithObjectsJson);\r\n    assertThat(json).contains(bagOfPrimitivesJson);\r\n    assertThat(json).contains(\"\\\"\" + stringValue + \"\\\"\");\r\n}",
    "testBagOfPrimitiveWrappersSerialization": "{\r\n    BagOfPrimitiveWrappers target \u003d new BagOfPrimitiveWrappers(10L, 20, false);\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "testJsonObjectSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().serializeNulls().create();\r\n    JsonObject obj \u003d new JsonObject();\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n}",
    "testStaticFieldDeserialization": "{\r\n    // By default Gson should ignore static fields\r\n    ClassWithStaticField unused \u003d gson.fromJson(\"{\\\"s\\\":\\\"custom\\\"}\", ClassWithStaticField.class);\r\n    assertThat(ClassWithStaticField.s).isEqualTo(\"initial\");\r\n    Gson gson \u003d new GsonBuilder().// Include static fields\r\n    excludeFieldsWithModifiers(0).create();\r\n    String oldValue \u003d ClassWithStaticField.s;\r\n    try {\r\n        ClassWithStaticField obj \u003d gson.fromJson(\"{\\\"s\\\":\\\"custom\\\"}\", ClassWithStaticField.class);\r\n        assertThat(obj).isNotNull();\r\n        assertThat(ClassWithStaticField.s).isEqualTo(\"custom\");\r\n    } finally {\r\n        ClassWithStaticField.s \u003d oldValue;\r\n    }\r\n    try {\r\n        gson.fromJson(\"{\\\"s\\\":\\\"custom\\\"}\", ClassWithStaticFinalField.class);\r\n        fail();\r\n    } catch (JsonIOException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Cannot set value of \u0027static final\u0027 field \u0027com.google.gson.functional.ObjectTest$ClassWithStaticFinalField#s\u0027\");\r\n    }\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n    oldTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"));\r\n    oldLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n}",
    "testClassWithTransientFieldsDeserialization": "{\r\n    String json \u003d \"{\\\"longValue\\\":[1]}\";\r\n    ClassWithTransientFields\u003c?\u003e target \u003d gson.fromJson(json, ClassWithTransientFields.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "createInstance": "{\r\n    return p.new Child();\r\n}",
    "testJsonInMixedQuotesDeserialization": "{\r\n    String json \u003d \"{\\\"stringValue\\\":\u0027no message\u0027,\u0027intValue\u0027:10,\u0027longValue\u0027:20}\";\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.stringValue).isEqualTo(\"no message\");\r\n    assertThat(target.intValue).isEqualTo(10);\r\n    assertThat(target.longValue).isEqualTo(20);\r\n}",
    "testArrayOfObjectsDeserialization": "{\r\n    String json \u003d new ArrayOfObjects().getExpectedJson();\r\n    ArrayOfObjects target \u003d gson.fromJson(json, ArrayOfObjects.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "testInnerClassDeserialization": "{\r\n    final Parent p \u003d new Parent();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Parent.Child.class, new InstanceCreator\u003cParent.Child\u003e() {\r\n\r\n        @Override\r\n        public Parent.Child createInstance(Type type) {\r\n            return p.new Child();\r\n        }\r\n    }).create();\r\n    String json \u003d \"{\u0027value2\u0027:3}\";\r\n    Parent.Child c \u003d gson.fromJson(json, Parent.Child.class);\r\n    assertThat(c.value2).isEqualTo(3);\r\n}",
    "testNullFieldsDeserialization": "{\r\n    String json \u003d \"{\\\"primitive1\\\":{\\\"longValue\\\":10,\\\"intValue\\\":20,\\\"booleanValue\\\":false\" + \",\\\"stringValue\\\":\\\"stringValue\\\"}}\";\r\n    Nested target \u003d gson.fromJson(json, Nested.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "testPrimitiveArrayInAnObjectDeserialization": "{\r\n    String json \u003d \"{\\\"longArray\\\":[0,1,2,3,4,5,6,7,8,9]}\";\r\n    PrimitiveArray target \u003d gson.fromJson(json, PrimitiveArray.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "serialize": "{\r\n    return new JsonObject();\r\n}",
    "testEmptyCollectionInAnObjectDeserialization": "{\r\n    String json \u003d \"{\\\"children\\\":[]}\";\r\n    ClassWithCollectionField target \u003d gson.fromJson(json, ClassWithCollectionField.class);\r\n    assertThat(target).isNotNull();\r\n    assertThat(target.children).isEmpty();\r\n}",
    "testDateAsMapObjectField": "{\r\n    HasObjectMap a \u003d new HasObjectMap();\r\n    a.map.put(\"date\", new Date(0));\r\n    assertThat(gson.toJson(a)).matches(\"\\\\{\\\"map\\\":\\\\{\\\"date\\\":\\\"Dec 31, 1969,? 4:00:00\\\\hPM\\\"\\\\}\\\\}\");\r\n}",
    "testStaticFieldSerialization": "{\r\n    // By default Gson should ignore static fields\r\n    assertThat(gson.toJson(new ClassWithStaticField())).isEqualTo(\"{}\");\r\n    Gson gson \u003d new GsonBuilder().// Include static fields\r\n    excludeFieldsWithModifiers(0).create();\r\n    String json \u003d gson.toJson(new ClassWithStaticField());\r\n    assertThat(json).isEqualTo(\"{\\\"s\\\":\\\"initial\\\"}\");\r\n    json \u003d gson.toJson(new ClassWithStaticFinalField());\r\n    assertThat(json).isEqualTo(\"{\\\"s\\\":\\\"initial\\\"}\");\r\n}",
    "testBagOfPrimitivesDeserialization": "{\r\n    BagOfPrimitives src \u003d new BagOfPrimitives(10, 20, false, \"stringValue\");\r\n    String json \u003d src.getExpectedJson();\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "testNestedSerialization": "{\r\n    Nested target \u003d new Nested(new BagOfPrimitives(10, 20, false, \"stringValue\"), new BagOfPrimitives(30, 40, true, \"stringValue\"));\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "testNullArraysDeserialization": "{\r\n    String json \u003d \"{\\\"array\\\": null}\";\r\n    ClassWithArray target \u003d gson.fromJson(json, ClassWithArray.class);\r\n    assertThat(target.array).isNull();\r\n}",
    "testAnonymousLocalClassesSerialization": "{\r\n    assertThat(gson.toJson(new ClassWithNoFields() {\r\n    })).isEqualTo(\"null\");\r\n}",
    "testArrayOfArraysDeserialization": "{\r\n    String json \u003d new ArrayOfArrays().getExpectedJson();\r\n    ArrayOfArrays target \u003d gson.fromJson(json, ArrayOfArrays.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "testNullPrimitiveFieldsDeserialization": "{\r\n    String json \u003d \"{\\\"longValue\\\":null}\";\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.longValue).isEqualTo(BagOfPrimitives.DEFAULT_VALUE);\r\n}",
    "testClassWithObjectFieldSerialization": "{\r\n    ClassWithObjectField obj \u003d new ClassWithObjectField();\r\n    obj.member \u003d \"abc\";\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).contains(\"abc\");\r\n}",
    "testArrayOfArraysSerialization": "{\r\n    ArrayOfArrays target \u003d new ArrayOfArrays();\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "testClassWithNoFieldsSerialization": "{\r\n    assertThat(gson.toJson(new ClassWithNoFields())).isEqualTo(\"{}\");\r\n}",
    "testNullSerialization": "{\r\n    assertThat(gson.toJson(null)).isEqualTo(\"null\");\r\n}",
    "testNullDeserialization": "{\r\n    String myNullObject \u003d null;\r\n    Object object \u003d gson.fromJson(myNullObject, Object.class);\r\n    assertThat(object).isNull();\r\n}",
    "testStringFieldWithNumberValueDeserialization": "{\r\n    String json \u003d \"{\\\"stringValue\\\":1}\";\r\n    BagOfPrimitives bag \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(bag.stringValue).isEqualTo(\"1\");\r\n    json \u003d \"{\\\"stringValue\\\":1.5E+6}\";\r\n    bag \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(bag.stringValue).isEqualTo(\"1.5E+6\");\r\n    json \u003d \"{\\\"stringValue\\\":true}\";\r\n    bag \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(bag.stringValue).isEqualTo(\"true\");\r\n}",
    "testAnonymousLocalClassesCustomSerialization": "{\r\n    gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(ClassWithNoFields.class, new JsonSerializer\u003cClassWithNoFields\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(ClassWithNoFields src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonObject();\r\n        }\r\n    }).create();\r\n    assertThat(gson.toJson(new ClassWithNoFields() {\r\n    })).isEqualTo(\"null\");\r\n}",
    "testBagOfPrimitiveWrappersDeserialization": "{\r\n    BagOfPrimitiveWrappers target \u003d new BagOfPrimitiveWrappers(10L, 20, false);\r\n    String jsonString \u003d target.getExpectedJson();\r\n    target \u003d gson.fromJson(jsonString, BagOfPrimitiveWrappers.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(jsonString);\r\n}",
    "testEmptyCollectionInAnObjectSerialization": "{\r\n    ClassWithCollectionField target \u003d new ClassWithCollectionField();\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"children\\\":[]}\");\r\n}",
    "testPrimitiveArrayFieldSerialization": "{\r\n    PrimitiveArray target \u003d new PrimitiveArray(new long[] { 1L, 2L, 3L });\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "shouldSkipClass": "{\r\n    return false;\r\n}",
    "testEmptyStringDeserialization": "{\r\n    Object object \u003d gson.fromJson(\"\", Object.class);\r\n    assertThat(object).isNull();\r\n}",
    "testPrivateNoArgConstructorDeserialization": "{\r\n    ClassWithPrivateNoArgsConstructor target \u003d gson.fromJson(\"{\\\"a\\\":20}\", ClassWithPrivateNoArgsConstructor.class);\r\n    assertThat(target.a).isEqualTo(20);\r\n}",
    "testBagOfPrimitivesSerialization": "{\r\n    BagOfPrimitives target \u003d new BagOfPrimitives(10, 20, false, \"stringValue\");\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "testNullObjectFieldsDeserialization": "{\r\n    String json \u003d \"{\\\"bag\\\": null}\";\r\n    ClassWithObjects target \u003d gson.fromJson(json, ClassWithObjects.class);\r\n    assertThat(target.bag).isNull();\r\n}",
    "testNestedDeserialization": "{\r\n    String json \u003d \"{\\\"primitive1\\\":{\\\"longValue\\\":10,\\\"intValue\\\":20,\\\"booleanValue\\\":false,\" + \"\\\"stringValue\\\":\\\"stringValue\\\"},\\\"primitive2\\\":{\\\"longValue\\\":30,\\\"intValue\\\":40,\" + \"\\\"booleanValue\\\":true,\\\"stringValue\\\":\\\"stringValue\\\"}}\";\r\n    Nested target \u003d gson.fromJson(json, Nested.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "testClassWithNoFieldsDeserialization": "{\r\n    String json \u003d \"{}\";\r\n    ClassWithNoFields target \u003d gson.fromJson(json, ClassWithNoFields.class);\r\n    ClassWithNoFields expected \u003d new ClassWithNoFields();\r\n    assertThat(target).isEqualTo(expected);\r\n}",
    "testNullFieldsSerialization": "{\r\n    Nested target \u003d new Nested(new BagOfPrimitives(10, 20, false, \"stringValue\"), null);\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored": "{\r\n    String json \u003d \"{\\\"transientLongValue\\\":1,\\\"longValue\\\":[1]}\";\r\n    ClassWithTransientFields\u003c?\u003e target \u003d gson.fromJson(json, ClassWithTransientFields.class);\r\n    assertThat(target.transientLongValue !\u003d 1).isFalse();\r\n}",
    "tearDown": "{\r\n    TimeZone.setDefault(oldTimeZone);\r\n    Locale.setDefault(oldLocale);\r\n}",
    "testThrowingDefaultConstructor": "{\r\n    try {\r\n        gson.fromJson(\"{}\", ClassWithThrowingConstructor.class);\r\n        fail();\r\n    }// TODO: Adjust this once Gson throws more specific exception type\r\n     catch (RuntimeException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Failed to invoke constructor \u0027com.google.gson.functional.ObjectTest$ClassWithThrowingConstructor()\u0027 with no args\");\r\n        assertThat(e).hasCauseThat().isSameInstanceAs(ClassWithThrowingConstructor.thrownException);\r\n    }\r\n}",
    "testClassWithDuplicateFields": "{\r\n    String expectedMessage \u003d \"Class com.google.gson.functional.ObjectTest$Subclass declares multiple JSON fields named \u0027s\u0027;\" + \" conflict is caused by fields com.google.gson.functional.ObjectTest$Superclass1#s and\" + \" com.google.gson.functional.ObjectTest$Superclass2#s\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#duplicate-fields\";\r\n    try {\r\n        gson.getAdapter(Subclass.class);\r\n        fail();\r\n    } catch (IllegalArgumentException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    }\r\n    // Detection should also work properly when duplicate fields exist only for serialization\r\n    Gson gson \u003d new GsonBuilder().addDeserializationExclusionStrategy(new ExclusionStrategy() {\r\n\r\n        @Override\r\n        public boolean shouldSkipField(FieldAttributes f) {\r\n            // Skip all fields for deserialization\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n            return false;\r\n        }\r\n    }).create();\r\n    try {\r\n        gson.getAdapter(Subclass.class);\r\n        fail();\r\n    } catch (IllegalArgumentException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    }\r\n}",
    "testStringFieldWithEmptyValueDeserialization": "{\r\n    String json \u003d \"{a:\\\"5794749\\\",b:\\\"\\\",c:\\\"\\\"}\";\r\n    ClassWithEmptyStringFields target \u003d gson.fromJson(json, ClassWithEmptyStringFields.class);\r\n    assertThat(target.a).isEqualTo(\"5794749\");\r\n    assertThat(target.b).isEqualTo(\"\");\r\n    assertThat(target.c).isEqualTo(\"\");\r\n}",
    "shouldSkipField": "{\r\n    // Skip all fields for deserialization\r\n    return true;\r\n}",
    "getExpectedJson": "{\r\n    StringBuilder sb \u003d new StringBuilder(\"{\\\"elements\\\":[\");\r\n    boolean first \u003d true;\r\n    for (BagOfPrimitives[] row : elements) {\r\n        if (first) {\r\n            first \u003d false;\r\n        } else {\r\n            sb.append(\",\");\r\n        }\r\n        boolean firstOfRow \u003d true;\r\n        sb.append(\"[\");\r\n        for (BagOfPrimitives element : row) {\r\n            if (firstOfRow) {\r\n                firstOfRow \u003d false;\r\n            } else {\r\n                sb.append(\",\");\r\n            }\r\n            sb.append(element.getExpectedJson());\r\n        }\r\n        sb.append(\"]\");\r\n    }\r\n    sb.append(\"]}\");\r\n    return sb.toString();\r\n}",
    "testJsonInSingleQuotesDeserialization": "{\r\n    String json \u003d \"{\u0027stringValue\u0027:\u0027no message\u0027,\u0027intValue\u0027:10,\u0027longValue\u0027:20}\";\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.stringValue).isEqualTo(\"no message\");\r\n    assertThat(target.intValue).isEqualTo(10);\r\n    assertThat(target.longValue).isEqualTo(20);\r\n}",
    "testArrayOfObjectsSerialization": "{\r\n    ArrayOfObjects target \u003d new ArrayOfObjects();\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\PrimitiveTypeAdapter.java": {
    "adaptType": "{\r\n    Class\u003c?\u003e aClass \u003d Primitives.wrap(to);\r\n    if (Primitives.isWrapperType(aClass)) {\r\n        if (aClass \u003d\u003d Character.class) {\r\n            String value \u003d from.toString();\r\n            if (value.length() \u003d\u003d 1) {\r\n                return (T) (Character) from.toString().charAt(0);\r\n            }\r\n            throw new JsonParseException(\"The value: \" + value + \" contains more than a character.\");\r\n        }\r\n        try {\r\n            Constructor\u003c?\u003e constructor \u003d aClass.getConstructor(String.class);\r\n            return (T) constructor.newInstance(from.toString());\r\n        } catch (NoSuchMethodException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (InstantiationException e) {\r\n            throw new JsonParseException(e);\r\n        }\r\n    } else if (Enum.class.isAssignableFrom(to)) {\r\n        // Case where the type being adapted to is an Enum\r\n        // We will try to convert from.toString() to the enum\r\n        try {\r\n            Method valuesMethod \u003d to.getMethod(\"valueOf\", String.class);\r\n            return (T) valuesMethod.invoke(null, from.toString());\r\n        } catch (NoSuchMethodException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    } else {\r\n        throw new JsonParseException(\"Can not adapt type \" + from.getClass() + \" to \" + to);\r\n    }\r\n}"
  },
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\BagOfPrimitivesDeserializationBenchmark.java": {
    "timeBagOfPrimitivesStreaming": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginObject();\r\n        long longValue \u003d 0;\r\n        int intValue \u003d 0;\r\n        boolean booleanValue \u003d false;\r\n        String stringValue \u003d null;\r\n        while (jr.hasNext()) {\r\n            String name \u003d jr.nextName();\r\n            if (name.equals(\"longValue\")) {\r\n                longValue \u003d jr.nextLong();\r\n            } else if (name.equals(\"intValue\")) {\r\n                intValue \u003d jr.nextInt();\r\n            } else if (name.equals(\"booleanValue\")) {\r\n                booleanValue \u003d jr.nextBoolean();\r\n            } else if (name.equals(\"stringValue\")) {\r\n                stringValue \u003d jr.nextString();\r\n            } else {\r\n                throw new IOException(\"Unexpected name: \" + name);\r\n            }\r\n        }\r\n        jr.endObject();\r\n        new BagOfPrimitives(longValue, intValue, booleanValue, stringValue);\r\n    }\r\n}",
    "timeBagOfPrimitivesDefault": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        gson.fromJson(json, BagOfPrimitives.class);\r\n    }\r\n}",
    "setUp": "{\r\n    this.gson \u003d new Gson();\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives(10L, 1, false, \"foo\");\r\n    this.json \u003d gson.toJson(bag);\r\n}",
    "main": "{\r\n    NonUploadingCaliperRunner.run(BagOfPrimitivesDeserializationBenchmark.class, args);\r\n}",
    "timeBagOfPrimitivesReflectionStreaming": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginObject();\r\n        BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n        while (jr.hasNext()) {\r\n            String name \u003d jr.nextName();\r\n            for (Field field : BagOfPrimitives.class.getDeclaredFields()) {\r\n                if (field.getName().equals(name)) {\r\n                    Class\u003c?\u003e fieldType \u003d field.getType();\r\n                    if (fieldType.equals(long.class)) {\r\n                        field.setLong(bag, jr.nextLong());\r\n                    } else if (fieldType.equals(int.class)) {\r\n                        field.setInt(bag, jr.nextInt());\r\n                    } else if (fieldType.equals(boolean.class)) {\r\n                        field.setBoolean(bag, jr.nextBoolean());\r\n                    } else if (fieldType.equals(String.class)) {\r\n                        field.set(bag, jr.nextString());\r\n                    } else {\r\n                        throw new RuntimeException(\"Unexpected: type: \" + fieldType + \", name: \" + name);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        jr.endObject();\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\ConstructorConstructor.java": {
    "newDefaultConstructor": "{\r\n    // Cannot invoke constructor of abstract class\r\n    if (Modifier.isAbstract(rawType.getModifiers())) {\r\n        return null;\r\n    }\r\n    final Constructor\u003c? super T\u003e constructor;\r\n    try {\r\n        constructor \u003d rawType.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException e) {\r\n        return null;\r\n    }\r\n    boolean canAccess \u003d filterResult \u003d\u003d FilterResult.ALLOW || (ReflectionAccessFilterHelper.canAccess(constructor, null) \u0026\u0026 // Be a bit more lenient here for BLOCK_ALL; if constructor is accessible and public then allow calling it\r\n    (filterResult !\u003d FilterResult.BLOCK_ALL || Modifier.isPublic(constructor.getModifiers())));\r\n    if (!canAccess) {\r\n        final String message \u003d \"Unable to invoke no-args constructor of \" + rawType + \";\" + \" constructor is not accessible and ReflectionAccessFilter does not permit making\" + \" it accessible. Register an InstanceCreator or a TypeAdapter for this type, change\" + \" the visibility of the constructor or adjust the access filter.\";\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(message);\r\n            }\r\n        };\r\n    }\r\n    // Only try to make accessible if allowed; in all other cases checks above should\r\n    // have verified that constructor is accessible\r\n    if (filterResult \u003d\u003d FilterResult.ALLOW) {\r\n        final String exceptionMessage \u003d ReflectionHelper.tryMakeAccessible(constructor);\r\n        if (exceptionMessage !\u003d null) {\r\n            /*\r\n         * Create ObjectConstructor which throws exception.\r\n         * This keeps backward compatibility (compared to returning `null` which\r\n         * would then choose another way of creating object).\r\n         * And it supports types which are only serialized but not deserialized\r\n         * (compared to directly throwing exception here), e.g. when runtime type\r\n         * of object is inaccessible, but compile-time type is accessible.\r\n         */\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    // New exception is created every time to avoid keeping reference\r\n                    // to exception with potentially long stack trace, causing a\r\n                    // memory leak\r\n                    throw new JsonIOException(exceptionMessage);\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return new ObjectConstructor\u003cT\u003e() {\r\n\r\n        @Override\r\n        public T construct() {\r\n            try {\r\n                // T is the same raw type as is requested\r\n                @SuppressWarnings(\"unchecked\")\r\n                T newInstance \u003d (T) constructor.newInstance();\r\n                return newInstance;\r\n            }// Note: InstantiationException should be impossible because check at start of method made sure\r\n            //   that class is not abstract\r\n             catch (InstantiationException e) {\r\n                throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with no args\", e);\r\n            } catch (InvocationTargetException e) {\r\n                // TODO: don\u0027t wrap if cause is unchecked?\r\n                // TODO: JsonParseException ?\r\n                throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with no args\", e.getCause());\r\n            } catch (IllegalAccessException e) {\r\n                throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n            }\r\n        }\r\n    };\r\n}",
    "get": "{\r\n    final Type type \u003d typeToken.getType();\r\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    // first try an instance creator\r\n    // types must agree\r\n    @SuppressWarnings(\"unchecked\")\r\n    final InstanceCreator\u003cT\u003e typeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\r\n    if (typeCreator !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                return typeCreator.createInstance(type);\r\n            }\r\n        };\r\n    }\r\n    // Next try raw type match for instance creators\r\n    // types must agree\r\n    @SuppressWarnings(\"unchecked\")\r\n    final InstanceCreator\u003cT\u003e rawTypeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(rawType);\r\n    if (rawTypeCreator !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                return rawTypeCreator.createInstance(type);\r\n            }\r\n        };\r\n    }\r\n    // First consider special constructors before checking for no-args constructors\r\n    // below to avoid matching internal no-args constructors which might be added in\r\n    // future JDK versions\r\n    ObjectConstructor\u003cT\u003e specialConstructor \u003d newSpecialCollectionConstructor(type, rawType);\r\n    if (specialConstructor !\u003d null) {\r\n        return specialConstructor;\r\n    }\r\n    FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, rawType);\r\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType, filterResult);\r\n    if (defaultConstructor !\u003d null) {\r\n        return defaultConstructor;\r\n    }\r\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\r\n    if (defaultImplementation !\u003d null) {\r\n        return defaultImplementation;\r\n    }\r\n    // Check whether type is instantiable; otherwise ReflectionAccessFilter recommendation\r\n    // of adjusting filter suggested below is irrelevant since it would not solve the problem\r\n    final String exceptionMessage \u003d checkInstantiable(rawType);\r\n    if (exceptionMessage !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(exceptionMessage);\r\n            }\r\n        };\r\n    }\r\n    // Consider usage of Unsafe as reflection, so don\u0027t use if BLOCK_ALL\r\n    // Additionally, since it is not calling any constructor at all, don\u0027t use if BLOCK_INACCESSIBLE\r\n    if (filterResult \u003d\u003d FilterResult.ALLOW) {\r\n        // finally try unsafe\r\n        return newUnsafeAllocator(rawType);\r\n    } else {\r\n        final String message \u003d \"Unable to create instance of \" + rawType + \"; ReflectionAccessFilter\" + \" does not permit using reflection or Unsafe. Register an InstanceCreator or a TypeAdapter\" + \" for this type or adjust the access filter to allow using reflection.\";\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(message);\r\n            }\r\n        };\r\n    }\r\n}",
    "checkInstantiable": "{\r\n    int modifiers \u003d c.getModifiers();\r\n    if (Modifier.isInterface(modifiers)) {\r\n        return \"Interfaces can\u0027t be instantiated! Register an InstanceCreator\" + \" or a TypeAdapter for this type. Interface name: \" + c.getName();\r\n    }\r\n    if (Modifier.isAbstract(modifiers)) {\r\n        // R8 performs aggressive optimizations where it removes the default constructor of a class\r\n        // and makes the class `abstract`; check for that here explicitly\r\n        /*\r\n       * Note: Ideally should only show this R8-specific message when it is clear that R8 was\r\n       * used (e.g. when `c.getDeclaredConstructors().length \u003d\u003d 0`), but on Android where this\r\n       * issue with R8 occurs most, R8 seems to keep some constructors for some reason while\r\n       * still making the class abstract\r\n       */\r\n        return \"Abstract classes can\u0027t be instantiated! Adjust the R8 configuration or register\" + \" an InstanceCreator or a TypeAdapter for this type. Class name: \" + c.getName() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"r8-abstract-class\");\r\n    }\r\n    return null;\r\n}",
    "toString": "{\r\n    return instanceCreators.toString();\r\n}",
    "construct": "{\r\n    throw new JsonIOException(exceptionMessageF);\r\n}",
    "newDefaultImplementationConstructor": "{\r\n    /*\r\n     * IMPORTANT: Must only create instances for classes with public no-args constructor.\r\n     * For classes with special constructors / factory methods (e.g. EnumSet)\r\n     * `newSpecialCollectionConstructor` defined above must be used, to avoid no-args\r\n     * constructor check (which is called before this method) detecting internal no-args\r\n     * constructors which might be added in a future JDK version\r\n     */\r\n    if (Collection.class.isAssignableFrom(rawType)) {\r\n        if (SortedSet.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new TreeSet\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (Set.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedHashSet\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (Queue.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ArrayDeque\u003c\u003e();\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ArrayList\u003c\u003e();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    if (Map.class.isAssignableFrom(rawType)) {\r\n        if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ConcurrentSkipListMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ConcurrentHashMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (SortedMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new TreeMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (type instanceof ParameterizedType \u0026\u0026 !String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType())) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedHashMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedTreeMap\u003c\u003e();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}",
    "newSpecialCollectionConstructor": "{\r\n    if (EnumSet.class.isAssignableFrom(rawType)) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                if (type instanceof ParameterizedType) {\r\n                    Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                    if (elementType instanceof Class) {\r\n                        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n                        T set \u003d (T) EnumSet.noneOf((Class) elementType);\r\n                        return set;\r\n                    } else {\r\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n                    }\r\n                } else {\r\n                    throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n                }\r\n            }\r\n        };\r\n    } else // Only support creation of EnumMap, but not of custom subtypes; for them type parameters\r\n    // and constructor parameter might have completely different meaning\r\n    if (rawType \u003d\u003d EnumMap.class) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                if (type instanceof ParameterizedType) {\r\n                    Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                    if (elementType instanceof Class) {\r\n                        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n                        T map \u003d (T) new EnumMap((Class) elementType);\r\n                        return map;\r\n                    } else {\r\n                        throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\r\n                    }\r\n                } else {\r\n                    throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\r\n                }\r\n            }\r\n        };\r\n    }\r\n    return null;\r\n}",
    "newUnsafeAllocator": "{\r\n    if (useJdkUnsafe) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                try {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    T newInstance \u003d (T) UnsafeAllocator.INSTANCE.newInstance(rawType);\r\n                    return newInstance;\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException((\"Unable to create instance of \" + rawType + \".\" + \" Registering an InstanceCreator or a TypeAdapter for this type, or adding a no-args\" + \" constructor may fix this problem.\"), e);\r\n                }\r\n            }\r\n        };\r\n    } else {\r\n        String exceptionMessage \u003d \"Unable to create instance of \" + rawType + \"; usage of JDK Unsafe\" + \" is disabled. Registering an InstanceCreator or a TypeAdapter for this type, adding a no-args\" + \" constructor, or enabling usage of JDK Unsafe may fix this problem.\";\r\n        // Check if R8 removed all constructors\r\n        if (rawType.getDeclaredConstructors().length \u003d\u003d 0) {\r\n            // R8 with Unsafe disabled might not be common enough to warrant a separate Troubleshooting Guide entry\r\n            exceptionMessage +\u003d \" Or adjust your R8 configuration to keep the no-args constructor of the class.\";\r\n        }\r\n        // Explicit final variable to allow usage in the anonymous class below\r\n        final String exceptionMessageF \u003d exceptionMessage;\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(exceptionMessageF);\r\n            }\r\n        };\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\InstanceCreatorTest.java": {
    "testInstanceCreatorReturnsBaseType": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new InstanceCreator\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base createInstance(Type type) {\r\n            return new Base();\r\n        }\r\n    }).create();\r\n    String json \u003d \"{baseName:\u0027BaseRevised\u0027,subName:\u0027Sub\u0027}\";\r\n    Base base \u003d gson.fromJson(json, Base.class);\r\n    assertThat(base.baseName).isEqualTo(\"BaseRevised\");\r\n}",
    "createInstance": "{\r\n    return new SubTreeSet\u003c\u003e();\r\n}",
    "testInstanceCreatorForCollectionType": "{\r\n    @SuppressWarnings(\"serial\")\r\n    class SubArrayList\u003cT\u003e extends ArrayList\u003cT\u003e {\r\n    }\r\n    InstanceCreator\u003cList\u003cString\u003e\u003e listCreator \u003d new InstanceCreator\u003cList\u003cString\u003e\u003e() {\r\n\r\n        @Override\r\n        public List\u003cString\u003e createInstance(Type type) {\r\n            return new SubArrayList\u003c\u003e();\r\n        }\r\n    };\r\n    Type listOfStringType \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(listOfStringType, listCreator).create();\r\n    List\u003cString\u003e list \u003d gson.fromJson(\"[\\\"a\\\"]\", listOfStringType);\r\n    assertThat(list.getClass()).isEqualTo(SubArrayList.class);\r\n}",
    "testInstanceCreatorReturnsSubTypeForTopLevelObject": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new InstanceCreator\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base createInstance(Type type) {\r\n            return new Sub();\r\n        }\r\n    }).create();\r\n    String json \u003d \"{baseName:\u0027Base\u0027,subName:\u0027SubRevised\u0027}\";\r\n    Base base \u003d gson.fromJson(json, Base.class);\r\n    assertThat(base instanceof Sub).isTrue();\r\n    Sub sub \u003d (Sub) base;\r\n    assertThat(\"SubRevised\".equals(sub.subName)).isFalse();\r\n    assertThat(sub.subName).isEqualTo(Sub.SUB_NAME);\r\n}",
    "testInstanceCreatorReturnsSubTypeForField": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new InstanceCreator\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base createInstance(Type type) {\r\n            return new Sub();\r\n        }\r\n    }).create();\r\n    String json \u003d \"{base:{baseName:\u0027Base\u0027,subName:\u0027SubRevised\u0027}}\";\r\n    ClassWithBaseField target \u003d gson.fromJson(json, ClassWithBaseField.class);\r\n    assertThat(target.base instanceof Sub).isTrue();\r\n    assertThat(((Sub) target.base).subName).isEqualTo(Sub.SUB_NAME);\r\n}",
    "testInstanceCreatorForParametrizedType": "{\r\n    @SuppressWarnings(\"serial\")\r\n    class SubTreeSet\u003cT\u003e extends TreeSet\u003cT\u003e {\r\n    }\r\n    InstanceCreator\u003cSortedSet\u003c?\u003e\u003e sortedSetCreator \u003d new InstanceCreator\u003cSortedSet\u003c?\u003e\u003e() {\r\n\r\n        @Override\r\n        public SortedSet\u003c?\u003e createInstance(Type type) {\r\n            return new SubTreeSet\u003c\u003e();\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(SortedSet.class, sortedSetCreator).create();\r\n    Type sortedSetType \u003d new TypeToken\u003cSortedSet\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    SortedSet\u003cString\u003e set \u003d gson.fromJson(\"[\\\"a\\\"]\", sortedSetType);\r\n    assertThat(set.first()).isEqualTo(\"a\");\r\n    assertThat(set.getClass()).isEqualTo(SubTreeSet.class);\r\n    set \u003d gson.fromJson(\"[\\\"b\\\"]\", SortedSet.class);\r\n    assertThat(set.first()).isEqualTo(\"b\");\r\n    assertThat(set.getClass()).isEqualTo(SubTreeSet.class);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\MixedStreamTest.java": {
    "testWriteLenient": "{\r\n    List\u003cDouble\u003e doubles \u003d Arrays.asList(Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, -0.0d, 0.5d, 0.0d);\r\n    Type type \u003d new TypeToken\u003cList\u003cDouble\u003e\u003e() {\r\n    }.getType();\r\n    StringWriter writer \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(writer);\r\n    new GsonBuilder().serializeSpecialFloatingPointValues().create().toJson(doubles, type, jsonWriter);\r\n    assertThat(writer.toString()).isEqualTo(\"[NaN,-Infinity,Infinity,-0.0,0.5,0.0]\");\r\n    try {\r\n        new Gson().toJson(doubles, type, new JsonWriter(new StringWriter()));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testWriteDoesNotMutateState": "{\r\n    Gson gson \u003d new Gson();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.beginArray();\r\n    jsonWriter.setHtmlSafe(true);\r\n    jsonWriter.setLenient(true);\r\n    gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\r\n    assertThat(jsonWriter.isHtmlSafe()).isTrue();\r\n    assertThat(jsonWriter.isLenient()).isTrue();\r\n    jsonWriter.setHtmlSafe(false);\r\n    jsonWriter.setLenient(false);\r\n    gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\r\n    assertThat(jsonWriter.isHtmlSafe()).isFalse();\r\n    assertThat(jsonWriter.isLenient()).isFalse();\r\n}",
    "testReadMixedStreamed": "{\r\n    Gson gson \u003d new Gson();\r\n    StringReader stringReader \u003d new StringReader(CARS_JSON);\r\n    JsonReader jsonReader \u003d new JsonReader(stringReader);\r\n    jsonReader.beginArray();\r\n    // actual and expected object are inverted in the test.\r\n    // gson.fromJson(jsonReader, Car.class) as arg of assertThat() cause an ambiguous method call\r\n    assertThat(BLUE_MUSTANG).isEqualTo(gson.fromJson(jsonReader, Car.class));\r\n    assertThat(BLACK_BMW).isEqualTo(gson.fromJson(jsonReader, Car.class));\r\n    assertThat(RED_MIATA).isEqualTo(gson.fromJson(jsonReader, Car.class));\r\n    jsonReader.endArray();\r\n}",
    "testWriteClosed": "{\r\n    Gson gson \u003d new Gson();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.beginArray();\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    try {\r\n        gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "testWriteNulls": "{\r\n    Gson gson \u003d new Gson();\r\n    try {\r\n        gson.toJson(new JsonPrimitive(\"hello\"), (JsonWriter) null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    gson.toJson(null, new JsonWriter(stringWriter));\r\n    assertThat(stringWriter.toString()).isEqualTo(\"null\");\r\n}",
    "testWriteHtmlSafe": "{\r\n    List\u003cString\u003e contents \u003d Arrays.asList(\"\u003c\", \"\u003e\", \"\u0026\", \"\u003d\", \"\u0027\");\r\n    Type type \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    StringWriter writer \u003d new StringWriter();\r\n    new Gson().toJson(contents, type, new JsonWriter(writer));\r\n    assertThat(writer.toString()).isEqualTo(\"[\\\"\\\\u003c\\\",\\\"\\\\u003e\\\",\\\"\\\\u0026\\\",\\\"\\\\u003d\\\",\\\"\\\\u0027\\\"]\");\r\n    writer \u003d new StringWriter();\r\n    new GsonBuilder().disableHtmlEscaping().create().toJson(contents, type, new JsonWriter(writer));\r\n    assertThat(writer.toString()).isEqualTo(\"[\\\"\u003c\\\",\\\"\u003e\\\",\\\"\u0026\\\",\\\"\u003d\\\",\\\"\u0027\\\"]\");\r\n}",
    "testReaderDoesNotMutateState": "{\r\n    Gson gson \u003d new Gson();\r\n    JsonReader jsonReader \u003d new JsonReader(new StringReader(CARS_JSON));\r\n    jsonReader.beginArray();\r\n    jsonReader.setLenient(false);\r\n    Car unused1 \u003d gson.fromJson(jsonReader, Car.class);\r\n    assertThat(jsonReader.isLenient()).isFalse();\r\n    jsonReader.setLenient(true);\r\n    Car unused2 \u003d gson.fromJson(jsonReader, Car.class);\r\n    assertThat(jsonReader.isLenient()).isTrue();\r\n}",
    "testReadClosed": "{\r\n    Gson gson \u003d new Gson();\r\n    JsonReader jsonReader \u003d new JsonReader(new StringReader(CARS_JSON));\r\n    jsonReader.close();\r\n    try {\r\n        gson.fromJson(jsonReader, new TypeToken\u003cList\u003cCar\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "hashCode": "{\r\n    return name.hashCode() ^ color;\r\n}",
    "testWriteMixedStreamed": "{\r\n    Gson gson \u003d new Gson();\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.setIndent(\"  \");\r\n    gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\r\n    gson.toJson(BLACK_BMW, Car.class, jsonWriter);\r\n    gson.toJson(RED_MIATA, Car.class, jsonWriter);\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(CARS_JSON);\r\n}",
    "equals": "{\r\n    return o instanceof Car \u0026\u0026 ((Car) o).name.equals(name) \u0026\u0026 ((Car) o).color \u003d\u003d color;\r\n}",
    "testReadNulls": "{\r\n    Gson gson \u003d new Gson();\r\n    try {\r\n        gson.fromJson((JsonReader) null, Integer.class);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n    try {\r\n        gson.fromJson(new JsonReader(new StringReader(\"true\")), (Type) null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "testReadInvalidState": "{\r\n    Gson gson \u003d new Gson();\r\n    JsonReader jsonReader \u003d new JsonReader(new StringReader(CARS_JSON));\r\n    jsonReader.beginArray();\r\n    jsonReader.beginObject();\r\n    try {\r\n        gson.fromJson(jsonReader, String.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testWriteInvalidState": "{\r\n    Gson gson \u003d new Gson();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.beginObject();\r\n    try {\r\n        gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ObjectTypeAdapter.java": {
    "tryBeginNesting": "{\r\n    switch(peeked) {\r\n        case BEGIN_ARRAY:\r\n            in.beginArray();\r\n            return new ArrayList\u003c\u003e();\r\n        case BEGIN_OBJECT:\r\n            in.beginObject();\r\n            return new LinkedTreeMap\u003c\u003e();\r\n        default:\r\n            return null;\r\n    }\r\n}",
    "read": "{\r\n    // Either List or Map\r\n    Object current;\r\n    JsonToken peeked \u003d in.peek();\r\n    current \u003d tryBeginNesting(in, peeked);\r\n    if (current \u003d\u003d null) {\r\n        return readTerminal(in, peeked);\r\n    }\r\n    Deque\u003cObject\u003e stack \u003d new ArrayDeque\u003c\u003e();\r\n    while (true) {\r\n        while (in.hasNext()) {\r\n            String name \u003d null;\r\n            // Name is only used for JSON object members\r\n            if (current instanceof Map) {\r\n                name \u003d in.nextName();\r\n            }\r\n            peeked \u003d in.peek();\r\n            Object value \u003d tryBeginNesting(in, peeked);\r\n            boolean isNesting \u003d value !\u003d null;\r\n            if (value \u003d\u003d null) {\r\n                value \u003d readTerminal(in, peeked);\r\n            }\r\n            if (current instanceof List) {\r\n                @SuppressWarnings(\"unchecked\")\r\n                List\u003cObject\u003e list \u003d (List\u003cObject\u003e) current;\r\n                list.add(value);\r\n            } else {\r\n                @SuppressWarnings(\"unchecked\")\r\n                Map\u003cString, Object\u003e map \u003d (Map\u003cString, Object\u003e) current;\r\n                map.put(name, value);\r\n            }\r\n            if (isNesting) {\r\n                stack.addLast(current);\r\n                current \u003d value;\r\n            }\r\n        }\r\n        // End current element\r\n        if (current instanceof List) {\r\n            in.endArray();\r\n        } else {\r\n            in.endObject();\r\n        }\r\n        if (stack.isEmpty()) {\r\n            return current;\r\n        } else {\r\n            // Continue with enclosing element\r\n            current \u003d stack.removeLast();\r\n        }\r\n    }\r\n}",
    "newFactory": "{\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            if (type.getRawType() \u003d\u003d Object.class) {\r\n                return (TypeAdapter\u003cT\u003e) new ObjectTypeAdapter(gson, toNumberStrategy);\r\n            }\r\n            return null;\r\n        }\r\n    };\r\n}",
    "readTerminal": "{\r\n    switch(peeked) {\r\n        case STRING:\r\n            return in.nextString();\r\n        case NUMBER:\r\n            return toNumberStrategy.readNumber(in);\r\n        case BOOLEAN:\r\n            return in.nextBoolean();\r\n        case NULL:\r\n            in.nextNull();\r\n            return null;\r\n        default:\r\n            // When read(JsonReader) is called with JsonReader in invalid state\r\n            throw new IllegalStateException(\"Unexpected token: \" + peeked);\r\n    }\r\n}",
    "create": "{\r\n    if (type.getRawType() \u003d\u003d Object.class) {\r\n        return (TypeAdapter\u003cT\u003e) new ObjectTypeAdapter(gson, toNumberStrategy);\r\n    }\r\n    return null;\r\n}",
    "getFactory": "{\r\n    if (toNumberStrategy \u003d\u003d ToNumberPolicy.DOUBLE) {\r\n        return DOUBLE_FACTORY;\r\n    } else {\r\n        return newFactory(toNumberStrategy);\r\n    }\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cObject\u003e typeAdapter \u003d (TypeAdapter\u003cObject\u003e) gson.getAdapter(value.getClass());\r\n    if (typeAdapter instanceof ObjectTypeAdapter) {\r\n        out.beginObject();\r\n        out.endObject();\r\n        return;\r\n    }\r\n    typeAdapter.write(out, value);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\Strictness.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\TypeAdapterTest.java": {
    "testToJson_ThrowingIOException": "{\r\n    final IOException exception \u003d new IOException(\"test\");\r\n    TypeAdapter\u003cInteger\u003e adapter \u003d new TypeAdapter\u003cInteger\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Integer value) throws IOException {\r\n            throw exception;\r\n        }\r\n\r\n        @Override\r\n        public Integer read(JsonReader in) {\r\n            throw new AssertionError(\"not needed by this test\");\r\n        }\r\n    };\r\n    JsonIOException e \u003d assertThrows(JsonIOException.class, () -\u003e adapter.toJson(1));\r\n    assertThat(e).hasCauseThat().isEqualTo(exception);\r\n    e \u003d assertThrows(JsonIOException.class, () -\u003e adapter.toJsonTree(1));\r\n    assertThat(e).hasCauseThat().isEqualTo(exception);\r\n}",
    "testFromJson_Reader_TrailingData": "{\r\n    assertThat(adapter.fromJson(new StringReader(\"\\\"a\\\"1\"))).isEqualTo(\"a\");\r\n}",
    "read": "{\r\n    return in.nextString();\r\n}",
    "testNullSafe": "{\r\n    TypeAdapter\u003cString\u003e adapter \u003d new TypeAdapter\u003cString\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) {\r\n            throw new AssertionError(\"unexpected call\");\r\n        }\r\n\r\n        @Override\r\n        public String read(JsonReader in) {\r\n            throw new AssertionError(\"unexpected call\");\r\n        }\r\n    }.nullSafe();\r\n    assertThat(adapter.toJson(null)).isEqualTo(\"null\");\r\n    assertThat(adapter.fromJson(\"null\")).isNull();\r\n}",
    "testFromJson_String_TrailingData": "{\r\n    assertThat(adapter.fromJson(\"\\\"a\\\"1\")).isEqualTo(\"a\");\r\n}",
    "write": "{\r\n    out.value(value);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonIOException.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\sql\\SqlTypesSupport.java": {
    "deserialize": "{\r\n    return new Timestamp(date.getTime());\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601UtilsTest.java": {
    "utcTimeZone": "{\r\n    return TimeZone.getTimeZone(\"UTC\");\r\n}",
    "testDateFormatWithMilliseconds": "{\r\n    long time \u003d 1530209176870L;\r\n    Date date \u003d new Date(time);\r\n    String dateStr \u003d ISO8601Utils.format(date, true);\r\n    String expectedDate \u003d \"2018-06-28T18:06:16.870Z\";\r\n    assertThat(dateStr).isEqualTo(expectedDate);\r\n}",
    "testDateParseWithDefaultTimezone": "{\r\n    String dateStr \u003d \"2018-06-25\";\r\n    Date date \u003d ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n    Date expectedDate \u003d new GregorianCalendar(2018, Calendar.JUNE, 25).getTime();\r\n    assertThat(date).isEqualTo(expectedDate);\r\n}",
    "testDateParseSpecialTimezone": "{\r\n    String dateStr \u003d \"2018-06-25T00:02:00-02:58\";\r\n    Date date \u003d ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n    GregorianCalendar calendar \u003d createUtcCalendar();\r\n    calendar.set(2018, Calendar.JUNE, 25, 3, 0);\r\n    Date expectedDate \u003d calendar.getTime();\r\n    assertThat(date).isEqualTo(expectedDate);\r\n}",
    "testDateParseWithTimezone": "{\r\n    String dateStr \u003d \"2018-06-25T00:00:00-03:00\";\r\n    Date date \u003d ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n    GregorianCalendar calendar \u003d createUtcCalendar();\r\n    calendar.set(2018, Calendar.JUNE, 25, 3, 0);\r\n    Date expectedDate \u003d calendar.getTime();\r\n    assertThat(date).isEqualTo(expectedDate);\r\n}",
    "createUtcCalendar": "{\r\n    TimeZone utc \u003d utcTimeZone();\r\n    GregorianCalendar calendar \u003d new GregorianCalendar(utc);\r\n    // Calendar was created with current time, must clear it\r\n    calendar.clear();\r\n    return calendar;\r\n}",
    "testDateParseInvalidDay": "{\r\n    String dateStr \u003d \"2022-12-33\";\r\n    try {\r\n        ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n        fail(\"Expected parsing to fail\");\r\n    } catch (ParseException expected) {\r\n    }\r\n}",
    "testDateParseInvalidTime": "{\r\n    final String dateStr \u003d \"2018-06-25T61:60:62-03:00\";\r\n    assertThrows(ParseException.class, new ThrowingRunnable() {\r\n\r\n        @Override\r\n        public void run() throws Throwable {\r\n            ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n        }\r\n    });\r\n}",
    "run": "{\r\n    ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n}",
    "testDateFormatString": "{\r\n    GregorianCalendar calendar \u003d new GregorianCalendar(utcTimeZone(), Locale.US);\r\n    // Calendar was created with current time, must clear it\r\n    calendar.clear();\r\n    calendar.set(2018, Calendar.JUNE, 25);\r\n    Date date \u003d calendar.getTime();\r\n    String dateStr \u003d ISO8601Utils.format(date);\r\n    String expectedDate \u003d \"2018-06-25\";\r\n    assertThat(dateStr.substring(0, expectedDate.length())).isEqualTo(expectedDate);\r\n}",
    "testDateFormatWithTimezone": "{\r\n    long time \u003d 1530209176870L;\r\n    Date date \u003d new Date(time);\r\n    String dateStr \u003d ISO8601Utils.format(date, true, TimeZone.getTimeZone(\"Brazil/East\"));\r\n    String expectedDate \u003d \"2018-06-28T15:06:16.870-03:00\";\r\n    assertThat(dateStr).isEqualTo(expectedDate);\r\n}",
    "testDateParseInvalidMonth": "{\r\n    String dateStr \u003d \"2022-14-30\";\r\n    try {\r\n        ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n        fail(\"Expected parsing to fail\");\r\n    } catch (ParseException expected) {\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java": {
    "createDuplicateFieldException": "{\r\n    throw new IllegalArgumentException(\"Class \" + declaringType.getName() + \" declares multiple JSON fields named \u0027\" + duplicateName + \"\u0027; conflict is caused\" + \" by fields \" + ReflectionHelper.fieldToString(field1) + \" and \" + ReflectionHelper.fieldToString(field2) + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\r\n}",
    "primitiveDefaults": "{\r\n    Map\u003cClass\u003c?\u003e, Object\u003e zeroes \u003d new HashMap\u003c\u003e();\r\n    zeroes.put(byte.class, (byte) 0);\r\n    zeroes.put(short.class, (short) 0);\r\n    zeroes.put(int.class, 0);\r\n    zeroes.put(long.class, 0L);\r\n    zeroes.put(float.class, 0F);\r\n    zeroes.put(double.class, 0D);\r\n    zeroes.put(char.class, \u0027\\0\u0027);\r\n    zeroes.put(boolean.class, false);\r\n    return zeroes;\r\n}",
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    A accumulator \u003d createAccumulator();\r\n    Map\u003cString, BoundField\u003e deserializedFields \u003d fieldsData.deserializedFields;\r\n    try {\r\n        in.beginObject();\r\n        while (in.hasNext()) {\r\n            String name \u003d in.nextName();\r\n            BoundField field \u003d deserializedFields.get(name);\r\n            if (field \u003d\u003d null) {\r\n                in.skipValue();\r\n            } else {\r\n                readField(accumulator, in, field);\r\n            }\r\n        }\r\n    } catch (IllegalStateException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IllegalAccessException e) {\r\n        throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n    }\r\n    in.endObject();\r\n    return finalize(accumulator);\r\n}",
    "checkAccessible": "{\r\n    if (!ReflectionAccessFilterHelper.canAccess(member, Modifier.isStatic(member.getModifiers()) ? null : object)) {\r\n        String memberDescription \u003d ReflectionHelper.getAccessibleObjectDescription(member, true);\r\n        throw new JsonIOException(memberDescription + \" is not accessible and ReflectionAccessFilter does not\" + \" permit making it accessible. Register a TypeAdapter for the declaring type, adjust the\" + \" access filter or increase the visibility of the element and its declaring type.\");\r\n    }\r\n}",
    "getFieldNames": "{\r\n    SerializedName annotation \u003d f.getAnnotation(SerializedName.class);\r\n    if (annotation \u003d\u003d null) {\r\n        String name \u003d fieldNamingPolicy.translateName(f);\r\n        return Collections.singletonList(name);\r\n    }\r\n    String serializedName \u003d annotation.value();\r\n    String[] alternates \u003d annotation.alternate();\r\n    if (alternates.length \u003d\u003d 0) {\r\n        return Collections.singletonList(serializedName);\r\n    }\r\n    List\u003cString\u003e fieldNames \u003d new ArrayList\u003c\u003e(alternates.length + 1);\r\n    fieldNames.add(serializedName);\r\n    Collections.addAll(fieldNames, alternates);\r\n    return fieldNames;\r\n}",
    "readIntoField": "{\r\n    Object fieldValue \u003d typeAdapter.read(reader);\r\n    if (fieldValue !\u003d null || !isPrimitive) {\r\n        if (blockInaccessible) {\r\n            checkAccessible(target, field);\r\n        } else if (isStaticFinalField) {\r\n            // Reflection does not permit setting value of `static final` field, even after calling `setAccessible`\r\n            // Handle this here to avoid causing IllegalAccessException when calling `Field.set`\r\n            String fieldDescription \u003d ReflectionHelper.getAccessibleObjectDescription(field, false);\r\n            throw new JsonIOException(\"Cannot set value of \u0027static final\u0027 \" + fieldDescription);\r\n        }\r\n        field.set(target, fieldValue);\r\n    }\r\n}",
    "readIntoArray": "{\r\n    Object fieldValue \u003d typeAdapter.read(reader);\r\n    if (fieldValue \u003d\u003d null \u0026\u0026 isPrimitive) {\r\n        throw new JsonParseException(\"null is not allowed as value for record component \u0027\" + fieldName + \"\u0027\" + \" of primitive type; at path \" + reader.getPath());\r\n    }\r\n    target[index] \u003d fieldValue;\r\n}",
    "createAccumulator": "{\r\n    return constructorArgsDefaults.clone();\r\n}",
    "includeField": "{\r\n    return !excluder.excludeClass(f.getType(), serialize) \u0026\u0026 !excluder.excludeField(f, serialize);\r\n}",
    "createBoundField": "{\r\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\r\n    int modifiers \u003d field.getModifiers();\r\n    final boolean isStaticFinalField \u003d Modifier.isStatic(modifiers) \u0026\u0026 Modifier.isFinal(modifiers);\r\n    JsonAdapter annotation \u003d field.getAnnotation(JsonAdapter.class);\r\n    TypeAdapter\u003c?\u003e mapped \u003d null;\r\n    if (annotation !\u003d null) {\r\n        // This is not safe; requires that user has specified correct adapter class for @JsonAdapter\r\n        mapped \u003d jsonAdapterFactory.getTypeAdapter(constructorConstructor, context, fieldType, annotation, false);\r\n    }\r\n    final boolean jsonAdapterPresent \u003d mapped !\u003d null;\r\n    if (mapped \u003d\u003d null)\r\n        mapped \u003d context.getAdapter(fieldType);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final TypeAdapter\u003cObject\u003e typeAdapter \u003d (TypeAdapter\u003cObject\u003e) mapped;\r\n    final TypeAdapter\u003cObject\u003e writeTypeAdapter;\r\n    if (serialize) {\r\n        writeTypeAdapter \u003d jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper\u003c\u003e(context, typeAdapter, fieldType.getType());\r\n    } else {\r\n        // Will never actually be used, but we set it to avoid confusing nullness-analysis tools\r\n        writeTypeAdapter \u003d typeAdapter;\r\n    }\r\n    return new BoundField(serializedName, field) {\r\n\r\n        @Override\r\n        void write(JsonWriter writer, Object source) throws IOException, IllegalAccessException {\r\n            if (blockInaccessible) {\r\n                if (accessor \u003d\u003d null) {\r\n                    checkAccessible(source, field);\r\n                } else {\r\n                    // Note: This check might actually be redundant because access check for canonical\r\n                    // constructor should have failed already\r\n                    checkAccessible(source, accessor);\r\n                }\r\n            }\r\n            Object fieldValue;\r\n            if (accessor !\u003d null) {\r\n                try {\r\n                    fieldValue \u003d accessor.invoke(source);\r\n                } catch (InvocationTargetException e) {\r\n                    String accessorDescription \u003d ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                    throw new JsonIOException(\"Accessor \" + accessorDescription + \" threw exception\", e.getCause());\r\n                }\r\n            } else {\r\n                fieldValue \u003d field.get(source);\r\n            }\r\n            if (fieldValue \u003d\u003d source) {\r\n                // avoid direct recursion\r\n                return;\r\n            }\r\n            writer.name(serializedName);\r\n            writeTypeAdapter.write(writer, fieldValue);\r\n        }\r\n\r\n        @Override\r\n        void readIntoArray(JsonReader reader, int index, Object[] target) throws IOException, JsonParseException {\r\n            Object fieldValue \u003d typeAdapter.read(reader);\r\n            if (fieldValue \u003d\u003d null \u0026\u0026 isPrimitive) {\r\n                throw new JsonParseException(\"null is not allowed as value for record component \u0027\" + fieldName + \"\u0027\" + \" of primitive type; at path \" + reader.getPath());\r\n            }\r\n            target[index] \u003d fieldValue;\r\n        }\r\n\r\n        @Override\r\n        void readIntoField(JsonReader reader, Object target) throws IOException, IllegalAccessException {\r\n            Object fieldValue \u003d typeAdapter.read(reader);\r\n            if (fieldValue !\u003d null || !isPrimitive) {\r\n                if (blockInaccessible) {\r\n                    checkAccessible(target, field);\r\n                } else if (isStaticFinalField) {\r\n                    // Reflection does not permit setting value of `static final` field, even after calling `setAccessible`\r\n                    // Handle this here to avoid causing IllegalAccessException when calling `Field.set`\r\n                    String fieldDescription \u003d ReflectionHelper.getAccessibleObjectDescription(field, false);\r\n                    throw new JsonIOException(\"Cannot set value of \u0027static final\u0027 \" + fieldDescription);\r\n                }\r\n                field.set(target, fieldValue);\r\n            }\r\n        }\r\n    };\r\n}",
    "readField": "{\r\n    // Obtain the component index from the name of the field backing it\r\n    Integer componentIndex \u003d componentIndices.get(field.fieldName);\r\n    if (componentIndex \u003d\u003d null) {\r\n        throw new IllegalStateException(\"Could not find the index in the constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" for field with name \u0027\" + field.fieldName + \"\u0027,\" + \" unable to determine which argument in the constructor the field corresponds\" + \" to. This is unexpected behavior, as we expect the RecordComponents to have the\" + \" same names as the fields in the Java class, and that the order of the\" + \" RecordComponents is the same as the order of the canonical constructor parameters.\");\r\n    }\r\n    field.readIntoArray(in, componentIndex, accumulator);\r\n}",
    "create": "{\r\n    Class\u003c? super T\u003e raw \u003d type.getRawType();\r\n    if (!Object.class.isAssignableFrom(raw)) {\r\n        // it\u0027s a primitive!\r\n        return null;\r\n    }\r\n    FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n    if (filterResult \u003d\u003d FilterResult.BLOCK_ALL) {\r\n        throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \". Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n    boolean blockInaccessible \u003d filterResult \u003d\u003d FilterResult.BLOCK_INACCESSIBLE;\r\n    // If the type is actually a Java Record, we need to use the RecordAdapter instead. This will always be false\r\n    // on JVMs that do not support records.\r\n    if (ReflectionHelper.isRecord(raw)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e adapter \u003d (TypeAdapter\u003cT\u003e) new RecordAdapter\u003c\u003e(raw, getBoundFields(gson, type, raw, blockInaccessible, true), blockInaccessible);\r\n        return adapter;\r\n    }\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(type);\r\n    return new FieldReflectionAdapter\u003c\u003e(constructor, getBoundFields(gson, type, raw, blockInaccessible, false));\r\n}",
    "finalize": "{\r\n    try {\r\n        return constructor.newInstance(accumulator);\r\n    } catch (IllegalAccessException e) {\r\n        throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n    }// Note: InstantiationException should be impossible because record class is not abstract;\r\n    //  IllegalArgumentException should not be possible unless a bad adapter returns objects of the wrong type\r\n     catch (InstantiationException | IllegalArgumentException e) {\r\n        throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with args \" + Arrays.toString(accumulator), e);\r\n    } catch (InvocationTargetException e) {\r\n        // TODO: JsonParseException ?\r\n        throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with args \" + Arrays.toString(accumulator), e.getCause());\r\n    }\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginObject();\r\n    try {\r\n        for (BoundField boundField : fieldsData.serializedFields) {\r\n            boundField.write(out, value);\r\n        }\r\n    } catch (IllegalAccessException e) {\r\n        throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n    }\r\n    out.endObject();\r\n}",
    "getBoundFields": "{\r\n    if (raw.isInterface()) {\r\n        return FieldsData.EMPTY;\r\n    }\r\n    Map\u003cString, BoundField\u003e deserializedFields \u003d new LinkedHashMap\u003c\u003e();\r\n    // For serialized fields use a Map to track duplicate field names; otherwise this could be a List\u003cBoundField\u003e instead\r\n    Map\u003cString, BoundField\u003e serializedFields \u003d new LinkedHashMap\u003c\u003e();\r\n    Class\u003c?\u003e originalRaw \u003d raw;\r\n    while (raw !\u003d Object.class) {\r\n        Field[] fields \u003d raw.getDeclaredFields();\r\n        // For inherited fields, check if access to their declaring class is allowed\r\n        if (raw !\u003d originalRaw \u0026\u0026 fields.length \u003e 0) {\r\n            FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n            if (filterResult \u003d\u003d FilterResult.BLOCK_ALL) {\r\n                throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\" + \" or adjust the access filter.\");\r\n            }\r\n            blockInaccessible \u003d filterResult \u003d\u003d FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n        for (Field field : fields) {\r\n            boolean serialize \u003d includeField(field, true);\r\n            boolean deserialize \u003d includeField(field, false);\r\n            if (!serialize \u0026\u0026 !deserialize) {\r\n                continue;\r\n            }\r\n            // The accessor method is only used for records. If the type is a record, we will read out values\r\n            // via its accessor method instead of via reflection. This way we will bypass the accessible restrictions\r\n            Method accessor \u003d null;\r\n            if (isRecord) {\r\n                // If there is a static field on a record, there will not be an accessor. Instead we will use the default\r\n                // field serialization logic, but for deserialization the field is excluded for simplicity. Note that Gson\r\n                // ignores static fields by default, but GsonBuilder.excludeFieldsWithModifiers can overwrite this.\r\n                if (Modifier.isStatic(field.getModifiers())) {\r\n                    deserialize \u003d false;\r\n                } else {\r\n                    accessor \u003d ReflectionHelper.getAccessor(raw, field);\r\n                    // If blockInaccessible, skip and perform access check later\r\n                    if (!blockInaccessible) {\r\n                        ReflectionHelper.makeAccessible(accessor);\r\n                    }\r\n                    // @SerializedName can be placed on accessor method, but it is not supported there\r\n                    // If field and method have annotation it is not easily possible to determine if accessor method\r\n                    // is implicit and has inherited annotation, or if it is explicitly declared with custom annotation\r\n                    if (accessor.getAnnotation(SerializedName.class) !\u003d null \u0026\u0026 field.getAnnotation(SerializedName.class) \u003d\u003d null) {\r\n                        String methodDescription \u003d ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                        throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\r\n                    }\r\n                }\r\n            }\r\n            // If blockInaccessible, skip and perform access check later\r\n            // For Records if the accessor method is used the field does not have to be made accessible\r\n            if (!blockInaccessible \u0026\u0026 accessor \u003d\u003d null) {\r\n                ReflectionHelper.makeAccessible(field);\r\n            }\r\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\r\n            List\u003cString\u003e fieldNames \u003d getFieldNames(field);\r\n            String serializedName \u003d fieldNames.get(0);\r\n            BoundField boundField \u003d createBoundField(context, field, accessor, serializedName, TypeToken.get(fieldType), serialize, blockInaccessible);\r\n            if (deserialize) {\r\n                for (String name : fieldNames) {\r\n                    BoundField replaced \u003d deserializedFields.put(name, boundField);\r\n                    if (replaced !\u003d null) {\r\n                        throw createDuplicateFieldException(originalRaw, name, replaced.field, field);\r\n                    }\r\n                }\r\n            }\r\n            if (serialize) {\r\n                BoundField replaced \u003d serializedFields.put(serializedName, boundField);\r\n                if (replaced !\u003d null) {\r\n                    throw createDuplicateFieldException(originalRaw, serializedName, replaced.field, field);\r\n                }\r\n            }\r\n        }\r\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\r\n        raw \u003d type.getRawType();\r\n    }\r\n    return new FieldsData(deserializedFields, new ArrayList\u003c\u003e(serializedFields.values()));\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\ReflectionAccessFilterHelper.java": {
    "canAccess": "{\r\n    // Cannot determine whether object can be accessed, so assume it can be accessed\r\n    return true;\r\n}",
    "isAndroidType": "{\r\n    return className.startsWith(\"android.\") || className.startsWith(\"androidx.\") || isJavaType(className);\r\n}",
    "isAnyPlatformType": "{\r\n    String className \u003d c.getName();\r\n    return // Covers Android and Java\r\n    isAndroidType(className) || className.startsWith(\"kotlin.\") || className.startsWith(\"kotlinx.\") || className.startsWith(\"scala.\");\r\n}",
    "isJavaType": "{\r\n    return className.startsWith(\"java.\") || className.startsWith(\"javax.\");\r\n}",
    "getFilterResult": "{\r\n    for (ReflectionAccessFilter filter : reflectionFilters) {\r\n        FilterResult result \u003d filter.check(c);\r\n        if (result !\u003d FilterResult.INDECISIVE) {\r\n            return result;\r\n        }\r\n    }\r\n    return FilterResult.ALLOW;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnFieldsTest.java": {
    "testFieldAnnotationWorksForParameterizedType": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Gizmo2(Arrays.asList(new Part(\"Part\"))));\r\n    assertThat(json).isEqualTo(\"{\\\"part\\\":\\\"GizmoPartTypeAdapterFactory\\\"}\");\r\n    Gizmo2 computer \u003d gson.fromJson(\"{\u0027part\u0027:\u0027Part\u0027}\", Gizmo2.class);\r\n    assertThat(computer.part.get(0).name).isEqualTo(\"GizmoPartTypeAdapterFactory\");\r\n}",
    "testOverwriteBuiltIn": "{\r\n    BuiltInOverwriting obj \u003d new BuiltInOverwriting();\r\n    obj.f \u003d new JsonPrimitive(true);\r\n    String json \u003d new Gson().toJson(obj);\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":\\\"\" + JsonElementAdapter.SERIALIZED + \"\\\"}\");\r\n    BuiltInOverwriting deserialized \u003d new Gson().fromJson(\"{\\\"f\\\": 2}\", BuiltInOverwriting.class);\r\n    assertThat(deserialized.f).isEqualTo(JsonElementAdapter.DESERIALIZED);\r\n}",
    "testExcludeSerializePrecedence": "{\r\n    Gson gson \u003d new GsonBuilder().addSerializationExclusionStrategy(new ExclusionStrategy() {\r\n\r\n        @Override\r\n        public boolean shouldSkipField(FieldAttributes f) {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n            return false;\r\n        }\r\n    }).create();\r\n    DelegatingAndOverwriting obj \u003d new DelegatingAndOverwriting();\r\n    obj.f \u003d 1;\r\n    obj.f2 \u003d new JsonPrimitive(2);\r\n    obj.f3 \u003d new JsonPrimitive(true);\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n    DelegatingAndOverwriting deserialized \u003d gson.fromJson(\"{\\\"f\\\":1,\\\"f2\\\":2,\\\"f3\\\":3}\", DelegatingAndOverwriting.class);\r\n    assertThat(deserialized.f).isEqualTo(Integer.valueOf(1));\r\n    assertThat(deserialized.f2).isEqualTo(new JsonPrimitive(2));\r\n    // Verify that for deserialization type adapter specified by @JsonAdapter is used\r\n    assertThat(deserialized.f3).isEqualTo(JsonElementAdapter.DESERIALIZED);\r\n}",
    "testGetAdapterDelegation": "{\r\n    Gson gson \u003d new Gson();\r\n    GetAdapterDelegation deserialized \u003d gson.fromJson(\"{\\\"f\\\":\\\"de\\\"}\", GetAdapterDelegation.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de-custom\");\r\n    String json \u003d gson.toJson(new GetAdapterDelegation(\"se\"));\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":\\\"se-custom\\\"}\");\r\n}",
    "testJsonDeserializer": "{\r\n    Gson gson \u003d new Gson();\r\n    WithJsonDeserializer deserialized \u003d gson.fromJson(\"{\\\"f\\\":[5]}\", WithJsonDeserializer.class);\r\n    // Uses custom deserializer which always returns `[3, 2, 1]`\r\n    assertThat(deserialized.f).isEqualTo(Arrays.asList(3, 2, 1));\r\n    // Verify that delegate serializer for List is used\r\n    String json \u003d gson.toJson(new WithJsonDeserializer(Arrays.asList(4, 5, 6)));\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":[4,5,6]}\");\r\n}",
    "testJsonAdapterInvokedOnlyForAnnotatedFields": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d \"{\u0027part1\u0027:\u0027name\u0027,\u0027part2\u0027:{\u0027name\u0027:\u0027name2\u0027}}\";\r\n    GadgetWithTwoParts gadget \u003d gson.fromJson(json, GadgetWithTwoParts.class);\r\n    assertThat(gadget.part1.name).isEqualTo(\"PartJsonFieldAnnotationAdapter\");\r\n    assertThat(gadget.part2.name).isEqualTo(\"name2\");\r\n}",
    "testJsonSerializer": "{\r\n    Gson gson \u003d new Gson();\r\n    // Verify that delegate deserializer for List is used\r\n    WithJsonSerializer deserialized \u003d gson.fromJson(\"{\\\"f\\\":[1,2,3]}\", WithJsonSerializer.class);\r\n    assertThat(deserialized.f).isEqualTo(Arrays.asList(1, 2, 3));\r\n    String json \u003d gson.toJson(new WithJsonSerializer());\r\n    // Uses custom serializer which always returns `true`\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":true}\");\r\n}",
    "delegate": "{\r\n    return (TypeAdapter\u003cString\u003e) gson.getDelegateAdapter(Factory.this, type);\r\n}",
    "testClassAnnotationAdapterFactoryTakesPrecedenceOverDefault": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Gizmo(new Part(\"Part\")));\r\n    assertThat(json).isEqualTo(\"{\\\"part\\\":\\\"GizmoPartTypeAdapterFactory\\\"}\");\r\n    Gizmo computer \u003d gson.fromJson(\"{\u0027part\u0027:\u0027Part\u0027}\", Gizmo.class);\r\n    assertThat(computer.part.name).isEqualTo(\"GizmoPartTypeAdapterFactory\");\r\n}",
    "shouldSkipClass": "{\r\n    return false;\r\n}",
    "testJsonAdapterWrappedInNullSafeAsRequested": "{\r\n    Gson gson \u003d new Gson();\r\n    String fromJson \u003d \"{\u0027part\u0027:null}\";\r\n    GadgetWithOptionalPart gadget \u003d gson.fromJson(fromJson, GadgetWithOptionalPart.class);\r\n    assertThat(gadget.part).isNull();\r\n    String toJson \u003d gson.toJson(gadget);\r\n    assertThat(toJson).doesNotContain(\"PartJsonFieldAnnotationAdapter\");\r\n}",
    "testRegisteredTypeAdapterTakesPrecedenceOverClassAnnotationAdapter": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(User.class, new RegisteredUserAdapter()).create();\r\n    String json \u003d gson.toJson(new Computer(new User(\"Inderjeet Singh\")));\r\n    assertThat(json).isEqualTo(\"{\\\"user\\\":\\\"RegisteredUserAdapter\\\"}\");\r\n    Computer computer \u003d gson.fromJson(\"{\u0027user\u0027:\u0027Inderjeet Singh\u0027}\", Computer.class);\r\n    assertThat(computer.user.name).isEqualTo(\"RegisteredUserAdapter\");\r\n}",
    "create": "{\r\n    // Uses `Gson.getAdapter` instead of `Gson.getDelegateAdapter`\r\n    TypeAdapter\u003cString\u003e delegate \u003d (TypeAdapter\u003cString\u003e) gson.getAdapter(type);\r\n    return (TypeAdapter\u003cT\u003e) new TypeAdapter\u003cString\u003e() {\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            return delegate.read(in) + \"-custom\";\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            delegate.write(out, value + \"-custom\");\r\n        }\r\n    };\r\n}",
    "testClassAnnotationAdapterTakesPrecedenceOverDefault": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Computer(new User(\"Inderjeet Singh\")));\r\n    assertThat(json).isEqualTo(\"{\\\"user\\\":\\\"UserClassAnnotationAdapter\\\"}\");\r\n    Computer computer \u003d gson.fromJson(\"{\u0027user\u0027:\u0027Inderjeet Singh\u0027}\", Computer.class);\r\n    assertThat(computer.user.name).isEqualTo(\"UserClassAnnotationAdapter\");\r\n}",
    "write": "{\r\n    delegate.write(out, value + \"-custom\");\r\n}",
    "deserialize": "{\r\n    return Arrays.asList(3, 2, 1);\r\n}",
    "testNonPrimitiveFieldAnnotationTakesPrecedenceOverDefault": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new GadgetWithOptionalPart(new Part(\"foo\")));\r\n    assertThat(json).isEqualTo(\"{\\\"part\\\":\\\"PartJsonFieldAnnotationAdapter\\\"}\");\r\n    GadgetWithOptionalPart gadget \u003d gson.fromJson(\"{\u0027part\u0027:\u0027foo\u0027}\", GadgetWithOptionalPart.class);\r\n    assertThat(gadget.part.name).isEqualTo(\"PartJsonFieldAnnotationAdapter\");\r\n}",
    "read": "{\r\n    return delegate.read(in) + \"-custom\";\r\n}",
    "testDelegatingAdapterFactory": "{\r\n    @SuppressWarnings(\"unchecked\")\r\n    WithDelegatingFactory\u003cString\u003e deserialized \u003d new Gson().fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"test-custom\");\r\n    deserialized \u003d new Gson().fromJson(\"{\\\"f\\\":\\\"test\\\"}\", new TypeToken\u003cWithDelegatingFactory\u003cString\u003e\u003e() {\r\n    });\r\n    assertThat(deserialized.f).isEqualTo(\"test-custom\");\r\n    WithDelegatingFactory\u003cString\u003e serialized \u003d new WithDelegatingFactory\u003c\u003e();\r\n    serialized.f \u003d \"value\";\r\n    assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"f\\\":\\\"value-custom\\\"}\");\r\n}",
    "testFieldAnnotationTakesPrecedenceOverRegisteredTypeAdapter": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Part.class, new TypeAdapter\u003cPart\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Part part) {\r\n            throw new AssertionError();\r\n        }\r\n\r\n        @Override\r\n        public Part read(JsonReader in) {\r\n            throw new AssertionError();\r\n        }\r\n    }).create();\r\n    String json \u003d gson.toJson(new Gadget(new Part(\"screen\")));\r\n    assertThat(json).isEqualTo(\"{\\\"part\\\":\\\"PartJsonFieldAnnotationAdapter\\\"}\");\r\n    Gadget gadget \u003d gson.fromJson(\"{\u0027part\u0027:\u0027screen\u0027}\", Gadget.class);\r\n    assertThat(gadget.part.name).isEqualTo(\"PartJsonFieldAnnotationAdapter\");\r\n}",
    "testExcludeDeserializePrecedence": "{\r\n    Gson gson \u003d new GsonBuilder().addDeserializationExclusionStrategy(new ExclusionStrategy() {\r\n\r\n        @Override\r\n        public boolean shouldSkipField(FieldAttributes f) {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n            return false;\r\n        }\r\n    }).create();\r\n    DelegatingAndOverwriting obj \u003d new DelegatingAndOverwriting();\r\n    obj.f \u003d 1;\r\n    obj.f2 \u003d new JsonPrimitive(2);\r\n    obj.f3 \u003d new JsonPrimitive(true);\r\n    String json \u003d gson.toJson(obj);\r\n    // Verify that for serialization type adapters specified by @JsonAdapter are used\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":1,\\\"f2\\\":2,\\\"f3\\\":\\\"\" + JsonElementAdapter.SERIALIZED + \"\\\"}\");\r\n    DelegatingAndOverwriting deserialized \u003d gson.fromJson(\"{\\\"f\\\":1,\\\"f2\\\":2,\\\"f3\\\":3}\", DelegatingAndOverwriting.class);\r\n    assertThat(deserialized.f).isNull();\r\n    assertThat(deserialized.f2).isNull();\r\n    assertThat(deserialized.f3).isNull();\r\n}",
    "testExcludePrecedence": "{\r\n    Gson gson \u003d new GsonBuilder().setExclusionStrategies(new ExclusionStrategy() {\r\n\r\n        @Override\r\n        public boolean shouldSkipField(FieldAttributes f) {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n            return false;\r\n        }\r\n    }).create();\r\n    DelegatingAndOverwriting obj \u003d new DelegatingAndOverwriting();\r\n    obj.f \u003d 1;\r\n    obj.f2 \u003d new JsonPrimitive(2);\r\n    obj.f3 \u003d new JsonPrimitive(true);\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n    DelegatingAndOverwriting deserialized \u003d gson.fromJson(\"{\\\"f\\\":1,\\\"f2\\\":2,\\\"f3\\\":3}\", DelegatingAndOverwriting.class);\r\n    assertThat(deserialized.f).isNull();\r\n    assertThat(deserialized.f2).isNull();\r\n    assertThat(deserialized.f3).isNull();\r\n}",
    "testFieldAnnotationTakesPrecedenceOverClassAnnotation": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Computer2(new User(\"Inderjeet Singh\")));\r\n    assertThat(json).isEqualTo(\"{\\\"user\\\":\\\"UserFieldAnnotationAdapter\\\"}\");\r\n    Computer2 target \u003d gson.fromJson(\"{\u0027user\u0027:\u0027Interjeet Singh\u0027}\", Computer2.class);\r\n    assertThat(target.user.name).isEqualTo(\"UserFieldAnnotationAdapter\");\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(true);\r\n}",
    "shouldSkipField": "{\r\n    return true;\r\n}",
    "testPrimitiveFieldAnnotationTakesPrecedenceOverDefault": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new GadgetWithPrimitivePart(42));\r\n    assertThat(json).isEqualTo(\"{\\\"part\\\":\\\"42\\\"}\");\r\n    GadgetWithPrimitivePart gadget \u003d gson.fromJson(json, GadgetWithPrimitivePart.class);\r\n    assertThat(gadget.part).isEqualTo(42);\r\n}",
    "testDelegatingAdapterFactory_Delayed": "{\r\n    WithDelayedDelegatingFactory deserialized \u003d new Gson().fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithDelayedDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"test-custom\");\r\n    WithDelayedDelegatingFactory serialized \u003d new WithDelayedDelegatingFactory();\r\n    serialized.f \u003d \"value\";\r\n    assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"f\\\":\\\"value-custom\\\"}\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ToNumberPolicyFunctionalTest.java": {
    "testAsLongsOrDoubles": "{\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(ToNumberPolicy.LONG_OR_DOUBLE).setNumberToNumberStrategy(ToNumberPolicy.LONG_OR_DOUBLE).create();\r\n    assertThat(gson.fromJson(\"null\", Object.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Object.class)).isEqualTo(10L);\r\n    assertThat(gson.fromJson(\"10.0\", Object.class)).isEqualTo(10.0);\r\n    assertThat(gson.fromJson(\"null\", Number.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Number.class)).isEqualTo(10L);\r\n    assertThat(gson.fromJson(\"10.0\", Number.class)).isEqualTo(10.0);\r\n}",
    "testAsListOfLongsOrDoubles": "{\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(ToNumberPolicy.LONG_OR_DOUBLE).setNumberToNumberStrategy(ToNumberPolicy.LONG_OR_DOUBLE).create();\r\n    Type objectCollectionType \u003d new TypeToken\u003cCollection\u003cObject\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cObject\u003e objects \u003d gson.fromJson(\"[null,10,10.0]\", objectCollectionType);\r\n    assertThat(objects).containsExactly(null, 10L, 10.0).inOrder();\r\n    Type numberCollectionType \u003d new TypeToken\u003cCollection\u003cNumber\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cObject\u003e numbers \u003d gson.fromJson(\"[null,10,10.0]\", numberCollectionType);\r\n    assertThat(numbers).containsExactly(null, 10L, 10.0).inOrder();\r\n}",
    "testCustomStrategiesCannotAffectConcreteDeclaredNumbers": "{\r\n    ToNumberStrategy fail \u003d new ToNumberStrategy() {\r\n\r\n        @Override\r\n        public Byte readNumber(JsonReader in) {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(fail).setNumberToNumberStrategy(fail).create();\r\n    List\u003cObject\u003e numbers \u003d gson.fromJson(\"[null, 10, 20, 30]\", new TypeToken\u003cList\u003cByte\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(numbers).containsExactly(null, (byte) 10, (byte) 20, (byte) 30).inOrder();\r\n    try {\r\n        gson.fromJson(\"[null, 10, 20, 30]\", new TypeToken\u003cList\u003cObject\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (UnsupportedOperationException ex) {\r\n    }\r\n    try {\r\n        gson.fromJson(\"[null, 10, 20, 30]\", new TypeToken\u003cList\u003cNumber\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (UnsupportedOperationException ex) {\r\n    }\r\n}",
    "testDefault": "{\r\n    Gson gson \u003d new Gson();\r\n    assertThat(gson.fromJson(\"null\", Object.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Object.class)).isEqualTo(10D);\r\n    assertThat(gson.fromJson(\"null\", Number.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Number.class)).isEqualTo(new LazilyParsedNumber(\"10\"));\r\n}",
    "testAsBigDecimals": "{\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(ToNumberPolicy.BIG_DECIMAL).setNumberToNumberStrategy(ToNumberPolicy.BIG_DECIMAL).create();\r\n    assertThat(gson.fromJson(\"null\", Object.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Object.class)).isEqualTo(new BigDecimal(\"10\"));\r\n    assertThat(gson.fromJson(\"10.0\", Object.class)).isEqualTo(new BigDecimal(\"10.0\"));\r\n    assertThat(gson.fromJson(\"null\", Number.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Number.class)).isEqualTo(new BigDecimal(\"10\"));\r\n    assertThat(gson.fromJson(\"10.0\", Number.class)).isEqualTo(new BigDecimal(\"10.0\"));\r\n    assertThat(gson.fromJson(\"3.141592653589793238462643383279\", BigDecimal.class)).isEqualTo(new BigDecimal(\"3.141592653589793238462643383279\"));\r\n    assertThat(gson.fromJson(\"1e400\", BigDecimal.class)).isEqualTo(new BigDecimal(\"1e400\"));\r\n}",
    "readNumber": "{\r\n    throw new UnsupportedOperationException();\r\n}",
    "testAsDoubles": "{\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(ToNumberPolicy.DOUBLE).setNumberToNumberStrategy(ToNumberPolicy.DOUBLE).create();\r\n    assertThat(gson.fromJson(\"null\", Object.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Object.class)).isEqualTo(10.0);\r\n    assertThat(gson.fromJson(\"null\", Number.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Number.class)).isEqualTo(10.0);\r\n}",
    "testAsLazilyParsedNumbers": "{\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(ToNumberPolicy.LAZILY_PARSED_NUMBER).setNumberToNumberStrategy(ToNumberPolicy.LAZILY_PARSED_NUMBER).create();\r\n    assertThat(gson.fromJson(\"null\", Object.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Object.class)).isEqualTo(new LazilyParsedNumber(\"10\"));\r\n    assertThat(gson.fromJson(\"null\", Number.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Number.class)).isEqualTo(new LazilyParsedNumber(\"10\"));\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\UtcDateTypeAdapter.java": {
    "parseInt": "{\r\n    if (beginIndex \u003c 0 || endIndex \u003e value.length() || beginIndex \u003e endIndex) {\r\n        throw new NumberFormatException(value);\r\n    }\r\n    // use same logic as in Integer.parseInt() but less generic we\u0027re not supporting negative values\r\n    int i \u003d beginIndex;\r\n    int result \u003d 0;\r\n    int digit;\r\n    if (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value);\r\n        }\r\n        result \u003d -digit;\r\n    }\r\n    while (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value);\r\n        }\r\n        result *\u003d 10;\r\n        result -\u003d digit;\r\n    }\r\n    return -result;\r\n}",
    "read": "{\r\n    try {\r\n        switch(in.peek()) {\r\n            case NULL:\r\n                in.nextNull();\r\n                return null;\r\n            default:\r\n                String date \u003d in.nextString();\r\n                // Instead of using iso8601Format.parse(value), we use Jackson\u0027s date parsing\r\n                // This is because Android doesn\u0027t support XXX because it is JDK 1.6\r\n                return parse(date, new ParsePosition(0));\r\n        }\r\n    } catch (ParseException e) {\r\n        throw new JsonParseException(e);\r\n    }\r\n}",
    "format": "{\r\n    Calendar calendar \u003d new GregorianCalendar(tz, Locale.US);\r\n    calendar.setTime(date);\r\n    // estimate capacity of buffer as close as we can (yeah, that\u0027s pedantic ;)\r\n    int capacity \u003d \"yyyy-MM-ddThh:mm:ss\".length();\r\n    capacity +\u003d millis ? \".sss\".length() : 0;\r\n    capacity +\u003d tz.getRawOffset() \u003d\u003d 0 ? \"Z\".length() : \"+hh:mm\".length();\r\n    StringBuilder formatted \u003d new StringBuilder(capacity);\r\n    padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\r\n    formatted.append(\u0027T\u0027);\r\n    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\r\n    if (millis) {\r\n        formatted.append(\u0027.\u0027);\r\n        padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\r\n    }\r\n    int offset \u003d tz.getOffset(calendar.getTimeInMillis());\r\n    if (offset !\u003d 0) {\r\n        int hours \u003d Math.abs((offset / (60 * 1000)) / 60);\r\n        int minutes \u003d Math.abs((offset / (60 * 1000)) % 60);\r\n        formatted.append(offset \u003c 0 ? \u0027-\u0027 : \u0027+\u0027);\r\n        padInt(formatted, hours, \"hh\".length());\r\n        formatted.append(\u0027:\u0027);\r\n        padInt(formatted, minutes, \"mm\".length());\r\n    } else {\r\n        formatted.append(\u0027Z\u0027);\r\n    }\r\n    return formatted.toString();\r\n}",
    "padInt": "{\r\n    String strValue \u003d Integer.toString(value);\r\n    for (int i \u003d length - strValue.length(); i \u003e 0; i--) {\r\n        buffer.append(\u00270\u0027);\r\n    }\r\n    buffer.append(strValue);\r\n}",
    "checkOffset": "{\r\n    return (offset \u003c value.length()) \u0026\u0026 (value.charAt(offset) \u003d\u003d expected);\r\n}",
    "parse": "{\r\n    Exception fail \u003d null;\r\n    try {\r\n        int offset \u003d pos.getIndex();\r\n        // extract year\r\n        int year \u003d parseInt(date, offset, offset +\u003d 4);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract month\r\n        int month \u003d parseInt(date, offset, offset +\u003d 2);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract day\r\n        int day \u003d parseInt(date, offset, offset +\u003d 2);\r\n        // default time value\r\n        int hour \u003d 0;\r\n        int minutes \u003d 0;\r\n        int seconds \u003d 0;\r\n        // always use 0 otherwise returned date will include millis of current time\r\n        int milliseconds \u003d 0;\r\n        if (checkOffset(date, offset, \u0027T\u0027)) {\r\n            // extract hours, minutes, seconds and milliseconds\r\n            hour \u003d parseInt(date, offset +\u003d 1, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            minutes \u003d parseInt(date, offset, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            // second and milliseconds can be optional\r\n            if (date.length() \u003e offset) {\r\n                char c \u003d date.charAt(offset);\r\n                if (c !\u003d \u0027Z\u0027 \u0026\u0026 c !\u003d \u0027+\u0027 \u0026\u0026 c !\u003d \u0027-\u0027) {\r\n                    seconds \u003d parseInt(date, offset, offset +\u003d 2);\r\n                    // milliseconds can be optional in the format\r\n                    if (checkOffset(date, offset, \u0027.\u0027)) {\r\n                        milliseconds \u003d parseInt(date, offset +\u003d 1, offset +\u003d 3);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // extract timezone\r\n        String timezoneId;\r\n        if (date.length() \u003c\u003d offset) {\r\n            throw new IllegalArgumentException(\"No time zone indicator\");\r\n        }\r\n        char timezoneIndicator \u003d date.charAt(offset);\r\n        if (timezoneIndicator \u003d\u003d \u0027+\u0027 || timezoneIndicator \u003d\u003d \u0027-\u0027) {\r\n            String timezoneOffset \u003d date.substring(offset);\r\n            timezoneId \u003d GMT_ID + timezoneOffset;\r\n            offset +\u003d timezoneOffset.length();\r\n        } else if (timezoneIndicator \u003d\u003d \u0027Z\u0027) {\r\n            timezoneId \u003d GMT_ID;\r\n            offset +\u003d 1;\r\n        } else {\r\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \" + timezoneIndicator);\r\n        }\r\n        TimeZone timezone \u003d TimeZone.getTimeZone(timezoneId);\r\n        if (!timezone.getID().equals(timezoneId)) {\r\n            throw new IndexOutOfBoundsException();\r\n        }\r\n        Calendar calendar \u003d new GregorianCalendar(timezone);\r\n        calendar.setLenient(false);\r\n        calendar.set(Calendar.YEAR, year);\r\n        calendar.set(Calendar.MONTH, month - 1);\r\n        calendar.set(Calendar.DAY_OF_MONTH, day);\r\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\r\n        calendar.set(Calendar.MINUTE, minutes);\r\n        calendar.set(Calendar.SECOND, seconds);\r\n        calendar.set(Calendar.MILLISECOND, milliseconds);\r\n        pos.setIndex(offset);\r\n        return calendar.getTime();\r\n        // If we get a ParseException it\u0027ll already have the right message/offset.\r\n        // Other exception types can convert here.\r\n    } catch (IndexOutOfBoundsException e) {\r\n        fail \u003d e;\r\n    } catch (NumberFormatException e) {\r\n        fail \u003d e;\r\n    } catch (IllegalArgumentException e) {\r\n        fail \u003d e;\r\n    }\r\n    String input \u003d (date \u003d\u003d null) ? null : (\"\u0027\" + date + \"\u0027\");\r\n    throw new ParseException(\"Failed to parse date [\" + input + \"]: \" + fail.getMessage(), pos.getIndex());\r\n}",
    "write": "{\r\n    if (date \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        String value \u003d format(date, true, UTC_TIME_ZONE);\r\n        out.value(value);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\ToNumberPolicy.java": {
    "readNumber": "{\r\n    String value \u003d in.nextString();\r\n    try {\r\n        return new BigDecimal(value);\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonParseException(\"Cannot parse \" + value + \"; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}"
  },
  "google_json\\graal-native-image-test\\src\\test\\java\\com\\google\\gson\\native_test\\ReflectionTest.java": {
    "createInstance": "{\r\n    return new ClassWithoutDefaultConstructor(-2);\r\n}",
    "read": "{\r\n    return new ClassWithRegisteredAdapter(in.nextInt() + 5);\r\n}",
    "testInstanceCreator": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ClassWithoutDefaultConstructor.class, new InstanceCreator\u003cClassWithoutDefaultConstructor\u003e() {\r\n\r\n        @Override\r\n        public ClassWithoutDefaultConstructor createInstance(Type type) {\r\n            return new ClassWithoutDefaultConstructor(-2);\r\n        }\r\n    }).create();\r\n    ClassWithoutDefaultConstructor c \u003d gson.fromJson(\"{\\\"i\\\":1}\", ClassWithoutDefaultConstructor.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n    c \u003d gson.fromJson(\"{}\", ClassWithoutDefaultConstructor.class);\r\n    // Uses default value specified by InstanceCreator\r\n    assertThat(c.i).isEqualTo(-2);\r\n}",
    "testCustomAdapter": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ClassWithRegisteredAdapter.class, new TypeAdapter\u003cClassWithRegisteredAdapter\u003e() {\r\n\r\n        @Override\r\n        public ClassWithRegisteredAdapter read(JsonReader in) throws IOException {\r\n            return new ClassWithRegisteredAdapter(in.nextInt() + 5);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, ClassWithRegisteredAdapter value) throws IOException {\r\n            out.value(value.i + 6);\r\n        }\r\n    }).create();\r\n    ClassWithRegisteredAdapter c \u003d gson.fromJson(\"1\", ClassWithRegisteredAdapter.class);\r\n    assertThat(c.i).isEqualTo(6);\r\n    assertThat(gson.toJson(new ClassWithRegisteredAdapter(1))).isEqualTo(\"7\");\r\n}",
    "testFinalField": "{\r\n    Gson gson \u003d new Gson();\r\n    ClassWithFinalField c \u003d gson.fromJson(\"{\\\"i\\\":2}\", ClassWithFinalField.class);\r\n    assertThat(c.i).isEqualTo(2);\r\n    c \u003d gson.fromJson(\"{}\", ClassWithFinalField.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n}",
    "testClassWithoutDefaultConstructor": "{\r\n    Gson gson \u003d new Gson();\r\n    ClassWithoutDefaultConstructor c \u003d gson.fromJson(\"{\\\"i\\\":1}\", ClassWithoutDefaultConstructor.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n    c \u003d gson.fromJson(\"{}\", ClassWithoutDefaultConstructor.class);\r\n    // Class is instantiated with JDK Unsafe, so field keeps its default value instead of assigned -1\r\n    assertThat(c.i).isEqualTo(0);\r\n}",
    "testCustomClassAdapter": "{\r\n    Gson gson \u003d new Gson();\r\n    ClassWithCustomClassAdapter c \u003d gson.fromJson(\"1\", ClassWithCustomClassAdapter.class);\r\n    assertThat(c.i).isEqualTo(6);\r\n    assertThat(gson.toJson(new ClassWithCustomClassAdapter(1))).isEqualTo(\"7\");\r\n}",
    "testGenerics": "{\r\n    Gson gson \u003d new Gson();\r\n    List\u003cClassWithDefaultConstructor\u003e list \u003d gson.fromJson(\"[{\\\"i\\\":1}]\", new TypeToken\u003cList\u003cClassWithDefaultConstructor\u003e\u003e() {\r\n    });\r\n    assertThat(list).hasSize(1);\r\n    assertThat(list.get(0).i).isEqualTo(1);\r\n    @SuppressWarnings(\"unchecked\")\r\n    List\u003cClassWithDefaultConstructor\u003e list2 \u003d (List\u003cClassWithDefaultConstructor\u003e) gson.fromJson(\"[{\\\"i\\\":1}]\", TypeToken.getParameterized(List.class, ClassWithDefaultConstructor.class));\r\n    assertThat(list2).hasSize(1);\r\n    assertThat(list2.get(0).i).isEqualTo(1);\r\n}",
    "testCustomDefaultConstructor": "{\r\n    Gson gson \u003d new Gson();\r\n    ClassWithCustomDefaultConstructor c \u003d gson.fromJson(\"{\\\"i\\\":2}\", ClassWithCustomDefaultConstructor.class);\r\n    assertThat(c.i).isEqualTo(2);\r\n    c \u003d gson.fromJson(\"{}\", ClassWithCustomDefaultConstructor.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n}",
    "testDefaultConstructor": "{\r\n    Gson gson \u003d new Gson();\r\n    ClassWithDefaultConstructor c \u003d gson.fromJson(\"{\\\"i\\\":1}\", ClassWithDefaultConstructor.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n}",
    "nonConstant": "{\r\n    // \u003d 1\r\n    return \"a\".length();\r\n}",
    "testSerializedName": "{\r\n    Gson gson \u003d new Gson();\r\n    ClassWithSerializedName c \u003d gson.fromJson(\"{\\\"custom-name\\\":1}\", ClassWithSerializedName.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n    c \u003d new ClassWithSerializedName();\r\n    c.i \u003d 2;\r\n    assertThat(gson.toJson(c)).isEqualTo(\"{\\\"custom-name\\\":2}\");\r\n}",
    "testCustomFieldAdapter": "{\r\n    Gson gson \u003d new Gson();\r\n    ClassWithCustomFieldAdapter c \u003d gson.fromJson(\"{\\\"i\\\":1}\", ClassWithCustomFieldAdapter.class);\r\n    assertThat(c.i).isEqualTo(6);\r\n    assertThat(gson.toJson(new ClassWithCustomFieldAdapter(1))).isEqualTo(\"{\\\"i\\\":7}\");\r\n}",
    "write": "{\r\n    out.value(value.i + 6);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java": {
    "tryBeginNesting": "{\r\n    switch(peeked) {\r\n        case BEGIN_ARRAY:\r\n            in.beginArray();\r\n            return new JsonArray();\r\n        case BEGIN_OBJECT:\r\n            in.beginObject();\r\n            return new JsonObject();\r\n        default:\r\n            return null;\r\n    }\r\n}",
    "read": "{\r\n    T1 result \u003d typeAdapter.read(in);\r\n    if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\r\n        throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n    }\r\n    return result;\r\n}",
    "newFactory": "{\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the \u0027T\u0027s equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n            Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n            return (rawType \u003d\u003d unboxed || rawType \u003d\u003d boxed) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[type\u003d\" + boxed.getName() + \"+\" + unboxed.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "readTerminal": "{\r\n    switch(peeked) {\r\n        case STRING:\r\n            return new JsonPrimitive(in.nextString());\r\n        case NUMBER:\r\n            String number \u003d in.nextString();\r\n            return new JsonPrimitive(new LazilyParsedNumber(number));\r\n        case BOOLEAN:\r\n            return new JsonPrimitive(in.nextBoolean());\r\n        case NULL:\r\n            in.nextNull();\r\n            return JsonNull.INSTANCE;\r\n        default:\r\n            // When read(JsonReader) is called with JsonReader in invalid state\r\n            throw new IllegalStateException(\"Unexpected token: \" + peeked);\r\n    }\r\n}",
    "newFactoryForMultipleTypes": "{\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the \u0027T\u0027s equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n            Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n            return (rawType \u003d\u003d base || rawType \u003d\u003d sub) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[type\u003d\" + base.getName() + \"+\" + sub.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "create": "{\r\n    final Class\u003c? super T2\u003e requestedType \u003d typeToken.getRawType();\r\n    if (!clazz.isAssignableFrom(requestedType)) {\r\n        return null;\r\n    }\r\n    return (TypeAdapter\u003cT2\u003e) new TypeAdapter\u003cT1\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T1 value) throws IOException {\r\n            typeAdapter.write(out, value);\r\n        }\r\n\r\n        @Override\r\n        public T1 read(JsonReader in) throws IOException {\r\n            T1 result \u003d typeAdapter.read(in);\r\n            if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\r\n                throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n}",
    "run": "{\r\n    Field[] fields \u003d classOfT.getDeclaredFields();\r\n    ArrayList\u003cField\u003e constantFieldsList \u003d new ArrayList\u003c\u003e(fields.length);\r\n    for (Field f : fields) {\r\n        if (f.isEnumConstant()) {\r\n            constantFieldsList.add(f);\r\n        }\r\n    }\r\n    Field[] constantFields \u003d constantFieldsList.toArray(new Field[0]);\r\n    AccessibleObject.setAccessible(constantFields, true);\r\n    return constantFields;\r\n}",
    "toString": "{\r\n    return \"Factory[typeHierarchy\u003d\" + clazz.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n}",
    "write": "{\r\n    typeAdapter.write(out, value);\r\n}",
    "newTypeHierarchyFactory": "{\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT2\u003e TypeAdapter\u003cT2\u003e create(Gson gson, TypeToken\u003cT2\u003e typeToken) {\r\n            final Class\u003c? super T2\u003e requestedType \u003d typeToken.getRawType();\r\n            if (!clazz.isAssignableFrom(requestedType)) {\r\n                return null;\r\n            }\r\n            return (TypeAdapter\u003cT2\u003e) new TypeAdapter\u003cT1\u003e() {\r\n\r\n                @Override\r\n                public void write(JsonWriter out, T1 value) throws IOException {\r\n                    typeAdapter.write(out, value);\r\n                }\r\n\r\n                @Override\r\n                public T1 read(JsonReader in) throws IOException {\r\n                    T1 result \u003d typeAdapter.read(in);\r\n                    if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\r\n                        throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[typeHierarchy\u003d\" + clazz.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\CustomDeserializerTest.java": {
    "testJsonTypeFieldBasedDeserialization": "{\r\n    String json \u003d \"{field1:\u0027abc\u0027,field2:\u0027def\u0027,__type__:\u0027SUB_TYPE1\u0027}\";\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(MyBase.class, new JsonDeserializer\u003cMyBase\u003e() {\r\n\r\n        @Override\r\n        public MyBase deserialize(JsonElement json, Type pojoType, JsonDeserializationContext context) throws JsonParseException {\r\n            String type \u003d json.getAsJsonObject().get(MyBase.TYPE_ACCESS).getAsString();\r\n            return context.deserialize(json, SubTypes.valueOf(type).getSubclass());\r\n        }\r\n    }).create();\r\n    SubType1 target \u003d (SubType1) gson.fromJson(json, MyBase.class);\r\n    assertThat(target.field1).isEqualTo(\"abc\");\r\n}",
    "testCustomDeserializerReturnsNullForArrayElements": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonDeserializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return null;\r\n        }\r\n    }).create();\r\n    String json \u003d \"[{baseName:\u0027Base\u0027},{baseName:\u0027Base\u0027}]\";\r\n    Base[] target \u003d gson.fromJson(json, Base[].class);\r\n    assertThat(target[0]).isNull();\r\n    assertThat(target[1]).isNull();\r\n}",
    "getSubclass": "{\r\n    return subClass;\r\n}",
    "testDefaultConstructorNotCalledOnObject": "{\r\n    DataHolder data \u003d new DataHolder(DEFAULT_VALUE);\r\n    String json \u003d gson.toJson(data);\r\n    DataHolder actual \u003d gson.fromJson(json, DataHolder.class);\r\n    assertThat(actual.getData()).isEqualTo(DEFAULT_VALUE + SUFFIX);\r\n}",
    "testDefaultConstructorNotCalledOnField": "{\r\n    DataHolderWrapper dataWrapper \u003d new DataHolderWrapper(new DataHolder(DEFAULT_VALUE));\r\n    String json \u003d gson.toJson(dataWrapper);\r\n    DataHolderWrapper actual \u003d gson.fromJson(json, DataHolderWrapper.class);\r\n    assertThat(actual.getWrappedData().getData()).isEqualTo(DEFAULT_VALUE + SUFFIX);\r\n}",
    "testCustomDeserializerReturnsNullForTopLevelObject": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonDeserializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return null;\r\n        }\r\n    }).create();\r\n    String json \u003d \"{baseName:\u0027Base\u0027,subName:\u0027SubRevised\u0027}\";\r\n    Base target \u003d gson.fromJson(json, Base.class);\r\n    assertThat(target).isNull();\r\n}",
    "setUp": "{\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(DataHolder.class, new DataHolderDeserializer()).create();\r\n}",
    "getWrappedData": "{\r\n    return wrappedData;\r\n}",
    "testCustomDeserializerReturnsNull": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonDeserializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return null;\r\n        }\r\n    }).create();\r\n    String json \u003d \"{base:{baseName:\u0027Base\u0027,subName:\u0027SubRevised\u0027}}\";\r\n    ClassWithBaseField target \u003d gson.fromJson(json, ClassWithBaseField.class);\r\n    assertThat(target.base).isNull();\r\n}",
    "getData": "{\r\n    return data;\r\n}",
    "deserialize": "{\r\n    return null;\r\n}",
    "testCustomDeserializerReturnsNullForArrayElementsForArrayField": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonDeserializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return null;\r\n        }\r\n    }).create();\r\n    String json \u003d \"{bases:[{baseName:\u0027Base\u0027},{baseName:\u0027Base\u0027}]}\";\r\n    ClassWithBaseArray target \u003d gson.fromJson(json, ClassWithBaseArray.class);\r\n    assertThat(target.bases[0]).isNull();\r\n    assertThat(target.bases[1]).isNull();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JavaUtilConcurrentAtomicTest.java": {
    "testAtomicLongArray": "{\r\n    AtomicLongArray target \u003d gson.fromJson(\"[10, 13, 14]\", AtomicLongArray.class);\r\n    assertThat(target.length()).isEqualTo(3);\r\n    assertThat(target.get(0)).isEqualTo(10);\r\n    assertThat(target.get(1)).isEqualTo(13);\r\n    assertThat(target.get(2)).isEqualTo(14);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"[10,13,14]\");\r\n}",
    "testAtomicIntegerArray": "{\r\n    AtomicIntegerArray target \u003d gson.fromJson(\"[10, 13, 14]\", AtomicIntegerArray.class);\r\n    assertThat(target.length()).isEqualTo(3);\r\n    assertThat(target.get(0)).isEqualTo(10);\r\n    assertThat(target.get(1)).isEqualTo(13);\r\n    assertThat(target.get(2)).isEqualTo(14);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"[10,13,14]\");\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testAtomicLongWithStringSerializationPolicy": "{\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\r\n    AtomicLongHolder target \u003d gson.fromJson(\"{\u0027value\u0027:\u002710\u0027}\", AtomicLongHolder.class);\r\n    assertThat(target.value.get()).isEqualTo(10);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"{\\\"value\\\":\\\"10\\\"}\");\r\n}",
    "testAtomicBoolean": "{\r\n    AtomicBoolean target \u003d gson.fromJson(\"true\", AtomicBoolean.class);\r\n    assertThat(target.get()).isTrue();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"true\");\r\n}",
    "testAtomicInteger": "{\r\n    AtomicInteger target \u003d gson.fromJson(\"10\", AtomicInteger.class);\r\n    assertThat(target.get()).isEqualTo(10);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"10\");\r\n}",
    "testAtomicLongArrayWithStringSerializationPolicy": "{\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\r\n    AtomicLongArray target \u003d gson.fromJson(\"[\u002710\u0027, \u002713\u0027, \u002714\u0027]\", AtomicLongArray.class);\r\n    assertThat(target.length()).isEqualTo(3);\r\n    assertThat(target.get(0)).isEqualTo(10);\r\n    assertThat(target.get(1)).isEqualTo(13);\r\n    assertThat(target.get(2)).isEqualTo(14);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"[\\\"10\\\",\\\"13\\\",\\\"14\\\"]\");\r\n}",
    "testAtomicLong": "{\r\n    AtomicLong target \u003d gson.fromJson(\"10\", AtomicLong.class);\r\n    assertThat(target.get()).isEqualTo(10);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"10\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\JsonStreamParserTest.java": {
    "testMalformedInput": "{\r\n    JsonStreamParser parser \u003d new JsonStreamParser(\":\");\r\n    assertThrows(JsonSyntaxException.class, parser::hasNext);\r\n    parser \u003d new JsonStreamParser(\":\");\r\n    assertThrows(JsonSyntaxException.class, parser::next);\r\n}",
    "testNoSideEffectForHasNext": "{\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.next().getAsString()).isEqualTo(\"one\");\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.next().getAsString()).isEqualTo(\"two\");\r\n    assertThat(parser.hasNext()).isFalse();\r\n    assertThat(parser.hasNext()).isFalse();\r\n}",
    "testParseTwoStrings": "{\r\n    String actualOne \u003d parser.next().getAsString();\r\n    assertThat(actualOne).isEqualTo(\"one\");\r\n    String actualTwo \u003d parser.next().getAsString();\r\n    assertThat(actualTwo).isEqualTo(\"two\");\r\n}",
    "testEmptyInput": "{\r\n    JsonStreamParser parser \u003d new JsonStreamParser(\"\");\r\n    JsonIOException e \u003d assertThrows(JsonIOException.class, parser::next);\r\n    assertThat(e).hasCauseThat().isInstanceOf(EOFException.class);\r\n    parser \u003d new JsonStreamParser(\"\");\r\n    e \u003d assertThrows(JsonIOException.class, parser::hasNext);\r\n    assertThat(e).hasCauseThat().isInstanceOf(EOFException.class);\r\n}",
    "setUp": "{\r\n    parser \u003d new JsonStreamParser(\"\u0027one\u0027 \u0027two\u0027\");\r\n}",
    "testCallingNextBeyondAvailableInput": "{\r\n    JsonElement unused1 \u003d parser.next();\r\n    JsonElement unused2 \u003d parser.next();\r\n    // Parser should not go beyond available input\r\n    assertThrows(NoSuchElementException.class, parser::next);\r\n}",
    "testIterator": "{\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.next().getAsString()).isEqualTo(\"one\");\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.next().getAsString()).isEqualTo(\"two\");\r\n    assertThat(parser.hasNext()).isFalse();\r\n}",
    "testIncompleteInput": "{\r\n    JsonStreamParser parser \u003d new JsonStreamParser(\"[\");\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThrows(JsonSyntaxException.class, parser::next);\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithUnreferencedNoArgsConstructor.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ConcurrencyTest.java": {
    "testSingleThreadSerialization": "{\r\n    MyObject myObj \u003d new MyObject();\r\n    for (int i \u003d 0; i \u003c 10; i++) {\r\n        String unused \u003d gson.toJson(myObj);\r\n    }\r\n}",
    "testMultiThreadSerialization": "{\r\n    final CountDownLatch startLatch \u003d new CountDownLatch(1);\r\n    final CountDownLatch finishedLatch \u003d new CountDownLatch(10);\r\n    final AtomicBoolean failed \u003d new AtomicBoolean(false);\r\n    ExecutorService executor \u003d Executors.newFixedThreadPool(10);\r\n    for (int taskCount \u003d 0; taskCount \u003c 10; taskCount++) {\r\n        executor.execute(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                MyObject myObj \u003d new MyObject();\r\n                try {\r\n                    startLatch.await();\r\n                    for (int i \u003d 0; i \u003c 10; i++) {\r\n                        String unused \u003d gson.toJson(myObj);\r\n                    }\r\n                } catch (Throwable t) {\r\n                    failed.set(true);\r\n                } finally {\r\n                    finishedLatch.countDown();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    startLatch.countDown();\r\n    finishedLatch.await();\r\n    assertThat(failed.get()).isFalse();\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "run": "{\r\n    try {\r\n        startLatch.await();\r\n        for (int i \u003d 0; i \u003c 10; i++) {\r\n            MyObject unused \u003d gson.fromJson(\"{\u0027a\u0027:\u0027hello\u0027,\u0027b\u0027:\u0027world\u0027,\u0027i\u0027:1}\", MyObject.class);\r\n        }\r\n    } catch (Throwable t) {\r\n        failed.set(true);\r\n    } finally {\r\n        finishedLatch.countDown();\r\n    }\r\n}",
    "testSingleThreadDeserialization": "{\r\n    for (int i \u003d 0; i \u003c 10; i++) {\r\n        MyObject unused \u003d gson.fromJson(\"{\u0027a\u0027:\u0027hello\u0027,\u0027b\u0027:\u0027world\u0027,\u0027i\u0027:1}\", MyObject.class);\r\n    }\r\n}",
    "testMultiThreadDeserialization": "{\r\n    final CountDownLatch startLatch \u003d new CountDownLatch(1);\r\n    final CountDownLatch finishedLatch \u003d new CountDownLatch(10);\r\n    final AtomicBoolean failed \u003d new AtomicBoolean(false);\r\n    ExecutorService executor \u003d Executors.newFixedThreadPool(10);\r\n    for (int taskCount \u003d 0; taskCount \u003c 10; taskCount++) {\r\n        executor.execute(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    startLatch.await();\r\n                    for (int i \u003d 0; i \u003c 10; i++) {\r\n                        MyObject unused \u003d gson.fromJson(\"{\u0027a\u0027:\u0027hello\u0027,\u0027b\u0027:\u0027world\u0027,\u0027i\u0027:1}\", MyObject.class);\r\n                    }\r\n                } catch (Throwable t) {\r\n                    failed.set(true);\r\n                } finally {\r\n                    finishedLatch.countDown();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    startLatch.countDown();\r\n    finishedLatch.await();\r\n    assertThat(failed.get()).isFalse();\r\n}"
  },
  "google_json\\proto\\src\\test\\java\\com\\google\\gson\\protobuf\\functional\\ProtosWithAnnotationsTest.java": {
    "testProtoWithAnnotations_deserialize": "{\r\n    String json \u003d String.format(\"{  %n\" + \"   \\\"id\\\":\\\"41e5e7fd6065d101b97018a465ffff01\\\",%n\" + \"   \\\"expiration_date\\\":{  %n\" + \"      \\\"month\\\":\\\"12\\\",%n\" + \"      \\\"year\\\":\\\"2017\\\",%n\" + \"      \\\"timeStamp\\\":\\\"9864653135687\\\",%n\" + \"      \\\"countryCode5f55\\\":\\\"en_US\\\"%n\" + \"   },%n\" + // Don\u0027t define innerMessage1\r\n    \"   \\\"innerMessage2\\\":{  %n\" + // Set a number as a string; it should work\r\n    \"      \\\"nIdCt\\\":\\\"98798465\\\",%n\" + \"      \\\"content\\\":\\\"text/plain\\\",%n\" + \"      \\\"$binary_data$\\\":[  %n\" + \"         {  %n\" + \"            \\\"data\\\":\\\"OFIN8e9fhwoeh8((8efywoih\\\",%n\" + // Don\u0027t define width\r\n    \"            \\\"height\\\":665%n\" + \"         },%n\" + \"         {  %n\" + // Define as an int; it should work\r\n    \"            \\\"data\\\":65,%n\" + \"            \\\"width\\\":-56684%n\" + // Don\u0027t define height\r\n    \"         }%n\" + \"      ]%n\" + \"   },%n\" + // Define a bunch of non recognizable data\r\n    \"   \\\"non_existing\\\":\\\"foobar\\\",%n\" + \"   \\\"stillNot\\\":{  %n\" + \"      \\\"bunch\\\":\\\"of_useless data\\\"%n\" + \"   }%n\" + \"}\");\r\n    ProtoWithAnnotations proto \u003d gson.fromJson(json, ProtoWithAnnotations.class);\r\n    assertThat(proto.getId()).isEqualTo(\"41e5e7fd6065d101b97018a465ffff01\");\r\n    assertThat(proto.getOuterMessage()).isEqualTo(OuterMessage.newBuilder().setMonth(12).setYear(2017).setLongTimestamp(9864653135687L).setCountryCode5F55(\"en_US\").build());\r\n    assertThat(proto.hasInnerMessage1()).isFalse();\r\n    assertThat(proto.getInnerMessage2()).isEqualTo(InnerMessage.newBuilder().setNIdCt(98798465).setContent(InnerMessage.Type.TEXT).addData(InnerMessage.Data.newBuilder().setData(\"OFIN8e9fhwoeh8((8efywoih\").setHeight(665)).addData(InnerMessage.Data.newBuilder().setData(\"65\").setWidth(-56684)).build());\r\n    String rebuilt \u003d gson.toJson(proto);\r\n    assertThat(rebuilt).isEqualTo(\"{\" + \"\\\"id\\\":\\\"41e5e7fd6065d101b97018a465ffff01\\\",\" + \"\\\"expiration_date\\\":{\" + \"\\\"month\\\":12,\" + \"\\\"year\\\":2017,\" + \"\\\"timeStamp\\\":9864653135687,\" + \"\\\"countryCode5f55\\\":\\\"en_US\\\"\" + \"},\" + \"\\\"innerMessage2\\\":{\" + \"\\\"nIdCt\\\":98798465,\" + \"\\\"content\\\":\\\"text/plain\\\",\" + \"\\\"$binary_data$\\\":[\" + \"{\" + \"\\\"data\\\":\\\"OFIN8e9fhwoeh8((8efywoih\\\",\" + \"\\\"height\\\":665\" + \"},\" + \"{\" + \"\\\"data\\\":\\\"65\\\",\" + \"\\\"width\\\":-56684\" + \"}]}}\");\r\n}",
    "testProtoWithAnnotations_deserializeWithEnumNumbers": "{\r\n    String json \u003d String.format(\"{  %n\" + \"   \\\"content\\\":\\\"0\\\"%n\" + \"}\");\r\n    InnerMessage proto \u003d gsonWithEnumNumbers.fromJson(json, InnerMessage.class);\r\n    assertThat(proto.getContent()).isEqualTo(InnerMessage.Type.UNKNOWN);\r\n    String rebuilt \u003d gsonWithEnumNumbers.toJson(proto);\r\n    assertThat(rebuilt).isEqualTo(\"{\\\"content\\\":0}\");\r\n    json \u003d String.format(\"{  %n\" + \"   \\\"content\\\":\\\"2\\\"%n\" + \"}\");\r\n    proto \u003d gsonWithEnumNumbers.fromJson(json, InnerMessage.class);\r\n    assertThat(proto.getContent()).isEqualTo(InnerMessage.Type.IMAGE);\r\n    rebuilt \u003d gsonWithEnumNumbers.toJson(proto);\r\n    assertThat(rebuilt).isEqualTo(\"{\\\"content\\\":2}\");\r\n}",
    "setUp": "{\r\n    ProtoTypeAdapter.Builder protoTypeAdapter \u003d ProtoTypeAdapter.newBuilder().setEnumSerialization(EnumSerialization.NAME).addSerializedNameExtension(Annotations.serializedName).addSerializedEnumValueExtension(Annotations.serializedValue);\r\n    gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, protoTypeAdapter.build()).create();\r\n    gsonWithEnumNumbers \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, protoTypeAdapter.setEnumSerialization(EnumSerialization.NUMBER).build()).create();\r\n    gsonWithLowerHyphen \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, protoTypeAdapter.setFieldNameSerializationFormat(CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_HYPHEN).build()).create();\r\n}",
    "testProtoWithAnnotations_serialize": "{\r\n    ProtoWithAnnotations proto \u003d ProtoWithAnnotations.newBuilder().setId(\"09f3j20839h032y0329hf30932h0nffn\").setOuterMessage(OuterMessage.newBuilder().setMonth(14).setYear(6650).setLongTimestamp(468406876880768L)).setInnerMessage1(InnerMessage.newBuilder().setNIdCt(12).setContent(InnerMessage.Type.IMAGE).addData(InnerMessage.Data.newBuilder().setData(\"data$$\").setWidth(200)).addData(InnerMessage.Data.newBuilder().setHeight(56))).build();\r\n    String json \u003d gsonWithLowerHyphen.toJson(proto);\r\n    assertThat(json).isEqualTo(\"{\\\"id\\\":\\\"09f3j20839h032y0329hf30932h0nffn\\\",\" + \"\\\"expiration_date\\\":{\" + \"\\\"month\\\":14,\" + \"\\\"year\\\":6650,\" + \"\\\"timeStamp\\\":468406876880768\" + \"},\" + // This field should be using hyphens\r\n    \"\\\"inner-message-1\\\":{\" + \"\\\"n--id-ct\\\":12,\" + \"\\\"content\\\":2,\" + \"\\\"$binary_data$\\\":[\" + \"{\" + \"\\\"data\\\":\\\"data$$\\\",\" + \"\\\"width\\\":200\" + \"},\" + \"{\" + \"\\\"height\\\":56\" + \"}]\" + \"}\" + \"}\");\r\n    ProtoWithAnnotations rebuilt \u003d gsonWithLowerHyphen.fromJson(json, ProtoWithAnnotations.class);\r\n    assertThat(rebuilt).isEqualTo(proto);\r\n}",
    "testProtoWithAnnotations_deserializeUnrecognizedEnumValue": "{\r\n    String json \u003d String.format(\"{  %n\" + \"   \\\"content\\\":\\\"UNRECOGNIZED\\\"%n\" + \"}\");\r\n    try {\r\n        gson.fromJson(json, InnerMessage.class);\r\n        assertWithMessage(\"Should have thrown\").fail();\r\n    } catch (JsonParseException e) {\r\n        // expected\r\n    }\r\n}",
    "testProtoWithAnnotations_deserializeUnknownEnumValue": "{\r\n    String json \u003d String.format(\"{  %n\" + \"   \\\"content\\\":\\\"UNKNOWN\\\"%n\" + \"}\");\r\n    InnerMessage proto \u003d gson.fromJson(json, InnerMessage.class);\r\n    assertThat(proto.getContent()).isEqualTo(InnerMessage.Type.UNKNOWN);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java": {
    "testGetAdapter_Concurrency": "{\r\n    class DummyAdapter\u003cT\u003e extends TypeAdapter\u003cT\u003e {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n    }\r\n    final AtomicInteger adapterInstancesCreated \u003d new AtomicInteger(0);\r\n    final AtomicReference\u003cTypeAdapter\u003c?\u003e\u003e threadAdapter \u003d new AtomicReference\u003c\u003e();\r\n    final Class\u003c?\u003e requestedType \u003d Number.class;\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(new TypeAdapterFactory() {\r\n\r\n        private volatile boolean isFirstCall \u003d true;\r\n\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, TypeToken\u003cT\u003e type) {\r\n            if (isFirstCall) {\r\n                isFirstCall \u003d false;\r\n                // Create a separate thread which requests an adapter for the same type\r\n                // This will cause this factory to return a different adapter instance than\r\n                // the one it is currently creating\r\n                Thread thread \u003d new Thread() {\r\n\r\n                    @Override\r\n                    public void run() {\r\n                        threadAdapter.set(gson.getAdapter(requestedType));\r\n                    }\r\n                };\r\n                thread.start();\r\n                try {\r\n                    thread.join();\r\n                } catch (InterruptedException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n            // Create a new dummy adapter instance\r\n            adapterInstancesCreated.incrementAndGet();\r\n            return new DummyAdapter\u003c\u003e();\r\n        }\r\n    }).create();\r\n    TypeAdapter\u003c?\u003e adapter \u003d gson.getAdapter(requestedType);\r\n    assertThat(adapterInstancesCreated.get()).isEqualTo(2);\r\n    assertThat(adapter).isInstanceOf(DummyAdapter.class);\r\n    assertThat(threadAdapter.get()).isInstanceOf(DummyAdapter.class);\r\n}",
    "testNewJsonReader_Default": "{\r\n    // String without quotes\r\n    String json \u003d \"test\";\r\n    JsonReader jsonReader \u003d new Gson().newJsonReader(new StringReader(json));\r\n    assertThrows(MalformedJsonException.class, jsonReader::nextString);\r\n    jsonReader.close();\r\n}",
    "testGetAdapter_Null": "{\r\n    Gson gson \u003d new Gson();\r\n    NullPointerException e \u003d assertThrows(NullPointerException.class, () -\u003e gson.getAdapter((TypeToken\u003c?\u003e) null));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"type must not be null\");\r\n}",
    "run": "{\r\n    otherThreadAdapter.set(gson.getAdapter(CustomClass1.class));\r\n}",
    "testClonedTypeAdapterFactoryListsAreIndependent": "{\r\n    Gson original \u003d new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY, new HashMap\u003cType, InstanceCreator\u003c?\u003e\u003e(), true, false, true, false, FormattingStyle.PRETTY, Strictness.LENIENT, false, true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT, new ArrayList\u003cTypeAdapterFactory\u003e(), new ArrayList\u003cTypeAdapterFactory\u003e(), new ArrayList\u003cTypeAdapterFactory\u003e(), CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY, Collections.\u003cReflectionAccessFilter\u003eemptyList());\r\n    Gson clone \u003d original.newBuilder().registerTypeAdapter(int.class, new TestTypeAdapter()).create();\r\n    assertThat(clone.factories).hasSize(original.factories.size() + 1);\r\n}",
    "testStrictnessDefault": "{\r\n    assertThat(new Gson().strictness).isNull();\r\n}",
    "hashCode": "{\r\n    return adapter.hashCode();\r\n}",
    "testGetAdapter_FutureAdapterConcurrency": "{\r\n    /**\r\n     * Adapter which wraps another adapter. Can be imagined as a simplified version of the\r\n     * {@code ReflectiveTypeAdapterFactory$Adapter}.\r\n     */\r\n    class WrappingAdapter\u003cT\u003e extends TypeAdapter\u003cT\u003e {\r\n\r\n        final TypeAdapter\u003c?\u003e wrapped;\r\n\r\n        boolean isFirstCall \u003d true;\r\n\r\n        WrappingAdapter(TypeAdapter\u003c?\u003e wrapped) {\r\n            this.wrapped \u003d wrapped;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            // Due to how this test is set up there is infinite recursion, therefore\r\n            // need to track how deeply nested this call is\r\n            if (isFirstCall) {\r\n                isFirstCall \u003d false;\r\n                out.beginArray();\r\n                wrapped.write(out, null);\r\n                out.endArray();\r\n                isFirstCall \u003d true;\r\n            } else {\r\n                out.value(\"wrapped-nested\");\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n    }\r\n    final CountDownLatch isThreadWaiting \u003d new CountDownLatch(1);\r\n    final CountDownLatch canThreadProceed \u003d new CountDownLatch(1);\r\n    final Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(new TypeAdapterFactory() {\r\n\r\n        // volatile instead of AtomicBoolean is safe here because CountDownLatch prevents\r\n        // \"true\" concurrency\r\n        volatile boolean isFirstCaller \u003d true;\r\n\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            Class\u003c?\u003e raw \u003d type.getRawType();\r\n            if (raw \u003d\u003d CustomClass1.class) {\r\n                // Retrieves a WrappingAdapter containing a nested FutureAdapter for CustomClass1\r\n                TypeAdapter\u003c?\u003e adapter \u003d gson.getAdapter(CustomClass2.class);\r\n                // Let thread wait so the FutureAdapter for CustomClass1 nested in the adapter\r\n                // for CustomClass2 is not resolved yet\r\n                if (isFirstCaller) {\r\n                    isFirstCaller \u003d false;\r\n                    isThreadWaiting.countDown();\r\n                    try {\r\n                        canThreadProceed.await();\r\n                    } catch (InterruptedException e) {\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                }\r\n                return new WrappingAdapter\u003c\u003e(adapter);\r\n            } else if (raw \u003d\u003d CustomClass2.class) {\r\n                TypeAdapter\u003c?\u003e adapter \u003d gson.getAdapter(CustomClass1.class);\r\n                assertThat(adapter).isInstanceOf(FutureTypeAdapter.class);\r\n                return new WrappingAdapter\u003c\u003e(adapter);\r\n            } else {\r\n                throw new AssertionError(\"Adapter for unexpected type requested: \" + raw);\r\n            }\r\n        }\r\n    }).create();\r\n    final AtomicReference\u003cTypeAdapter\u003c?\u003e\u003e otherThreadAdapter \u003d new AtomicReference\u003c\u003e();\r\n    Thread thread \u003d new Thread() {\r\n\r\n        @Override\r\n        public void run() {\r\n            otherThreadAdapter.set(gson.getAdapter(CustomClass1.class));\r\n        }\r\n    };\r\n    thread.start();\r\n    // Wait until other thread has obtained FutureAdapter\r\n    isThreadWaiting.await();\r\n    TypeAdapter\u003c?\u003e adapter \u003d gson.getAdapter(CustomClass1.class);\r\n    // Should not fail due to referring to unresolved FutureTypeAdapter\r\n    assertThat(adapter.toJson(null)).isEqualTo(\"[[\\\"wrapped-nested\\\"]]\");\r\n    // Let other thread proceed and have it resolve its FutureTypeAdapter\r\n    canThreadProceed.countDown();\r\n    thread.join();\r\n    assertThat(otherThreadAdapter.get().toJson(null)).isEqualTo(\"[[\\\"wrapped-nested\\\"]]\");\r\n}",
    "create": "{\r\n    return (TypeAdapter\u003cT\u003e) adapter;\r\n}",
    "write": "{\r\n    out.value(\"overwritten custom-adapter\");\r\n}",
    "testNewJsonReader_Custom": "{\r\n    // String without quotes\r\n    String json \u003d \"test\";\r\n    JsonReader jsonReader \u003d new GsonBuilder().setLenient().create().newJsonReader(new StringReader(json));\r\n    assertThat(jsonReader.nextString()).isEqualTo(\"test\");\r\n    jsonReader.close();\r\n}",
    "testGetDelegateAdapter": "{\r\n    class DummyAdapter extends TypeAdapter\u003cNumber\u003e {\r\n\r\n        private final int number;\r\n\r\n        DummyAdapter(int number) {\r\n            this.number \u003d number;\r\n        }\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            throw new AssertionError(\"not needed for test\");\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            throw new AssertionError(\"not needed for test\");\r\n        }\r\n\r\n        // Override toString() for better assertion error messages\r\n        @Override\r\n        public String toString() {\r\n            return \"adapter-\" + number;\r\n        }\r\n    }\r\n    class DummyFactory implements TypeAdapterFactory {\r\n\r\n        private final DummyAdapter adapter;\r\n\r\n        DummyFactory(DummyAdapter adapter) {\r\n            this.adapter \u003d adapter;\r\n        }\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            return (TypeAdapter\u003cT\u003e) adapter;\r\n        }\r\n\r\n        // Override equals to verify that reference equality check is performed by Gson,\r\n        // and this method is ignored\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            return obj instanceof DummyFactory \u0026\u0026 ((DummyFactory) obj).adapter.equals(adapter);\r\n        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n            return adapter.hashCode();\r\n        }\r\n    }\r\n    DummyAdapter adapter1 \u003d new DummyAdapter(1);\r\n    DummyFactory factory1 \u003d new DummyFactory(adapter1);\r\n    DummyAdapter adapter2 \u003d new DummyAdapter(2);\r\n    DummyFactory factory2 \u003d new DummyFactory(adapter2);\r\n    Gson gson \u003d new GsonBuilder().// Note: This is \u0027last in, first out\u0027 order; Gson will first use factory2, then factory1\r\n    registerTypeAdapterFactory(factory1).registerTypeAdapterFactory(factory2).create();\r\n    TypeToken\u003c?\u003e type \u003d TypeToken.get(Number.class);\r\n    assertThrows(NullPointerException.class, () -\u003e gson.getDelegateAdapter(null, type));\r\n    assertThrows(NullPointerException.class, () -\u003e gson.getDelegateAdapter(factory1, null));\r\n    // For unknown factory the first adapter for that type should be returned\r\n    assertThat(gson.getDelegateAdapter(new DummyFactory(new DummyAdapter(0)), type)).isEqualTo(adapter2);\r\n    assertThat(gson.getDelegateAdapter(factory2, type)).isEqualTo(adapter1);\r\n    // Default Gson adapter should be returned\r\n    assertThat(gson.getDelegateAdapter(factory1, type)).isNotInstanceOf(DummyAdapter.class);\r\n    DummyFactory factory1Eq \u003d new DummyFactory(adapter1);\r\n    // Verify that test setup is correct\r\n    assertThat(factory1.equals(factory1Eq)).isTrue();\r\n    // Should only consider reference equality and ignore that custom `equals` method considers\r\n    // factories to be equal, therefore returning `adapter2` which came from `factory2` instead\r\n    // of skipping past `factory1`\r\n    assertThat(gson.getDelegateAdapter(factory1Eq, type)).isEqualTo(adapter2);\r\n}",
    "createInstance": "{\r\n    return new CustomClass3(\"overwritten custom-instance\");\r\n}",
    "read": "{\r\n    throw new UnsupportedOperationException();\r\n}",
    "assertDefaultGson": "{\r\n    // Should use default reflective adapter\r\n    String json1 \u003d gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"{}\");\r\n    // Should use default reflective adapter\r\n    String json2 \u003d gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"{}\");\r\n    // Should use default instance creator\r\n    CustomClass3 customClass3 \u003d gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(CustomClass3.NO_ARG_CONSTRUCTOR_VALUE);\r\n}",
    "testDefaultGsonNewBuilderModification": "{\r\n    Gson gson \u003d new Gson();\r\n    GsonBuilder gsonBuilder \u003d gson.newBuilder();\r\n    // Modifications of `gsonBuilder` should not affect `gson` object\r\n    gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter\u003cCustomClass1\u003e() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"custom-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, new JsonSerializer\u003cCustomClass2\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"custom-hierarchy-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeAdapter(CustomClass3.class, new InstanceCreator\u003cCustomClass3\u003e() {\r\n\r\n        @Override\r\n        public CustomClass3 createInstance(Type type) {\r\n            return new CustomClass3(\"custom-instance\");\r\n        }\r\n    });\r\n    assertDefaultGson(gson);\r\n    // New GsonBuilder created from `gson` should not have been affected by changes either\r\n    assertDefaultGson(gson.newBuilder().create());\r\n    // But new Gson instance from `gsonBuilder` should use custom adapters\r\n    assertCustomGson(gsonBuilder.create());\r\n}",
    "testNewJsonWriter_Default": "{\r\n    StringWriter writer \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new Gson().newJsonWriter(writer);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"test\");\r\n    jsonWriter.nullValue();\r\n    jsonWriter.name(\"\u003ctest2\");\r\n    jsonWriter.value(true);\r\n    jsonWriter.endObject();\r\n    // Additional top-level value\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e jsonWriter.value(1));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"JSON must have only one top-level value.\");\r\n    jsonWriter.close();\r\n    assertThat(writer.toString()).isEqualTo(\"{\\\"\\\\u003ctest2\\\":true}\");\r\n}",
    "assertCustomGson": "{\r\n    String json1 \u003d gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"\\\"custom-adapter\\\"\");\r\n    String json2 \u003d gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"\\\"custom-hierarchy-adapter\\\"\");\r\n    CustomClass3 customClass3 \u003d gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(\"custom-instance\");\r\n}",
    "translateName": "{\r\n    return \"foo\";\r\n}",
    "testOverridesDefaultExcluder": "{\r\n    Gson gson \u003d new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY, new HashMap\u003cType, InstanceCreator\u003c?\u003e\u003e(), true, false, true, false, FormattingStyle.PRETTY, Strictness.LENIENT, false, true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT, new ArrayList\u003cTypeAdapterFactory\u003e(), new ArrayList\u003cTypeAdapterFactory\u003e(), new ArrayList\u003cTypeAdapterFactory\u003e(), CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY, Collections.\u003cReflectionAccessFilter\u003eemptyList());\r\n    assertThat(gson.excluder).isEqualTo(CUSTOM_EXCLUDER);\r\n    assertThat(gson.fieldNamingStrategy()).isEqualTo(CUSTOM_FIELD_NAMING_STRATEGY);\r\n    assertThat(gson.serializeNulls()).isTrue();\r\n    assertThat(gson.htmlSafe()).isFalse();\r\n}",
    "testNewBuilderModification": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(CustomClass1.class, new TypeAdapter\u003cCustomClass1\u003e() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"custom-adapter\");\r\n        }\r\n    }).registerTypeHierarchyAdapter(CustomClass2.class, new JsonSerializer\u003cCustomClass2\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"custom-hierarchy-adapter\");\r\n        }\r\n    }).registerTypeAdapter(CustomClass3.class, new InstanceCreator\u003cCustomClass3\u003e() {\r\n\r\n        @Override\r\n        public CustomClass3 createInstance(Type type) {\r\n            return new CustomClass3(\"custom-instance\");\r\n        }\r\n    }).create();\r\n    assertCustomGson(gson);\r\n    // Modify `gson.newBuilder()`\r\n    GsonBuilder gsonBuilder \u003d gson.newBuilder();\r\n    gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter\u003cCustomClass1\u003e() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"overwritten custom-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, new JsonSerializer\u003cCustomClass2\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"overwritten custom-hierarchy-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeAdapter(CustomClass3.class, new InstanceCreator\u003cCustomClass3\u003e() {\r\n\r\n        @Override\r\n        public CustomClass3 createInstance(Type type) {\r\n            return new CustomClass3(\"overwritten custom-instance\");\r\n        }\r\n    });\r\n    // `gson` object should not have been affected by changes to new GsonBuilder\r\n    assertCustomGson(gson);\r\n    // New GsonBuilder based on `gson` should not have been affected either\r\n    assertCustomGson(gson.newBuilder().create());\r\n    // But new Gson instance from `gsonBuilder` should be affected by changes\r\n    Gson otherGson \u003d gsonBuilder.create();\r\n    String json1 \u003d otherGson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"\\\"overwritten custom-adapter\\\"\");\r\n    String json2 \u003d otherGson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"\\\"overwritten custom-hierarchy-adapter\\\"\");\r\n    CustomClass3 customClass3 \u003d otherGson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(\"overwritten custom-instance\");\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(\"overwritten custom-hierarchy-adapter\");\r\n}",
    "equals": "{\r\n    return obj instanceof DummyFactory \u0026\u0026 ((DummyFactory) obj).adapter.equals(adapter);\r\n}",
    "toString": "{\r\n    return \"adapter-\" + number;\r\n}",
    "testNewJsonWriter_Custom": "{\r\n    StringWriter writer \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new GsonBuilder().disableHtmlEscaping().generateNonExecutableJson().setPrettyPrinting().serializeNulls().setLenient().create().newJsonWriter(writer);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"test\");\r\n    jsonWriter.nullValue();\r\n    jsonWriter.name(\"\u003ctest2\");\r\n    jsonWriter.value(true);\r\n    jsonWriter.endObject();\r\n    // Additional top-level value\r\n    jsonWriter.value(1);\r\n    jsonWriter.close();\r\n    assertThat(writer.toString()).isEqualTo(\")]}\u0027\\n{\\n  \\\"test\\\": null,\\n  \\\"\u003ctest2\\\": true\\n}1\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonSyntaxException.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\InterfaceTest.java": {
    "setUp": "{\r\n    gson \u003d new Gson();\r\n    obj \u003d new TestObject(\"StringValue\");\r\n}",
    "testSerializingInterfaceObjectField": "{\r\n    TestObjectWrapper objWrapper \u003d new TestObjectWrapper(obj);\r\n    assertThat(gson.toJson(objWrapper)).isEqualTo(\"{\\\"obj\\\":\" + OBJ_JSON + \"}\");\r\n}",
    "testSerializingObjectImplementingInterface": "{\r\n    assertThat(gson.toJson(obj)).isEqualTo(OBJ_JSON);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java": {
    "nextQuotedValue": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    StringBuilder builder \u003d null;\r\n    while (true) {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        int start \u003d p;\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            // In strict mode, throw an exception when meeting unescaped control characters (U+0000 through U+001F)\r\n            if (strictness \u003d\u003d Strictness.STRICT \u0026\u0026 c \u003c 0x20) {\r\n                throw syntaxError(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n            } else if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    return new String(buffer, start, len);\r\n                } else {\r\n                    builder.append(buffer, start, len);\r\n                    return builder.toString();\r\n                }\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    int estimatedLength \u003d (len + 1) * 2;\r\n                    builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n                }\r\n                builder.append(buffer, start, len);\r\n                builder.append(readEscapeCharacter());\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n                start \u003d p;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        if (builder \u003d\u003d null) {\r\n            int estimatedLength \u003d (p - start) * 2;\r\n            builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n        }\r\n        builder.append(buffer, start, p - start);\r\n        pos \u003d p;\r\n        if (!fillBuffer(1)) {\r\n            throw syntaxError(\"Unterminated string\");\r\n        }\r\n    }\r\n}",
    "syntaxError": "{\r\n    throw new MalformedJsonException(message + locationString() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"malformed-json\"));\r\n}",
    "isLenient": "{\r\n    return strictness \u003d\u003d Strictness.LENIENT;\r\n}",
    "skipTo": "{\r\n    int length \u003d toFind.length();\r\n    outer: for (; pos + length \u003c\u003d limit || fillBuffer(length); pos++) {\r\n        if (buffer[pos] \u003d\u003d \u0027\\n\u0027) {\r\n            lineNumber++;\r\n            lineStart \u003d pos + 1;\r\n            continue;\r\n        }\r\n        for (int c \u003d 0; c \u003c length; c++) {\r\n            if (buffer[pos + c] !\u003d toFind.charAt(c)) {\r\n                continue outer;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "readEscapeCharacter": "{\r\n    if (pos \u003d\u003d limit \u0026\u0026 !fillBuffer(1)) {\r\n        throw syntaxError(\"Unterminated escape sequence\");\r\n    }\r\n    char escaped \u003d buffer[pos++];\r\n    switch(escaped) {\r\n        case \u0027u\u0027:\r\n            if (pos + 4 \u003e limit \u0026\u0026 !fillBuffer(4)) {\r\n                throw syntaxError(\"Unterminated escape sequence\");\r\n            }\r\n            // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\r\n            int result \u003d 0;\r\n            for (int i \u003d pos, end \u003d i + 4; i \u003c end; i++) {\r\n                char c \u003d buffer[i];\r\n                result \u003c\u003c\u003d 4;\r\n                if (c \u003e\u003d \u00270\u0027 \u0026\u0026 c \u003c\u003d \u00279\u0027) {\r\n                    result +\u003d (c - \u00270\u0027);\r\n                } else if (c \u003e\u003d \u0027a\u0027 \u0026\u0026 c \u003c\u003d \u0027f\u0027) {\r\n                    result +\u003d (c - \u0027a\u0027 + 10);\r\n                } else if (c \u003e\u003d \u0027A\u0027 \u0026\u0026 c \u003c\u003d \u0027F\u0027) {\r\n                    result +\u003d (c - \u0027A\u0027 + 10);\r\n                } else {\r\n                    throw syntaxError(\"Malformed Unicode escape \\\\u\" + new String(buffer, pos, 4));\r\n                }\r\n            }\r\n            pos +\u003d 4;\r\n            return (char) result;\r\n        case \u0027t\u0027:\r\n            return \u0027\\t\u0027;\r\n        case \u0027b\u0027:\r\n            return \u0027\\b\u0027;\r\n        case \u0027n\u0027:\r\n            return \u0027\\n\u0027;\r\n        case \u0027r\u0027:\r\n            return \u0027\\r\u0027;\r\n        case \u0027f\u0027:\r\n            return \u0027\\f\u0027;\r\n        case \u0027\\n\u0027:\r\n            if (strictness \u003d\u003d Strictness.STRICT) {\r\n                throw syntaxError(\"Cannot escape a newline character in strict mode\");\r\n            }\r\n            lineNumber++;\r\n            lineStart \u003d pos;\r\n        // fall-through\r\n        case \u0027\\\u0027\u0027:\r\n            if (strictness \u003d\u003d Strictness.STRICT) {\r\n                throw syntaxError(\"Invalid escaped character \\\"\u0027\\\" in strict mode\");\r\n            }\r\n        case \u0027\"\u0027:\r\n        case \u0027\\\\\u0027:\r\n        case \u0027/\u0027:\r\n            return escaped;\r\n        default:\r\n            // throw error when none of the above cases are matched\r\n            throw syntaxError(\"Invalid escape sequence\");\r\n    }\r\n}",
    "endArray": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_END_ARRAY) {\r\n        stackSize--;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"END_ARRAY\");\r\n    }\r\n}",
    "nextString": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    String result;\r\n    if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n        result \u003d nextUnquotedValue();\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED) {\r\n        result \u003d nextQuotedValue(\u0027\\\u0027\u0027);\r\n    } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\r\n        result \u003d nextQuotedValue(\u0027\"\u0027);\r\n    } else if (p \u003d\u003d PEEKED_BUFFERED) {\r\n        result \u003d peekedString;\r\n        peekedString \u003d null;\r\n    } else if (p \u003d\u003d PEEKED_LONG) {\r\n        result \u003d Long.toString(peekedLong);\r\n    } else if (p \u003d\u003d PEEKED_NUMBER) {\r\n        result \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else {\r\n        throw unexpectedTokenError(\"a string\");\r\n    }\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "setLenient": "{\r\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\r\n}",
    "skipUnquotedValue": "{\r\n    do {\r\n        int i \u003d 0;\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    pos +\u003d i;\r\n                    return;\r\n            }\r\n        }\r\n        pos +\u003d i;\r\n    } while (fillBuffer(1));\r\n}",
    "beginArray": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_BEGIN_ARRAY) {\r\n        push(JsonScope.EMPTY_ARRAY);\r\n        pathIndices[stackSize - 1] \u003d 0;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"BEGIN_ARRAY\");\r\n    }\r\n}",
    "checkLenient": "{\r\n    if (strictness !\u003d Strictness.LENIENT) {\r\n        throw syntaxError(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON\");\r\n    }\r\n}",
    "skipQuotedValue": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    do {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                return;\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                char unused \u003d readEscapeCharacter();\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        pos \u003d p;\r\n    } while (fillBuffer(1));\r\n    throw syntaxError(\"Unterminated string\");\r\n}",
    "promoteNameToValue": "{\r\n    if (reader instanceof JsonTreeReader) {\r\n        ((JsonTreeReader) reader).promoteNameToValue();\r\n        return;\r\n    }\r\n    int p \u003d reader.peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d reader.doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\r\n        reader.peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\r\n        reader.peeked \u003d PEEKED_SINGLE_QUOTED;\r\n    } else if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\r\n        reader.peeked \u003d PEEKED_UNQUOTED;\r\n    } else {\r\n        throw reader.unexpectedTokenError(\"a name\");\r\n    }\r\n}",
    "fillBuffer": "{\r\n    char[] buffer \u003d this.buffer;\r\n    lineStart -\u003d pos;\r\n    if (limit !\u003d pos) {\r\n        limit -\u003d pos;\r\n        System.arraycopy(buffer, pos, buffer, 0, limit);\r\n    } else {\r\n        limit \u003d 0;\r\n    }\r\n    pos \u003d 0;\r\n    int total;\r\n    while ((total \u003d in.read(buffer, limit, buffer.length - limit)) !\u003d -1) {\r\n        limit +\u003d total;\r\n        // if this is the first read, consume an optional byte order mark (BOM) if it exists\r\n        if (lineNumber \u003d\u003d 0 \u0026\u0026 lineStart \u003d\u003d 0 \u0026\u0026 limit \u003e 0 \u0026\u0026 buffer[0] \u003d\u003d \u0027\\ufeff\u0027) {\r\n            pos++;\r\n            lineStart++;\r\n            minimum++;\r\n        }\r\n        if (limit \u003e\u003d minimum) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "getPath": "{\r\n    return getPath(false);\r\n}",
    "nextNonWhitespace": "{\r\n    /*\r\n     * This code uses ugly local variables \u0027p\u0027 and \u0027l\u0027 representing the \u0027pos\u0027\r\n     * and \u0027limit\u0027 fields respectively. Using locals rather than fields saves\r\n     * a few field reads for each whitespace character in a pretty-printed\r\n     * document, resulting in a 5% speedup. We need to flush \u0027p\u0027 to its field\r\n     * before any (potentially indirect) call to fillBuffer() and reread both\r\n     * \u0027p\u0027 and \u0027l\u0027 after any (potentially indirect) call to the same method.\r\n     */\r\n    char[] buffer \u003d this.buffer;\r\n    int p \u003d pos;\r\n    int l \u003d limit;\r\n    while (true) {\r\n        if (p \u003d\u003d l) {\r\n            pos \u003d p;\r\n            if (!fillBuffer(1)) {\r\n                break;\r\n            }\r\n            p \u003d pos;\r\n            l \u003d limit;\r\n        }\r\n        int c \u003d buffer[p++];\r\n        if (c \u003d\u003d \u0027\\n\u0027) {\r\n            lineNumber++;\r\n            lineStart \u003d p;\r\n            continue;\r\n        } else if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\t\u0027) {\r\n            continue;\r\n        }\r\n        if (c \u003d\u003d \u0027/\u0027) {\r\n            pos \u003d p;\r\n            if (p \u003d\u003d l) {\r\n                // push back \u0027/\u0027 so it\u0027s still in the buffer when this method returns\r\n                pos--;\r\n                boolean charsLoaded \u003d fillBuffer(2);\r\n                // consume the \u0027/\u0027 again\r\n                pos++;\r\n                if (!charsLoaded) {\r\n                    return c;\r\n                }\r\n            }\r\n            checkLenient();\r\n            char peek \u003d buffer[pos];\r\n            switch(peek) {\r\n                case \u0027*\u0027:\r\n                    // skip a /* c-style comment */\r\n                    pos++;\r\n                    if (!skipTo(\"*/\")) {\r\n                        throw syntaxError(\"Unterminated comment\");\r\n                    }\r\n                    p \u003d pos + 2;\r\n                    l \u003d limit;\r\n                    continue;\r\n                case \u0027/\u0027:\r\n                    // skip a // end-of-line comment\r\n                    pos++;\r\n                    skipToEndOfLine();\r\n                    p \u003d pos;\r\n                    l \u003d limit;\r\n                    continue;\r\n                default:\r\n                    return c;\r\n            }\r\n        } else if (c \u003d\u003d \u0027#\u0027) {\r\n            pos \u003d p;\r\n            /*\r\n         * Skip a # hash end-of-line comment. The JSON RFC doesn\u0027t\r\n         * specify this behaviour, but it\u0027s required to parse\r\n         * existing documents. See http://b/2571423.\r\n         */\r\n            checkLenient();\r\n            skipToEndOfLine();\r\n            p \u003d pos;\r\n            l \u003d limit;\r\n        } else {\r\n            pos \u003d p;\r\n            return c;\r\n        }\r\n    }\r\n    if (throwOnEof) {\r\n        throw new EOFException(\"End of input\" + locationString());\r\n    } else {\r\n        return -1;\r\n    }\r\n}",
    "nextBoolean": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_TRUE) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return true;\r\n    } else if (p \u003d\u003d PEEKED_FALSE) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return false;\r\n    }\r\n    throw unexpectedTokenError(\"a boolean\");\r\n}",
    "peekKeyword": "{\r\n    // Figure out which keyword we\u0027re matching against by its first character.\r\n    char c \u003d buffer[pos];\r\n    String keyword;\r\n    String keywordUpper;\r\n    int peeking;\r\n    // Look at the first letter to determine what keyword we are trying to match.\r\n    if (c \u003d\u003d \u0027t\u0027 || c \u003d\u003d \u0027T\u0027) {\r\n        keyword \u003d \"true\";\r\n        keywordUpper \u003d \"TRUE\";\r\n        peeking \u003d PEEKED_TRUE;\r\n    } else if (c \u003d\u003d \u0027f\u0027 || c \u003d\u003d \u0027F\u0027) {\r\n        keyword \u003d \"false\";\r\n        keywordUpper \u003d \"FALSE\";\r\n        peeking \u003d PEEKED_FALSE;\r\n    } else if (c \u003d\u003d \u0027n\u0027 || c \u003d\u003d \u0027N\u0027) {\r\n        keyword \u003d \"null\";\r\n        keywordUpper \u003d \"NULL\";\r\n        peeking \u003d PEEKED_NULL;\r\n    } else {\r\n        return PEEKED_NONE;\r\n    }\r\n    // Uppercased keywords are not allowed in STRICT mode\r\n    boolean allowsUpperCased \u003d strictness !\u003d Strictness.STRICT;\r\n    // Confirm that chars [0..length) match the keyword.\r\n    int length \u003d keyword.length();\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        if (pos + i \u003e\u003d limit \u0026\u0026 !fillBuffer(i + 1)) {\r\n            return PEEKED_NONE;\r\n        }\r\n        c \u003d buffer[pos + i];\r\n        boolean matched \u003d c \u003d\u003d keyword.charAt(i) || (allowsUpperCased \u0026\u0026 c \u003d\u003d keywordUpper.charAt(i));\r\n        if (!matched) {\r\n            return PEEKED_NONE;\r\n        }\r\n    }\r\n    if ((pos + length \u003c limit || fillBuffer(length + 1)) \u0026\u0026 isLiteral(buffer[pos + length])) {\r\n        // Don\u0027t match trues, falsey or nullsoft!\r\n        return PEEKED_NONE;\r\n    }\r\n    // We\u0027ve found the keyword followed either by EOF or by a non-literal character.\r\n    pos +\u003d length;\r\n    return peeked \u003d peeking;\r\n}",
    "close": "{\r\n    peeked \u003d PEEKED_NONE;\r\n    stack[0] \u003d JsonScope.CLOSED;\r\n    stackSize \u003d 1;\r\n    in.close();\r\n}",
    "doPeek": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (strictness \u003d\u003d Strictness.LENIENT) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}",
    "skipValue": "{\r\n    int count \u003d 0;\r\n    do {\r\n        int p \u003d peeked;\r\n        if (p \u003d\u003d PEEKED_NONE) {\r\n            p \u003d doPeek();\r\n        }\r\n        switch(p) {\r\n            case PEEKED_BEGIN_ARRAY:\r\n                push(JsonScope.EMPTY_ARRAY);\r\n                count++;\r\n                break;\r\n            case PEEKED_BEGIN_OBJECT:\r\n                push(JsonScope.EMPTY_OBJECT);\r\n                count++;\r\n                break;\r\n            case PEEKED_END_ARRAY:\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_END_OBJECT:\r\n                // Only update when object end is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    // Free the last path name so that it can be garbage collected\r\n                    pathNames[stackSize - 1] \u003d null;\r\n                }\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_UNQUOTED:\r\n                skipUnquotedValue();\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED:\r\n                skipQuotedValue(\u0027\\\u0027\u0027);\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED:\r\n                skipQuotedValue(\u0027\"\u0027);\r\n                break;\r\n            case PEEKED_UNQUOTED_NAME:\r\n                skipUnquotedValue();\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED_NAME:\r\n                skipQuotedValue(\u0027\\\u0027\u0027);\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED_NAME:\r\n                skipQuotedValue(\u0027\"\u0027);\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_NUMBER:\r\n                pos +\u003d peekedNumberLength;\r\n                break;\r\n            case PEEKED_EOF:\r\n                // Do nothing\r\n                return;\r\n        }\r\n        peeked \u003d PEEKED_NONE;\r\n    } while (count \u003e 0);\r\n    pathIndices[stackSize - 1]++;\r\n}",
    "skipToEndOfLine": "{\r\n    while (pos \u003c limit || fillBuffer(1)) {\r\n        char c \u003d buffer[pos++];\r\n        if (c \u003d\u003d \u0027\\n\u0027) {\r\n            lineNumber++;\r\n            lineStart \u003d pos;\r\n            break;\r\n        } else if (c \u003d\u003d \u0027\\r\u0027) {\r\n            break;\r\n        }\r\n    }\r\n}",
    "getPreviousPath": "{\r\n    return getPath(true);\r\n}",
    "nextUnquotedValue": "{\r\n    StringBuilder builder \u003d null;\r\n    int i \u003d 0;\r\n    findNonLiteralCharacter: while (true) {\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    break findNonLiteralCharacter;\r\n            }\r\n        }\r\n        // Attempt to load the entire literal into the buffer at once.\r\n        if (i \u003c buffer.length) {\r\n            if (fillBuffer(i + 1)) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // use a StringBuilder when the value is too long. This is too long to be a number!\r\n        if (builder \u003d\u003d null) {\r\n            builder \u003d new StringBuilder(Math.max(i, 16));\r\n        }\r\n        builder.append(buffer, pos, i);\r\n        pos +\u003d i;\r\n        i \u003d 0;\r\n        if (!fillBuffer(1)) {\r\n            break;\r\n        }\r\n    }\r\n    String result \u003d (null \u003d\u003d builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n    pos +\u003d i;\r\n    return result;\r\n}",
    "hasNext": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    return p !\u003d PEEKED_END_OBJECT \u0026\u0026 p !\u003d PEEKED_END_ARRAY \u0026\u0026 p !\u003d PEEKED_EOF;\r\n}",
    "nextInt": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    int result;\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        result \u003d (int) peekedLong;\r\n        if (peekedLong !\u003d result) {\r\n            // Make sure no precision was lost casting to \u0027int\u0027.\r\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\r\n        }\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return result;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED || p \u003d\u003d PEEKED_UNQUOTED) {\r\n        if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n            peekedString \u003d nextUnquotedValue();\r\n        } else {\r\n            peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n        }\r\n        try {\r\n            result \u003d Integer.parseInt(peekedString);\r\n            peeked \u003d PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        } catch (NumberFormatException ignored) {\r\n            // Fall back to parse as a double below.\r\n        }\r\n    } else {\r\n        throw unexpectedTokenError(\"an int\");\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double asDouble \u003d Double.parseDouble(peekedString);\r\n    result \u003d (int) asDouble;\r\n    if (result !\u003d asDouble) {\r\n        // Make sure no precision was lost casting to \u0027int\u0027.\r\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "nextLong": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return peekedLong;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED || p \u003d\u003d PEEKED_UNQUOTED) {\r\n        if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n            peekedString \u003d nextUnquotedValue();\r\n        } else {\r\n            peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n        }\r\n        try {\r\n            long result \u003d Long.parseLong(peekedString);\r\n            peeked \u003d PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        } catch (NumberFormatException ignored) {\r\n            // Fall back to parse as a double below.\r\n        }\r\n    } else {\r\n        throw unexpectedTokenError(\"a long\");\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double asDouble \u003d Double.parseDouble(peekedString);\r\n    long result \u003d (long) asDouble;\r\n    if (result !\u003d asDouble) {\r\n        // Make sure no precision was lost casting to \u0027long\u0027.\r\n        throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "getStrictness": "{\r\n    return strictness;\r\n}",
    "nextDouble": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return (double) peekedLong;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\r\n        peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n    } else if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n        peekedString \u003d nextUnquotedValue();\r\n    } else if (p !\u003d PEEKED_BUFFERED) {\r\n        throw unexpectedTokenError(\"a double\");\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double result \u003d Double.parseDouble(peekedString);\r\n    if (strictness !\u003d Strictness.LENIENT \u0026\u0026 (Double.isNaN(result) || Double.isInfinite(result))) {\r\n        throw syntaxError(\"JSON forbids NaN and infinities: \" + result);\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "push": "{\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        int newLength \u003d stackSize * 2;\r\n        stack \u003d Arrays.copyOf(stack, newLength);\r\n        pathIndices \u003d Arrays.copyOf(pathIndices, newLength);\r\n        pathNames \u003d Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}",
    "endObject": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_END_OBJECT) {\r\n        stackSize--;\r\n        // Free the last path name so that it can be garbage collected!\r\n        pathNames[stackSize] \u003d null;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"END_OBJECT\");\r\n    }\r\n}",
    "peek": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}",
    "peekNumber": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    int p \u003d pos;\r\n    int l \u003d limit;\r\n    // Negative to accommodate Long.MIN_VALUE more easily.\r\n    long value \u003d 0;\r\n    boolean negative \u003d false;\r\n    boolean fitsInLong \u003d true;\r\n    int last \u003d NUMBER_CHAR_NONE;\r\n    int i \u003d 0;\r\n    charactersOfNumber: for (; true; i++) {\r\n        if (p + i \u003d\u003d l) {\r\n            if (i \u003d\u003d buffer.length) {\r\n                // Though this looks like a well-formed number, it\u0027s too long to continue reading. Give up\r\n                // and let the application handle this as an unquoted literal.\r\n                return PEEKED_NONE;\r\n            }\r\n            if (!fillBuffer(i + 1)) {\r\n                break;\r\n            }\r\n            p \u003d pos;\r\n            l \u003d limit;\r\n        }\r\n        char c \u003d buffer[p + i];\r\n        switch(c) {\r\n            case \u0027-\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_NONE) {\r\n                    negative \u003d true;\r\n                    last \u003d NUMBER_CHAR_SIGN;\r\n                    continue;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_EXP_E) {\r\n                    last \u003d NUMBER_CHAR_EXP_SIGN;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case \u0027+\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_EXP_E) {\r\n                    last \u003d NUMBER_CHAR_EXP_SIGN;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case \u0027e\u0027:\r\n            case \u0027E\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_DIGIT || last \u003d\u003d NUMBER_CHAR_FRACTION_DIGIT) {\r\n                    last \u003d NUMBER_CHAR_EXP_E;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case \u0027.\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_DIGIT) {\r\n                    last \u003d NUMBER_CHAR_DECIMAL;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            default:\r\n                if (c \u003c \u00270\u0027 || c \u003e \u00279\u0027) {\r\n                    if (!isLiteral(c)) {\r\n                        break charactersOfNumber;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                }\r\n                if (last \u003d\u003d NUMBER_CHAR_SIGN || last \u003d\u003d NUMBER_CHAR_NONE) {\r\n                    value \u003d -(c - \u00270\u0027);\r\n                    last \u003d NUMBER_CHAR_DIGIT;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_DIGIT) {\r\n                    if (value \u003d\u003d 0) {\r\n                        // Leading \u00270\u0027 prefix is not allowed (since it could be octal).\r\n                        return PEEKED_NONE;\r\n                    }\r\n                    long newValue \u003d value * 10 - (c - \u00270\u0027);\r\n                    fitsInLong \u0026\u003d value \u003e MIN_INCOMPLETE_INTEGER || (value \u003d\u003d MIN_INCOMPLETE_INTEGER \u0026\u0026 newValue \u003c value);\r\n                    value \u003d newValue;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_DECIMAL) {\r\n                    last \u003d NUMBER_CHAR_FRACTION_DIGIT;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_EXP_E || last \u003d\u003d NUMBER_CHAR_EXP_SIGN) {\r\n                    last \u003d NUMBER_CHAR_EXP_DIGIT;\r\n                }\r\n        }\r\n    }\r\n    // We\u0027ve read a complete number. Decide if it\u0027s a PEEKED_LONG or a PEEKED_NUMBER.\r\n    // Don\u0027t store -0 as long; user might want to read it as double -0.0\r\n    // Don\u0027t try to convert Long.MIN_VALUE to positive long; it would overflow MAX_VALUE\r\n    if (last \u003d\u003d NUMBER_CHAR_DIGIT \u0026\u0026 fitsInLong \u0026\u0026 (value !\u003d Long.MIN_VALUE || negative) \u0026\u0026 (value !\u003d 0 || !negative)) {\r\n        peekedLong \u003d negative ? value : -value;\r\n        pos +\u003d i;\r\n        return peeked \u003d PEEKED_LONG;\r\n    } else if (last \u003d\u003d NUMBER_CHAR_DIGIT || last \u003d\u003d NUMBER_CHAR_FRACTION_DIGIT || last \u003d\u003d NUMBER_CHAR_EXP_DIGIT) {\r\n        peekedNumberLength \u003d i;\r\n        return peeked \u003d PEEKED_NUMBER;\r\n    } else {\r\n        return PEEKED_NONE;\r\n    }\r\n}",
    "isLiteral": "{\r\n    switch(c) {\r\n        case \u0027/\u0027:\r\n        case \u0027\\\\\u0027:\r\n        case \u0027;\u0027:\r\n        case \u0027#\u0027:\r\n        case \u0027\u003d\u0027:\r\n            // fall-through\r\n            checkLenient();\r\n        case \u0027{\u0027:\r\n        case \u0027}\u0027:\r\n        case \u0027[\u0027:\r\n        case \u0027]\u0027:\r\n        case \u0027:\u0027:\r\n        case \u0027,\u0027:\r\n        case \u0027 \u0027:\r\n        case \u0027\\t\u0027:\r\n        case \u0027\\f\u0027:\r\n        case \u0027\\r\u0027:\r\n        case \u0027\\n\u0027:\r\n            return false;\r\n        default:\r\n            return true;\r\n    }\r\n}",
    "beginObject": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_BEGIN_OBJECT) {\r\n        push(JsonScope.EMPTY_OBJECT);\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"BEGIN_OBJECT\");\r\n    }\r\n}",
    "locationString": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}",
    "consumeNonExecutePrefix": "{\r\n    // fast-forward through the leading whitespace\r\n    int unused \u003d nextNonWhitespace(true);\r\n    pos--;\r\n    if (pos + 5 \u003e limit \u0026\u0026 !fillBuffer(5)) {\r\n        return;\r\n    }\r\n    int p \u003d pos;\r\n    char[] buf \u003d buffer;\r\n    if (buf[p] !\u003d \u0027)\u0027 || buf[p + 1] !\u003d \u0027]\u0027 || buf[p + 2] !\u003d \u0027}\u0027 || buf[p + 3] !\u003d \u0027\\\u0027\u0027 || buf[p + 4] !\u003d \u0027\\n\u0027) {\r\n        // not a security token!\r\n        return;\r\n    }\r\n    // we consumed a security token!\r\n    pos +\u003d 5;\r\n}",
    "toString": "{\r\n    return getClass().getSimpleName() + locationString();\r\n}",
    "unexpectedTokenError": "{\r\n    JsonToken peeked \u003d peek();\r\n    String troubleshootingId \u003d peeked \u003d\u003d JsonToken.NULL ? \"adapter-not-null-safe\" : \"unexpected-json-structure\";\r\n    return new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString() + \"\\nSee \" + TroubleshootingGuide.createUrl(troubleshootingId));\r\n}",
    "setStrictness": "{\r\n    Objects.requireNonNull(strictness);\r\n    this.strictness \u003d strictness;\r\n}",
    "nextName": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    String result;\r\n    if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\r\n        result \u003d nextUnquotedValue();\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\r\n        result \u003d nextQuotedValue(\u0027\\\u0027\u0027);\r\n    } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\r\n        result \u003d nextQuotedValue(\u0027\"\u0027);\r\n    } else {\r\n        throw unexpectedTokenError(\"a name\");\r\n    }\r\n    peeked \u003d PEEKED_NONE;\r\n    pathNames[stackSize - 1] \u003d result;\r\n    return result;\r\n}",
    "nextNull": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_NULL) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n    } else {\r\n        throw unexpectedTokenError(\"null\");\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\Primitives.java": {
    "isWrapperType": "{\r\n    return type \u003d\u003d Integer.class || type \u003d\u003d Float.class || type \u003d\u003d Byte.class || type \u003d\u003d Double.class || type \u003d\u003d Long.class || type \u003d\u003d Character.class || type \u003d\u003d Boolean.class || type \u003d\u003d Short.class || type \u003d\u003d Void.class;\r\n}",
    "isPrimitive": "{\r\n    return type instanceof Class\u003c?\u003e \u0026\u0026 ((Class\u003c?\u003e) type).isPrimitive();\r\n}",
    "wrap": "{\r\n    if (type \u003d\u003d int.class)\r\n        return (Class\u003cT\u003e) Integer.class;\r\n    if (type \u003d\u003d float.class)\r\n        return (Class\u003cT\u003e) Float.class;\r\n    if (type \u003d\u003d byte.class)\r\n        return (Class\u003cT\u003e) Byte.class;\r\n    if (type \u003d\u003d double.class)\r\n        return (Class\u003cT\u003e) Double.class;\r\n    if (type \u003d\u003d long.class)\r\n        return (Class\u003cT\u003e) Long.class;\r\n    if (type \u003d\u003d char.class)\r\n        return (Class\u003cT\u003e) Character.class;\r\n    if (type \u003d\u003d boolean.class)\r\n        return (Class\u003cT\u003e) Boolean.class;\r\n    if (type \u003d\u003d short.class)\r\n        return (Class\u003cT\u003e) Short.class;\r\n    if (type \u003d\u003d void.class)\r\n        return (Class\u003cT\u003e) Void.class;\r\n    return type;\r\n}",
    "unwrap": "{\r\n    if (type \u003d\u003d Integer.class)\r\n        return (Class\u003cT\u003e) int.class;\r\n    if (type \u003d\u003d Float.class)\r\n        return (Class\u003cT\u003e) float.class;\r\n    if (type \u003d\u003d Byte.class)\r\n        return (Class\u003cT\u003e) byte.class;\r\n    if (type \u003d\u003d Double.class)\r\n        return (Class\u003cT\u003e) double.class;\r\n    if (type \u003d\u003d Long.class)\r\n        return (Class\u003cT\u003e) long.class;\r\n    if (type \u003d\u003d Character.class)\r\n        return (Class\u003cT\u003e) char.class;\r\n    if (type \u003d\u003d Boolean.class)\r\n        return (Class\u003cT\u003e) boolean.class;\r\n    if (type \u003d\u003d Short.class)\r\n        return (Class\u003cT\u003e) short.class;\r\n    if (type \u003d\u003d Void.class)\r\n        return (Class\u003cT\u003e) void.class;\r\n    return type;\r\n}"
  },
  "google_json\\examples\\android-proguard-example\\src\\com\\google\\gson\\examples\\android\\GsonProguardExampleActivity.java": {
    "onCreate": "{\r\n    super.onCreate(icicle);\r\n    setContentView(R.layout.main);\r\n    TextView tv \u003d (TextView) findViewById(R.id.tv);\r\n    Gson gson \u003d new Gson();\r\n    Cart cart \u003d buildCart();\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\"Gson.toJson() example: \\n\");\r\n    sb.append(\"  Cart Object: \").append(cart).append(\"\\n\");\r\n    sb.append(\"  Cart JSON: \").append(gson.toJson(cart)).append(\"\\n\");\r\n    sb.append(\"\\n\\nGson.fromJson() example: \\n\");\r\n    String json \u003d \"{buyer:\u0027Happy Camper\u0027,creditCard:\u00274111-1111-1111-1111\u0027,\" + \"lineItems:[{name:\u0027nails\u0027,priceInMicros:100000,quantity:100,currencyCode:\u0027USD\u0027}]}\";\r\n    sb.append(\"Cart JSON: \").append(json).append(\"\\n\");\r\n    sb.append(\"Cart Object: \").append(gson.fromJson(json, Cart.class)).append(\"\\n\");\r\n    tv.setText(sb.toString());\r\n    tv.invalidate();\r\n}",
    "buildCart": "{\r\n    List\u003cLineItem\u003e lineItems \u003d new ArrayList\u003c\u003e();\r\n    lineItems.add(new LineItem(\"hammer\", 1, 12000000, \"USD\"));\r\n    return new Cart(lineItems, \"Happy Buyer\", \"4111-1111-1111-1111\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ExclusionStrategyFunctionalTest.java": {
    "testExclusionStrategySerialization": "{\r\n    Gson gson \u003d createGson(new MyExclusionStrategy(String.class), true);\r\n    String json \u003d gson.toJson(src);\r\n    assertThat(json).doesNotContain(\"\\\"stringField\\\"\");\r\n    assertThat(json).doesNotContain(\"\\\"annotatedField\\\"\");\r\n    assertThat(json).contains(\"\\\"longField\\\"\");\r\n}",
    "testExclusionStrategySerializationDoesNotImpactSerialization": "{\r\n    Gson gson \u003d createGson(new MyExclusionStrategy(String.class), false);\r\n    String json \u003d gson.toJson(src);\r\n    assertThat(json).contains(\"\\\"stringField\\\"\");\r\n    assertThat(json).contains(\"\\\"annotatedField\\\"\");\r\n    assertThat(json).contains(\"\\\"longField\\\"\");\r\n}",
    "testExclusionStrategyDeserialization": "{\r\n    Gson gson \u003d createGson(new MyExclusionStrategy(String.class), false);\r\n    JsonObject json \u003d new JsonObject();\r\n    json.add(\"annotatedField\", new JsonPrimitive(src.annotatedField + 5));\r\n    json.add(\"stringField\", new JsonPrimitive(src.stringField + \"blah,blah\"));\r\n    json.add(\"longField\", new JsonPrimitive(1212311L));\r\n    SampleObjectForTest target \u003d gson.fromJson(json, SampleObjectForTest.class);\r\n    assertThat(target.longField).isEqualTo(1212311L);\r\n    // assert excluded fields are set to the defaults\r\n    assertThat(target.annotatedField).isEqualTo(src.annotatedField);\r\n    assertThat(target.stringField).isEqualTo(src.stringField);\r\n}",
    "testExclusionStrategyWithMode": "{\r\n    SampleObjectForTest testObj \u003d new SampleObjectForTest(src.annotatedField + 5, src.stringField + \"blah,blah\", src.longField + 655L);\r\n    Gson gson \u003d createGson(new MyExclusionStrategy(String.class), false);\r\n    JsonObject json \u003d gson.toJsonTree(testObj).getAsJsonObject();\r\n    assertThat(json.get(\"annotatedField\").getAsInt()).isEqualTo(testObj.annotatedField);\r\n    assertThat(json.get(\"stringField\").getAsString()).isEqualTo(testObj.stringField);\r\n    assertThat(json.get(\"longField\").getAsLong()).isEqualTo(testObj.longField);\r\n    SampleObjectForTest target \u003d gson.fromJson(json, SampleObjectForTest.class);\r\n    assertThat(target.longField).isEqualTo(testObj.longField);\r\n    // assert excluded fields are set to the defaults\r\n    assertThat(target.annotatedField).isEqualTo(src.annotatedField);\r\n    assertThat(target.stringField).isEqualTo(src.stringField);\r\n}",
    "testExcludeTopLevelClassSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().addSerializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST).create();\r\n    assertThat(gson.toJson(new SampleObjectForTest(), SampleObjectForTest.class)).isEqualTo(\"null\");\r\n}",
    "createGson": "{\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    if (serialization) {\r\n        gsonBuilder.addSerializationExclusionStrategy(exclusionStrategy);\r\n    } else {\r\n        gsonBuilder.addDeserializationExclusionStrategy(exclusionStrategy);\r\n    }\r\n    return gsonBuilder.serializeNulls().create();\r\n}",
    "shouldSkipClass": "{\r\n    return (clazz \u003d\u003d typeToSkip);\r\n}",
    "shouldSkipField": "{\r\n    return f.getAnnotation(Foo.class) !\u003d null;\r\n}",
    "testExcludeTopLevelClassSerializationDoesNotImpactDeserialization": "{\r\n    Gson gson \u003d new GsonBuilder().addSerializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST).create();\r\n    String json \u003d \"{\\\"annotatedField\\\":1,\\\"stringField\\\":\\\"x\\\",\\\"longField\\\":2}\";\r\n    SampleObjectForTest value \u003d gson.fromJson(json, SampleObjectForTest.class);\r\n    assertThat(value.annotatedField).isEqualTo(1);\r\n    assertThat(value.stringField).isEqualTo(\"x\");\r\n    assertThat(value.longField).isEqualTo(2);\r\n}",
    "setUp": "{\r\n    src \u003d new SampleObjectForTest();\r\n}",
    "testExclusionStrategySerializationDoesNotImpactDeserialization": "{\r\n    String json \u003d \"{\\\"annotatedField\\\":1,\\\"stringField\\\":\\\"x\\\",\\\"longField\\\":2}\";\r\n    Gson gson \u003d createGson(new MyExclusionStrategy(String.class), true);\r\n    SampleObjectForTest value \u003d gson.fromJson(json, SampleObjectForTest.class);\r\n    assertThat(value.annotatedField).isEqualTo(1);\r\n    assertThat(value.stringField).isEqualTo(\"x\");\r\n    assertThat(value.longField).isEqualTo(2);\r\n}",
    "testExcludeTopLevelClassDeserialization": "{\r\n    Gson gson \u003d new GsonBuilder().addDeserializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST).create();\r\n    String json \u003d \"{\\\"annotatedField\\\":1,\\\"stringField\\\":\\\"x\\\",\\\"longField\\\":2}\";\r\n    SampleObjectForTest value \u003d gson.fromJson(json, SampleObjectForTest.class);\r\n    assertThat(value).isNull();\r\n}",
    "testExcludeTopLevelClassDeserializationDoesNotImpactSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().addDeserializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST).create();\r\n    String json \u003d gson.toJson(new SampleObjectForTest(), SampleObjectForTest.class);\r\n    assertThat(json).contains(\"\\\"stringField\\\"\");\r\n    assertThat(json).contains(\"\\\"annotatedField\\\"\");\r\n    assertThat(json).contains(\"\\\"longField\\\"\");\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithAdapter.java": {
    "read": "{\r\n    in.beginObject();\r\n    String name \u003d in.nextName();\r\n    if (!name.equals(\"custom\")) {\r\n        throw new IllegalArgumentException(\"Unexpected name: \" + name);\r\n    }\r\n    int i \u003d in.nextInt();\r\n    in.endObject();\r\n    return new ClassWithAdapter(i);\r\n}",
    "toString": "{\r\n    return \"ClassWithAdapter[\" + i + \"]\";\r\n}",
    "write": "{\r\n    out.beginObject();\r\n    out.name(\"custom\");\r\n    out.value(value.i);\r\n    out.endObject();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\InheritanceTest.java": {
    "setContains": "{\r\n    for (float value : values) {\r\n        if (!set.contains(value)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "testClassWithBaseFieldSerialization": "{\r\n    ClassWithBaseField sub \u003d new ClassWithBaseField(new Sub());\r\n    JsonObject json \u003d (JsonObject) gson.toJsonTree(sub);\r\n    JsonElement base \u003d json.getAsJsonObject().get(ClassWithBaseField.FIELD_KEY);\r\n    assertThat(base.getAsJsonObject().get(Sub.SUB_FIELD_KEY).getAsString()).isEqualTo(Sub.SUB_NAME);\r\n}",
    "testSubInterfacesOfCollectionDeserialization": "{\r\n    String json \u003d \"{\\\"list\\\":[0,1,2,3],\\\"queue\\\":[0,1,2,3],\\\"set\\\":[0.1,0.2,0.3,0.4],\" + \"\\\"sortedSet\\\":[\\\"a\\\",\\\"b\\\",\\\"c\\\",\\\"d\\\"]\" + \"}\";\r\n    ClassWithSubInterfacesOfCollection target \u003d gson.fromJson(json, ClassWithSubInterfacesOfCollection.class);\r\n    assertThat(target.listContains(0, 1, 2, 3)).isTrue();\r\n    assertThat(target.queueContains(0, 1, 2, 3)).isTrue();\r\n    assertThat(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)).isTrue();\r\n    assertThat(target.sortedSetContains(\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027)).isTrue();\r\n}",
    "testSubInterfacesOfCollectionSerialization": "{\r\n    List\u003cInteger\u003e list \u003d new LinkedList\u003c\u003e();\r\n    list.add(0);\r\n    list.add(1);\r\n    list.add(2);\r\n    list.add(3);\r\n    Queue\u003cLong\u003e queue \u003d new LinkedList\u003c\u003e();\r\n    queue.add(0L);\r\n    queue.add(1L);\r\n    queue.add(2L);\r\n    queue.add(3L);\r\n    Set\u003cFloat\u003e set \u003d new TreeSet\u003c\u003e();\r\n    set.add(0.1F);\r\n    set.add(0.2F);\r\n    set.add(0.3F);\r\n    set.add(0.4F);\r\n    SortedSet\u003cCharacter\u003e sortedSet \u003d new TreeSet\u003c\u003e();\r\n    sortedSet.add(\u0027a\u0027);\r\n    sortedSet.add(\u0027b\u0027);\r\n    sortedSet.add(\u0027c\u0027);\r\n    sortedSet.add(\u0027d\u0027);\r\n    ClassWithSubInterfacesOfCollection target \u003d new ClassWithSubInterfacesOfCollection(list, queue, set, sortedSet);\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "testSubClassDeserialization": "{\r\n    String json \u003d \"{\\\"value\\\":5,\\\"primitive1\\\":{\\\"longValue\\\":10,\\\"intValue\\\":20,\" + \"\\\"booleanValue\\\":false,\\\"stringValue\\\":\\\"stringValue\\\"},\\\"primitive2\\\":\" + \"{\\\"longValue\\\":30,\\\"intValue\\\":40,\\\"booleanValue\\\":true,\" + \"\\\"stringValue\\\":\\\"stringValue\\\"}}\";\r\n    SubTypeOfNested target \u003d gson.fromJson(json, SubTypeOfNested.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "sortedSetContains": "{\r\n    for (char value : values) {\r\n        if (!sortedSet.contains(value)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "testBaseSerializedAsBaseWhenSpecifiedWithExplicitTypeForToJsonMethod": "{\r\n    Base base \u003d new Sub();\r\n    String json \u003d gson.toJson(base, Base.class);\r\n    assertThat(json).contains(Base.BASE_NAME);\r\n    assertThat(json).doesNotContain(Sub.SUB_FIELD_KEY);\r\n}",
    "queueContains": "{\r\n    for (long value : values) {\r\n        if (!queue.contains(value)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "appendFields": "{\r\n    sb.append(\"\\\"value\\\":\").append(value).append(\",\");\r\n    super.appendFields(sb);\r\n}",
    "testClassWithBaseArrayFieldSerialization": "{\r\n    Base[] baseClasses \u003d new Base[] { new Sub(), new Sub() };\r\n    ClassWithBaseArrayField sub \u003d new ClassWithBaseArrayField(baseClasses);\r\n    JsonObject json \u003d gson.toJsonTree(sub).getAsJsonObject();\r\n    JsonArray bases \u003d json.get(ClassWithBaseArrayField.FIELD_KEY).getAsJsonArray();\r\n    for (JsonElement element : bases) {\r\n        assertThat(element.getAsJsonObject().get(Sub.SUB_FIELD_KEY).getAsString()).isEqualTo(Sub.SUB_NAME);\r\n    }\r\n}",
    "testSubClassSerialization": "{\r\n    SubTypeOfNested target \u003d new SubTypeOfNested(new BagOfPrimitives(10, 20, false, \"stringValue\"), new BagOfPrimitives(30, 40, true, \"stringValue\"));\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "testBaseSerializedAsBaseWhenSpecifiedWithExplicitType": "{\r\n    Base base \u003d new Sub();\r\n    JsonObject json \u003d gson.toJsonTree(base, Base.class).getAsJsonObject();\r\n    assertThat(json.get(Base.BASE_FIELD_KEY).getAsString()).isEqualTo(Base.BASE_NAME);\r\n    assertThat(json.get(Sub.SUB_FIELD_KEY)).isNull();\r\n}",
    "getExpectedJson": "{\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\"{\");\r\n    sb.append(\"\\\"list\\\":\");\r\n    append(sb, list).append(\",\");\r\n    sb.append(\"\\\"queue\\\":\");\r\n    append(sb, queue).append(\",\");\r\n    sb.append(\"\\\"set\\\":\");\r\n    append(sb, set).append(\",\");\r\n    sb.append(\"\\\"sortedSet\\\":\");\r\n    append(sb, sortedSet);\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "testBaseSerializedAsSubWhenSpecifiedWithExplicitTypeForToJsonMethod": "{\r\n    Base base \u003d new Sub();\r\n    String json \u003d gson.toJson(base, Sub.class);\r\n    assertThat(json).contains(Sub.SUB_NAME);\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "listContains": "{\r\n    for (int value : values) {\r\n        if (!list.contains(value)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "testBaseSerializedAsSubForToJsonMethod": "{\r\n    Base base \u003d new Sub();\r\n    String json \u003d gson.toJson(base);\r\n    assertThat(json).contains(Sub.SUB_NAME);\r\n}",
    "testClassWithBaseCollectionFieldSerialization": "{\r\n    Collection\u003cBase\u003e baseClasses \u003d new ArrayList\u003c\u003e();\r\n    baseClasses.add(new Sub());\r\n    baseClasses.add(new Sub());\r\n    ClassWithBaseCollectionField sub \u003d new ClassWithBaseCollectionField(baseClasses);\r\n    JsonObject json \u003d gson.toJsonTree(sub).getAsJsonObject();\r\n    JsonArray bases \u003d json.get(ClassWithBaseArrayField.FIELD_KEY).getAsJsonArray();\r\n    for (JsonElement element : bases) {\r\n        assertThat(element.getAsJsonObject().get(Sub.SUB_FIELD_KEY).getAsString()).isEqualTo(Sub.SUB_NAME);\r\n    }\r\n}",
    "testBaseSerializedAsSubWhenSpecifiedWithExplicitType": "{\r\n    Base base \u003d new Sub();\r\n    JsonObject json \u003d gson.toJsonTree(base, Sub.class).getAsJsonObject();\r\n    assertThat(json.get(Sub.SUB_FIELD_KEY).getAsString()).isEqualTo(Sub.SUB_NAME);\r\n}",
    "append": "{\r\n    sb.append(\"[\");\r\n    boolean first \u003d true;\r\n    for (Object o : c) {\r\n        if (!first) {\r\n            sb.append(\",\");\r\n        } else {\r\n            first \u003d false;\r\n        }\r\n        if (o instanceof String || o instanceof Character) {\r\n            sb.append(\u0027\\\"\u0027);\r\n        }\r\n        sb.append(o.toString());\r\n        if (o instanceof String || o instanceof Character) {\r\n            sb.append(\u0027\\\"\u0027);\r\n        }\r\n    }\r\n    sb.append(\"]\");\r\n    return sb;\r\n}",
    "testBaseSerializedAsSub": "{\r\n    Base base \u003d new Sub();\r\n    JsonObject json \u003d gson.toJsonTree(base).getAsJsonObject();\r\n    assertThat(json.get(Sub.SUB_FIELD_KEY).getAsString()).isEqualTo(Sub.SUB_NAME);\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\PostConstructAdapterFactory.java": {
    "read": "{\r\n    T result \u003d delegate.read(in);\r\n    if (result !\u003d null) {\r\n        try {\r\n            method.invoke(result);\r\n        } catch (IllegalAccessException e) {\r\n            throw new AssertionError();\r\n        } catch (InvocationTargetException e) {\r\n            if (e.getCause() instanceof RuntimeException)\r\n                throw (RuntimeException) e.getCause();\r\n            throw new RuntimeException(e.getCause());\r\n        }\r\n    }\r\n    return result;\r\n}",
    "create": "{\r\n    for (Class\u003c?\u003e t \u003d type.getRawType(); (t !\u003d Object.class) \u0026\u0026 (t.getSuperclass() !\u003d null); t \u003d t.getSuperclass()) {\r\n        for (Method m : t.getDeclaredMethods()) {\r\n            if (m.isAnnotationPresent(PostConstruct.class)) {\r\n                m.setAccessible(true);\r\n                TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n                return new PostConstructAdapter\u003c\u003e(delegate, m);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "write": "{\r\n    delegate.write(out, value);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\TypeAdapterFactory.java": {},
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\interceptors\\JsonPostDeserializer.java": {},
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\TestExecutor.java": {
    "same": "{\r\n    // This is essentially `return t`, but contains some redundant code to try\r\n    // prevent the code shrinkers from simplifying this\r\n    return Optional.of(t).map(v -\u003e Optional.of(v).get()).orElseThrow(() -\u003e new AssertionError(\"unreachable\"));\r\n}",
    "run": "{\r\n    String result;\r\n    try {\r\n        result \u003d resultSupplier.get();\r\n    } catch (Throwable t) {\r\n        throw new RuntimeException(\"Test failed: \" + name, t);\r\n    }\r\n    outputConsumer.accept(name, result);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\MockExclusionStrategy.java": {
    "shouldSkipClass": "{\r\n    return skipClass;\r\n}",
    "shouldSkipField": "{\r\n    return skipField;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonDeserializationContext.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\FieldNamingTest.java": {
    "getGsonWithNamingPolicy": "{\r\n    return new GsonBuilder().setFieldNamingPolicy(fieldNamingPolicy).create();\r\n}",
    "testUpperCaseWithUnderscores": "{\r\n    Gson gson \u003d getGsonWithNamingPolicy(UPPER_CASE_WITH_UNDERSCORES);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027LOWER_CAMEL\u0027:1,\u0027UPPER_CAMEL\u0027:2,\u0027_LOWER_CAMEL_LEADING_UNDERSCORE\u0027:3,\" + \"\u0027__UPPER_CAMEL_LEADING_UNDERSCORE\u0027:4,\u0027LOWER_WORDS\u0027:5,\u0027U_P_P_E_R__W_O_R_D_S\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027LOWER_ID\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "testLowerCaseWithDashes": "{\r\n    Gson gson \u003d getGsonWithNamingPolicy(LOWER_CASE_WITH_DASHES);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027lower-camel\u0027:1,\u0027upper-camel\u0027:2,\u0027_lower-camel-leading-underscore\u0027:3,\" + \"\u0027_-upper-camel-leading-underscore\u0027:4,\u0027lower_words\u0027:5,\u0027u-p-p-e-r_-w-o-r-d-s\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027lower-id\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "testUpperCamelCaseWithSpaces": "{\r\n    Gson gson \u003d getGsonWithNamingPolicy(UPPER_CAMEL_CASE_WITH_SPACES);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027Lower Camel\u0027:1,\u0027Upper Camel\u0027:2,\u0027_Lower Camel Leading Underscore\u0027:3,\" + \"\u0027_ Upper Camel Leading Underscore\u0027:4,\u0027Lower_words\u0027:5,\u0027U P P E R_ W O R D S\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027Lower Id\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "testUpperCamelCase": "{\r\n    Gson gson \u003d getGsonWithNamingPolicy(UPPER_CAMEL_CASE);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027LowerCamel\u0027:1,\u0027UpperCamel\u0027:2,\u0027_LowerCamelLeadingUnderscore\u0027:3,\" + \"\u0027_UpperCamelLeadingUnderscore\u0027:4,\u0027Lower_words\u0027:5,\u0027UPPER_WORDS\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027LowerId\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "testIdentity": "{\r\n    Gson gson \u003d getGsonWithNamingPolicy(IDENTITY);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027lowerCamel\u0027:1,\u0027UpperCamel\u0027:2,\u0027_lowerCamelLeadingUnderscore\u0027:3,\" + \"\u0027_UpperCamelLeadingUnderscore\u0027:4,\u0027lower_words\u0027:5,\u0027UPPER_WORDS\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027lowerId\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "testLowerCaseWithUnderscores": "{\r\n    Gson gson \u003d getGsonWithNamingPolicy(LOWER_CASE_WITH_UNDERSCORES);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027lower_camel\u0027:1,\u0027upper_camel\u0027:2,\u0027_lower_camel_leading_underscore\u0027:3,\" + \"\u0027__upper_camel_leading_underscore\u0027:4,\u0027lower_words\u0027:5,\u0027u_p_p_e_r__w_o_r_d_s\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027lower_id\u0027:8,\u0027_9\u0027:9}\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\FieldNamingStrategy.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\JsonReaderInternalAccess.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonToken.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\CircularReferenceTest.java": {
    "serialize": "{\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"property\", \"value\");\r\n    obj.add(\"child\", context.serialize(src.child));\r\n    return obj;\r\n}",
    "testSelfReferenceArrayFieldSerialization": "{\r\n    ClassWithSelfReferenceArray objA \u003d new ClassWithSelfReferenceArray();\r\n    objA.children \u003d new ClassWithSelfReferenceArray[] { objA };\r\n    try {\r\n        gson.toJson(objA);\r\n        fail(\"Circular reference to self can not be serialized!\");\r\n    } catch (StackOverflowError expected) {\r\n    }\r\n}",
    "testDirectedAcyclicGraphDeserialization": "{\r\n    String json \u003d \"{\\\"children\\\":[{\\\"children\\\":[{\\\"children\\\":[]}]},{\\\"children\\\":[]}]}\";\r\n    ContainsReferenceToSelfType target \u003d gson.fromJson(json, ContainsReferenceToSelfType.class);\r\n    assertThat(target).isNotNull();\r\n    assertThat(target.children).hasSize(2);\r\n}",
    "testCircularSerialization": "{\r\n    ContainsReferenceToSelfType a \u003d new ContainsReferenceToSelfType();\r\n    ContainsReferenceToSelfType b \u003d new ContainsReferenceToSelfType();\r\n    a.children.add(b);\r\n    b.children.add(a);\r\n    try {\r\n        gson.toJson(a);\r\n        fail(\"Circular types should not get printed!\");\r\n    } catch (StackOverflowError expected) {\r\n    }\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testDirectedAcyclicGraphSerialization": "{\r\n    ContainsReferenceToSelfType a \u003d new ContainsReferenceToSelfType();\r\n    ContainsReferenceToSelfType b \u003d new ContainsReferenceToSelfType();\r\n    ContainsReferenceToSelfType c \u003d new ContainsReferenceToSelfType();\r\n    a.children.add(b);\r\n    a.children.add(c);\r\n    b.children.add(c);\r\n    assertThat(gson.toJson(a)).isNotNull();\r\n}",
    "testSelfReferenceCustomHandlerSerialization": "{\r\n    ClassWithSelfReference obj \u003d new ClassWithSelfReference();\r\n    obj.child \u003d obj;\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ClassWithSelfReference.class, new JsonSerializer\u003cClassWithSelfReference\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(ClassWithSelfReference src, Type typeOfSrc, JsonSerializationContext context) {\r\n            JsonObject obj \u003d new JsonObject();\r\n            obj.addProperty(\"property\", \"value\");\r\n            obj.add(\"child\", context.serialize(src.child));\r\n            return obj;\r\n        }\r\n    }).create();\r\n    try {\r\n        gson.toJson(obj);\r\n        fail(\"Circular reference to self can not be serialized!\");\r\n    } catch (StackOverflowError expected) {\r\n    }\r\n}",
    "testSelfReferenceIgnoredInSerialization": "{\r\n    ClassOverridingEquals objA \u003d new ClassOverridingEquals();\r\n    objA.ref \u003d objA;\r\n    String json \u003d gson.toJson(objA);\r\n    // self-reference is ignored\r\n    assertThat(json).doesNotContain(\"ref\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\JsonObjectAsMapTest.java": {
    "testClear": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    map.clear();\r\n    assertThat(map).hasSize(0);\r\n    assertThat(o.size()).isEqualTo(0);\r\n}",
    "testEqualsHashCode": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    MoreAsserts.assertEqualsAndHashCode(map, Collections.singletonMap(\"a\", new JsonPrimitive(1)));\r\n    assertThat(map.equals(Collections.emptyMap())).isFalse();\r\n    assertThat(map.equals(Collections.singletonMap(\"a\", new JsonPrimitive(2)))).isFalse();\r\n}",
    "testRemove": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map.remove(\"b\")).isNull();\r\n    assertThat(map).hasSize(1);\r\n    JsonElement old \u003d map.remove(\"a\");\r\n    assertThat(old).isEqualTo(new JsonPrimitive(1));\r\n    assertThat(map).hasSize(0);\r\n    assertThat(map.remove(\"a\")).isNull();\r\n    assertThat(map).hasSize(0);\r\n    assertThat(o.size()).isEqualTo(0);\r\n    assertThat(map.remove(null)).isNull();\r\n}",
    "testPut": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map.put(\"a\", new JsonPrimitive(1))).isNull();\r\n    assertThat(map.get(\"a\")).isEqualTo(new JsonPrimitive(1));\r\n    JsonElement old \u003d map.put(\"a\", new JsonPrimitive(2));\r\n    assertThat(old).isEqualTo(new JsonPrimitive(1));\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"a\")).isEqualTo(new JsonPrimitive(2));\r\n    assertThat(o.get(\"a\")).isEqualTo(new JsonPrimitive(2));\r\n    assertThat(map.put(\"b\", JsonNull.INSTANCE)).isNull();\r\n    assertThat(map.get(\"b\")).isEqualTo(JsonNull.INSTANCE);\r\n    try {\r\n        map.put(null, new JsonPrimitive(1));\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"key \u003d\u003d null\");\r\n    }\r\n    try {\r\n        map.put(\"a\", null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n}",
    "testEntrySet": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"b\", 2);\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    Set\u003cEntry\u003cString, JsonElement\u003e\u003e entrySet \u003d map.entrySet();\r\n    List\u003cEntry\u003c?, ?\u003e\u003e expectedEntrySet \u003d Arrays.\u003cEntry\u003c?, ?\u003e\u003easList(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(2)), new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(1)));\r\n    // Should contain entries in same order\r\n    assertThat(new ArrayList\u003c\u003e(entrySet)).isEqualTo(expectedEntrySet);\r\n    try {\r\n        entrySet.add(new SimpleEntry\u003cString, JsonElement\u003e(\"c\", new JsonPrimitive(3)));\r\n        fail();\r\n    } catch (UnsupportedOperationException e) {\r\n    }\r\n    assertThat(entrySet.remove(new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(1)))).isTrue();\r\n    assertThat(map.entrySet()).isEqualTo(Collections.singleton(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(2))));\r\n    assertThat(o.entrySet()).isEqualTo(Collections.singleton(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(2))));\r\n    // Should return false because entry has already been removed\r\n    assertThat(entrySet.remove(new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(1)))).isFalse();\r\n    Entry\u003cString, JsonElement\u003e entry \u003d entrySet.iterator().next();\r\n    JsonElement old \u003d entry.setValue(new JsonPrimitive(3));\r\n    assertThat(old).isEqualTo(new JsonPrimitive(2));\r\n    assertThat(map.entrySet()).isEqualTo(Collections.singleton(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(3))));\r\n    assertThat(o.entrySet()).isEqualTo(Collections.singleton(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(3))));\r\n    try {\r\n        entry.setValue(null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n}",
    "testPutAll": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e otherMap \u003d new HashMap\u003c\u003e();\r\n    otherMap.put(\"a\", new JsonPrimitive(2));\r\n    otherMap.put(\"b\", new JsonPrimitive(3));\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    map.putAll(otherMap);\r\n    assertThat(map).hasSize(2);\r\n    assertThat(map.get(\"a\")).isEqualTo(new JsonPrimitive(2));\r\n    assertThat(map.get(\"b\")).isEqualTo(new JsonPrimitive(3));\r\n    try {\r\n        map.putAll(Collections.\u003cString, JsonElement\u003esingletonMap(null, new JsonPrimitive(1)));\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"key \u003d\u003d null\");\r\n    }\r\n    try {\r\n        map.putAll(Collections.\u003cString, JsonElement\u003esingletonMap(\"a\", null));\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n}",
    "testContainsValue": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    o.add(\"b\", JsonNull.INSTANCE);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map.containsValue(new JsonPrimitive(1))).isTrue();\r\n    assertThat(map.containsValue(new JsonPrimitive(2))).isFalse();\r\n    assertThat(map.containsValue(null)).isFalse();\r\n    @SuppressWarnings({ \"unlikely-arg-type\", \"CollectionIncompatibleType\" })\r\n    boolean // should only contain JsonPrimitive(1)\r\n    containsInt \u003d map.containsValue(1);\r\n    assertThat(containsInt).isFalse();\r\n}",
    "testKeySet": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"b\", 1);\r\n    o.addProperty(\"a\", 2);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    Set\u003cString\u003e keySet \u003d map.keySet();\r\n    // Should contain keys in same order\r\n    assertThat(keySet).containsExactly(\"b\", \"a\").inOrder();\r\n    // Key set doesn\u0027t support insertions\r\n    try {\r\n        keySet.add(\"c\");\r\n        fail();\r\n    } catch (UnsupportedOperationException e) {\r\n    }\r\n    assertThat(keySet.remove(\"a\")).isTrue();\r\n    assertThat(map.keySet()).isEqualTo(Collections.singleton(\"b\"));\r\n    assertThat(o.keySet()).isEqualTo(Collections.singleton(\"b\"));\r\n}",
    "testGet": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map.get(\"a\")).isEqualTo(new JsonPrimitive(1));\r\n    assertThat(map.get(\"b\")).isNull();\r\n    assertThat(map.get(null)).isNull();\r\n}",
    "testViewUpdates": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    o.addProperty(\"a\", 1);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"a\")).isEqualTo(new JsonPrimitive(1));\r\n    map.put(\"b\", new JsonPrimitive(2));\r\n    assertThat(o.size()).isEqualTo(2);\r\n    assertThat(map.get(\"b\")).isEqualTo(new JsonPrimitive(2));\r\n}",
    "testSize": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    assertThat(o.asMap().size()).isEqualTo(0);\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map).hasSize(1);\r\n    map.clear();\r\n    assertThat(map).hasSize(0);\r\n    assertThat(o.size()).isEqualTo(0);\r\n}",
    "testContainsKey": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map.containsKey(\"a\")).isTrue();\r\n    assertThat(map.containsKey(\"b\")).isFalse();\r\n    assertThat(map.containsKey(null)).isFalse();\r\n}",
    "testValues": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 2);\r\n    o.addProperty(\"b\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    Collection\u003cJsonElement\u003e values \u003d map.values();\r\n    // Should contain values in same order\r\n    assertThat(values).containsExactly(new JsonPrimitive(2), new JsonPrimitive(1)).inOrder();\r\n    // Values collection doesn\u0027t support insertions\r\n    try {\r\n        values.add(new JsonPrimitive(3));\r\n        fail();\r\n    } catch (UnsupportedOperationException e) {\r\n    }\r\n    assertThat(values.remove(new JsonPrimitive(2))).isTrue();\r\n    assertThat(new ArrayList\u003c\u003e(map.values())).isEqualTo(Collections.singletonList(new JsonPrimitive(1)));\r\n    assertThat(o.size()).isEqualTo(1);\r\n    assertThat(o.get(\"b\")).isEqualTo(new JsonPrimitive(1));\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\PrimitiveCharacterTest.java": {
    "testPrimitiveCharacterAutoboxedSerialization": "{\r\n    assertThat(gson.toJson(\u0027A\u0027)).isEqualTo(\"\\\"A\\\"\");\r\n    assertThat(gson.toJson(\u0027A\u0027, char.class)).isEqualTo(\"\\\"A\\\"\");\r\n    assertThat(gson.toJson(\u0027A\u0027, Character.class)).isEqualTo(\"\\\"A\\\"\");\r\n}",
    "testPrimitiveCharacterAutoboxedDeserialization": "{\r\n    char expected \u003d \u0027a\u0027;\r\n    char actual \u003d gson.fromJson(\"a\", char.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    actual \u003d gson.fromJson(\"\\\"a\\\"\", char.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    actual \u003d gson.fromJson(\"a\", Character.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonTreeTest.java": {
    "testToJsonTreeObjectType": "{\r\n    SubTypeOfBagOfPrimitives bag \u003d new SubTypeOfBagOfPrimitives(10L, 5, false, \"foo\", 1.4F);\r\n    JsonElement json \u003d gson.toJsonTree(bag, BagOfPrimitives.class);\r\n    assertThat(json.isJsonObject()).isTrue();\r\n    JsonObject obj \u003d json.getAsJsonObject();\r\n    Set\u003cEntry\u003cString, JsonElement\u003e\u003e children \u003d obj.entrySet();\r\n    assertThat(children).hasSize(4);\r\n    assertContains(obj, new JsonPrimitive(10L));\r\n    assertContains(obj, new JsonPrimitive(5));\r\n    assertContains(obj, new JsonPrimitive(false));\r\n    assertContains(obj, new JsonPrimitive(\"foo\"));\r\n}",
    "testToJsonTree": "{\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives(10L, 5, false, \"foo\");\r\n    JsonElement json \u003d gson.toJsonTree(bag);\r\n    assertThat(json.isJsonObject()).isTrue();\r\n    JsonObject obj \u003d json.getAsJsonObject();\r\n    Set\u003cEntry\u003cString, JsonElement\u003e\u003e children \u003d obj.entrySet();\r\n    assertThat(children).hasSize(4);\r\n    assertContains(obj, new JsonPrimitive(10L));\r\n    assertContains(obj, new JsonPrimitive(5));\r\n    assertContains(obj, new JsonPrimitive(false));\r\n    assertContains(obj, new JsonPrimitive(\"foo\"));\r\n}",
    "testJsonTreeToString": "{\r\n    SubTypeOfBagOfPrimitives bag \u003d new SubTypeOfBagOfPrimitives(10L, 5, false, \"foo\", 1.4F);\r\n    String json1 \u003d gson.toJson(bag);\r\n    JsonElement jsonElement \u003d gson.toJsonTree(bag, SubTypeOfBagOfPrimitives.class);\r\n    String json2 \u003d gson.toJson(jsonElement);\r\n    assertThat(json2).isEqualTo(json1);\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testJsonTreeNull": "{\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives(10L, 5, false, null);\r\n    JsonObject jsonElement \u003d (JsonObject) gson.toJsonTree(bag, BagOfPrimitives.class);\r\n    assertThat(jsonElement.has(\"stringValue\")).isFalse();\r\n}",
    "assertContains": "{\r\n    for (Map.Entry\u003cString, JsonElement\u003e entry : json.entrySet()) {\r\n        JsonElement node \u003d entry.getValue();\r\n        if (node.isJsonPrimitive()) {\r\n            if (node.getAsJsonPrimitive().equals(child)) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    fail();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterSerializerDeserializerTest.java": {
    "testJsonSerializerDeserializerBasedJsonAdapterOnFields": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Computer(new User(\"Inderjeet Singh\"), null, new User(\"Jesse Wilson\")));\r\n    assertThat(json).isEqualTo(\"{\\\"user1\\\":\\\"UserSerializer\\\",\\\"user3\\\":\\\"UserSerializerDeserializer\\\"}\");\r\n    Computer computer \u003d gson.fromJson(\"{\u0027user2\u0027:\u0027Jesse Wilson\u0027,\u0027user3\u0027:\u0027Jake Wharton\u0027}\", Computer.class);\r\n    assertThat(computer.user2.name).isEqualTo(\"UserDeserializer\");\r\n    assertThat(computer.user3.name).isEqualTo(\"UserSerializerDeserializer\");\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(\"BaseIntegerAdapter\");\r\n}",
    "testJsonAdapterNullSafe": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(User.class, new TypeAdapter\u003cUser\u003e() {\r\n\r\n        @Override\r\n        public User read(JsonReader in) throws IOException {\r\n            in.nextNull();\r\n            return new User(\"fallback-read\");\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, User value) throws IOException {\r\n            assertThat(value).isNull();\r\n            out.value(\"fallback-write\");\r\n        }\r\n    }).serializeNulls().create();\r\n    String json \u003d gson.toJson(new WithNullSafe(null, null, null, null));\r\n    // Only nullSafe\u003dtrue serializer writes null; for @JsonAdapter with deserializer nullSafe is ignored when serializing\r\n    assertThat(json).isEqualTo(\"{\\\"userS\\\":\\\"UserSerializer\\\",\\\"userSN\\\":null,\\\"userD\\\":\\\"fallback-write\\\",\\\"userDN\\\":\\\"fallback-write\\\"}\");\r\n    WithNullSafe deserialized \u003d gson.fromJson(\"{\\\"userS\\\":null,\\\"userSN\\\":null,\\\"userD\\\":null,\\\"userDN\\\":null}\", WithNullSafe.class);\r\n    // For @JsonAdapter with serializer nullSafe is ignored when deserializing\r\n    assertThat(deserialized.userS.name).isEqualTo(\"fallback-read\");\r\n    assertThat(deserialized.userSN.name).isEqualTo(\"fallback-read\");\r\n    assertThat(deserialized.userD.name).isEqualTo(\"UserDeserializer\");\r\n    assertThat(deserialized.userDN).isNull();\r\n}",
    "read": "{\r\n    in.nextNull();\r\n    return new User(\"fallback-read\");\r\n}",
    "testDifferentJsonAdaptersForGenericFieldsOfSameRawType": "{\r\n    Container c \u003d new Container(\"Foo\", 10);\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(c);\r\n    assertThat(json).contains(\"\\\"a\\\":\\\"BaseStringAdapter\\\"\");\r\n    assertThat(json).contains(\"\\\"b\\\":\\\"BaseIntegerAdapter\\\"\");\r\n}",
    "testJsonSerializerDeserializerBasedJsonAdapterOnClass": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Computer2(new User2(\"Inderjeet Singh\")));\r\n    assertThat(json).isEqualTo(\"{\\\"user\\\":\\\"UserSerializerDeserializer2\\\"}\");\r\n    Computer2 computer \u003d gson.fromJson(\"{\u0027user\u0027:\u0027Inderjeet Singh\u0027}\", Computer2.class);\r\n    assertThat(computer.user.name).isEqualTo(\"UserSerializerDeserializer2\");\r\n}",
    "write": "{\r\n    assertThat(value).isNull();\r\n    out.value(\"fallback-write\");\r\n}",
    "deserialize": "{\r\n    return new User2(\"UserSerializerDeserializer2\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\StreamingTypeAdaptersTest.java": {
    "testDeserialize2dArray": "{\r\n    TypeAdapter\u003cdouble[][]\u003e arrayAdapter \u003d miniGson.getAdapter(new TypeToken\u003cdouble[][]\u003e() {\r\n    });\r\n    double[][] array \u003d arrayAdapter.fromJson(\"[[1.0,2.0],[3.0]]\");\r\n    double[][] expected \u003d { { 1.0, 2.0 }, { 3.0 } };\r\n    assertThat(array).isEqualTo(expected);\r\n}",
    "read": "{\r\n    List\u003cString\u003e values \u003d Splitter.on(\u0027,\u0027).splitToList(in.nextString());\r\n    return new Person(values.get(0), Integer.parseInt(values.get(1)));\r\n}",
    "usePersonNameAdapter": "{\r\n    TypeAdapter\u003cPerson\u003e personNameAdapter \u003d new TypeAdapter\u003cPerson\u003e() {\r\n\r\n        @Override\r\n        public Person read(JsonReader in) throws IOException {\r\n            String name \u003d in.nextString();\r\n            return new Person(name, -1);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Person value) throws IOException {\r\n            out.value(value.name);\r\n        }\r\n    };\r\n    miniGson \u003d new GsonBuilder().registerTypeAdapter(Person.class, personNameAdapter).create();\r\n    truckAdapter \u003d miniGson.getAdapter(Truck.class);\r\n}",
    "testSerializeMap": "{\r\n    Map\u003cString, Double\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", 5.0);\r\n    map.put(\"b\", 10.0);\r\n    assertThat(mapAdapter.toJson(map).replace(\u0027\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027a\u0027:5.0,\u0027b\u0027:10.0}\");\r\n}",
    "testSerializeRecursive": "{\r\n    TypeAdapter\u003cNode\u003e nodeAdapter \u003d miniGson.getAdapter(Node.class);\r\n    Node root \u003d new Node(\"root\");\r\n    root.left \u003d new Node(\"left\");\r\n    root.right \u003d new Node(\"right\");\r\n    assertThat(nodeAdapter.toJson(root).replace(\u0027\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027label\u0027:\u0027root\u0027,\" + \"\u0027left\u0027:{\u0027label\u0027:\u0027left\u0027,\u0027left\u0027:null,\u0027right\u0027:null},\" + \"\u0027right\u0027:{\u0027label\u0027:\u0027right\u0027,\u0027left\u0027:null,\u0027right\u0027:null}}\");\r\n}",
    "testDeserialize1dArray": "{\r\n    TypeAdapter\u003cdouble[]\u003e arrayAdapter \u003d miniGson.getAdapter(new TypeToken\u003cdouble[]\u003e() {\r\n    });\r\n    double[] array \u003d arrayAdapter.fromJson(\"[1.0,2.0,3.0]\");\r\n    assertThat(array).isEqualTo(new double[] { 1.0, 2.0, 3.0 });\r\n}",
    "testDeserializeMap": "{\r\n    Map\u003cString, Double\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", 5.0);\r\n    map.put(\"b\", 10.0);\r\n    assertThat(mapAdapter.fromJson(\"{\u0027a\u0027:5.0,\u0027b\u0027:10.0}\".replace(\u0027\\\u0027\u0027, \u0027\\\"\u0027))).isEqualTo(map);\r\n}",
    "testSerialize1dArray": "{\r\n    TypeAdapter\u003cdouble[]\u003e arrayAdapter \u003d miniGson.getAdapter(new TypeToken\u003cdouble[]\u003e() {\r\n    });\r\n    assertThat(arrayAdapter.toJson(new double[] { 1.0, 2.0, 3.0 })).isEqualTo(\"[1.0,2.0,3.0]\");\r\n}",
    "testFromJsonTree": "{\r\n    JsonObject truckObject \u003d new JsonObject();\r\n    truckObject.add(\"horsePower\", new JsonPrimitive(300));\r\n    JsonArray passengersArray \u003d new JsonArray();\r\n    JsonObject jesseObject \u003d new JsonObject();\r\n    jesseObject.add(\"age\", new JsonPrimitive(30));\r\n    jesseObject.add(\"name\", new JsonPrimitive(\"Jesse\"));\r\n    passengersArray.add(jesseObject);\r\n    truckObject.add(\"passengers\", passengersArray);\r\n    Truck truck \u003d truckAdapter.fromJsonTree(truckObject);\r\n    assertThat(truck.horsePower).isEqualTo(300.0);\r\n    assertThat(truck.passengers).isEqualTo(Arrays.asList(new Person(\"Jesse\", 30)));\r\n}",
    "testSerialize": "{\r\n    Truck truck \u003d new Truck();\r\n    truck.passengers \u003d Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29));\r\n    truck.horsePower \u003d 300;\r\n    assertThat(truckAdapter.toJson(truck).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027horsePower\u0027:300.0,\" + \"\u0027passengers\u0027:[{\u0027age\u0027:29,\u0027name\u0027:\u0027Jesse\u0027},{\u0027age\u0027:29,\u0027name\u0027:\u0027Jodie\u0027}]}\");\r\n}",
    "testNullSafe": "{\r\n    TypeAdapter\u003cPerson\u003e typeAdapter \u003d new TypeAdapter\u003cPerson\u003e() {\r\n\r\n        @Override\r\n        public Person read(JsonReader in) throws IOException {\r\n            List\u003cString\u003e values \u003d Splitter.on(\u0027,\u0027).splitToList(in.nextString());\r\n            return new Person(values.get(0), Integer.parseInt(values.get(1)));\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Person person) throws IOException {\r\n            out.value(person.name + \",\" + person.age);\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Person.class, typeAdapter).create();\r\n    Truck truck \u003d new Truck();\r\n    truck.horsePower \u003d 1.0D;\r\n    truck.passengers \u003d new ArrayList\u003c\u003e();\r\n    truck.passengers.add(null);\r\n    truck.passengers.add(new Person(\"jesse\", 30));\r\n    try {\r\n        gson.toJson(truck, Truck.class);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n    String json \u003d \"{horsePower:1.0,passengers:[null,\u0027jesse,30\u0027]}\";\r\n    try {\r\n        gson.fromJson(json, Truck.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"java.lang.IllegalStateException: Expected a string but was NULL at line 1 column 33 path $.passengers[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#adapter-not-null-safe\");\r\n    }\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(Person.class, typeAdapter.nullSafe()).create();\r\n    assertThat(gson.toJson(truck, Truck.class)).isEqualTo(\"{\\\"horsePower\\\":1.0,\\\"passengers\\\":[null,\\\"jesse,30\\\"]}\");\r\n    truck \u003d gson.fromJson(json, Truck.class);\r\n    assertThat(truck.horsePower).isEqualTo(1.0D);\r\n    assertThat(truck.passengers.get(0)).isNull();\r\n    assertThat(truck.passengers.get(1).name).isEqualTo(\"jesse\");\r\n}",
    "testSerializeWithCustomTypeAdapter": "{\r\n    usePersonNameAdapter();\r\n    Truck truck \u003d new Truck();\r\n    truck.passengers \u003d Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29));\r\n    assertThat(truckAdapter.toJson(truck).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:[\u0027Jesse\u0027,\u0027Jodie\u0027]}\");\r\n}",
    "testSerialize2dArray": "{\r\n    TypeAdapter\u003cdouble[][]\u003e arrayAdapter \u003d miniGson.getAdapter(new TypeToken\u003cdouble[][]\u003e() {\r\n    });\r\n    double[][] array \u003d { { 1.0, 2.0 }, { 3.0 } };\r\n    assertThat(arrayAdapter.toJson(array)).isEqualTo(\"[[1.0,2.0],[3.0]]\");\r\n}",
    "hashCode": "{\r\n    return name.hashCode() ^ age;\r\n}",
    "equals": "{\r\n    return o instanceof Person \u0026\u0026 ((Person) o).name.equals(name) \u0026\u0026 ((Person) o).age \u003d\u003d age;\r\n}",
    "testSerializeNullField": "{\r\n    Truck truck \u003d new Truck();\r\n    truck.passengers \u003d null;\r\n    assertThat(truckAdapter.toJson(truck).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:null}\");\r\n}",
    "testSerializeNullObject": "{\r\n    Truck truck \u003d new Truck();\r\n    truck.passengers \u003d Arrays.asList((Person) null);\r\n    assertThat(truckAdapter.toJson(truck).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:[null]}\");\r\n}",
    "testDeserializeNullField": "{\r\n    Truck truck \u003d truckAdapter.fromJson(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:null}\".replace(\u0027\\\u0027\u0027, \u0027\\\"\u0027));\r\n    assertThat(truck.passengers).isNull();\r\n}",
    "testDeserializeWithCustomTypeAdapter": "{\r\n    usePersonNameAdapter();\r\n    Truck truck \u003d truckAdapter.fromJson(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:[\u0027Jesse\u0027,\u0027Jodie\u0027]}\".replace(\u0027\\\u0027\u0027, \u0027\\\"\u0027));\r\n    assertThat(truck.passengers).isEqualTo(Arrays.asList(new Person(\"Jesse\", -1), new Person(\"Jodie\", -1)));\r\n}",
    "testDeserializeNullObject": "{\r\n    Truck truck \u003d truckAdapter.fromJson(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:[null]}\".replace(\u0027\\\u0027\u0027, \u0027\\\"\u0027));\r\n    assertThat(truck.passengers).isEqualTo(Arrays.asList((Person) null));\r\n}",
    "write": "{\r\n    out.value(person.name + \",\" + person.age);\r\n}",
    "testDeserialize": "{\r\n    String json \u003d \"{\u0027horsePower\u0027:300.0,\" + \"\u0027passengers\u0027:[{\u0027age\u0027:29,\u0027name\u0027:\u0027Jesse\u0027},{\u0027age\u0027:29,\u0027name\u0027:\u0027Jodie\u0027}]}\";\r\n    Truck truck \u003d truckAdapter.fromJson(json.replace(\u0027\\\u0027\u0027, \u0027\\\"\u0027));\r\n    assertThat(truck.horsePower).isEqualTo(300.0);\r\n    assertThat(truck.passengers).isEqualTo(Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29)));\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapterRuntimeTypeWrapper.java": {
    "read": "{\r\n    return delegate.read(in);\r\n}",
    "getRuntimeTypeIfMoreSpecific": "{\r\n    if (value !\u003d null \u0026\u0026 (type instanceof Class\u003c?\u003e || type instanceof TypeVariable\u003c?\u003e)) {\r\n        type \u003d value.getClass();\r\n    }\r\n    return type;\r\n}",
    "write": "{\r\n    // Order of preference for choosing type adapters\r\n    // First preference: a type adapter registered for the runtime type\r\n    // Second preference: a type adapter registered for the declared type\r\n    // Third preference: reflective type adapter for the runtime type (if it is a subclass of the declared type)\r\n    // Fourth preference: reflective type adapter for the declared type\r\n    TypeAdapter\u003cT\u003e chosen \u003d delegate;\r\n    Type runtimeType \u003d getRuntimeTypeIfMoreSpecific(type, value);\r\n    if (runtimeType !\u003d type) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e runtimeTypeAdapter \u003d (TypeAdapter\u003cT\u003e) context.getAdapter(TypeToken.get(runtimeType));\r\n        // For backward compatibility only check ReflectiveTypeAdapterFactory.Adapter here but not any other\r\n        // wrapping adapters, see https://github.com/google/gson/pull/1787#issuecomment-1222175189\r\n        if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {\r\n            // The user registered a type adapter for the runtime type, so we will use that\r\n            chosen \u003d runtimeTypeAdapter;\r\n        } else if (!isReflective(delegate)) {\r\n            // The user registered a type adapter for Base class, so we prefer it over the\r\n            // reflective type adapter for the runtime type\r\n            chosen \u003d delegate;\r\n        } else {\r\n            // Use the type adapter for runtime type\r\n            chosen \u003d runtimeTypeAdapter;\r\n        }\r\n    }\r\n    chosen.write(out, value);\r\n}",
    "isReflective": "{\r\n    // Run this in loop in case multiple delegating adapters are nested\r\n    while (typeAdapter instanceof SerializationDelegatingTypeAdapter) {\r\n        TypeAdapter\u003c?\u003e delegate \u003d ((SerializationDelegatingTypeAdapter\u003c?\u003e) typeAdapter).getSerializationDelegate();\r\n        // Break if adapter does not delegate serialization\r\n        if (delegate \u003d\u003d typeAdapter) {\r\n            break;\r\n        }\r\n        typeAdapter \u003d delegate;\r\n    }\r\n    return typeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\MapAsArrayTypeAdapterTest.java": {
    "testTwoTypesCollapseToOneSerialize": "{\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    Map\u003cNumber, String\u003e original \u003d new LinkedHashMap\u003c\u003e();\r\n    original.put(1.0D, \"a\");\r\n    original.put(1.0F, \"b\");\r\n    try {\r\n        gson.toJson(original, new TypeToken\u003cMap\u003cNumber, String\u003e\u003e() {\r\n        }.getType());\r\n        // we no longer hash keys at serialization time\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "hashCode": "{\r\n    return x * 37 + y;\r\n}",
    "equals": "{\r\n    return o instanceof Point \u0026\u0026 ((Point) o).x \u003d\u003d x \u0026\u0026 ((Point) o).y \u003d\u003d y;\r\n}",
    "testTwoTypesCollapseToOneDeserialize": "{\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    String s \u003d \"[[\\\"1.00\\\",\\\"a\\\"],[\\\"1.0\\\",\\\"b\\\"]]\";\r\n    try {\r\n        gson.fromJson(s, new TypeToken\u003cMap\u003cDouble, String\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testMultipleEnableComplexKeyRegistrationHasNoEffect": "{\r\n    Type type \u003d new TypeToken\u003cMap\u003cPoint, String\u003e\u003e() {\r\n    }.getType();\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().enableComplexMapKeySerialization().create();\r\n    Map\u003cPoint, String\u003e original \u003d new LinkedHashMap\u003c\u003e();\r\n    original.put(new Point(6, 5), \"abc\");\r\n    original.put(new Point(1, 8), \"def\");\r\n    String json \u003d gson.toJson(original, type);\r\n    assertThat(json).isEqualTo(\"[[{\\\"x\\\":6,\\\"y\\\":5},\\\"abc\\\"],[{\\\"x\\\":1,\\\"y\\\":8},\\\"def\\\"]]\");\r\n    assertThat(gson.\u003cMap\u003cPoint, String\u003e\u003efromJson(json, type)).isEqualTo(original);\r\n}",
    "testSerializeComplexMapWithTypeAdapter": "{\r\n    Type type \u003d new TypeToken\u003cMap\u003cPoint, String\u003e\u003e() {\r\n    }.getType();\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    Map\u003cPoint, String\u003e original \u003d new LinkedHashMap\u003c\u003e();\r\n    original.put(new Point(5, 5), \"a\");\r\n    original.put(new Point(8, 8), \"b\");\r\n    String json \u003d gson.toJson(original, type);\r\n    assertThat(json).isEqualTo(\"[[{\\\"x\\\":5,\\\"y\\\":5},\\\"a\\\"],[{\\\"x\\\":8,\\\"y\\\":8},\\\"b\\\"]]\");\r\n    assertThat(gson.\u003cMap\u003cPoint, String\u003e\u003efromJson(json, type)).isEqualTo(original);\r\n    // test that registering a type adapter for one map doesn\u0027t interfere with others\r\n    Map\u003cString, Boolean\u003e otherMap \u003d new LinkedHashMap\u003c\u003e();\r\n    otherMap.put(\"t\", true);\r\n    otherMap.put(\"f\", false);\r\n    assertThat(gson.toJson(otherMap, Map.class)).isEqualTo(\"{\\\"t\\\":true,\\\"f\\\":false}\");\r\n    assertThat(gson.toJson(otherMap, new TypeToken\u003cMap\u003cString, Boolean\u003e\u003e() {\r\n    }.getType())).isEqualTo(\"{\\\"t\\\":true,\\\"f\\\":false}\");\r\n    assertThat(gson.\u003cObject\u003efromJson(\"{\\\"t\\\":true,\\\"f\\\":false}\", new TypeToken\u003cMap\u003cString, Boolean\u003e\u003e() {\r\n    }.getType())).isEqualTo(otherMap);\r\n}",
    "testMapWithTypeVariableDeserialization": "{\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    String json \u003d \"{map:[[{x:2,y:3},{x:4,y:5}]]}\";\r\n    Type type \u003d new TypeToken\u003cPointWithProperty\u003cPoint\u003e\u003e() {\r\n    }.getType();\r\n    PointWithProperty\u003cPoint\u003e map \u003d gson.fromJson(json, type);\r\n    Point key \u003d map.map.keySet().iterator().next();\r\n    Point value \u003d map.map.values().iterator().next();\r\n    assertThat(key).isEqualTo(new Point(2, 3));\r\n    assertThat(value).isEqualTo(new Point(4, 5));\r\n}",
    "toString": "{\r\n    return \"(\" + x + \",\" + y + \")\";\r\n}",
    "testMapWithTypeVariableSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    PointWithProperty\u003cPoint\u003e map \u003d new PointWithProperty\u003c\u003e();\r\n    map.map.put(new Point(2, 3), new Point(4, 5));\r\n    Type type \u003d new TypeToken\u003cPointWithProperty\u003cPoint\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, type);\r\n    assertThat(json).isEqualTo(\"{\\\"map\\\":[[{\\\"x\\\":2,\\\"y\\\":3},{\\\"x\\\":4,\\\"y\\\":5}]]}\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\JavaVersionTest.java": {
    "testJava10": "{\r\n    // Oracle JDK 10.0.1\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"10.0.1\")).isEqualTo(10);\r\n}",
    "testUnknownVersionFormat": "{\r\n    // unknown format\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"Java9\")).isEqualTo(6);\r\n}",
    "testJava6": "{\r\n    // http://www.oracle.com/technetwork/java/javase/version-6-141920.html\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.6.0\")).isEqualTo(6);\r\n}",
    "testJava7": "{\r\n    // http://www.oracle.com/technetwork/java/javase/jdk7-naming-418744.html\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.7.0\")).isEqualTo(7);\r\n}",
    "testGetMajorJavaVersion": "{\r\n    // Gson currently requires at least Java 7\r\n    assertThat(JavaVersion.getMajorJavaVersion() \u003e\u003d 7).isTrue();\r\n}",
    "testJava8": "{\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8\")).isEqualTo(8);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0\")).isEqualTo(8);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0_131\")).isEqualTo(8);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0_60-ea\")).isEqualTo(8);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0_111-internal\")).isEqualTo(8);\r\n    // openjdk8 per https://github.com/AdoptOpenJDK/openjdk-build/issues/93\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0-internal\")).isEqualTo(8);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0_131-adoptopenjdk\")).isEqualTo(8);\r\n}",
    "testJava9": "{\r\n    // Legacy style\r\n    // Oracle JDK 9\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9.0.4\")).isEqualTo(9);\r\n    // Debian as reported in https://github.com/google/gson/issues/1310\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9-Debian\")).isEqualTo(9);\r\n    // New style\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9-ea+19\")).isEqualTo(9);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9+100\")).isEqualTo(9);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9.0.1+20\")).isEqualTo(9);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9.1.1+20\")).isEqualTo(9);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonSerializationContext.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\OverrideCoreTypeAdaptersTest.java": {
    "testOverrideStringAdapter": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(String.class, swapCaseStringAdapter).create();\r\n    assertThat(gson.toJson(\"Hello\", String.class)).isEqualTo(\"\\\"HELLO\\\"\");\r\n    assertThat(gson.fromJson(\"\\\"Hello\\\"\", String.class)).isEqualTo(\"hello\");\r\n}",
    "read": "{\r\n    return in.nextString().toLowerCase(Locale.US);\r\n}",
    "testOverrideWrapperBooleanAdapter": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Boolean.class, booleanAsIntAdapter).create();\r\n    assertThat(gson.toJson(true, boolean.class)).isEqualTo(\"true\");\r\n    assertThat(gson.toJson(true, Boolean.class)).isEqualTo(\"1\");\r\n    assertThat(gson.fromJson(\"true\", boolean.class)).isEqualTo(Boolean.TRUE);\r\n    assertThat(gson.fromJson(\"1\", Boolean.class)).isEqualTo(Boolean.TRUE);\r\n    assertThat(gson.fromJson(\"0\", Boolean.class)).isEqualTo(Boolean.FALSE);\r\n}",
    "testOverridePrimitiveBooleanAdapter": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(boolean.class, booleanAsIntAdapter).create();\r\n    assertThat(gson.toJson(true, boolean.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(true, Boolean.class)).isEqualTo(\"true\");\r\n    assertThat(gson.fromJson(\"1\", boolean.class)).isEqualTo(Boolean.TRUE);\r\n    assertThat(gson.fromJson(\"true\", Boolean.class)).isEqualTo(Boolean.TRUE);\r\n    assertThat(gson.toJson(false, boolean.class)).isEqualTo(\"0\");\r\n}",
    "write": "{\r\n    out.value(value.toUpperCase(Locale.US));\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\FieldExclusionTest.java": {
    "testDefaultInnerClassExclusion": "{\r\n    Gson gson \u003d new Gson();\r\n    Outer.Inner target \u003d outer.new Inner(VALUE);\r\n    String result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(target.toJson());\r\n    gson \u003d new GsonBuilder().create();\r\n    target \u003d outer.new Inner(VALUE);\r\n    result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(target.toJson());\r\n}",
    "testDefaultNestedStaticClassIncluded": "{\r\n    Gson gson \u003d new Gson();\r\n    Outer.Inner target \u003d outer.new Inner(VALUE);\r\n    String result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(target.toJson());\r\n    gson \u003d new GsonBuilder().create();\r\n    target \u003d outer.new Inner(VALUE);\r\n    result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(target.toJson());\r\n}",
    "toJson": "{\r\n    return \"{\\\"value\\\":\\\"\" + value + \"\\\"}\";\r\n}",
    "setUp": "{\r\n    outer \u003d new Outer();\r\n}",
    "testInnerClassExclusion": "{\r\n    Gson gson \u003d new GsonBuilder().disableInnerClassSerialization().create();\r\n    Outer.Inner target \u003d outer.new Inner(VALUE);\r\n    String result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(\"null\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\CollectionTest.java": {
    "testTopLevelCollectionOfIntegersSerialization": "{\r\n    Collection\u003cInteger\u003e target \u003d Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\r\n    Type targetType \u003d new TypeToken\u003cCollection\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(target, targetType);\r\n    assertThat(json).isEqualTo(\"[1,2,3,4,5,6,7,8,9]\");\r\n}",
    "testQueueSerialization": "{\r\n    Queue\u003cString\u003e queue \u003d new LinkedList\u003c\u003e();\r\n    queue.add(\"a1\");\r\n    queue.add(\"a2\");\r\n    Type queueType \u003d new TypeToken\u003cQueue\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(queue, queueType);\r\n    assertThat(json).contains(\"a1\");\r\n    assertThat(json).contains(\"a2\");\r\n}",
    "testVector": "{\r\n    Type type \u003d new TypeToken\u003cVector\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    Vector\u003cInteger\u003e target \u003d gson.fromJson(\"[10, 20, 31]\", type);\r\n    assertThat(target.size()).isEqualTo(3);\r\n    assertThat(target.get(0)).isEqualTo(10);\r\n    assertThat(target.get(1)).isEqualTo(20);\r\n    assertThat(target.get(2)).isEqualTo(31);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"[10,20,31]\");\r\n}",
    "testPriorityQueue": "{\r\n    Type type \u003d new TypeToken\u003cPriorityQueue\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    PriorityQueue\u003cInteger\u003e queue \u003d gson.fromJson(\"[10, 20, 22]\", type);\r\n    assertThat(queue.size()).isEqualTo(3);\r\n    String json \u003d gson.toJson(queue);\r\n    assertThat(queue.remove()).isEqualTo(10);\r\n    assertThat(queue.remove()).isEqualTo(20);\r\n    assertThat(queue.remove()).isEqualTo(22);\r\n    assertThat(json).isEqualTo(\"[10,20,22]\");\r\n}",
    "testCollectionOfStringsDeserialization": "{\r\n    String json \u003d \"[\\\"Hello\\\",\\\"World\\\"]\";\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cString\u003e target \u003d gson.fromJson(json, collectionType);\r\n    assertThat(target).containsExactly(\"Hello\", \"World\").inOrder();\r\n}",
    "testWildcardCollectionField": "{\r\n    Collection\u003cBagOfPrimitives\u003e collection \u003d new ArrayList\u003c\u003e();\r\n    BagOfPrimitives objA \u003d new BagOfPrimitives(3L, 1, true, \"blah\");\r\n    BagOfPrimitives objB \u003d new BagOfPrimitives(2L, 6, false, \"blahB\");\r\n    collection.add(objA);\r\n    collection.add(objB);\r\n    ObjectWithWildcardCollection target \u003d new ObjectWithWildcardCollection(collection);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(objA.getExpectedJson());\r\n    assertThat(json).contains(objB.getExpectedJson());\r\n    target \u003d gson.fromJson(json, ObjectWithWildcardCollection.class);\r\n    Collection\u003c? extends BagOfPrimitives\u003e deserializedCollection \u003d target.getCollection();\r\n    assertThat(deserializedCollection.size()).isEqualTo(2);\r\n    assertThat(deserializedCollection).contains(objA);\r\n    assertThat(deserializedCollection).contains(objB);\r\n}",
    "testIssue1107": "{\r\n    String json \u003d \"{\\n\" + \"  \\\"inBig\\\": {\\n\" + \"    \\\"key\\\": [\\n\" + \"      { \\\"inSmall\\\": \\\"hello\\\" }\\n\" + \"    ]\\n\" + \"  }\\n\" + \"}\";\r\n    BigClass bigClass \u003d new Gson().fromJson(json, BigClass.class);\r\n    SmallClass small \u003d bigClass.inBig.get(\"key\").get(0);\r\n    assertThat(small).isNotNull();\r\n    assertThat(small.inSmall).isEqualTo(\"hello\");\r\n}",
    "testCollectionOfObjectWithNullSerialization": "{\r\n    List\u003cObject\u003e target \u003d new ArrayList\u003c\u003e();\r\n    target.add(\"Hello\");\r\n    target.add(null);\r\n    target.add(\"World\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[\\\"Hello\\\",null,\\\"World\\\"]\");\r\n    Type type \u003d new TypeToken\u003cList\u003cObject\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(gson.toJson(target, type)).isEqualTo(\"[\\\"Hello\\\",null,\\\"World\\\"]\");\r\n}",
    "testUserCollectionTypeAdapter": "{\r\n    Type listOfString \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Object stringListSerializer \u003d new JsonSerializer\u003cList\u003cString\u003e\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(List\u003cString\u003e src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(src.get(0) + \";\" + src.get(1));\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(listOfString, stringListSerializer).create();\r\n    assertThat(gson.toJson(Arrays.asList(\"ab\", \"cd\"), listOfString)).isEqualTo(\"\\\"ab;cd\\\"\");\r\n}",
    "toIntArray": "{\r\n    int[] ints \u003d new int[collection.size()];\r\n    int i \u003d 0;\r\n    for (Iterator\u003c?\u003e iterator \u003d collection.iterator(); iterator.hasNext(); ++i) {\r\n        Object obj \u003d iterator.next();\r\n        if (obj instanceof Integer) {\r\n            ints[i] \u003d (Integer) obj;\r\n        } else if (obj instanceof Long) {\r\n            ints[i] \u003d ((Long) obj).intValue();\r\n        }\r\n    }\r\n    return ints;\r\n}",
    "testTopLevelListOfIntegerCollectionsDeserialization": "{\r\n    String json \u003d \"[[1,2,3],[4,5,6],[7,8,9]]\";\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003cCollection\u003cInteger\u003e\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cCollection\u003cInteger\u003e\u003e target \u003d gson.fromJson(json, collectionType);\r\n    int[][] expected \u003d new int[3][3];\r\n    for (int i \u003d 0; i \u003c 3; ++i) {\r\n        int start \u003d (3 * i) + 1;\r\n        for (int j \u003d 0; j \u003c 3; ++j) {\r\n            expected[i][j] \u003d start + j;\r\n        }\r\n    }\r\n    for (int i \u003d 0; i \u003c 3; i++) {\r\n        assertThat(toIntArray(target.get(i))).isEqualTo(expected[i]);\r\n    }\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testCollectionOfObjectSerialization": "{\r\n    List\u003cObject\u003e target \u003d new ArrayList\u003c\u003e();\r\n    target.add(\"Hello\");\r\n    target.add(\"World\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[\\\"Hello\\\",\\\"World\\\"]\");\r\n    Type type \u003d new TypeToken\u003cList\u003cObject\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(gson.toJson(target, type)).isEqualTo(\"[\\\"Hello\\\",\\\"World\\\"]\");\r\n}",
    "testLinkedListSerialization": "{\r\n    List\u003cString\u003e list \u003d new LinkedList\u003c\u003e();\r\n    list.add(\"a1\");\r\n    list.add(\"a2\");\r\n    Type linkedListType \u003d new TypeToken\u003cLinkedList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(list, linkedListType);\r\n    assertThat(json).contains(\"a1\");\r\n    assertThat(json).contains(\"a2\");\r\n}",
    "testCollectionOfBagOfPrimitivesSerialization": "{\r\n    List\u003cBagOfPrimitives\u003e target \u003d new ArrayList\u003c\u003e();\r\n    BagOfPrimitives objA \u003d new BagOfPrimitives(3L, 1, true, \"blah\");\r\n    BagOfPrimitives objB \u003d new BagOfPrimitives(2L, 6, false, \"blahB\");\r\n    target.add(objA);\r\n    target.add(objB);\r\n    String result \u003d gson.toJson(target);\r\n    assertThat(result.startsWith(\"[\")).isTrue();\r\n    assertThat(result.endsWith(\"]\")).isTrue();\r\n    for (BagOfPrimitives obj : target) {\r\n        assertThat(result).contains(obj.getExpectedJson());\r\n    }\r\n}",
    "testWildcardPrimitiveCollectionDeserilaization": "{\r\n    String json \u003d \"[1,2,3,4,5,6,7,8,9]\";\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003c? extends Integer\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003c? extends Integer\u003e target \u003d gson.fromJson(json, collectionType);\r\n    assertThat(target.size()).isEqualTo(9);\r\n    assertThat(target).contains(1);\r\n    assertThat(target).contains(2);\r\n}",
    "getCollection": "{\r\n    return collection;\r\n}",
    "testNullsInListSerialization": "{\r\n    List\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(\"foo\");\r\n    list.add(null);\r\n    list.add(\"bar\");\r\n    String expected \u003d \"[\\\"foo\\\",null,\\\"bar\\\"]\";\r\n    Type typeOfList \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(list, typeOfList);\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "testWildcardPrimitiveCollectionSerilaization": "{\r\n    Collection\u003c? extends Integer\u003e target \u003d Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003c? extends Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(target, collectionType);\r\n    assertThat(json).isEqualTo(\"[1,2,3,4,5,6,7,8,9]\");\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"[1,2,3,4,5,6,7,8,9]\");\r\n}",
    "testNullsInListDeserialization": "{\r\n    List\u003cString\u003e expected \u003d new ArrayList\u003c\u003e();\r\n    expected.add(\"foo\");\r\n    expected.add(null);\r\n    expected.add(\"bar\");\r\n    String json \u003d \"[\\\"foo\\\",null,\\\"bar\\\"]\";\r\n    Type expectedType \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cString\u003e target \u003d gson.fromJson(json, expectedType);\r\n    for (int i \u003d 0; i \u003c expected.size(); ++i) {\r\n        assertThat(target.get(i)).isEqualTo(expected.get(i));\r\n    }\r\n}",
    "testStack": "{\r\n    Type type \u003d new TypeToken\u003cStack\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    Stack\u003cInteger\u003e target \u003d gson.fromJson(\"[11, 13, 17]\", type);\r\n    assertThat(target.size()).isEqualTo(3);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(target.pop()).isEqualTo(17);\r\n    assertThat(target.pop()).isEqualTo(13);\r\n    assertThat(target.pop()).isEqualTo(11);\r\n    assertThat(json).isEqualTo(\"[11,13,17]\");\r\n}",
    "testCollectionOfStringsSerialization": "{\r\n    List\u003cString\u003e target \u003d new ArrayList\u003c\u003e();\r\n    target.add(\"Hello\");\r\n    target.add(\"World\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[\\\"Hello\\\",\\\"World\\\"]\");\r\n}",
    "testSetSerialization": "{\r\n    Set\u003cEntry\u003e set \u003d new HashSet\u003c\u003e();\r\n    set.add(new Entry(1));\r\n    set.add(new Entry(2));\r\n    String json \u003d gson.toJson(set);\r\n    assertThat(json).contains(\"1\");\r\n    assertThat(json).contains(\"2\");\r\n}",
    "testLinkedListDeserialization": "{\r\n    String json \u003d \"[\u0027a1\u0027,\u0027a2\u0027]\";\r\n    Type linkedListType \u003d new TypeToken\u003cLinkedList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cString\u003e list \u003d gson.fromJson(json, linkedListType);\r\n    assertThat(list.get(0)).isEqualTo(\"a1\");\r\n    assertThat(list.get(1)).isEqualTo(\"a2\");\r\n}",
    "testRawCollectionDeserializationNotAllowed": "{\r\n    String json \u003d \"[0,1,2,3,4,5,6,7,8,9]\";\r\n    Collection\u003c?\u003e integers \u003d gson.fromJson(json, Collection.class);\r\n    // JsonReader converts numbers to double by default so we need a floating point comparison\r\n    assertThat(integers).containsExactly(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0).inOrder();\r\n    json \u003d \"[\\\"Hello\\\", \\\"World\\\"]\";\r\n    Collection\u003c?\u003e strings \u003d gson.fromJson(json, Collection.class);\r\n    assertThat(strings).containsExactly(\"Hello\", \"World\").inOrder();\r\n}",
    "testRawCollectionOfBagOfPrimitivesNotAllowed": "{\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives(10, 20, false, \"stringValue\");\r\n    String json \u003d \u0027[\u0027 + bag.getExpectedJson() + \u0027,\u0027 + bag.getExpectedJson() + \u0027]\u0027;\r\n    Collection\u003c?\u003e target \u003d gson.fromJson(json, Collection.class);\r\n    assertThat(target.size()).isEqualTo(2);\r\n    for (Object bag1 : target) {\r\n        // Gson 2.0 converts raw objects into maps\r\n        @SuppressWarnings(\"unchecked\")\r\n        Map\u003cString, Object\u003e values \u003d (Map\u003cString, Object\u003e) bag1;\r\n        assertThat(values.containsValue(10.0)).isTrue();\r\n        assertThat(values.containsValue(20.0)).isTrue();\r\n        assertThat(values.containsValue(\"stringValue\")).isTrue();\r\n    }\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(src.get(0) + \";\" + src.get(1));\r\n}",
    "testQueueDeserialization": "{\r\n    String json \u003d \"[\u0027a1\u0027,\u0027a2\u0027]\";\r\n    Type queueType \u003d new TypeToken\u003cQueue\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Queue\u003cString\u003e queue \u003d gson.fromJson(json, queueType);\r\n    assertThat(queue.element()).isEqualTo(\"a1\");\r\n    queue.remove();\r\n    assertThat(queue.element()).isEqualTo(\"a2\");\r\n}",
    "testRawCollectionOfIntegersSerialization": "{\r\n    Collection\u003cInteger\u003e target \u003d Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[1,2,3,4,5,6,7,8,9]\");\r\n}",
    "testSetDeserialization": "{\r\n    String json \u003d \"[{value:1},{value:2}]\";\r\n    Type type \u003d new TypeToken\u003cSet\u003cEntry\u003e\u003e() {\r\n    }.getType();\r\n    Set\u003cEntry\u003e set \u003d gson.fromJson(json, type);\r\n    assertThat(set.size()).isEqualTo(2);\r\n    for (Entry entry : set) {\r\n        assertThat(entry.value).isAnyOf(1, 2);\r\n    }\r\n}",
    "testFieldIsArrayList": "{\r\n    HasArrayListField object \u003d new HasArrayListField();\r\n    object.longs.add(1L);\r\n    object.longs.add(3L);\r\n    String json \u003d gson.toJson(object, HasArrayListField.class);\r\n    assertThat(json).isEqualTo(\"{\\\"longs\\\":[1,3]}\");\r\n    HasArrayListField copy \u003d gson.fromJson(\"{\\\"longs\\\":[1,3]}\", HasArrayListField.class);\r\n    assertThat(copy.longs).isEqualTo(Arrays.asList(1L, 3L));\r\n}",
    "testTopLevelCollectionOfIntegersDeserialization": "{\r\n    String json \u003d \"[0,1,2,3,4,5,6,7,8,9]\";\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cInteger\u003e target \u003d gson.fromJson(json, collectionType);\r\n    int[] expected \u003d { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    assertThat(toIntArray(target)).isEqualTo(expected);\r\n}",
    "testObjectCollectionSerialization": "{\r\n    BagOfPrimitives bag1 \u003d new BagOfPrimitives();\r\n    Collection\u003c?\u003e target \u003d Arrays.asList(bag1, bag1, \"test\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(bag1.getExpectedJson());\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\CollectionTypeAdapterFactory.java": {
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    Collection\u003cE\u003e collection \u003d constructor.construct();\r\n    in.beginArray();\r\n    while (in.hasNext()) {\r\n        E instance \u003d elementTypeAdapter.read(in);\r\n        collection.add(instance);\r\n    }\r\n    in.endArray();\r\n    return collection;\r\n}",
    "create": "{\r\n    Type type \u003d typeToken.getType();\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    if (!Collection.class.isAssignableFrom(rawType)) {\r\n        return null;\r\n    }\r\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\r\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\r\n    // create() doesn\u0027t define a type parameter\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\r\n    return result;\r\n}",
    "write": "{\r\n    if (collection \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginArray();\r\n    for (E element : collection) {\r\n        elementTypeAdapter.write(out, element);\r\n    }\r\n    out.endArray();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\EnumTest.java": {
    "testEnumSet": "{\r\n    EnumSet\u003cRoshambo\u003e foo \u003d EnumSet.of(Roshambo.ROCK, Roshambo.PAPER);\r\n    String json \u003d gson.toJson(foo);\r\n    assertThat(json).isEqualTo(\"[\\\"ROCK\\\",\\\"PAPER\\\"]\");\r\n    Type type \u003d new TypeToken\u003cEnumSet\u003cRoshambo\u003e\u003e() {\r\n    }.getType();\r\n    EnumSet\u003cRoshambo\u003e bar \u003d gson.fromJson(json, type);\r\n    assertThat(bar).containsExactly(Roshambo.ROCK, Roshambo.PAPER).inOrder();\r\n    assertThat(bar).doesNotContain(Roshambo.SCISSORS);\r\n}",
    "testEnumSubclassAsParameterizedType": "{\r\n    Collection\u003cRoshambo\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(Roshambo.ROCK);\r\n    list.add(Roshambo.PAPER);\r\n    String json \u003d gson.toJson(list);\r\n    assertThat(json).isEqualTo(\"[\\\"ROCK\\\",\\\"PAPER\\\"]\");\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003cRoshambo\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cRoshambo\u003e actualJsonList \u003d gson.fromJson(json, collectionType);\r\n    MoreAsserts.assertContains(actualJsonList, Roshambo.ROCK);\r\n    MoreAsserts.assertContains(actualJsonList, Roshambo.PAPER);\r\n}",
    "testEnumSubclassWithRegisteredTypeAdapter": "{\r\n    gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Roshambo.class, new MyEnumTypeAdapter()).create();\r\n    assertThat(Roshambo.ROCK.getClass()).isNotEqualTo(Roshambo.class);\r\n    assertThat(gson.toJson(Roshambo.ROCK)).isEqualTo(\"\\\"123ROCK\\\"\");\r\n    assertThat(gson.toJson(EnumSet.allOf(Roshambo.class))).isEqualTo(\"[\\\"123ROCK\\\",\\\"123PAPER\\\",\\\"123SCISSORS\\\"]\");\r\n    assertThat(gson.fromJson(\"\\\"123ROCK\\\"\", Roshambo.class)).isEqualTo(Roshambo.ROCK);\r\n    assertThat(EnumSet.allOf(Roshambo.class)).isEqualTo(gson.fromJson(\"[\\\"123ROCK\\\",\\\"123PAPER\\\",\\\"123SCISSORS\\\"]\", new TypeToken\u003cSet\u003cRoshambo\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "testEnumClassWithFields": "{\r\n    assertThat(gson.toJson(Color.RED)).isEqualTo(\"\\\"RED\\\"\");\r\n    assertThat(gson.fromJson(\"RED\", Color.class).value).isEqualTo(\"red\");\r\n    assertThat(gson.fromJson(\"BLUE\", Color.class).index).isEqualTo(2);\r\n}",
    "testCollectionOfEnumsSerialization": "{\r\n    Type type \u003d new TypeToken\u003cCollection\u003cMyEnum\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cMyEnum\u003e target \u003d new ArrayList\u003c\u003e();\r\n    target.add(MyEnum.VALUE1);\r\n    target.add(MyEnum.VALUE2);\r\n    String expectedJson \u003d \"[\\\"VALUE1\\\",\\\"VALUE2\\\"]\";\r\n    String actualJson \u003d gson.toJson(target);\r\n    assertThat(actualJson).isEqualTo(expectedJson);\r\n    actualJson \u003d gson.toJson(target, type);\r\n    assertThat(actualJson).isEqualTo(expectedJson);\r\n}",
    "testEnumCaseMapping": "{\r\n    assertThat(gson.fromJson(\"\\\"boy\\\"\", Gender.class)).isEqualTo(Gender.MALE);\r\n    assertThat(gson.toJson(Gender.MALE, Gender.class)).isEqualTo(\"\\\"boy\\\"\");\r\n}",
    "testEnumMap": "{\r\n    EnumMap\u003cMyEnum, String\u003e map \u003d new EnumMap\u003c\u003e(MyEnum.class);\r\n    map.put(MyEnum.VALUE1, \"test\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"VALUE1\\\":\\\"test\\\"}\");\r\n    Type type \u003d new TypeToken\u003cEnumMap\u003cMyEnum, String\u003e\u003e() {\r\n    }.getType();\r\n    EnumMap\u003c?, ?\u003e actualMap \u003d gson.fromJson(\"{\\\"VALUE1\\\":\\\"test\\\"}\", type);\r\n    Map\u003c?, ?\u003e expectedMap \u003d Collections.singletonMap(MyEnum.VALUE1, \"test\");\r\n    assertThat(actualMap).isEqualTo(expectedMap);\r\n}",
    "testTopLevelEnumSerialization": "{\r\n    String result \u003d gson.toJson(MyEnum.VALUE1);\r\n    assertThat(result).isEqualTo(\u0027\"\u0027 + MyEnum.VALUE1.toString() + \u0027\"\u0027);\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(\"123\" + src.name());\r\n}",
    "testTopLevelEnumDeserialization": "{\r\n    MyEnum result \u003d gson.fromJson(\u0027\"\u0027 + MyEnum.VALUE1.toString() + \u0027\"\u0027, MyEnum.class);\r\n    assertThat(result).isEqualTo(MyEnum.VALUE1);\r\n}",
    "testEnumSubclass": "{\r\n    assertThat(Roshambo.ROCK.getClass()).isNotEqualTo(Roshambo.class);\r\n    assertThat(gson.toJson(Roshambo.ROCK)).isEqualTo(\"\\\"ROCK\\\"\");\r\n    assertThat(gson.toJson(EnumSet.allOf(Roshambo.class))).isEqualTo(\"[\\\"ROCK\\\",\\\"PAPER\\\",\\\"SCISSORS\\\"]\");\r\n    assertThat(gson.fromJson(\"\\\"ROCK\\\"\", Roshambo.class)).isEqualTo(Roshambo.ROCK);\r\n    assertThat(EnumSet.allOf(Roshambo.class)).isEqualTo(gson.fromJson(\"[\\\"ROCK\\\",\\\"PAPER\\\",\\\"SCISSORS\\\"]\", new TypeToken\u003cSet\u003cRoshambo\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "testEnumToStringReadInterchanged": "{\r\n    assertThat(gson.fromJson(\"\\\"A\\\"\", InterchangedToString.class)).isEqualTo(InterchangedToString.A);\r\n    assertThat(gson.fromJson(\"\\\"B\\\"\", InterchangedToString.class)).isEqualTo(InterchangedToString.B);\r\n}",
    "getExpectedJson": "{\r\n    return \"{\\\"value1\\\":\\\"\" + value1 + \"\\\",\\\"value2\\\":\\\"\" + value2 + \"\\\"}\";\r\n}",
    "defeats": "{\r\n    return PAPER;\r\n}",
    "testClassWithEnumFieldDeserialization": "{\r\n    String json \u003d \"{value1:\u0027VALUE1\u0027,value2:\u0027VALUE2\u0027}\";\r\n    ClassWithEnumFields target \u003d gson.fromJson(json, ClassWithEnumFields.class);\r\n    assertThat(target.value1).isEqualTo(MyEnum.VALUE1);\r\n    assertThat(target.value2).isEqualTo(MyEnum.VALUE2);\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testCollectionOfEnumsDeserialization": "{\r\n    Type type \u003d new TypeToken\u003cCollection\u003cMyEnum\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d \"[\\\"VALUE1\\\",\\\"VALUE2\\\"]\";\r\n    Collection\u003cMyEnum\u003e target \u003d gson.fromJson(json, type);\r\n    MoreAsserts.assertContains(target, MyEnum.VALUE1);\r\n    MoreAsserts.assertContains(target, MyEnum.VALUE2);\r\n}",
    "testEnumToStringRead": "{\r\n    // Should still be able to read constant name\r\n    assertThat(gson.fromJson(\"\\\"A\\\"\", CustomToString.class)).isEqualTo(CustomToString.A);\r\n    // Should be able to read toString() value\r\n    assertThat(gson.fromJson(\"\\\"test\\\"\", CustomToString.class)).isEqualTo(CustomToString.A);\r\n    assertThat(gson.fromJson(\"\\\"other\\\"\", CustomToString.class)).isNull();\r\n}",
    "toString": "{\r\n    return toString;\r\n}",
    "testClassWithEnumFieldSerialization": "{\r\n    ClassWithEnumFields target \u003d new ClassWithEnumFields();\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "deserialize": "{\r\n    return Roshambo.valueOf(json.getAsString().substring(3));\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java": {
    "testDefaultStrictness": "{\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    Gson gson \u003d builder.create();\r\n    assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n    assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n}",
    "createInstance": "{\r\n    return new CustomClass3(\"custom-instance\");\r\n}",
    "read": "{\r\n    throw new UnsupportedOperationException();\r\n}",
    "assertDefaultGson": "{\r\n    // Should use default reflective adapter\r\n    String json1 \u003d gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"{}\");\r\n    // Should use default reflective adapter\r\n    String json2 \u003d gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"{}\");\r\n    // Should use default instance creator\r\n    CustomClass3 customClass3 \u003d gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(CustomClass3.NO_ARG_CONSTRUCTOR_VALUE);\r\n}",
    "testTransientFieldExclusion": "{\r\n    Gson gson \u003d new GsonBuilder().excludeFieldsWithModifiers().create();\r\n    assertThat(gson.toJson(new HasTransients())).isEqualTo(\"{\\\"a\\\":\\\"a\\\"}\");\r\n}",
    "testSetStrictness": "{\r\n    final Strictness STRICTNESS \u003d Strictness.STRICT;\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    builder.setStrictness(STRICTNESS);\r\n    Gson gson \u003d builder.create();\r\n    assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(STRICTNESS);\r\n    assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(STRICTNESS);\r\n}",
    "testRegisterTypeAdapterForObjectAndJsonElements": "{\r\n    final String ERROR_MESSAGE \u003d \"Cannot override built-in adapter for \";\r\n    Type[] types \u003d { Object.class, JsonElement.class, JsonArray.class };\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    for (Type type : types) {\r\n        IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e gsonBuilder.registerTypeAdapter(type, NULL_TYPE_ADAPTER));\r\n        assertThat(e).hasMessageThat().isEqualTo(ERROR_MESSAGE + type);\r\n    }\r\n}",
    "assertCustomGson": "{\r\n    String json1 \u003d gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"\\\"custom-adapter\\\"\");\r\n    String json2 \u003d gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"\\\"custom-hierarchy-adapter\\\"\");\r\n    CustomClass3 customClass3 \u003d gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(\"custom-instance\");\r\n}",
    "translateName": "{\r\n    return \"test\";\r\n}",
    "testSetLenient": "{\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    builder.setLenient();\r\n    Gson gson \u003d builder.create();\r\n    assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(Strictness.LENIENT);\r\n    assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(Strictness.LENIENT);\r\n}",
    "testDisableJdkUnsafe": "{\r\n    Gson gson \u003d new GsonBuilder().disableJdkUnsafe().create();\r\n    try {\r\n        gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n        fail(\"Expected exception\");\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unable to create instance of class com.google.gson.GsonBuilderTest$ClassWithoutNoArgsConstructor; \" + \"usage of JDK Unsafe is disabled. Registering an InstanceCreator or a TypeAdapter for this type, \" + \"adding a no-args constructor, or enabling usage of JDK Unsafe may fix this problem.\");\r\n    }\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(\"custom-hierarchy-adapter\");\r\n}",
    "testRegisterTypeAdapterForCoreType": "{\r\n    Type[] types \u003d { byte.class, int.class, double.class, Short.class, Long.class, String.class };\r\n    for (Type type : types) {\r\n        new GsonBuilder().registerTypeAdapter(type, NULL_TYPE_ADAPTER);\r\n    }\r\n}",
    "testModificationAfterCreate": "{\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    Gson gson \u003d gsonBuilder.create();\r\n    // Modifications of `gsonBuilder` should not affect `gson` object\r\n    gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter\u003cCustomClass1\u003e() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"custom-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, new JsonSerializer\u003cCustomClass2\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"custom-hierarchy-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeAdapter(CustomClass3.class, new InstanceCreator\u003cCustomClass3\u003e() {\r\n\r\n        @Override\r\n        public CustomClass3 createInstance(Type type) {\r\n            return new CustomClass3(\"custom-instance\");\r\n        }\r\n    });\r\n    assertDefaultGson(gson);\r\n    // New GsonBuilder created from `gson` should not have been affected by changes\r\n    // to `gsonBuilder` either\r\n    assertDefaultGson(gson.newBuilder().create());\r\n    // New Gson instance from modified GsonBuilder should be affected by changes\r\n    assertCustomGson(gsonBuilder.create());\r\n}",
    "testRegisterTypeHierarchyAdapterJsonElements": "{\r\n    final String ERROR_MESSAGE \u003d \"Cannot override built-in adapter for \";\r\n    Class\u003c?\u003e[] types \u003d { JsonElement.class, JsonArray.class };\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    for (Class\u003c?\u003e type : types) {\r\n        IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e gsonBuilder.registerTypeHierarchyAdapter(type, NULL_TYPE_ADAPTER));\r\n        assertThat(e).hasMessageThat().isEqualTo(ERROR_MESSAGE + type);\r\n    }\r\n    // But registering type hierarchy adapter for Object should be allowed\r\n    gsonBuilder.registerTypeHierarchyAdapter(Object.class, NULL_TYPE_ADAPTER);\r\n}",
    "testSetVersionInvalid": "{\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    try {\r\n        builder.setVersion(Double.NaN);\r\n        fail();\r\n    } catch (IllegalArgumentException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid version: NaN\");\r\n    }\r\n    try {\r\n        builder.setVersion(-0.1);\r\n        fail();\r\n    } catch (IllegalArgumentException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid version: -0.1\");\r\n    }\r\n}",
    "testCreatingMoreThanOnce": "{\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    Gson gson \u003d builder.create();\r\n    assertThat(gson).isNotNull();\r\n    assertThat(builder.create()).isNotNull();\r\n    builder.setFieldNamingStrategy(new FieldNamingStrategy() {\r\n\r\n        @Override\r\n        public String translateName(Field f) {\r\n            return \"test\";\r\n        }\r\n    });\r\n    Gson otherGson \u003d builder.create();\r\n    assertThat(otherGson).isNotNull();\r\n    // Should be different instances because builder has been modified in the meantime\r\n    assertThat(gson).isNotSameInstanceAs(otherGson);\r\n}",
    "write": "{\r\n    out.value(\"custom-adapter\");\r\n}",
    "testExcludeFieldsWithModifiers": "{\r\n    Gson gson \u003d new GsonBuilder().excludeFieldsWithModifiers(Modifier.VOLATILE, Modifier.PRIVATE).create();\r\n    assertThat(gson.toJson(new HasModifiers())).isEqualTo(\"{\\\"d\\\":\\\"d\\\"}\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\JavaVersion.java": {
    "determineMajorJavaVersion": "{\r\n    String javaVersion \u003d System.getProperty(\"java.version\");\r\n    return getMajorJavaVersion(javaVersion);\r\n}",
    "getMajorJavaVersion": "{\r\n    return majorJavaVersion;\r\n}",
    "parseDotted": "{\r\n    try {\r\n        String[] parts \u003d javaVersion.split(\"[._]\", 3);\r\n        int firstVer \u003d Integer.parseInt(parts[0]);\r\n        if (firstVer \u003d\u003d 1 \u0026\u0026 parts.length \u003e 1) {\r\n            return Integer.parseInt(parts[1]);\r\n        } else {\r\n            return firstVer;\r\n        }\r\n    } catch (NumberFormatException e) {\r\n        return -1;\r\n    }\r\n}",
    "isJava9OrLater": "{\r\n    return majorJavaVersion \u003e\u003d 9;\r\n}",
    "extractBeginningInt": "{\r\n    try {\r\n        StringBuilder num \u003d new StringBuilder();\r\n        for (int i \u003d 0; i \u003c javaVersion.length(); ++i) {\r\n            char c \u003d javaVersion.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                num.append(c);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return Integer.parseInt(num.toString());\r\n    } catch (NumberFormatException e) {\r\n        return -1;\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\InternationalizationTest.java": {
    "testStringsWithUnicodeChineseCharactersSerialization": "{\r\n    String target \u003d \"\\u597d\\u597d\\u597d\";\r\n    String json \u003d gson.toJson(target);\r\n    String expected \u003d \u0027\"\u0027 + target + \u0027\"\u0027;\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "testSupplementaryUnicodeSerialization": "{\r\n    // Supplementary code point U+1F60A\r\n    String supplementaryCodePoint \u003d new String(new int[] { 0x1F60A }, 0, 1);\r\n    String json \u003d gson.toJson(supplementaryCodePoint);\r\n    assertThat(json).isEqualTo(\u0027\"\u0027 + supplementaryCodePoint + \u0027\"\u0027);\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testStringsWithUnicodeChineseCharactersDeserialization": "{\r\n    String expected \u003d \"\\u597d\\u597d\\u597d\";\r\n    String json \u003d \u0027\"\u0027 + expected + \u0027\"\u0027;\r\n    String actual \u003d gson.fromJson(json, String.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testSupplementaryUnicodeEscapedDeserialization": "{\r\n    // Supplementary code point U+1F60A\r\n    String supplementaryCodePoint \u003d new String(new int[] { 0x1F60A }, 0, 1);\r\n    String actual \u003d gson.fromJson(\"\\\"\\\\uD83D\\\\uDE0A\\\"\", String.class);\r\n    assertThat(actual).isEqualTo(supplementaryCodePoint);\r\n}",
    "testSupplementaryUnicodeDeserialization": "{\r\n    // Supplementary code point U+1F60A\r\n    String supplementaryCodePoint \u003d new String(new int[] { 0x1F60A }, 0, 1);\r\n    String actual \u003d gson.fromJson(\u0027\"\u0027 + supplementaryCodePoint + \u0027\"\u0027, String.class);\r\n    assertThat(actual).isEqualTo(supplementaryCodePoint);\r\n}",
    "testStringsWithUnicodeChineseCharactersEscapedDeserialization": "{\r\n    String actual \u003d gson.fromJson(\"\u0027\\\\u597d\\\\u597d\\\\u597d\u0027\", String.class);\r\n    assertThat(actual).isEqualTo(\"\\u597d\\u597d\\u597d\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\TypeAdapterRuntimeTypeWrapperTest.java": {
    "serialize": "{\r\n    return new JsonPrimitive(\"base\");\r\n}",
    "read": "{\r\n    throw new UnsupportedOperationException();\r\n}",
    "testGsonFutureAdapter": "{\r\n    CyclicBase b \u003d new CyclicBase();\r\n    b.f \u003d new CyclicSub(2);\r\n    String json \u003d new Gson().toJson(b);\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":{\\\"i\\\":2}}\");\r\n}",
    "testJsonDeserializer_JsonSerializerDelegate": "{\r\n    Gson gson \u003d new GsonBuilder().// Register JsonSerializer as delegate\r\n    registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"custom delegate\");\r\n        }\r\n    }).registerTypeAdapter(Base.class, new Deserializer()).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":\\\"custom delegate\\\"}\");\r\n}",
    "testJsonDeserializer_CustomSerializerDelegate": "{\r\n    Gson gson \u003d new GsonBuilder().// Register custom delegate\r\n    registerTypeAdapter(Base.class, new TypeAdapter\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Base value) throws IOException {\r\n            out.value(\"custom delegate\");\r\n        }\r\n    }).registerTypeAdapter(Base.class, new Deserializer()).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":\\\"custom delegate\\\"}\");\r\n}",
    "testJsonDeserializer_ReflectiveSerializerDelegate": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new Deserializer()).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":{\\\"f\\\":\\\"test\\\"}}\");\r\n}",
    "write": "{\r\n    out.value(\"custom delegate\");\r\n}",
    "testJsonSerializer": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"serializer\");\r\n        }\r\n    }).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":\\\"serializer\\\"}\");\r\n}",
    "deserialize": "{\r\n    throw new AssertionError(\"not needed for this test\");\r\n}",
    "testJsonDeserializer_ReflectiveTreeSerializerDelegate": "{\r\n    Gson gson \u003d new GsonBuilder().// Register delegate which itself falls back to reflective serialization\r\n    registerTypeAdapter(Base.class, new Deserializer()).registerTypeAdapter(Base.class, new Deserializer()).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":{\\\"f\\\":\\\"test\\\"}}\");\r\n}",
    "testJsonDeserializer_SubclassBackwardCompatibility": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Subclass.class, new JsonDeserializer\u003cSubclass\u003e() {\r\n\r\n        @Override\r\n        public Subclass deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n    }).registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"base\");\r\n        }\r\n    }).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":{\\\"f\\\":\\\"test\\\"}}\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\StringTest.java": {
    "testStringValueSerialization": "{\r\n    String value \u003d \"someRandomStringValue\";\r\n    assertThat(gson.toJson(value)).isEqualTo(\u0027\"\u0027 + value + \u0027\"\u0027);\r\n}",
    "testEscapingQuotesInStringDeserialization": "{\r\n    String value \u003d \"beforeQuote\\\\\\\"afterQuote\";\r\n    String actual \u003d gson.fromJson(\"\\\"\" + value + \"\\\"\", String.class);\r\n    String expected \u003d \"beforeQuote\\\"afterQuote\";\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testEscapingQuotesInStringSerialization": "{\r\n    String valueWithQuotes \u003d \"beforeQuote\\\"afterQuote\";\r\n    String jsonRepresentation \u003d gson.toJson(valueWithQuotes);\r\n    String target \u003d gson.fromJson(jsonRepresentation, String.class);\r\n    assertThat(target).isEqualTo(valueWithQuotes);\r\n}",
    "testJavascriptKeywordsInStringDeserialization": "{\r\n    String json \u003d \"\u0027null true false function\u0027\";\r\n    String value \u003d gson.fromJson(json, String.class);\r\n    assertThat(json.substring(1, json.length() - 1)).isEqualTo(value);\r\n}",
    "testEscapedBackslashInStringDeserialization": "{\r\n    String actual \u003d gson.fromJson(\"\u0027a\\\\\\\\b\u0027\", String.class);\r\n    assertThat(actual).isEqualTo(\"a\\\\b\");\r\n}",
    "testEscapedCtrlNInStringDeserialization": "{\r\n    String json \u003d \"\u0027a\\\\nb\u0027\";\r\n    String actual \u003d gson.fromJson(json, String.class);\r\n    assertThat(actual).isEqualTo(\"a\\nb\");\r\n}",
    "testAssignmentCharDeserialization": "{\r\n    String json \u003d \"\\\"abc\u003d\\\"\";\r\n    String value \u003d gson.fromJson(json, String.class);\r\n    assertThat(value).isEqualTo(\"abc\u003d\");\r\n    json \u003d \"\u0027abc\\\\u003d\u0027\";\r\n    value \u003d gson.fromJson(json, String.class);\r\n    assertThat(value).isEqualTo(\"abc\u003d\");\r\n}",
    "testAssignmentCharSerialization": "{\r\n    String value \u003d \"abc\u003d\";\r\n    String json \u003d gson.toJson(value);\r\n    assertThat(json).isEqualTo(\"\\\"abc\\\\u003d\\\"\");\r\n}",
    "testJavascriptKeywordsInStringSerialization": "{\r\n    String value \u003d \"null true false function\";\r\n    String json \u003d gson.toJson(value);\r\n    assertThat(json).isEqualTo(\"\\\"\" + value + \"\\\"\");\r\n}",
    "testStringValueAsSingleElementArraySerialization": "{\r\n    String[] target \u003d { \"abc\" };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[\\\"abc\\\"]\");\r\n    assertThat(gson.toJson(target, String[].class)).isEqualTo(\"[\\\"abc\\\"]\");\r\n}",
    "testEscapedCtrlNInStringSerialization": "{\r\n    String value \u003d \"a\\nb\";\r\n    String json \u003d gson.toJson(value);\r\n    assertThat(json).isEqualTo(\"\\\"a\\\\nb\\\"\");\r\n}",
    "testEscapedCtrlRInStringDeserialization": "{\r\n    String json \u003d \"\u0027a\\\\rb\u0027\";\r\n    String actual \u003d gson.fromJson(json, String.class);\r\n    assertThat(actual).isEqualTo(\"a\\rb\");\r\n}",
    "testSingleQuoteInStringSerialization": "{\r\n    String valueWithQuotes \u003d \"beforeQuote\u0027afterQuote\";\r\n    String jsonRepresentation \u003d gson.toJson(valueWithQuotes);\r\n    assertThat(gson.fromJson(jsonRepresentation, String.class)).isEqualTo(valueWithQuotes);\r\n}",
    "testEscapedCtrlRInStringSerialization": "{\r\n    String value \u003d \"a\\rb\";\r\n    String json \u003d gson.toJson(value);\r\n    assertThat(json).isEqualTo(\"\\\"a\\\\rb\\\"\");\r\n}",
    "testStringValueDeserialization": "{\r\n    String value \u003d \"someRandomStringValue\";\r\n    String actual \u003d gson.fromJson(\"\\\"\" + value + \"\\\"\", String.class);\r\n    assertThat(actual).isEqualTo(value);\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testStringWithEscapedSlashDeserialization": "{\r\n    String value \u003d \"/\";\r\n    String json \u003d \"\u0027\\\\/\u0027\";\r\n    String actual \u003d gson.fromJson(json, String.class);\r\n    assertThat(actual).isEqualTo(value);\r\n}",
    "testSingleQuoteInStringDeserialization": "{\r\n    String value \u003d \"beforeQuote\u0027afterQuote\";\r\n    String actual \u003d gson.fromJson(\"\\\"\" + value + \"\\\"\", String.class);\r\n    assertThat(actual).isEqualTo(value);\r\n}",
    "testEscapedBackslashInStringSerialization": "{\r\n    String value \u003d \"a\\\\b\";\r\n    String json \u003d gson.toJson(value);\r\n    assertThat(json).isEqualTo(\"\\\"a\\\\\\\\b\\\"\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonArray.java": {
    "getAsFloat": "{\r\n    return getAsSingleElement().getAsFloat();\r\n}",
    "getAsByte": "{\r\n    return getAsSingleElement().getAsByte();\r\n}",
    "getAsBigDecimal": "{\r\n    return getAsSingleElement().getAsBigDecimal();\r\n}",
    "getAsNumber": "{\r\n    return getAsSingleElement().getAsNumber();\r\n}",
    "getAsCharacter": "{\r\n    return getAsSingleElement().getAsCharacter();\r\n}",
    "getAsString": "{\r\n    return getAsSingleElement().getAsString();\r\n}",
    "remove": "{\r\n    return elements.remove(index);\r\n}",
    "getAsInt": "{\r\n    return getAsSingleElement().getAsInt();\r\n}",
    "asList": "{\r\n    return new NonNullElementWrapperList\u003c\u003e(elements);\r\n}",
    "iterator": "{\r\n    return elements.iterator();\r\n}",
    "getAsLong": "{\r\n    return getAsSingleElement().getAsLong();\r\n}",
    "hashCode": "{\r\n    return elements.hashCode();\r\n}",
    "get": "{\r\n    return elements.get(i);\r\n}",
    "add": "{\r\n    if (element \u003d\u003d null) {\r\n        element \u003d JsonNull.INSTANCE;\r\n    }\r\n    elements.add(element);\r\n}",
    "getAsBigInteger": "{\r\n    return getAsSingleElement().getAsBigInteger();\r\n}",
    "set": "{\r\n    return elements.set(index, element \u003d\u003d null ? JsonNull.INSTANCE : element);\r\n}",
    "isEmpty": "{\r\n    return elements.isEmpty();\r\n}",
    "getAsDouble": "{\r\n    return getAsSingleElement().getAsDouble();\r\n}",
    "getAsSingleElement": "{\r\n    int size \u003d elements.size();\r\n    if (size \u003d\u003d 1) {\r\n        return elements.get(0);\r\n    }\r\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\r\n}",
    "deepCopy": "{\r\n    if (!elements.isEmpty()) {\r\n        JsonArray result \u003d new JsonArray(elements.size());\r\n        for (JsonElement element : elements) {\r\n            result.add(element.deepCopy());\r\n        }\r\n        return result;\r\n    }\r\n    return new JsonArray();\r\n}",
    "contains": "{\r\n    return elements.contains(element);\r\n}",
    "size": "{\r\n    return elements.size();\r\n}",
    "addAll": "{\r\n    elements.addAll(array.elements);\r\n}",
    "getAsBoolean": "{\r\n    return getAsSingleElement().getAsBoolean();\r\n}",
    "equals": "{\r\n    return (o \u003d\u003d this) || (o instanceof JsonArray \u0026\u0026 ((JsonArray) o).elements.equals(elements));\r\n}",
    "getAsShort": "{\r\n    return getAsSingleElement().getAsShort();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\JsonPrimitiveTest.java": {
    "testBoolean": "{\r\n    JsonPrimitive json \u003d new JsonPrimitive(Boolean.TRUE);\r\n    assertThat(json.isBoolean()).isTrue();\r\n    assertThat(json.getAsBoolean()).isTrue();\r\n    // Extra support for booleans\r\n    json \u003d new JsonPrimitive(1);\r\n    assertThat(json.getAsBoolean()).isFalse();\r\n    json \u003d new JsonPrimitive(\"1\");\r\n    assertThat(json.getAsBoolean()).isFalse();\r\n    json \u003d new JsonPrimitive(\"true\");\r\n    assertThat(json.getAsBoolean()).isTrue();\r\n    json \u003d new JsonPrimitive(\"TrUe\");\r\n    assertThat(json.getAsBoolean()).isTrue();\r\n    json \u003d new JsonPrimitive(\"1.3\");\r\n    assertThat(json.getAsBoolean()).isFalse();\r\n}",
    "testFloatEqualsDouble": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10.25F);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10.25D);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testParsingStringAsNumber": "{\r\n    JsonPrimitive json \u003d new JsonPrimitive(\"1\");\r\n    assertThat(json.isNumber()).isFalse();\r\n    assertThat(json.getAsDouble()).isEqualTo(1.0);\r\n    assertThat(json.getAsFloat()).isEqualTo(1F);\r\n    assertThat(json.getAsInt()).isEqualTo(1);\r\n    assertThat(json.getAsLong()).isEqualTo(1L);\r\n    assertThat(json.getAsShort()).isEqualTo((short) 1);\r\n    assertThat(json.getAsByte()).isEqualTo((byte) 1);\r\n    assertThat(json.getAsBigInteger()).isEqualTo(new BigInteger(\"1\"));\r\n    assertThat(json.getAsBigDecimal()).isEqualTo(new BigDecimal(\"1\"));\r\n}",
    "testShortEqualsBigInteger": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((short) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigInteger(\"10\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testDoubleEqualsBigDecimal": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10.25D);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigDecimal(\"10.25\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testStringsAndChar": "{\r\n    JsonPrimitive json \u003d new JsonPrimitive(\"abc\");\r\n    assertThat(json.isString()).isTrue();\r\n    assertThat(json.getAsCharacter()).isEqualTo(\u0027a\u0027);\r\n    assertThat(json.getAsString()).isEqualTo(\"abc\");\r\n    json \u003d new JsonPrimitive(\u0027z\u0027);\r\n    assertThat(json.isString()).isTrue();\r\n    assertThat(json.getAsCharacter()).isEqualTo(\u0027z\u0027);\r\n    assertThat(json.getAsString()).isEqualTo(\"z\");\r\n    json \u003d new JsonPrimitive(true);\r\n    assertThat(json.getAsString()).isEqualTo(\"true\");\r\n    json \u003d new JsonPrimitive(\"\");\r\n    assertThat(json.getAsString()).isEqualTo(\"\");\r\n    try {\r\n        json.getAsCharacter();\r\n        fail();\r\n    } catch (UnsupportedOperationException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"String value is empty\");\r\n    }\r\n}",
    "testValidJsonOnToString": "{\r\n    JsonPrimitive json \u003d new JsonPrimitive(\"Some\\nEscaped\\nValue\");\r\n    assertThat(json.toString()).isEqualTo(\"\\\"Some\\\\nEscaped\\\\nValue\\\"\");\r\n    json \u003d new JsonPrimitive(new BigDecimal(\"1.333\"));\r\n    assertThat(json.toString()).isEqualTo(\"1.333\");\r\n}",
    "testByteEqualsInteger": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((byte) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testShortEqualsLong": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((short) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10L);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testEquals": "{\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(\"A\"), new JsonPrimitive(\"A\"));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(true), new JsonPrimitive(true));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(5L), new JsonPrimitive(5L));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(\u0027a\u0027), new JsonPrimitive(\u0027a\u0027));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.NaN), new JsonPrimitive(Float.NaN));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.NEGATIVE_INFINITY), new JsonPrimitive(Float.NEGATIVE_INFINITY));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.POSITIVE_INFINITY), new JsonPrimitive(Float.POSITIVE_INFINITY));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Double.NaN), new JsonPrimitive(Double.NaN));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Double.NEGATIVE_INFINITY), new JsonPrimitive(Double.NEGATIVE_INFINITY));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Double.POSITIVE_INFINITY), new JsonPrimitive(Double.POSITIVE_INFINITY));\r\n    assertThat(new JsonPrimitive(\"a\").equals(new JsonPrimitive(\"b\"))).isFalse();\r\n    assertThat(new JsonPrimitive(true).equals(new JsonPrimitive(false))).isFalse();\r\n    assertThat(new JsonPrimitive(0).equals(new JsonPrimitive(1))).isFalse();\r\n}",
    "testIntegerEqualsLong": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10L);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testIntegerEqualsBigInteger": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigInteger(\"10\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testNulls": "{\r\n    try {\r\n        new JsonPrimitive((Boolean) null);\r\n        fail();\r\n    } catch (NullPointerException ignored) {\r\n    }\r\n    try {\r\n        new JsonPrimitive((Number) null);\r\n        fail();\r\n    } catch (NullPointerException ignored) {\r\n    }\r\n    try {\r\n        new JsonPrimitive((String) null);\r\n        fail();\r\n    } catch (NullPointerException ignored) {\r\n    }\r\n    try {\r\n        new JsonPrimitive((Character) null);\r\n        fail();\r\n    } catch (NullPointerException ignored) {\r\n    }\r\n}",
    "testExponential": "{\r\n    JsonPrimitive json \u003d new JsonPrimitive(\"1E+7\");\r\n    assertThat(json.getAsBigDecimal()).isEqualTo(new BigDecimal(\"1E+7\"));\r\n    assertThat(json.getAsDouble()).isEqualTo(1E+7);\r\n    try {\r\n        json.getAsInt();\r\n        fail(\"Integers can not handle exponents like this.\");\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n}",
    "testByteEqualsLong": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((byte) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10L);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testEqualsIntegerAndBigInteger": "{\r\n    JsonPrimitive a \u003d new JsonPrimitive(5L);\r\n    JsonPrimitive b \u003d new JsonPrimitive(new BigInteger(\"18446744073709551621\"));\r\n    assertWithMessage(\"%s not equals %s\", a, b).that(a.equals(b)).isFalse();\r\n}",
    "testByteEqualsShort": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((byte) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive((short) 10);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testFloatEqualsBigDecimal": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10.25F);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigDecimal(\"10.25\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testDeepCopy": "{\r\n    JsonPrimitive a \u003d new JsonPrimitive(\"a\");\r\n    // Primitives are immutable!\r\n    assertThat(a).isSameInstanceAs(a.deepCopy());\r\n}",
    "testAsNumber_Boolean": "{\r\n    JsonPrimitive json \u003d new JsonPrimitive(true);\r\n    try {\r\n        json.getAsNumber();\r\n        fail();\r\n    } catch (UnsupportedOperationException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Primitive is neither a number nor a string\");\r\n    }\r\n}",
    "testEqualsDoesNotEquateStringAndNonStringTypes": "{\r\n    assertThat(new JsonPrimitive(\"true\").equals(new JsonPrimitive(true))).isFalse();\r\n    assertThat(new JsonPrimitive(\"0\").equals(new JsonPrimitive(0))).isFalse();\r\n    assertThat(new JsonPrimitive(\"NaN\").equals(new JsonPrimitive(Float.NaN))).isFalse();\r\n}",
    "testLongEqualsBigInteger": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10L);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigInteger(\"10\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testShortEqualsInteger": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((short) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testByteEqualsBigInteger": "{\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((byte) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigInteger(\"10\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "testEqualsAcrossTypes": "{\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(\"a\"), new JsonPrimitive(\u0027a\u0027));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(new BigInteger(\"0\")), new JsonPrimitive(0));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(0), new JsonPrimitive(0L));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(new BigInteger(\"0\")), new JsonPrimitive(0));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.NaN), new JsonPrimitive(Double.NaN));\r\n}",
    "testParsingStringAsBoolean": "{\r\n    JsonPrimitive json \u003d new JsonPrimitive(\"true\");\r\n    assertThat(json.isBoolean()).isFalse();\r\n    assertThat(json.getAsBoolean()).isTrue();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\bind\\JsonElementReaderTest.java": {
    "testStrings": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[\\\"A\\\",\\\"B\\\"]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"A\");\r\n    assertThat(reader.nextString()).isEqualTo(\"B\");\r\n    reader.endArray();\r\n}",
    "testNumbers": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[1, 2, 3]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.nextLong()).isEqualTo(2L);\r\n    assertThat(reader.nextDouble()).isEqualTo(3.0);\r\n    reader.endArray();\r\n}",
    "testNulls": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[null,null]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    reader.nextNull();\r\n    reader.nextNull();\r\n    reader.endArray();\r\n}",
    "testArray": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[1, 2, 3]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.BEGIN_ARRAY);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextInt()).isEqualTo(2);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextInt()).isEqualTo(3);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_ARRAY);\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testNumbersFromStrings": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[\\\"1\\\", \\\"2\\\", \\\"3\\\"]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.nextLong()).isEqualTo(2L);\r\n    assertThat(reader.nextDouble()).isEqualTo(3.0);\r\n    reader.endArray();\r\n}",
    "testWrongType": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[[],\\\"A\\\"]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.beginObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.endArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.endObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"A\");\r\n    reader.endArray();\r\n}",
    "testLenientNansAndInfinities": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[NaN, -Infinity, Infinity]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(Double.isNaN(reader.nextDouble())).isTrue();\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.NEGATIVE_INFINITY);\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.POSITIVE_INFINITY);\r\n    reader.endArray();\r\n}",
    "testNestedArrays": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[[],[[]]]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    reader.beginArray();\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    reader.endArray();\r\n    reader.endArray();\r\n}",
    "testStrictNansAndInfinities": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[NaN, -Infinity, Infinity]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.setStrictness(Strictness.LEGACY_STRICT);\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: NaN\");\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"NaN\");\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: -Infinity\");\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"-Infinity\");\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: Infinity\");\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"Infinity\");\r\n    reader.endArray();\r\n}",
    "testEmptyArray": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    reader.endArray();\r\n}",
    "testStringsFromNumbers": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[1]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"1\");\r\n    reader.endArray();\r\n}",
    "testObject": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"{\\\"A\\\": 1, \\\"B\\\": 2}\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.BEGIN_OBJECT);\r\n    reader.beginObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NAME);\r\n    assertThat(reader.nextName()).isEqualTo(\"A\");\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NAME);\r\n    assertThat(reader.nextName()).isEqualTo(\"B\");\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextInt()).isEqualTo(2);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_OBJECT);\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testNestedObjects": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"{\\\"A\\\":{},\\\"B\\\":{\\\"C\\\":{}}}\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"A\");\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"B\");\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"C\");\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    reader.endObject();\r\n    reader.endObject();\r\n}",
    "testEarlyClose": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[1, 2, 3]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    reader.close();\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "testBooleans": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[true, false]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isEqualTo(true);\r\n    assertThat(reader.nextBoolean()).isEqualTo(false);\r\n    reader.endArray();\r\n}",
    "testEmptyObject": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"{}\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginObject();\r\n    reader.endObject();\r\n}",
    "testSkipValue": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[\\\"A\\\",{\\\"B\\\":[[]]},\\\"C\\\",[[]],\\\"D\\\",null]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"A\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextString()).isEqualTo(\"C\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextString()).isEqualTo(\"D\");\r\n    reader.skipValue();\r\n    reader.endArray();\r\n}",
    "testNextJsonElement": "{\r\n    final JsonElement element \u003d JsonParser.parseString(\"{\\\"A\\\": 1, \\\"B\\\" : {}, \\\"C\\\" : []}\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginObject();\r\n    try {\r\n        reader.nextJsonElement();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    String unused1 \u003d reader.nextName();\r\n    assertThat(new JsonPrimitive(1)).isEqualTo(reader.nextJsonElement());\r\n    String unused2 \u003d reader.nextName();\r\n    reader.beginObject();\r\n    try {\r\n        reader.nextJsonElement();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    reader.endObject();\r\n    String unused3 \u003d reader.nextName();\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextJsonElement();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    reader.endArray();\r\n    reader.endObject();\r\n    try {\r\n        reader.nextJsonElement();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\sql\\SqlTimestampTypeAdapter.java": {
    "read": "{\r\n    Date date \u003d dateTypeAdapter.read(in);\r\n    return date !\u003d null ? new Timestamp(date.getTime()) : null;\r\n}",
    "create": "{\r\n    if (typeToken.getRawType() \u003d\u003d Timestamp.class) {\r\n        final TypeAdapter\u003cDate\u003e dateTypeAdapter \u003d gson.getAdapter(Date.class);\r\n        return (TypeAdapter\u003cT\u003e) new SqlTimestampTypeAdapter(dateTypeAdapter);\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "write": "{\r\n    dateTypeAdapter.write(out, value);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\reflect\\Java17ReflectionHelperTest.java": {
    "getName": "{\r\n    return name;\r\n}",
    "testJava17Record": "{\r\n    Class\u003c?\u003e unixDomainPrincipalClass \u003d Class.forName(\"jdk.net.UnixDomainPrincipal\");\r\n    // UnixDomainPrincipal is a record\r\n    assertThat(ReflectionHelper.isRecord(unixDomainPrincipalClass)).isTrue();\r\n    // with 2 components\r\n    assertThat(ReflectionHelper.getRecordComponentNames(unixDomainPrincipalClass)).isEqualTo(new String[] { \"user\", \"group\" });\r\n    // Check canonical constructor\r\n    Constructor\u003c?\u003e constructor \u003d ReflectionHelper.getCanonicalRecordConstructor(unixDomainPrincipalClass);\r\n    assertThat(constructor).isNotNull();\r\n    assertThat(constructor.getParameterTypes()).isEqualTo(new Class\u003c?\u003e[] { UserPrincipal.class, GroupPrincipal.class });\r\n}",
    "testJava17RecordAccessors": "{\r\n    // Create an instance of UnixDomainPrincipal, using our custom implementation of UserPrincipal,\r\n    // and GroupPrincipal. Then attempt to access each component of the record using our accessor\r\n    // methods.\r\n    Class\u003c?\u003e unixDomainPrincipalClass \u003d Class.forName(\"jdk.net.UnixDomainPrincipal\");\r\n    Object unixDomainPrincipal \u003d ReflectionHelper.getCanonicalRecordConstructor(unixDomainPrincipalClass).newInstance(new PrincipalImpl(\"user\"), new PrincipalImpl(\"group\"));\r\n    String[] componentNames \u003d ReflectionHelper.getRecordComponentNames(unixDomainPrincipalClass);\r\n    assertThat(componentNames.length \u003e 0).isTrue();\r\n    for (String componentName : componentNames) {\r\n        Field componentField \u003d unixDomainPrincipalClass.getDeclaredField(componentName);\r\n        Method accessor \u003d ReflectionHelper.getAccessor(unixDomainPrincipalClass, componentField);\r\n        Object principal \u003d accessor.invoke(unixDomainPrincipal);\r\n        assertThat(principal).isEqualTo(new PrincipalImpl(componentName));\r\n    }\r\n}",
    "hashCode": "{\r\n    return Objects.hash(name);\r\n}",
    "equals": "{\r\n    if (o instanceof PrincipalImpl) {\r\n        return Objects.equals(name, ((PrincipalImpl) o).name);\r\n    }\r\n    return false;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java": {
    "next": "{\r\n    return nextNode().key;\r\n}",
    "compare": "{\r\n    return a.compareTo(b);\r\n}",
    "rotateLeft": "{\r\n    Node\u003cK, V\u003e left \u003d root.left;\r\n    Node\u003cK, V\u003e pivot \u003d root.right;\r\n    Node\u003cK, V\u003e pivotLeft \u003d pivot.left;\r\n    Node\u003cK, V\u003e pivotRight \u003d pivot.right;\r\n    // move the pivot\u0027s left child to the root\u0027s right\r\n    root.right \u003d pivotLeft;\r\n    if (pivotLeft !\u003d null) {\r\n        pivotLeft.parent \u003d root;\r\n    }\r\n    replaceInParent(root, pivot);\r\n    // move the root to the pivot\u0027s left\r\n    pivot.left \u003d root;\r\n    root.parent \u003d pivot;\r\n    // fix heights\r\n    root.height \u003d Math.max(left !\u003d null ? left.height : 0, pivotLeft !\u003d null ? pivotLeft.height : 0) + 1;\r\n    pivot.height \u003d Math.max(root.height, pivotRight !\u003d null ? pivotRight.height : 0) + 1;\r\n}",
    "writeReplace": "{\r\n    return new LinkedHashMap\u003c\u003e(this);\r\n}",
    "put": "{\r\n    if (key \u003d\u003d null) {\r\n        throw new NullPointerException(\"key \u003d\u003d null\");\r\n    }\r\n    if (value \u003d\u003d null \u0026\u0026 !allowNullValues) {\r\n        throw new NullPointerException(\"value \u003d\u003d null\");\r\n    }\r\n    Node\u003cK, V\u003e created \u003d find(key, true);\r\n    V result \u003d created.value;\r\n    created.value \u003d value;\r\n    return result;\r\n}",
    "remove": "{\r\n    return removeInternalByKey(key) !\u003d null;\r\n}",
    "rebalance": "{\r\n    for (Node\u003cK, V\u003e node \u003d unbalanced; node !\u003d null; node \u003d node.parent) {\r\n        Node\u003cK, V\u003e left \u003d node.left;\r\n        Node\u003cK, V\u003e right \u003d node.right;\r\n        int leftHeight \u003d left !\u003d null ? left.height : 0;\r\n        int rightHeight \u003d right !\u003d null ? right.height : 0;\r\n        int delta \u003d leftHeight - rightHeight;\r\n        if (delta \u003d\u003d -2) {\r\n            Node\u003cK, V\u003e rightLeft \u003d right.left;\r\n            Node\u003cK, V\u003e rightRight \u003d right.right;\r\n            int rightRightHeight \u003d rightRight !\u003d null ? rightRight.height : 0;\r\n            int rightLeftHeight \u003d rightLeft !\u003d null ? rightLeft.height : 0;\r\n            int rightDelta \u003d rightLeftHeight - rightRightHeight;\r\n            if (rightDelta \u003d\u003d -1 || (rightDelta \u003d\u003d 0 \u0026\u0026 !insert)) {\r\n                // AVL right right\r\n                rotateLeft(node);\r\n            } else {\r\n                assert (rightDelta \u003d\u003d 1);\r\n                // AVL right left\r\n                rotateRight(right);\r\n                rotateLeft(node);\r\n            }\r\n            if (insert) {\r\n                // no further rotations will be necessary\r\n                break;\r\n            }\r\n        } else if (delta \u003d\u003d 2) {\r\n            Node\u003cK, V\u003e leftLeft \u003d left.left;\r\n            Node\u003cK, V\u003e leftRight \u003d left.right;\r\n            int leftRightHeight \u003d leftRight !\u003d null ? leftRight.height : 0;\r\n            int leftLeftHeight \u003d leftLeft !\u003d null ? leftLeft.height : 0;\r\n            int leftDelta \u003d leftLeftHeight - leftRightHeight;\r\n            if (leftDelta \u003d\u003d 1 || (leftDelta \u003d\u003d 0 \u0026\u0026 !insert)) {\r\n                // AVL left left\r\n                rotateRight(node);\r\n            } else {\r\n                assert (leftDelta \u003d\u003d -1);\r\n                // AVL left right\r\n                rotateLeft(left);\r\n                rotateRight(node);\r\n            }\r\n            if (insert) {\r\n                // no further rotations will be necessary\r\n                break;\r\n            }\r\n        } else if (delta \u003d\u003d 0) {\r\n            // leftHeight \u003d\u003d rightHeight\r\n            node.height \u003d leftHeight + 1;\r\n            if (insert) {\r\n                // the insert caused balance, so rebalancing is done!\r\n                break;\r\n            }\r\n        } else {\r\n            assert (delta \u003d\u003d -1 || delta \u003d\u003d 1);\r\n            node.height \u003d Math.max(leftHeight, rightHeight) + 1;\r\n            if (!insert) {\r\n                // the height hasn\u0027t changed, so rebalancing is done!\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}",
    "iterator": "{\r\n    return new LinkedTreeMapIterator\u003cK\u003e() {\r\n\r\n        @Override\r\n        public K next() {\r\n            return nextNode().key;\r\n        }\r\n    };\r\n}",
    "findByEntry": "{\r\n    Node\u003cK, V\u003e mine \u003d findByObject(entry.getKey());\r\n    boolean valuesEqual \u003d mine !\u003d null \u0026\u0026 equal(mine.value, entry.getValue());\r\n    return valuesEqual ? mine : null;\r\n}",
    "find": "{\r\n    Comparator\u003c? super K\u003e comparator \u003d this.comparator;\r\n    Node\u003cK, V\u003e nearest \u003d root;\r\n    int comparison \u003d 0;\r\n    if (nearest !\u003d null) {\r\n        // Micro-optimization: avoid polymorphic calls to Comparator.compare().\r\n        // Throws a ClassCastException below if there\u0027s trouble.\r\n        @SuppressWarnings(\"unchecked\")\r\n        Comparable\u003cObject\u003e comparableKey \u003d (comparator \u003d\u003d NATURAL_ORDER) ? (Comparable\u003cObject\u003e) key : null;\r\n        while (true) {\r\n            comparison \u003d (comparableKey !\u003d null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key, nearest.key);\r\n            // We found the requested key.\r\n            if (comparison \u003d\u003d 0) {\r\n                return nearest;\r\n            }\r\n            // If it exists, the key is in a subtree. Go deeper.\r\n            Node\u003cK, V\u003e child \u003d (comparison \u003c 0) ? nearest.left : nearest.right;\r\n            if (child \u003d\u003d null) {\r\n                break;\r\n            }\r\n            nearest \u003d child;\r\n        }\r\n    }\r\n    // The key doesn\u0027t exist in this tree.\r\n    if (!create) {\r\n        return null;\r\n    }\r\n    // Create the node and add it to the tree or the table.\r\n    Node\u003cK, V\u003e header \u003d this.header;\r\n    Node\u003cK, V\u003e created;\r\n    if (nearest \u003d\u003d null) {\r\n        // Check that the value is comparable if we didn\u0027t do any comparisons.\r\n        if (comparator \u003d\u003d NATURAL_ORDER \u0026\u0026 !(key instanceof Comparable)) {\r\n            throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\r\n        }\r\n        created \u003d new Node\u003c\u003e(allowNullValues, nearest, key, header, header.prev);\r\n        root \u003d created;\r\n    } else {\r\n        created \u003d new Node\u003c\u003e(allowNullValues, nearest, key, header, header.prev);\r\n        if (comparison \u003c 0) {\r\n            // nearest.key is higher\r\n            nearest.left \u003d created;\r\n        } else {\r\n            // comparison \u003e 0, nearest.key is lower\r\n            nearest.right \u003d created;\r\n        }\r\n        rebalance(nearest, true);\r\n    }\r\n    size++;\r\n    modCount++;\r\n    return created;\r\n}",
    "hashCode": "{\r\n    return (key \u003d\u003d null ? 0 : key.hashCode()) ^ (value \u003d\u003d null ? 0 : value.hashCode());\r\n}",
    "get": "{\r\n    Node\u003cK, V\u003e node \u003d findByObject(key);\r\n    return node !\u003d null ? node.value : null;\r\n}",
    "removeInternal": "{\r\n    if (unlink) {\r\n        node.prev.next \u003d node.next;\r\n        node.next.prev \u003d node.prev;\r\n    }\r\n    Node\u003cK, V\u003e left \u003d node.left;\r\n    Node\u003cK, V\u003e right \u003d node.right;\r\n    Node\u003cK, V\u003e originalParent \u003d node.parent;\r\n    if (left !\u003d null \u0026\u0026 right !\u003d null) {\r\n        /*\r\n       * To remove a node with both left and right subtrees, move an\r\n       * adjacent node from one of those subtrees into this node\u0027s place.\r\n       *\r\n       * Removing the adjacent node may change this node\u0027s subtrees. This\r\n       * node may no longer have two subtrees once the adjacent node is\r\n       * gone!\r\n       */\r\n        Node\u003cK, V\u003e adjacent \u003d (left.height \u003e right.height) ? left.last() : right.first();\r\n        // takes care of rebalance and size--\r\n        removeInternal(adjacent, false);\r\n        int leftHeight \u003d 0;\r\n        left \u003d node.left;\r\n        if (left !\u003d null) {\r\n            leftHeight \u003d left.height;\r\n            adjacent.left \u003d left;\r\n            left.parent \u003d adjacent;\r\n            node.left \u003d null;\r\n        }\r\n        int rightHeight \u003d 0;\r\n        right \u003d node.right;\r\n        if (right !\u003d null) {\r\n            rightHeight \u003d right.height;\r\n            adjacent.right \u003d right;\r\n            right.parent \u003d adjacent;\r\n            node.right \u003d null;\r\n        }\r\n        adjacent.height \u003d Math.max(leftHeight, rightHeight) + 1;\r\n        replaceInParent(node, adjacent);\r\n        return;\r\n    } else if (left !\u003d null) {\r\n        replaceInParent(node, left);\r\n        node.left \u003d null;\r\n    } else if (right !\u003d null) {\r\n        replaceInParent(node, right);\r\n        node.right \u003d null;\r\n    } else {\r\n        replaceInParent(node, null);\r\n    }\r\n    rebalance(originalParent, false);\r\n    size--;\r\n    modCount++;\r\n}",
    "keySet": "{\r\n    KeySet result \u003d keySet;\r\n    return result !\u003d null ? result : (keySet \u003d new KeySet());\r\n}",
    "getKey": "{\r\n    return key;\r\n}",
    "rotateRight": "{\r\n    Node\u003cK, V\u003e pivot \u003d root.left;\r\n    Node\u003cK, V\u003e right \u003d root.right;\r\n    Node\u003cK, V\u003e pivotLeft \u003d pivot.left;\r\n    Node\u003cK, V\u003e pivotRight \u003d pivot.right;\r\n    // move the pivot\u0027s right child to the root\u0027s left\r\n    root.left \u003d pivotRight;\r\n    if (pivotRight !\u003d null) {\r\n        pivotRight.parent \u003d root;\r\n    }\r\n    replaceInParent(root, pivot);\r\n    // move the root to the pivot\u0027s right\r\n    pivot.right \u003d root;\r\n    root.parent \u003d pivot;\r\n    // fixup heights\r\n    root.height \u003d Math.max(right !\u003d null ? right.height : 0, pivotRight !\u003d null ? pivotRight.height : 0) + 1;\r\n    pivot.height \u003d Math.max(root.height, pivotLeft !\u003d null ? pivotLeft.height : 0) + 1;\r\n}",
    "last": "{\r\n    Node\u003cK, V\u003e node \u003d this;\r\n    Node\u003cK, V\u003e child \u003d node.right;\r\n    while (child !\u003d null) {\r\n        node \u003d child;\r\n        child \u003d node.right;\r\n    }\r\n    return node;\r\n}",
    "entrySet": "{\r\n    EntrySet result \u003d entrySet;\r\n    return result !\u003d null ? result : (entrySet \u003d new EntrySet());\r\n}",
    "containsKey": "{\r\n    return findByObject(key) !\u003d null;\r\n}",
    "clear": "{\r\n    LinkedTreeMap.this.clear();\r\n}",
    "removeInternalByKey": "{\r\n    Node\u003cK, V\u003e node \u003d findByObject(key);\r\n    if (node !\u003d null) {\r\n        removeInternal(node, true);\r\n    }\r\n    return node;\r\n}",
    "hasNext": "{\r\n    return next !\u003d header;\r\n}",
    "findByObject": "{\r\n    try {\r\n        return key !\u003d null ? find((K) key, false) : null;\r\n    } catch (ClassCastException e) {\r\n        return null;\r\n    }\r\n}",
    "readObject": "{\r\n    // Don\u0027t permit directly deserializing this class; writeReplace() should have written a replacement\r\n    throw new InvalidObjectException(\"Deserialization is unsupported\");\r\n}",
    "equal": "{\r\n    return Objects.equals(a, b);\r\n}",
    "getValue": "{\r\n    return value;\r\n}",
    "contains": "{\r\n    return containsKey(o);\r\n}",
    "size": "{\r\n    return size;\r\n}",
    "nextNode": "{\r\n    Node\u003cK, V\u003e e \u003d next;\r\n    if (e \u003d\u003d header) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    if (modCount !\u003d expectedModCount) {\r\n        throw new ConcurrentModificationException();\r\n    }\r\n    next \u003d e.next;\r\n    return lastReturned \u003d e;\r\n}",
    "setValue": "{\r\n    if (value \u003d\u003d null \u0026\u0026 !allowNullValue) {\r\n        throw new NullPointerException(\"value \u003d\u003d null\");\r\n    }\r\n    V oldValue \u003d this.value;\r\n    this.value \u003d value;\r\n    return oldValue;\r\n}",
    "equals": "{\r\n    if (o instanceof Entry) {\r\n        Entry\u003c?, ?\u003e other \u003d (Entry\u003c?, ?\u003e) o;\r\n        return (key \u003d\u003d null ? other.getKey() \u003d\u003d null : key.equals(other.getKey())) \u0026\u0026 (value \u003d\u003d null ? other.getValue() \u003d\u003d null : value.equals(other.getValue()));\r\n    }\r\n    return false;\r\n}",
    "replaceInParent": "{\r\n    Node\u003cK, V\u003e parent \u003d node.parent;\r\n    node.parent \u003d null;\r\n    if (replacement !\u003d null) {\r\n        replacement.parent \u003d parent;\r\n    }\r\n    if (parent !\u003d null) {\r\n        if (parent.left \u003d\u003d node) {\r\n            parent.left \u003d replacement;\r\n        } else {\r\n            assert parent.right \u003d\u003d node;\r\n            parent.right \u003d replacement;\r\n        }\r\n    } else {\r\n        root \u003d replacement;\r\n    }\r\n}",
    "toString": "{\r\n    return key + \"\u003d\" + value;\r\n}",
    "first": "{\r\n    Node\u003cK, V\u003e node \u003d this;\r\n    Node\u003cK, V\u003e child \u003d node.left;\r\n    while (child !\u003d null) {\r\n        node \u003d child;\r\n        child \u003d node.left;\r\n    }\r\n    return node;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\PrimitiveTest.java": {
    "testDeserializingDecimalPointValueZeroSucceeds": "{\r\n    assertThat(gson.fromJson(\"1.0\", Integer.class)).isEqualTo(1);\r\n}",
    "testDeserializeJsonArrayAsDoublePrimitive": "{\r\n    try {\r\n        gson.fromJson(\"[1,2]\", double.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testNumberAsStringDeserialization": "{\r\n    Number value \u003d gson.fromJson(\"\\\"18\\\"\", Number.class);\r\n    assertThat(value.intValue()).isEqualTo(18);\r\n}",
    "testBooleanDeserialization": "{\r\n    boolean value \u003d gson.fromJson(\"false\", boolean.class);\r\n    assertThat(value).isEqualTo(false);\r\n    value \u003d gson.fromJson(\"true\", boolean.class);\r\n    assertThat(value).isEqualTo(true);\r\n}",
    "testFloatInfinitySerialization": "{\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    float infinity \u003d Float.POSITIVE_INFINITY;\r\n    assertThat(gson.toJson(infinity)).isEqualTo(\"Infinity\");\r\n    assertThat(gson.toJson(Float.POSITIVE_INFINITY)).isEqualTo(\"Infinity\");\r\n}",
    "testNumberDeserialization": "{\r\n    String json \u003d \"1\";\r\n    Number expected \u003d Integer.valueOf(json);\r\n    Number actual \u003d gson.fromJson(json, Number.class);\r\n    assertThat(actual.intValue()).isEqualTo(expected.intValue());\r\n    json \u003d String.valueOf(Long.MAX_VALUE);\r\n    expected \u003d Long.valueOf(json);\r\n    actual \u003d gson.fromJson(json, Number.class);\r\n    assertThat(actual.longValue()).isEqualTo(expected.longValue());\r\n    json \u003d \"1.0\";\r\n    actual \u003d gson.fromJson(json, Number.class);\r\n    assertThat(actual.longValue()).isEqualTo(1L);\r\n}",
    "testLongAsStringSerialization": "{\r\n    gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\r\n    String result \u003d gson.toJson(15L);\r\n    assertThat(result).isEqualTo(\"\\\"15\\\"\");\r\n    // Test with an integer and ensure its still a number\r\n    result \u003d gson.toJson(2);\r\n    assertThat(result).isEqualTo(\"2\");\r\n}",
    "testPrimitiveIntegerAutoboxedSerialization": "{\r\n    assertThat(gson.toJson(1)).isEqualTo(\"1\");\r\n}",
    "testBigIntegerInASingleElementArraySerialization": "{\r\n    BigInteger[] target \u003d { new BigInteger(\"1212121243434324323254365345367456456456465464564564\") };\r\n    String json \u003d gson.toJson(target);\r\n    String actual \u003d extractElementFromArray(json);\r\n    assertThat(new BigInteger(actual)).isEqualTo(target[0]);\r\n    json \u003d gson.toJson(target, BigInteger[].class);\r\n    actual \u003d extractElementFromArray(json);\r\n    assertThat(new BigInteger(actual)).isEqualTo(target[0]);\r\n}",
    "testLazilyParsedNumberDeserialization": "{\r\n    LazilyParsedNumber expected \u003d new LazilyParsedNumber(\"1.5\");\r\n    LazilyParsedNumber actual \u003d gson.fromJson(\"1.5\", LazilyParsedNumber.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testDeserializeJsonArrayAsByteWrapper": "{\r\n    try {\r\n        gson.fromJson(\"[1,2,3,4]\", Byte.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testNegativeInfinitySerialization": "{\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    double negativeInfinity \u003d Double.NEGATIVE_INFINITY;\r\n    assertThat(gson.toJson(negativeInfinity)).isEqualTo(\"-Infinity\");\r\n    assertThat(gson.toJson(Double.NEGATIVE_INFINITY)).isEqualTo(\"-Infinity\");\r\n}",
    "testDoubleInfinityDeserialization": "{\r\n    assertThat(Double.isInfinite(gson.fromJson(\"Infinity\", Double.class))).isTrue();\r\n    assertThat(Double.isInfinite(gson.fromJson(\"Infinity\", double.class))).isTrue();\r\n}",
    "testDeserializeJsonArrayAsLongWrapper": "{\r\n    try {\r\n        gson.fromJson(\"[1,2,3]\", Long.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testSmallValueForBigIntegerDeserialization": "{\r\n    BigInteger expected \u003d new BigInteger(\"15\");\r\n    BigInteger actual \u003d gson.fromJson(\"15\", BigInteger.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testDeserializeJsonObjectAsBigInteger": "{\r\n    try {\r\n        gson.fromJson(\"{\u0027c\u0027:2}\", BigInteger.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testUnquotedStringDeserializationFails": "{\r\n    assertThat(gson.fromJson(\"UnquotedSingleWord\", String.class)).isEqualTo(\"UnquotedSingleWord\");\r\n    String value \u003d \"String Blah Blah Blah...1, 2, 3\";\r\n    try {\r\n        gson.fromJson(value, String.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testQuotedStringSerializationAndDeserialization": "{\r\n    String value \u003d \"String Blah Blah Blah...1, 2, 3\";\r\n    String serializedForm \u003d gson.toJson(value);\r\n    assertThat(serializedForm).isEqualTo(\"\\\"\" + value + \"\\\"\");\r\n    String actual \u003d gson.fromJson(serializedForm, String.class);\r\n    assertThat(actual).isEqualTo(value);\r\n}",
    "testShortDeserializationLossy": "{\r\n    try {\r\n        gson.fromJson(\"-32769\", short.class);\r\n        fail();\r\n    } catch (JsonSyntaxException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Lossy conversion from -32769 to short; at path $\");\r\n    }\r\n    try {\r\n        gson.fromJson(\"65536\", short.class);\r\n        fail();\r\n    } catch (JsonSyntaxException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Lossy conversion from 65536 to short; at path $\");\r\n    }\r\n    try {\r\n        gson.fromJson(\"2147483648\", short.class);\r\n        fail();\r\n    } catch (JsonSyntaxException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"java.lang.NumberFormatException: Expected an int but was 2147483648 at line 1 column 11 path $\");\r\n    }\r\n}",
    "testPrimitiveDoubleAutoboxedSerialization": "{\r\n    assertThat(gson.toJson(-122.08234335D)).isEqualTo(\"-122.08234335\");\r\n    assertThat(gson.toJson(122.08112002D)).isEqualTo(\"122.08112002\");\r\n}",
    "testDeserializeJsonObjectAsBooleanPrimitive": "{\r\n    try {\r\n        gson.fromJson(\"{\u0027abc\u0027:1}\", boolean.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializeJsonObjectAsBytePrimitive": "{\r\n    try {\r\n        gson.fromJson(\"{\u0027abc\u0027:1}\", byte.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testSmallValueForBigDecimalSerialization": "{\r\n    BigDecimal target \u003d new BigDecimal(\"1.55\");\r\n    String actual \u003d gson.toJson(target);\r\n    assertThat(actual).isEqualTo(target.toString());\r\n}",
    "extractElementFromArray": "{\r\n    return json.substring(json.indexOf(\u0027[\u0027) + 1, json.indexOf(\u0027]\u0027));\r\n}",
    "testDeserializingBigIntegerAsInteger": "{\r\n    try {\r\n        gson.fromJson(\"12121211243123245845384534687435634558945453489543985435\", Integer.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testLongAsStringDeserialization": "{\r\n    long value \u003d gson.fromJson(\"\\\"15\\\"\", long.class);\r\n    assertThat(value).isEqualTo(15);\r\n    gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\r\n    value \u003d gson.fromJson(\"\\\"25\\\"\", long.class);\r\n    assertThat(value).isEqualTo(25);\r\n}",
    "testByteDeserializationLossy": "{\r\n    try {\r\n        gson.fromJson(\"-129\", byte.class);\r\n        fail();\r\n    } catch (JsonSyntaxException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Lossy conversion from -129 to byte; at path $\");\r\n    }\r\n    try {\r\n        gson.fromJson(\"256\", byte.class);\r\n        fail();\r\n    } catch (JsonSyntaxException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Lossy conversion from 256 to byte; at path $\");\r\n    }\r\n    try {\r\n        gson.fromJson(\"2147483648\", byte.class);\r\n        fail();\r\n    } catch (JsonSyntaxException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"java.lang.NumberFormatException: Expected an int but was 2147483648 at line 1 column 11 path $\");\r\n    }\r\n}",
    "testShortSerialization": "{\r\n    assertThat(gson.toJson(1, short.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(1, Short.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(Short.MIN_VALUE, Short.class)).isEqualTo(Short.toString(Short.MIN_VALUE));\r\n    assertThat(gson.toJson(Short.MAX_VALUE, Short.class)).isEqualTo(Short.toString(Short.MAX_VALUE));\r\n    // Should perform widening conversion\r\n    assertThat(gson.toJson((byte) 1, Short.class)).isEqualTo(\"1\");\r\n    // Should perform narrowing conversion\r\n    assertThat(gson.toJson(32768, Short.class)).isEqualTo(\"-32768\");\r\n    assertThat(gson.toJson(1.5, Short.class)).isEqualTo(\"1\");\r\n}",
    "testNegativeInfinitySerializationNotSupportedByDefault": "{\r\n    try {\r\n        double negativeInfinity \u003d Double.NEGATIVE_INFINITY;\r\n        gson.toJson(negativeInfinity);\r\n        fail(\"Gson should not accept negative infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Double.NEGATIVE_INFINITY);\r\n        fail(\"Gson should not accept negative infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testByteSerialization": "{\r\n    assertThat(gson.toJson(1, byte.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(1, Byte.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(Byte.MIN_VALUE, Byte.class)).isEqualTo(Byte.toString(Byte.MIN_VALUE));\r\n    assertThat(gson.toJson(Byte.MAX_VALUE, Byte.class)).isEqualTo(Byte.toString(Byte.MAX_VALUE));\r\n    // Should perform narrowing conversion\r\n    assertThat(gson.toJson(128, Byte.class)).isEqualTo(\"-128\");\r\n    assertThat(gson.toJson(1.5, Byte.class)).isEqualTo(\"1\");\r\n}",
    "testDeserializePrimitiveWrapperAsObjectField": "{\r\n    String json \u003d \"{i:10}\";\r\n    ClassWithIntegerField target \u003d gson.fromJson(json, ClassWithIntegerField.class);\r\n    assertThat(target.i).isEqualTo(10);\r\n}",
    "testPrimitiveDoubleAutoboxedInASingleElementArraySerialization": "{\r\n    double[] target \u003d { -122.08D };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[-122.08]\");\r\n    assertThat(gson.toJson(target, double[].class)).isEqualTo(\"[-122.08]\");\r\n    assertThat(gson.toJson(target, Double[].class)).isEqualTo(\"[-122.08]\");\r\n}",
    "testNegativeInfinityFloatSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    float negativeInfinity \u003d Float.NEGATIVE_INFINITY;\r\n    assertThat(gson.toJson(negativeInfinity)).isEqualTo(\"-Infinity\");\r\n    assertThat(gson.toJson(Float.NEGATIVE_INFINITY)).isEqualTo(\"-Infinity\");\r\n}",
    "testHtmlCharacterSerialization": "{\r\n    String target \u003d \"\u003cscript\u003evar a \u003d 12;\u003c/script\u003e\";\r\n    String result \u003d gson.toJson(target);\r\n    assertThat(result).isNotEqualTo(\u0027\"\u0027 + target + \u0027\"\u0027);\r\n    gson \u003d new GsonBuilder().disableHtmlEscaping().create();\r\n    result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(\u0027\"\u0027 + target + \u0027\"\u0027);\r\n}",
    "testReallyLongValuesSerialization": "{\r\n    long value \u003d 333961828784581L;\r\n    assertThat(gson.toJson(value)).isEqualTo(\"333961828784581\");\r\n}",
    "testPrimitiveBooleanAutoboxedSerialization": "{\r\n    assertThat(gson.toJson(true)).isEqualTo(\"true\");\r\n    assertThat(gson.toJson(false)).isEqualTo(\"false\");\r\n}",
    "testDoubleSerialization": "{\r\n    assertThat(gson.toJson(1.5, double.class)).isEqualTo(\"1.5\");\r\n    assertThat(gson.toJson(1.5, Double.class)).isEqualTo(\"1.5\");\r\n    assertThat(gson.toJson(Double.MIN_VALUE, Double.class)).isEqualTo(Double.toString(Double.MIN_VALUE));\r\n    assertThat(gson.toJson(Double.MAX_VALUE, Double.class)).isEqualTo(Double.toString(Double.MAX_VALUE));\r\n    // Should perform widening conversion\r\n    assertThat(gson.toJson((byte) 1, Double.class)).isEqualTo(\"1.0\");\r\n    // (This widening conversion is actually lossy)\r\n    assertThat(gson.toJson(Long.MAX_VALUE - 10L, Double.class)).isEqualTo(Double.toString((double) (Long.MAX_VALUE - 10L)));\r\n}",
    "testFloatInfinitySerializationNotSupportedByDefault": "{\r\n    try {\r\n        float infinity \u003d Float.POSITIVE_INFINITY;\r\n        gson.toJson(infinity);\r\n        fail(\"Gson should not accept positive infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Float.POSITIVE_INFINITY);\r\n        fail(\"Gson should not accept positive infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testReallyLongValuesDeserialization": "{\r\n    String json \u003d \"333961828784581\";\r\n    long value \u003d gson.fromJson(json, Long.class);\r\n    assertThat(value).isEqualTo(333961828784581L);\r\n}",
    "testPrimitiveDoubleAutoboxedDeserialization": "{\r\n    double actual \u003d gson.fromJson(\"-122.08858585\", double.class);\r\n    assertThat(actual).isEqualTo(-122.08858585D);\r\n    actual \u003d gson.fromJson(\"122.023900008000\", Double.class);\r\n    assertThat(actual).isEqualTo(122.023900008D);\r\n}",
    "testBigDecimalPreservePrecisionSerialization": "{\r\n    String expectedValue \u003d \"1.000\";\r\n    BigDecimal obj \u003d new BigDecimal(expectedValue);\r\n    String actualValue \u003d gson.toJson(obj);\r\n    assertThat(actualValue).isEqualTo(expectedValue);\r\n}",
    "testSmallValueForBigDecimalDeserialization": "{\r\n    BigDecimal expected \u003d new BigDecimal(\"1.55\");\r\n    BigDecimal actual \u003d gson.fromJson(\"1.55\", BigDecimal.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testByteDeserialization": "{\r\n    Byte boxed \u003d gson.fromJson(\"1\", Byte.class);\r\n    assertThat(boxed).isEqualTo(1);\r\n    byte primitive \u003d gson.fromJson(\"1\", byte.class);\r\n    assertThat(primitive).isEqualTo(1);\r\n    byte[] bytes \u003d gson.fromJson(\"[-128, 0, 127, 255]\", byte[].class);\r\n    assertThat(bytes).isEqualTo(new byte[] { -128, 0, 127, -1 });\r\n}",
    "testDoubleInfinitySerialization": "{\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    double infinity \u003d Double.POSITIVE_INFINITY;\r\n    assertThat(gson.toJson(infinity)).isEqualTo(\"Infinity\");\r\n    assertThat(gson.toJson(Double.POSITIVE_INFINITY)).isEqualTo(\"Infinity\");\r\n}",
    "testBigDecimalInASingleElementArraySerialization": "{\r\n    BigDecimal[] target \u003d { new BigDecimal(\"-122.08e-21\") };\r\n    String json \u003d gson.toJson(target);\r\n    String actual \u003d extractElementFromArray(json);\r\n    assertThat(new BigDecimal(actual)).isEqualTo(target[0]);\r\n    json \u003d gson.toJson(target, BigDecimal[].class);\r\n    actual \u003d extractElementFromArray(json);\r\n    assertThat(new BigDecimal(actual)).isEqualTo(target[0]);\r\n}",
    "testPrimitiveIntegerAutoboxedDeserialization": "{\r\n    int expected \u003d 1;\r\n    int actual \u003d gson.fromJson(\"1\", int.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    actual \u003d gson.fromJson(\"1\", Integer.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testShortDeserialization": "{\r\n    Short boxed \u003d gson.fromJson(\"1\", Short.class);\r\n    assertThat(boxed).isEqualTo(1);\r\n    short primitive \u003d gson.fromJson(\"1\", short.class);\r\n    assertThat(primitive).isEqualTo(1);\r\n    short[] shorts \u003d gson.fromJson(\"[-32768, 0, 32767, 65535]\", short[].class);\r\n    assertThat(shorts).isEqualTo(new short[] { -32768, 0, 32767, -1 });\r\n}",
    "testBigDecimalSerialization": "{\r\n    BigDecimal target \u003d new BigDecimal(\"-122.0e-21\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(new BigDecimal(json)).isEqualTo(target);\r\n}",
    "testDeserializeJsonObjectAsInteger": "{\r\n    try {\r\n        gson.fromJson(\"{}\", Integer.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializeJsonArrayAsBooleanWrapper": "{\r\n    try {\r\n        gson.fromJson(\"[1,2,3,4]\", Boolean.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializeJsonArrayAsShortWrapper": "{\r\n    try {\r\n        gson.fromJson(\"[\u0027a\u0027,\u0027b\u0027]\", Short.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testBigDecimalDeserialization": "{\r\n    BigDecimal target \u003d new BigDecimal(\"-122.0e-21\");\r\n    String json \u003d \"-122.0e-21\";\r\n    assertThat(gson.fromJson(json, BigDecimal.class)).isEqualTo(target);\r\n}",
    "testDoubleArrayDeserialization": "{\r\n    String json \u003d \"[0.0, 0.004761904761904762, 3.4013606962703525E-4, 7.936508173034305E-4,\" + \"0.0011904761904761906, 0.0]\";\r\n    double[] values \u003d gson.fromJson(json, double[].class);\r\n    assertThat(values).hasLength(6);\r\n    assertThat(values[0]).isEqualTo(0.0);\r\n    assertThat(values[1]).isEqualTo(0.004761904761904762);\r\n    assertThat(values[2]).isEqualTo(3.4013606962703525E-4);\r\n    assertThat(values[3]).isEqualTo(7.936508173034305E-4);\r\n    assertThat(values[4]).isEqualTo(0.0011904761904761906);\r\n    assertThat(values[5]).isEqualTo(0.0);\r\n}",
    "testBigDecimalPreservePrecisionDeserialization": "{\r\n    String json \u003d \"1.000\";\r\n    BigDecimal expected \u003d new BigDecimal(json);\r\n    BigDecimal actual \u003d gson.fromJson(json, BigDecimal.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testLazilyParsedNumberSerialization": "{\r\n    LazilyParsedNumber target \u003d new LazilyParsedNumber(\"1.5\");\r\n    String actual \u003d gson.toJson(target);\r\n    assertThat(actual).isEqualTo(\"1.5\");\r\n}",
    "testPrimitiveClassLiteral": "{\r\n    assertThat(gson.fromJson(\"1\", int.class)).isEqualTo(1);\r\n    assertThat(gson.fromJson(new StringReader(\"1\"), int.class)).isEqualTo(1);\r\n    assertThat(gson.fromJson(new JsonPrimitive(1), int.class)).isEqualTo(1);\r\n}",
    "testLargeDoubleDeserialization": "{\r\n    String doubleValue \u003d \"1.234567899E8\";\r\n    Double expected \u003d Double.valueOf(doubleValue);\r\n    Double actual \u003d gson.fromJson(doubleValue, Double.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    double actual1 \u003d gson.fromJson(doubleValue, double.class);\r\n    assertThat(actual1).isEqualTo(expected);\r\n}",
    "testBigDecimalInfinityDeserializationNotSupported": "{\r\n    try {\r\n        gson.fromJson(\"Infinity\", BigDecimal.class);\r\n        fail(\"Gson should not accept positive infinity for deserialization with BigDecimal\");\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testBigDecimalNaNDeserializationNotSupported": "{\r\n    try {\r\n        gson.fromJson(\"NaN\", BigDecimal.class);\r\n        fail(\"Gson should not accept NaN for deserialization by default.\");\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDoubleNoFractAsStringRepresentationDeserialization": "{\r\n    String doubleValue \u003d \"1E+5\";\r\n    Double expected \u003d Double.valueOf(doubleValue);\r\n    Double actual \u003d gson.fromJson(doubleValue, Double.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    double actual1 \u003d gson.fromJson(doubleValue, double.class);\r\n    assertThat(actual1).isEqualTo(expected);\r\n}",
    "testBigDecimalAsStringRepresentationDeserialization": "{\r\n    String doubleValue \u003d \"0.05E+5\";\r\n    BigDecimal expected \u003d new BigDecimal(doubleValue);\r\n    BigDecimal actual \u003d gson.fromJson(doubleValue, BigDecimal.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testDeserializeJsonObjectAsDoubleWrapper": "{\r\n    try {\r\n        gson.fromJson(\"{\u0027abc\u0027:1}\", Double.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testFloatNaNDeserialization": "{\r\n    assertThat(Float.isNaN(gson.fromJson(\"NaN\", Float.class))).isTrue();\r\n    assertThat(Float.isNaN(gson.fromJson(\"NaN\", float.class))).isTrue();\r\n}",
    "testDeserializeJsonObjectAsShortPrimitive": "{\r\n    try {\r\n        gson.fromJson(\"{\u0027abc\u0027:1}\", short.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializeJsonArrayAsNumber": "{\r\n    try {\r\n        gson.fromJson(\"[1,2,3,4]\", Number.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDoubleAsStringRepresentationDeserialization": "{\r\n    String doubleValue \u003d \"1.0043E+5\";\r\n    Double expected \u003d Double.valueOf(doubleValue);\r\n    Double actual \u003d gson.fromJson(doubleValue, Double.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    double actual1 \u003d gson.fromJson(doubleValue, double.class);\r\n    assertThat(actual1).isEqualTo(expected);\r\n}",
    "testBigIntegerSerialization": "{\r\n    BigInteger target \u003d new BigInteger(\"12121211243123245845384534687435634558945453489543985435\");\r\n    assertThat(gson.toJson(target)).isEqualTo(target.toString());\r\n}",
    "testDoubleNaNDeserialization": "{\r\n    assertThat(Double.isNaN(gson.fromJson(\"NaN\", Double.class))).isTrue();\r\n    assertThat(Double.isNaN(gson.fromJson(\"NaN\", double.class))).isTrue();\r\n}",
    "testDoubleNaNSerializationNotSupportedByDefault": "{\r\n    try {\r\n        double nan \u003d Double.NaN;\r\n        gson.toJson(nan);\r\n        fail(\"Gson should not accept NaN for serialization\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Double.NaN);\r\n        fail(\"Gson should not accept NaN for serialization\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testDeserializeJsonObjectAsLongPrimitive": "{\r\n    try {\r\n        gson.fromJson(\"{\u0027abc\u0027:1}\", long.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testStringsAsBooleans": "{\r\n    String json \u003d \"[\u0027true\u0027, \u0027false\u0027, \u0027TRUE\u0027, \u0027yes\u0027, \u00271\u0027]\";\r\n    List\u003cBoolean\u003e deserialized \u003d gson.fromJson(json, new TypeToken\u003cList\u003cBoolean\u003e\u003e() {\r\n    });\r\n    assertThat(deserialized).isEqualTo(Arrays.asList(true, false, true, false, false));\r\n}",
    "testDeserializingBigIntegerAsLong": "{\r\n    try {\r\n        gson.fromJson(\"12121211243123245845384534687435634558945453489543985435\", Long.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testNegativeInfinityDeserialization": "{\r\n    assertThat(Double.isInfinite(gson.fromJson(\"-Infinity\", double.class))).isTrue();\r\n    assertThat(Double.isInfinite(gson.fromJson(\"-Infinity\", Double.class))).isTrue();\r\n}",
    "testDeserializeJsonArrayAsBigDecimal": "{\r\n    try {\r\n        gson.fromJson(\"[1,2,3,4]\", BigDecimal.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testFloatInfinityDeserialization": "{\r\n    assertThat(Float.isInfinite(gson.fromJson(\"Infinity\", Float.class))).isTrue();\r\n    assertThat(Float.isInfinite(gson.fromJson(\"Infinity\", float.class))).isTrue();\r\n}",
    "testDeserializingNonZeroDecimalPointValuesAsIntegerFails": "{\r\n    try {\r\n        gson.fromJson(\"1.02\", Byte.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n    try {\r\n        gson.fromJson(\"1.02\", Short.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n    try {\r\n        gson.fromJson(\"1.02\", Integer.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n    try {\r\n        gson.fromJson(\"1.02\", Long.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testMoreSpecificSerialization": "{\r\n    Gson gson \u003d new Gson();\r\n    String expected \u003d \"This is a string\";\r\n    String expectedJson \u003d gson.toJson(expected);\r\n    Serializable serializableString \u003d expected;\r\n    String actualJson \u003d gson.toJson(serializableString, Serializable.class);\r\n    assertThat(actualJson).isNotEqualTo(expectedJson);\r\n}",
    "testFloatNaNSerializationNotSupportedByDefault": "{\r\n    try {\r\n        float nan \u003d Float.NaN;\r\n        gson.toJson(nan);\r\n        fail(\"Gson should not accept NaN for serialization\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Float.NaN);\r\n        fail(\"Gson should not accept NaN for serialization\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testNumberSerialization": "{\r\n    Number expected \u003d 1L;\r\n    String json \u003d gson.toJson(expected);\r\n    assertThat(json).isEqualTo(expected.toString());\r\n    json \u003d gson.toJson(expected, Number.class);\r\n    assertThat(json).isEqualTo(expected.toString());\r\n}",
    "testBigDecimalNoFractAsStringRepresentationDeserialization": "{\r\n    String doubleValue \u003d \"5E+5\";\r\n    BigDecimal expected \u003d new BigDecimal(doubleValue);\r\n    BigDecimal actual \u003d gson.fromJson(doubleValue, BigDecimal.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testBigDecimalNegativeInfinityDeserializationNotSupported": "{\r\n    try {\r\n        gson.fromJson(\"-Infinity\", BigDecimal.class);\r\n        fail(\"Gson should not accept positive infinity for deserialization\");\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializeJsonObjectAsBigDecimal": "{\r\n    try {\r\n        gson.fromJson(\"{\u0027a\u0027:1}\", BigDecimal.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDoubleNaNSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    double nan \u003d Double.NaN;\r\n    assertThat(gson.toJson(nan)).isEqualTo(\"NaN\");\r\n    assertThat(gson.toJson(Double.NaN)).isEqualTo(\"NaN\");\r\n}",
    "testDeserializingBigIntegerAsBigDecimal": "{\r\n    BigDecimal actual \u003d gson.fromJson(\"12121211243123245845384534687435634558945453489543985435\", BigDecimal.class);\r\n    assertThat(actual.toPlainString()).isEqualTo(\"12121211243123245845384534687435634558945453489543985435\");\r\n}",
    "testFloatSerialization": "{\r\n    assertThat(gson.toJson(1.5f, float.class)).isEqualTo(\"1.5\");\r\n    assertThat(gson.toJson(1.5f, Float.class)).isEqualTo(\"1.5\");\r\n    assertThat(gson.toJson(Float.MIN_VALUE, Float.class)).isEqualTo(Float.toString(Float.MIN_VALUE));\r\n    assertThat(gson.toJson(Float.MAX_VALUE, Float.class)).isEqualTo(Float.toString(Float.MAX_VALUE));\r\n    // Should perform widening conversion\r\n    assertThat(gson.toJson((byte) 1, Float.class)).isEqualTo(\"1.0\");\r\n    // (This widening conversion is actually lossy)\r\n    assertThat(gson.toJson(Long.MAX_VALUE - 10L, Float.class)).isEqualTo(Float.toString((float) (Long.MAX_VALUE - 10L)));\r\n    // Should perform narrowing conversion\r\n    gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    assertThat(gson.toJson(Double.MAX_VALUE, Float.class)).isEqualTo(\"Infinity\");\r\n}",
    "testNegativeInfinityFloatSerializationNotSupportedByDefault": "{\r\n    try {\r\n        float negativeInfinity \u003d Float.NEGATIVE_INFINITY;\r\n        gson.toJson(negativeInfinity);\r\n        fail(\"Gson should not accept negative infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Float.NEGATIVE_INFINITY);\r\n        fail(\"Gson should not accept negative infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testPrimitiveIntegerAutoboxedInASingleElementArraySerialization": "{\r\n    int[] target \u003d { -9332 };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[-9332]\");\r\n    assertThat(gson.toJson(target, int[].class)).isEqualTo(\"[-9332]\");\r\n    assertThat(gson.toJson(target, Integer[].class)).isEqualTo(\"[-9332]\");\r\n}",
    "testPrimitiveLongAutoboxedDeserialization": "{\r\n    long expected \u003d 1L;\r\n    long actual \u003d gson.fromJson(\"1\", long.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    actual \u003d gson.fromJson(\"1\", Long.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testBadValueForBigIntegerDeserialization": "{\r\n    try {\r\n        gson.fromJson(\"15.099\", BigInteger.class);\r\n        fail(\"BigInteger can not be decimal values.\");\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializingBigDecimalAsIntegerFails": "{\r\n    try {\r\n        gson.fromJson(\"-122.08e-213\", Integer.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializingBigDecimalAsBigIntegerFails": "{\r\n    try {\r\n        gson.fromJson(\"-122.08e-213\", BigInteger.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testFloatNaNSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    float nan \u003d Float.NaN;\r\n    assertThat(gson.toJson(nan)).isEqualTo(\"NaN\");\r\n    assertThat(gson.toJson(Float.NaN)).isEqualTo(\"NaN\");\r\n}",
    "testPrimitiveLongAutoboxedInASingleElementArraySerialization": "{\r\n    long[] target \u003d { -23L };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[-23]\");\r\n    assertThat(gson.toJson(target, long[].class)).isEqualTo(\"[-23]\");\r\n    assertThat(gson.toJson(target, Long[].class)).isEqualTo(\"[-23]\");\r\n}",
    "testNegativeInfinityFloatDeserialization": "{\r\n    assertThat(Float.isInfinite(gson.fromJson(\"-Infinity\", float.class))).isTrue();\r\n    assertThat(Float.isInfinite(gson.fromJson(\"-Infinity\", Float.class))).isTrue();\r\n}",
    "testDeserializingBigDecimalAsDouble": "{\r\n    String json \u003d \"-122.08e-2132332\";\r\n    double actual \u003d gson.fromJson(json, double.class);\r\n    assertThat(actual).isEqualTo(-0.0d);\r\n}",
    "testPrimitiveBooleanAutoboxedInASingleElementArraySerialization": "{\r\n    boolean[] target \u003d { false };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[false]\");\r\n    assertThat(gson.toJson(target, boolean[].class)).isEqualTo(\"[false]\");\r\n    assertThat(gson.toJson(target, Boolean[].class)).isEqualTo(\"[false]\");\r\n}",
    "testPrimitiveLongAutoboxedSerialization": "{\r\n    assertThat(gson.toJson(1L, long.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(1L, Long.class)).isEqualTo(\"1\");\r\n}",
    "testDoubleInfinitySerializationNotSupportedByDefault": "{\r\n    try {\r\n        double infinity \u003d Double.POSITIVE_INFINITY;\r\n        gson.toJson(infinity);\r\n        fail(\"Gson should not accept positive infinity for serialization by default.\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Double.POSITIVE_INFINITY);\r\n        fail(\"Gson should not accept positive infinity for serialization by default.\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testSmallValueForBigIntegerSerialization": "{\r\n    BigInteger target \u003d new BigInteger(\"15\");\r\n    String actual \u003d gson.toJson(target);\r\n    assertThat(actual).isEqualTo(target.toString());\r\n}",
    "testBigIntegerDeserialization": "{\r\n    String json \u003d \"12121211243123245845384534687435634558945453489543985435\";\r\n    BigInteger target \u003d new BigInteger(json);\r\n    assertThat(gson.fromJson(json, BigInteger.class)).isEqualTo(target);\r\n}",
    "testValueVeryCloseToZeroIsZero": "{\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", byte.class)).isEqualTo(0);\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", short.class)).isEqualTo(0);\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", int.class)).isEqualTo(0);\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", long.class)).isEqualTo(0);\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", float.class)).isEqualTo(-0.0f);\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", double.class)).isEqualTo(-0.0);\r\n    assertThat(gson.fromJson(\"122.08e-2132\", float.class)).isEqualTo(0.0f);\r\n    assertThat(gson.fromJson(\"122.08e-2132\", double.class)).isEqualTo(0.0);\r\n}",
    "testDeserializeJsonObjectAsFloatPrimitive": "{\r\n    try {\r\n        gson.fromJson(\"{\u0027abc\u0027:1}\", float.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializeJsonObjectAsNumber": "{\r\n    try {\r\n        gson.fromJson(\"{\u0027c\u0027:2}\", Number.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializingBigDecimalAsFloat": "{\r\n    String json \u003d \"-122.08e-2132332\";\r\n    float actual \u003d gson.fromJson(json, float.class);\r\n    assertThat(actual).isEqualTo(-0.0f);\r\n}",
    "testDeserializeJsonArrayAsFloatWrapper": "{\r\n    try {\r\n        gson.fromJson(\"[1,2,3]\", Float.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializeJsonArrayAsBigInteger": "{\r\n    try {\r\n        gson.fromJson(\"[1,2,3,4]\", BigInteger.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializeJsonArrayAsInt": "{\r\n    try {\r\n        gson.fromJson(\"[1, 2, 3, 4]\", int.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testLongSerialization": "{\r\n    assertThat(gson.toJson(1L, long.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(1L, Long.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(Long.MIN_VALUE, Long.class)).isEqualTo(Long.toString(Long.MIN_VALUE));\r\n    assertThat(gson.toJson(Long.MAX_VALUE, Long.class)).isEqualTo(Long.toString(Long.MAX_VALUE));\r\n    // Should perform widening conversion\r\n    assertThat(gson.toJson((byte) 1, Long.class)).isEqualTo(\"1\");\r\n    // Should perform narrowing conversion\r\n    assertThat(gson.toJson(1.5, Long.class)).isEqualTo(\"1\");\r\n}",
    "testIntSerialization": "{\r\n    assertThat(gson.toJson(1, int.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(1, Integer.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(Integer.MIN_VALUE, Integer.class)).isEqualTo(Integer.toString(Integer.MIN_VALUE));\r\n    assertThat(gson.toJson(Integer.MAX_VALUE, Integer.class)).isEqualTo(Integer.toString(Integer.MAX_VALUE));\r\n    // Should perform widening conversion\r\n    assertThat(gson.toJson((byte) 1, Integer.class)).isEqualTo(\"1\");\r\n    // Should perform narrowing conversion\r\n    assertThat(gson.toJson(2147483648L, Integer.class)).isEqualTo(\"-2147483648\");\r\n    assertThat(gson.toJson(1.5, Integer.class)).isEqualTo(\"1\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\DefaultDateTypeAdapter.java": {
    "createAdapterFactory": "{\r\n    return createFactory(new DefaultDateTypeAdapter\u003c\u003e(this, dateStyle, timeStyle));\r\n}",
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    Date date \u003d deserializeToDate(in);\r\n    return dateType.deserialize(date);\r\n}",
    "deserializeToDate": "{\r\n    String s \u003d in.nextString();\r\n    synchronized (dateFormats) {\r\n        for (DateFormat dateFormat : dateFormats) {\r\n            try {\r\n                return dateFormat.parse(s);\r\n            } catch (ParseException ignored) {\r\n                // OK: try the next format\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return ISO8601Utils.parse(s, new ParsePosition(0));\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "toString": "{\r\n    DateFormat defaultFormat \u003d dateFormats.get(0);\r\n    if (defaultFormat instanceof SimpleDateFormat) {\r\n        return SIMPLE_NAME + \u0027(\u0027 + ((SimpleDateFormat) defaultFormat).toPattern() + \u0027)\u0027;\r\n    } else {\r\n        return SIMPLE_NAME + \u0027(\u0027 + defaultFormat.getClass().getSimpleName() + \u0027)\u0027;\r\n    }\r\n}",
    "createFactory": "{\r\n    return TypeAdapters.newFactory(dateClass, adapter);\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    DateFormat dateFormat \u003d dateFormats.get(0);\r\n    String dateFormatAsString;\r\n    synchronized (dateFormats) {\r\n        dateFormatAsString \u003d dateFormat.format(value);\r\n    }\r\n    out.value(dateFormatAsString);\r\n}",
    "deserialize": "{\r\n    return date;\r\n}",
    "createDefaultsAdapterFactory": "{\r\n    return createFactory(new DefaultDateTypeAdapter\u003c\u003e(this, DateFormat.DEFAULT, DateFormat.DEFAULT));\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\ExclusionStrategy.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonParserTest.java": {
    "testBadFieldTypeForCustomDeserializerCustomTree": "{\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(new JsonPrimitive(\"blah\"));\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"stringValue\", \"foo\");\r\n    obj.addProperty(\"intValue\", 11);\r\n    obj.add(\"longValue\", array);\r\n    try {\r\n        gson.fromJson(obj, BagOfPrimitives.class);\r\n        fail(\"BagOfPrimitives is not an array\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testBadTypeForDeserializingCustomTree": "{\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"stringValue\", \"foo\");\r\n    obj.addProperty(\"intValue\", 11);\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(obj);\r\n    try {\r\n        gson.fromJson(array, BagOfPrimitives.class);\r\n        fail(\"BagOfPrimitives is not an array\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testChangingCustomTreeAndDeserializing": "{\r\n    StringReader json \u003d new StringReader(\"{\u0027stringValue\u0027:\u0027no message\u0027,\u0027intValue\u0027:10,\u0027longValue\u0027:20}\");\r\n    JsonObject obj \u003d (JsonObject) JsonParser.parseReader(json);\r\n    obj.remove(\"stringValue\");\r\n    obj.addProperty(\"stringValue\", \"fooBar\");\r\n    BagOfPrimitives target \u003d gson.fromJson(obj, BagOfPrimitives.class);\r\n    assertThat(target.intValue).isEqualTo(10);\r\n    assertThat(target.longValue).isEqualTo(20);\r\n    assertThat(target.stringValue).isEqualTo(\"fooBar\");\r\n}",
    "testExtraCommasInMaps": "{\r\n    Type type \u003d new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n    }.getType();\r\n    try {\r\n        gson.fromJson(\"{a:b,}\", type);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testDeserializingCustomTree": "{\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"stringValue\", \"foo\");\r\n    obj.addProperty(\"intValue\", 11);\r\n    BagOfPrimitives target \u003d gson.fromJson(obj, BagOfPrimitives.class);\r\n    assertThat(target.intValue).isEqualTo(11);\r\n    assertThat(target.stringValue).isEqualTo(\"foo\");\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testExtraCommasInArrays": "{\r\n    Type type \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(Arrays.asList(\"a\", null, \"b\", null, null)).isEqualTo(gson.fromJson(\"[a,,b,,]\", type));\r\n    assertThat(Arrays.asList(null, null)).isEqualTo(gson.fromJson(\"[,]\", type));\r\n    assertThat(Arrays.asList(\"a\", null)).isEqualTo(gson.fromJson(\"[a,]\", type));\r\n}",
    "testParseInvalidJson": "{\r\n    try {\r\n        gson.fromJson(\"[[]\", Object[].class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testBadFieldTypeForDeserializingCustomTree": "{\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(new JsonPrimitive(\"blah\"));\r\n    JsonObject primitive1 \u003d new JsonObject();\r\n    primitive1.addProperty(\"string\", \"foo\");\r\n    primitive1.addProperty(\"intValue\", 11);\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.add(\"primitive1\", primitive1);\r\n    obj.add(\"primitive2\", array);\r\n    try {\r\n        gson.fromJson(obj, Nested.class);\r\n        fail(\"Nested has field BagOfPrimitives which is not an array\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\common\\TestTypes.java": {
    "serialize": "{\r\n    return new JsonPrimitive(src + DIFFERENCE);\r\n}",
    "getValue": "{\r\n    return value;\r\n}",
    "getExpectedJson": "{\r\n    return \u0027{\u0027 + \"\\\"fooBar\\\":\" + f + \",\\\"Another Foo\\\":\" + g + \u0027}\u0027;\r\n}",
    "getIntValue": "{\r\n    return intValue;\r\n}",
    "hashCode": "{\r\n    return 1;\r\n}",
    "equals": "{\r\n    return true;\r\n}",
    "toString": "{\r\n    return String.format(\"(longValue\u003d%d,intValue\u003d%d,booleanValue\u003d%b,stringValue\u003d%s)\", longValue, intValue, booleanValue, stringValue);\r\n}",
    "appendFields": "{\r\n    if (primitive1 !\u003d null) {\r\n        sb.append(\"\\\"primitive1\\\":\").append(primitive1.getExpectedJson());\r\n    }\r\n    if (primitive1 !\u003d null \u0026\u0026 primitive2 !\u003d null) {\r\n        sb.append(\",\");\r\n    }\r\n    if (primitive2 !\u003d null) {\r\n        sb.append(\"\\\"primitive2\\\":\").append(primitive2.getExpectedJson());\r\n    }\r\n}",
    "getBag": "{\r\n    return bag;\r\n}",
    "deserialize": "{\r\n    return json.getAsLong() - DIFFERENCE;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TreeTypeAdapter.java": {
    "delegate": "{\r\n    // A race might lead to `delegate` being assigned by multiple threads but the last assignment will stick\r\n    TypeAdapter\u003cT\u003e d \u003d delegate;\r\n    return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(skipPastForGetDelegateAdapter, typeToken));\r\n}",
    "serialize": "{\r\n    return gson.toJsonTree(src, typeOfSrc);\r\n}",
    "read": "{\r\n    if (deserializer \u003d\u003d null) {\r\n        return delegate().read(in);\r\n    }\r\n    JsonElement value \u003d Streams.parse(in);\r\n    if (nullSafe \u0026\u0026 value.isJsonNull()) {\r\n        return null;\r\n    }\r\n    return deserializer.deserialize(value, typeToken.getType(), context);\r\n}",
    "newFactory": "{\r\n    return new SingleTypeFactory(typeAdapter, exactType, false, null);\r\n}",
    "getSerializationDelegate": "{\r\n    return serializer !\u003d null ? this : delegate();\r\n}",
    "create": "{\r\n    boolean matches \u003d exactType !\u003d null ? exactType.equals(type) || (matchRawType \u0026\u0026 exactType.getType() \u003d\u003d type.getRawType()) : hierarchyType.isAssignableFrom(type.getRawType());\r\n    return matches ? new TreeTypeAdapter\u003c\u003e((JsonSerializer\u003cT\u003e) serializer, (JsonDeserializer\u003cT\u003e) deserializer, gson, type, this) : null;\r\n}",
    "newFactoryWithMatchRawType": "{\r\n    // only bother matching raw types if exact type is a raw type\r\n    boolean matchRawType \u003d exactType.getType() \u003d\u003d exactType.getRawType();\r\n    return new SingleTypeFactory(typeAdapter, exactType, matchRawType, null);\r\n}",
    "write": "{\r\n    if (serializer \u003d\u003d null) {\r\n        delegate().write(out, value);\r\n        return;\r\n    }\r\n    if (nullSafe \u0026\u0026 value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    JsonElement tree \u003d serializer.serialize(value, typeToken.getType(), context);\r\n    Streams.write(tree, out);\r\n}",
    "newTypeHierarchyFactory": "{\r\n    return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);\r\n}",
    "deserialize": "{\r\n    return gson.fromJson(json, typeOfT);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\stream\\JsonReaderPathTest.java": {
    "skipEndOfDocument": "{\r\n    JsonReader reader \u003d factory.create(\"[]\");\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "skipObjectNames": "{\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":[]}\");\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\u003cskipped\u003e[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\u003cskipped\u003e[0]\");\r\n}",
    "objectOfObjects": "{\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":{\\\"a1\\\":1,\\\"a2\\\":2},\\\"b\\\":{\\\"b1\\\":1}}\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\");\r\n    String unused1 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.\");\r\n    String unused2 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.a1\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.a1\");\r\n    int unused3 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.a1\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.a1\");\r\n    String unused4 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.a2\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.a2\");\r\n    int unused5 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.a2\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.a2\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    String unused6 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b.\");\r\n    String unused7 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b.b1\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b.b1\");\r\n    int unused8 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b.b1\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b.b1\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "skipNestedStructures": "{\r\n    JsonReader reader \u003d factory.create(\"[[1,2,3],4]\");\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n}",
    "multipleTopLevelValuesInOneDocument": "{\r\n    assumeTrue(factory \u003d\u003d Factory.STRING_READER);\r\n    JsonReader reader \u003d factory.create(\"[][]\");\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "skipObjectEnd": "{\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":{},\\\"b\\\":2}\");\r\n    reader.beginObject();\r\n    String unused \u003d reader.nextName();\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.\");\r\n    // skip end of object\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n}",
    "arrayOfArrays": "{\r\n    JsonReader reader \u003d factory.create(\"[[],[],[]]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0][0]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1][0]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[2][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2][0]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[2]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[3]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "objectPath": "{\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":1,\\\"b\\\":2}\");\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    JsonToken unused1 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\");\r\n    JsonToken unused2 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\");\r\n    String unused3 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    JsonToken unused4 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    int unused5 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    JsonToken unused6 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    String unused7 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    JsonToken unused8 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    int unused9 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    JsonToken unused10 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    JsonToken unused11 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.close();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "path": "{\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":[2,true,false,null,\\\"b\\\",{\\\"c\\\":\\\"d\\\"},[3]]}\");\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\");\r\n    String unused1 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[0]\");\r\n    int unused2 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[1]\");\r\n    boolean unused3 \u003d reader.nextBoolean();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[2]\");\r\n    boolean unused4 \u003d reader.nextBoolean();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[2]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[3]\");\r\n    reader.nextNull();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[3]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[4]\");\r\n    String unused5 \u003d reader.nextString();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[4]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[5]\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[5].\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[5].\");\r\n    String unused6 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[5].c\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[5].c\");\r\n    String unused7 \u003d reader.nextString();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[5].c\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[5].c\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[5]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[6]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[6][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[6][0]\");\r\n    int unused8 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[6][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[6][1]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[6]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[7]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "arrayPath": "{\r\n    JsonReader reader \u003d factory.create(\"[1,2]\");\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    JsonToken unused1 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0]\");\r\n    JsonToken unused2 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0]\");\r\n    int unused3 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n    JsonToken unused4 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n    int unused5 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2]\");\r\n    JsonToken unused6 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    JsonToken unused7 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.close();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "create": "{\r\n    JsonElement element \u003d Streams.parse(new JsonReader(new StringReader(data)));\r\n    return new JsonTreeReader(element);\r\n}",
    "arrayOfObjects": "{\r\n    JsonReader reader \u003d factory.create(\"[{},{},{}]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0]\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0].\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0].\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1].\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1].\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2]\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[2].\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2].\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[2]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[3]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "parameters": "{\r\n    return Arrays.asList(new Object[] { Factory.STRING_READER }, new Object[] { Factory.OBJECT_READER });\r\n}",
    "skipArrayElements": "{\r\n    JsonReader reader \u003d factory.create(\"[1,2,3]\");\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2]\");\r\n}",
    "skipArrayEnd": "{\r\n    JsonReader reader \u003d factory.create(\"[[],1]\");\r\n    reader.beginArray();\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0][0]\");\r\n    // skip end of array\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n}",
    "skipObjectValues": "{\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":1,\\\"b\\\":2}\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\");\r\n    String unused1 \u003d reader.nextName();\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    String unused2 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n}"
  },
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\BagOfPrimitives.java": {
    "getExpectedJson": "{\r\n    return \"{\" + \"\\\"longValue\\\":\" + longValue + \",\" + \"\\\"intValue\\\":\" + intValue + \",\" + \"\\\"booleanValue\\\":\" + booleanValue + \",\" + \"\\\"stringValue\\\":\\\"\" + stringValue + \"\\\"\" + \"}\";\r\n}",
    "getIntValue": "{\r\n    return intValue;\r\n}",
    "hashCode": "{\r\n    final int prime \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d prime * result + (booleanValue ? 1231 : 1237);\r\n    result \u003d prime * result + intValue;\r\n    result \u003d prime * result + (int) (longValue ^ (longValue \u003e\u003e\u003e 32));\r\n    result \u003d prime * result + ((stringValue \u003d\u003d null) ? 0 : stringValue.hashCode());\r\n    return result;\r\n}",
    "equals": "{\r\n    if (this \u003d\u003d o) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof BagOfPrimitives)) {\r\n        return false;\r\n    }\r\n    BagOfPrimitives that \u003d (BagOfPrimitives) o;\r\n    return longValue \u003d\u003d that.longValue \u0026\u0026 intValue \u003d\u003d that.intValue \u0026\u0026 booleanValue \u003d\u003d that.booleanValue \u0026\u0026 Objects.equal(stringValue, that.stringValue);\r\n}",
    "toString": "{\r\n    return String.format(\"(longValue\u003d%d,intValue\u003d%d,booleanValue\u003d%b,stringValue\u003d%s)\", longValue, intValue, booleanValue, stringValue);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\ParameterizedTypeTest.java": {
    "testNotEquals": "{\r\n    Type differentParameterizedType \u003d new TypeToken\u003cList\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(differentParameterizedType.equals(ourType)).isFalse();\r\n    assertThat(ourType.equals(differentParameterizedType)).isFalse();\r\n}",
    "setUp": "{\r\n    ourType \u003d $Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class);\r\n}",
    "testOurTypeFunctionality": "{\r\n    Type parameterizedType \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(ourType.getOwnerType()).isNull();\r\n    assertThat(ourType.getActualTypeArguments()[0]).isSameInstanceAs(String.class);\r\n    assertThat(ourType.getRawType()).isSameInstanceAs(List.class);\r\n    assertThat(ourType).isEqualTo(parameterizedType);\r\n    assertThat(ourType.hashCode()).isEqualTo(parameterizedType.hashCode());\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\DateTypeAdapter.java": {
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return deserializeToDate(in);\r\n}",
    "deserializeToDate": "{\r\n    String s \u003d in.nextString();\r\n    synchronized (dateFormats) {\r\n        for (DateFormat dateFormat : dateFormats) {\r\n            try {\r\n                return dateFormat.parse(s);\r\n            } catch (ParseException ignored) {\r\n                // OK: try the next format\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return ISO8601Utils.parse(s, new ParsePosition(0));\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "create": "{\r\n    return typeToken.getRawType() \u003d\u003d Date.class ? (TypeAdapter\u003cT\u003e) new DateTypeAdapter() : null;\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    DateFormat dateFormat \u003d dateFormats.get(0);\r\n    String dateFormatAsString;\r\n    synchronized (dateFormats) {\r\n        dateFormatAsString \u003d dateFormat.format(value);\r\n    }\r\n    out.value(dateFormatAsString);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\stream\\JsonWriterTest.java": {
    "testBadNestingArray": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.beginArray();\r\n    try {\r\n        jsonWriter.endObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Nesting problem.\");\r\n    }\r\n}",
    "testNumbers": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(new BigInteger(\"0\"));\r\n    jsonWriter.value(new BigInteger(\"9223372036854775808\"));\r\n    jsonWriter.value(new BigInteger(\"-9223372036854775809\"));\r\n    jsonWriter.value(new BigDecimal(\"3.141592653589793238462643383\"));\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[0,\" + \"9223372036854775808,\" + \"-9223372036854775809,\" + \"3.141592653589793238462643383]\");\r\n}",
    "testTopLevelValueTypes": "{\r\n    StringWriter string1 \u003d new StringWriter();\r\n    JsonWriter writer1 \u003d new JsonWriter(string1);\r\n    writer1.value(true);\r\n    writer1.close();\r\n    assertThat(string1.toString()).isEqualTo(\"true\");\r\n    StringWriter string2 \u003d new StringWriter();\r\n    JsonWriter writer2 \u003d new JsonWriter(string2);\r\n    writer2.nullValue();\r\n    writer2.close();\r\n    assertThat(string2.toString()).isEqualTo(\"null\");\r\n    StringWriter string3 \u003d new StringWriter();\r\n    JsonWriter writer3 \u003d new JsonWriter(string3);\r\n    writer3.value(123);\r\n    writer3.close();\r\n    assertThat(string3.toString()).isEqualTo(\"123\");\r\n    StringWriter string4 \u003d new StringWriter();\r\n    JsonWriter writer4 \u003d new JsonWriter(string4);\r\n    writer4.value(123.4);\r\n    writer4.close();\r\n    assertThat(string4.toString()).isEqualTo(\"123.4\");\r\n    StringWriter string5 \u003d new StringWriter();\r\n    JsonWriter writert \u003d new JsonWriter(string5);\r\n    writert.value(\"a\");\r\n    writert.close();\r\n    assertThat(string5.toString()).isEqualTo(\"\\\"a\\\"\");\r\n}",
    "testClosedWriterThrowsOnStructure": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    try {\r\n        writer.beginArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        writer.endArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        writer.beginObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        writer.endObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "testNonFiniteDoublesWhenLenient": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.LENIENT);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(Double.NaN);\r\n    jsonWriter.value(Double.NEGATIVE_INFINITY);\r\n    jsonWriter.value(Double.POSITIVE_INFINITY);\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[NaN,-Infinity,Infinity]\");\r\n}",
    "testTwoNames": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    try {\r\n        jsonWriter.name(\"a\");\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Already wrote a name, expecting a value.\");\r\n    }\r\n}",
    "testNullStringValue": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    jsonWriter.value((String) null);\r\n    jsonWriter.endObject();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{\\\"a\\\":null}\");\r\n}",
    "testFloats": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(-0.0f);\r\n    jsonWriter.value(1.0f);\r\n    jsonWriter.value(Float.MAX_VALUE);\r\n    jsonWriter.value(Float.MIN_VALUE);\r\n    jsonWriter.value(0.0f);\r\n    jsonWriter.value(-0.5f);\r\n    jsonWriter.value(2.2250739E-38f);\r\n    jsonWriter.value(3.723379f);\r\n    jsonWriter.value((float) Math.PI);\r\n    jsonWriter.value((float) Math.E);\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[-0.0,\" + \"1.0,\" + \"3.4028235E38,\" + \"1.4E-45,\" + \"0.0,\" + \"-0.5,\" + \"2.2250739E-38,\" + \"3.723379,\" + \"3.1415927,\" + \"2.7182817]\");\r\n}",
    "testNullName": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    try {\r\n        jsonWriter.name(null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "testDeepNestingArrays": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    for (int i \u003d 0; i \u003c 20; i++) {\r\n        jsonWriter.beginArray();\r\n    }\r\n    for (int i \u003d 0; i \u003c 20; i++) {\r\n        jsonWriter.endArray();\r\n    }\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]\");\r\n}",
    "testNameAsTopLevelValue": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e jsonWriter.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n    jsonWriter.value(12);\r\n    jsonWriter.close();\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e jsonWriter.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"JsonWriter is closed.\");\r\n}",
    "testEmptyArray": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[]\");\r\n}",
    "testNumbersCustomClass": "{\r\n    String[] validNumbers \u003d { \"-0.0\", \"1.0\", \"1.7976931348623157E308\", \"4.9E-324\", \"0.0\", \"0.00\", \"-0.5\", \"2.2250738585072014E-308\", \"3.141592653589793\", \"2.718281828459045\", \"0\", \"0.01\", \"0e0\", \"1e+0\", \"1e-0\", // leading 0 is allowed for exponent\r\n    \"1e0000\", \"1e00001\", \"1e+1\" };\r\n    for (String validNumber : validNumbers) {\r\n        StringWriter stringWriter \u003d new StringWriter();\r\n        JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n        jsonWriter.value(new LazilyParsedNumber(validNumber));\r\n        jsonWriter.close();\r\n        assertThat(stringWriter.toString()).isEqualTo(validNumber);\r\n    }\r\n}",
    "testBoxedBooleans": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value((Boolean) true);\r\n    jsonWriter.value((Boolean) false);\r\n    jsonWriter.value((Boolean) null);\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[true,false,null]\");\r\n}",
    "testEmptyObject": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.endObject();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{}\");\r\n}",
    "testObjectsInArrays": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\").value(5);\r\n    jsonWriter.name(\"b\").value(false);\r\n    jsonWriter.endObject();\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"c\").value(6);\r\n    jsonWriter.name(\"d\").value(true);\r\n    jsonWriter.endObject();\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[{\\\"a\\\":5,\\\"b\\\":false},\" + \"{\\\"c\\\":6,\\\"d\\\":true}]\");\r\n}",
    "testMultipleTopLevelValues": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray().endArray();\r\n    IllegalStateException expected \u003d assertThrows(IllegalStateException.class, jsonWriter::beginArray);\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"JSON must have only one top-level value.\");\r\n}",
    "testLongs": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(0);\r\n    jsonWriter.value(1);\r\n    jsonWriter.value(-1);\r\n    jsonWriter.value(Long.MIN_VALUE);\r\n    jsonWriter.value(Long.MAX_VALUE);\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[0,\" + \"1,\" + \"-1,\" + \"-9223372036854775808,\" + \"9223372036854775807]\");\r\n}",
    "testDefaultStrictness": "{\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    assertThat(jsonWriter.getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n    jsonWriter.value(false);\r\n    jsonWriter.close();\r\n}",
    "testDeepNestingObjects": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    for (int i \u003d 0; i \u003c 20; i++) {\r\n        jsonWriter.name(\"a\");\r\n        jsonWriter.beginObject();\r\n    }\r\n    for (int i \u003d 0; i \u003c 20; i++) {\r\n        jsonWriter.endObject();\r\n    }\r\n    jsonWriter.endObject();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":\" + \"{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\" + \"}}}}}}}}}}}}}}}}}}}}}\");\r\n}",
    "testSetGetFormattingStyle": "{\r\n    String lineSeparator \u003d \"\\r\\n\";\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    // Default should be FormattingStyle.COMPACT\r\n    assertThat(jsonWriter.getFormattingStyle()).isSameInstanceAs(FormattingStyle.COMPACT);\r\n    jsonWriter.setFormattingStyle(FormattingStyle.PRETTY.withIndent(\" \\t \").withNewline(lineSeparator));\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(true);\r\n    jsonWriter.value(\"text\");\r\n    jsonWriter.value(5.0);\r\n    jsonWriter.nullValue();\r\n    jsonWriter.endArray();\r\n    String expected \u003d \"[\\r\\n\" + \" \\t true,\\r\\n\" + \" \\t \\\"text\\\",\\r\\n\" + \" \\t 5.0,\\r\\n\" + \" \\t null\\r\\n\" + \"]\";\r\n    assertThat(stringWriter.toString()).isEqualTo(expected);\r\n    assertThat(jsonWriter.getFormattingStyle().getNewline()).isEqualTo(lineSeparator);\r\n}",
    "testWriterCloseIsIdempotent": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    writer.close();\r\n}",
    "testMalformedNumbers": "{\r\n    String[] malformedNumbers \u003d { \"some text\", \"\", \".\", \"00\", \"01\", \"-00\", \"-\", \"--1\", // plus sign is not allowed for integer part\r\n    \"+1\", \"+\", \"1,0\", \"1,000\", // decimal digit is required\r\n    \"0.\", // integer part is required\r\n    \".1\", \"e1\", \".e1\", \".1e1\", \"1e-\", \"1e+\", \"1e--1\", \"1e+-1\", \"1e1e1\", \"1+e1\", \"1e1.0\" };\r\n    for (String malformedNumber : malformedNumbers) {\r\n        JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n        try {\r\n            jsonWriter.value(new LazilyParsedNumber(malformedNumber));\r\n            fail(\"Should have failed writing malformed number: \" + malformedNumber);\r\n        } catch (IllegalArgumentException e) {\r\n            assertThat(e).hasMessageThat().isEqualTo(\"String created by class com.google.gson.internal.LazilyParsedNumber is not a valid JSON number: \" + malformedNumber);\r\n        }\r\n    }\r\n}",
    "testUnicodeLineBreaksEscaped": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(\"\\u2028 \\u2029\");\r\n    jsonWriter.endArray();\r\n    // JSON specification does not require that they are escaped, but Gson escapes them for compatibility with JavaScript\r\n    // where they are considered line breaks\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[\\\"\\\\u2028 \\\\u2029\\\"]\");\r\n}",
    "testJsonValue": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    jsonWriter.jsonValue(\"{\\\"b\\\":true}\");\r\n    jsonWriter.name(\"c\");\r\n    jsonWriter.value(1);\r\n    jsonWriter.endObject();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{\\\"a\\\":{\\\"b\\\":true},\\\"c\\\":1}\");\r\n}",
    "testClosedWriterThrowsOnName": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    try {\r\n        writer.name(\"a\");\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "testClosedWriterThrowsOnFlush": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    try {\r\n        writer.flush();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "testPrettyPrintArray": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setIndent(\"   \");\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(true);\r\n    jsonWriter.value(false);\r\n    jsonWriter.value(5.0);\r\n    jsonWriter.nullValue();\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\").value(6.0);\r\n    jsonWriter.name(\"b\").value(7.0);\r\n    jsonWriter.endObject();\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(8.0);\r\n    jsonWriter.value(9.0);\r\n    jsonWriter.endArray();\r\n    jsonWriter.endArray();\r\n    String expected \u003d \"[\\n\" + \"   true,\\n\" + \"   false,\\n\" + \"   5.0,\\n\" + \"   null,\\n\" + \"   {\\n\" + \"      \\\"a\\\": 6.0,\\n\" + \"      \\\"b\\\": 7.0\\n\" + \"   },\\n\" + \"   [\\n\" + \"      8.0,\\n\" + \"      9.0\\n\" + \"   ]\\n\" + \"]\";\r\n    assertThat(stringWriter.toString()).isEqualTo(expected);\r\n}",
    "testNonFiniteNumbersWhenLenient": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.LENIENT);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(Double.valueOf(Double.NaN));\r\n    jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY));\r\n    jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY));\r\n    jsonWriter.value(new LazilyParsedNumber(\"Infinity\"));\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[NaN,-Infinity,Infinity,Infinity]\");\r\n}",
    "testDoubles": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(-0.0);\r\n    jsonWriter.value(1.0);\r\n    jsonWriter.value(Double.MAX_VALUE);\r\n    jsonWriter.value(Double.MIN_VALUE);\r\n    jsonWriter.value(0.0);\r\n    jsonWriter.value(-0.5);\r\n    jsonWriter.value(2.2250738585072014E-308);\r\n    jsonWriter.value(Math.PI);\r\n    jsonWriter.value(Math.E);\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[-0.0,\" + \"1.0,\" + \"1.7976931348623157E308,\" + \"4.9E-324,\" + \"0.0,\" + \"-0.5,\" + \"2.2250738585072014E-308,\" + \"3.141592653589793,\" + \"2.718281828459045]\");\r\n}",
    "testBadNestingObject": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.beginObject();\r\n    try {\r\n        jsonWriter.endArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Nesting problem.\");\r\n    }\r\n}",
    "testRepeatedName": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\").value(true);\r\n    jsonWriter.name(\"a\").value(false);\r\n    jsonWriter.endObject();\r\n    // JsonWriter doesn\u0027t attempt to detect duplicate names\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{\\\"a\\\":true,\\\"a\\\":false}\");\r\n}",
    "testNonFiniteNumbersWhenStrict": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.STRICT);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.NaN)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "testArraysInObjects": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(5);\r\n    jsonWriter.value(false);\r\n    jsonWriter.endArray();\r\n    jsonWriter.name(\"b\");\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(6);\r\n    jsonWriter.value(true);\r\n    jsonWriter.endArray();\r\n    jsonWriter.endObject();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{\\\"a\\\":[5,false],\" + \"\\\"b\\\":[6,true]}\");\r\n}",
    "testNonFiniteFloats": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.NaN));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.NEGATIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.POSITIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "testIndentOverwritesFormattingStyle": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setFormattingStyle(FormattingStyle.COMPACT);\r\n    // Should overwrite formatting style\r\n    jsonWriter.setIndent(\"  \");\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(1);\r\n    jsonWriter.value(2);\r\n    jsonWriter.endArray();\r\n    jsonWriter.endObject();\r\n    String expected \u003d \"{\\n\" + \"  \\\"a\\\": [\\n\" + \"    1,\\n\" + \"    2\\n\" + \"  ]\\n\" + \"}\";\r\n    assertThat(stringWriter.toString()).isEqualTo(expected);\r\n}",
    "testNonFiniteNumbers": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.NaN)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "testNameWithoutValue": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    try {\r\n        jsonWriter.endObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Dangling name: a\");\r\n    }\r\n}",
    "testBooleans": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(true);\r\n    jsonWriter.value(false);\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[true,false]\");\r\n}",
    "testNonFiniteDoublesWhenStrict": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.STRICT);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.NaN));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.NEGATIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.POSITIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "testNameInArray": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e jsonWriter.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n    jsonWriter.value(12);\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e jsonWriter.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[12]\");\r\n}",
    "testStrings": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(\"a\");\r\n    jsonWriter.value(\"a\\\"\");\r\n    jsonWriter.value(\"\\\"\");\r\n    jsonWriter.value(\":\");\r\n    jsonWriter.value(\",\");\r\n    jsonWriter.value(\"\\b\");\r\n    jsonWriter.value(\"\\f\");\r\n    jsonWriter.value(\"\\n\");\r\n    jsonWriter.value(\"\\r\");\r\n    jsonWriter.value(\"\\t\");\r\n    jsonWriter.value(\" \");\r\n    jsonWriter.value(\"\\\\\");\r\n    jsonWriter.value(\"{\");\r\n    jsonWriter.value(\"}\");\r\n    jsonWriter.value(\"[\");\r\n    jsonWriter.value(\"]\");\r\n    jsonWriter.value(\"\\0\");\r\n    jsonWriter.value(\"\\u0019\");\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[\\\"a\\\",\" + \"\\\"a\\\\\\\"\\\",\" + \"\\\"\\\\\\\"\\\",\" + \"\\\":\\\",\" + \"\\\",\\\",\" + \"\\\"\\\\b\\\",\" + \"\\\"\\\\f\\\",\" + \"\\\"\\\\n\\\",\" + \"\\\"\\\\r\\\",\" + \"\\\"\\\\t\\\",\" + \"\\\" \\\",\" + \"\\\"\\\\\\\\\\\",\" + \"\\\"{\\\",\" + \"\\\"}\\\",\" + \"\\\"[\\\",\" + \"\\\"]\\\",\" + \"\\\"\\\\u0000\\\",\" + \"\\\"\\\\u0019\\\"]\");\r\n}",
    "testSetStrictness": "{\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.setStrictness(Strictness.STRICT);\r\n    assertThat(jsonWriter.getStrictness()).isEqualTo(Strictness.STRICT);\r\n    jsonWriter.value(false);\r\n    jsonWriter.close();\r\n}",
    "testNulls": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.nullValue();\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[null]\");\r\n}",
    "testMultipleTopLevelValuesStrict": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.STRICT);\r\n    jsonWriter.beginArray().endArray();\r\n    IllegalStateException expected \u003d assertThrows(IllegalStateException.class, jsonWriter::beginArray);\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"JSON must have only one top-level value.\");\r\n}",
    "testValueWithoutName": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    try {\r\n        jsonWriter.value(true);\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Nesting problem.\");\r\n    }\r\n}",
    "testClosedWriterThrowsOnValue": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    try {\r\n        writer.value(\"a\");\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "testSetStrictnessNull": "{\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    assertThrows(NullPointerException.class, () -\u003e jsonWriter.setStrictness(null));\r\n    jsonWriter.value(false);\r\n    jsonWriter.close();\r\n}",
    "testNonFiniteFloatsWhenLenient": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.LENIENT);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(Float.NaN);\r\n    jsonWriter.value(Float.NEGATIVE_INFINITY);\r\n    jsonWriter.value(Float.POSITIVE_INFINITY);\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[NaN,-Infinity,Infinity]\");\r\n}",
    "testPrettyPrintObject": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setIndent(\"   \");\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\").value(true);\r\n    jsonWriter.name(\"b\").value(false);\r\n    jsonWriter.name(\"c\").value(5.0);\r\n    jsonWriter.name(\"e\").nullValue();\r\n    jsonWriter.name(\"f\").beginArray();\r\n    jsonWriter.value(6.0);\r\n    jsonWriter.value(7.0);\r\n    jsonWriter.endArray();\r\n    jsonWriter.name(\"g\").beginObject();\r\n    jsonWriter.name(\"h\").value(8.0);\r\n    jsonWriter.name(\"i\").value(9.0);\r\n    jsonWriter.endObject();\r\n    jsonWriter.endObject();\r\n    String expected \u003d \"{\\n\" + \"   \\\"a\\\": true,\\n\" + \"   \\\"b\\\": false,\\n\" + \"   \\\"c\\\": 5.0,\\n\" + \"   \\\"e\\\": null,\\n\" + \"   \\\"f\\\": [\\n\" + \"      6.0,\\n\" + \"      7.0\\n\" + \"   ],\\n\" + \"   \\\"g\\\": {\\n\" + \"      \\\"h\\\": 8.0,\\n\" + \"      \\\"i\\\": 9.0\\n\" + \"   }\\n\" + \"}\";\r\n    assertThat(stringWriter.toString()).isEqualTo(expected);\r\n}",
    "testMultipleTopLevelValuesLenient": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.setStrictness(Strictness.LENIENT);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[][]\");\r\n}",
    "testSetLenientTrue": "{\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.setLenient(true);\r\n    assertThat(jsonWriter.getStrictness()).isEqualTo(Strictness.LENIENT);\r\n    jsonWriter.value(false);\r\n    jsonWriter.close();\r\n}",
    "testNonFiniteDoubles": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.NaN));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.NEGATIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.POSITIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "testNonFiniteFloatsWhenStrict": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.STRICT);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.NaN));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.NEGATIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.POSITIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "testSetLenientFalse": "{\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.setLenient(false);\r\n    assertThat(jsonWriter.getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n    jsonWriter.value(false);\r\n    jsonWriter.close();\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java": {
    "parseInt": "{\r\n    if (beginIndex \u003c 0 || endIndex \u003e value.length() || beginIndex \u003e endIndex) {\r\n        throw new NumberFormatException(value);\r\n    }\r\n    // use same logic as in Integer.parseInt() but less generic we\u0027re not supporting negative values\r\n    int i \u003d beginIndex;\r\n    int result \u003d 0;\r\n    int digit;\r\n    if (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result \u003d -digit;\r\n    }\r\n    while (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result *\u003d 10;\r\n        result -\u003d digit;\r\n    }\r\n    return -result;\r\n}",
    "format": "{\r\n    Calendar calendar \u003d new GregorianCalendar(tz, Locale.US);\r\n    calendar.setTime(date);\r\n    // estimate capacity of buffer as close as we can (yeah, that\u0027s pedantic ;)\r\n    int capacity \u003d \"yyyy-MM-ddThh:mm:ss\".length();\r\n    capacity +\u003d millis ? \".sss\".length() : 0;\r\n    capacity +\u003d tz.getRawOffset() \u003d\u003d 0 ? \"Z\".length() : \"+hh:mm\".length();\r\n    StringBuilder formatted \u003d new StringBuilder(capacity);\r\n    padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\r\n    formatted.append(\u0027T\u0027);\r\n    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\r\n    if (millis) {\r\n        formatted.append(\u0027.\u0027);\r\n        padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\r\n    }\r\n    int offset \u003d tz.getOffset(calendar.getTimeInMillis());\r\n    if (offset !\u003d 0) {\r\n        int hours \u003d Math.abs((offset / (60 * 1000)) / 60);\r\n        int minutes \u003d Math.abs((offset / (60 * 1000)) % 60);\r\n        formatted.append(offset \u003c 0 ? \u0027-\u0027 : \u0027+\u0027);\r\n        padInt(formatted, hours, \"hh\".length());\r\n        formatted.append(\u0027:\u0027);\r\n        padInt(formatted, minutes, \"mm\".length());\r\n    } else {\r\n        formatted.append(\u0027Z\u0027);\r\n    }\r\n    return formatted.toString();\r\n}",
    "padInt": "{\r\n    String strValue \u003d Integer.toString(value);\r\n    for (int i \u003d length - strValue.length(); i \u003e 0; i--) {\r\n        buffer.append(\u00270\u0027);\r\n    }\r\n    buffer.append(strValue);\r\n}",
    "checkOffset": "{\r\n    return (offset \u003c value.length()) \u0026\u0026 (value.charAt(offset) \u003d\u003d expected);\r\n}",
    "parse": "{\r\n    Exception fail \u003d null;\r\n    try {\r\n        int offset \u003d pos.getIndex();\r\n        // extract year\r\n        int year \u003d parseInt(date, offset, offset +\u003d 4);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract month\r\n        int month \u003d parseInt(date, offset, offset +\u003d 2);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract day\r\n        int day \u003d parseInt(date, offset, offset +\u003d 2);\r\n        // default time value\r\n        int hour \u003d 0;\r\n        int minutes \u003d 0;\r\n        int seconds \u003d 0;\r\n        // always use 0 otherwise returned date will include millis of current time\r\n        int milliseconds \u003d 0;\r\n        // if the value has no time component (and no time zone), we are done\r\n        boolean hasT \u003d checkOffset(date, offset, \u0027T\u0027);\r\n        if (!hasT \u0026\u0026 (date.length() \u003c\u003d offset)) {\r\n            Calendar calendar \u003d new GregorianCalendar(year, month - 1, day);\r\n            calendar.setLenient(false);\r\n            pos.setIndex(offset);\r\n            return calendar.getTime();\r\n        }\r\n        if (hasT) {\r\n            // extract hours, minutes, seconds and milliseconds\r\n            hour \u003d parseInt(date, offset +\u003d 1, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            minutes \u003d parseInt(date, offset, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            // second and milliseconds can be optional\r\n            if (date.length() \u003e offset) {\r\n                char c \u003d date.charAt(offset);\r\n                if (c !\u003d \u0027Z\u0027 \u0026\u0026 c !\u003d \u0027+\u0027 \u0026\u0026 c !\u003d \u0027-\u0027) {\r\n                    seconds \u003d parseInt(date, offset, offset +\u003d 2);\r\n                    // truncate up to 3 leap seconds\r\n                    if (seconds \u003e 59 \u0026\u0026 seconds \u003c 63)\r\n                        seconds \u003d 59;\r\n                    // milliseconds can be optional in the format\r\n                    if (checkOffset(date, offset, \u0027.\u0027)) {\r\n                        offset +\u003d 1;\r\n                        // assume at least one digit\r\n                        int endOffset \u003d indexOfNonDigit(date, offset + 1);\r\n                        // parse up to 3 digits\r\n                        int parseEndOffset \u003d Math.min(endOffset, offset + 3);\r\n                        int fraction \u003d parseInt(date, offset, parseEndOffset);\r\n                        // compensate for \"missing\" digits\r\n                        switch(// number of digits parsed\r\n                        parseEndOffset - offset) {\r\n                            case 2:\r\n                                milliseconds \u003d fraction * 10;\r\n                                break;\r\n                            case 1:\r\n                                milliseconds \u003d fraction * 100;\r\n                                break;\r\n                            default:\r\n                                milliseconds \u003d fraction;\r\n                        }\r\n                        offset \u003d endOffset;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // extract timezone\r\n        if (date.length() \u003c\u003d offset) {\r\n            throw new IllegalArgumentException(\"No time zone indicator\");\r\n        }\r\n        TimeZone timezone \u003d null;\r\n        char timezoneIndicator \u003d date.charAt(offset);\r\n        if (timezoneIndicator \u003d\u003d \u0027Z\u0027) {\r\n            timezone \u003d TIMEZONE_UTC;\r\n            offset +\u003d 1;\r\n        } else if (timezoneIndicator \u003d\u003d \u0027+\u0027 || timezoneIndicator \u003d\u003d \u0027-\u0027) {\r\n            String timezoneOffset \u003d date.substring(offset);\r\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\r\n            timezoneOffset \u003d timezoneOffset.length() \u003e\u003d 5 ? timezoneOffset : timezoneOffset + \"00\";\r\n            offset +\u003d timezoneOffset.length();\r\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\r\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\r\n                timezone \u003d TIMEZONE_UTC;\r\n            } else {\r\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\r\n                //    not sure why, but that\u0027s the way it looks. Further, Javadocs for\r\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\r\n                //    custom timezones... odd.\r\n                String timezoneId \u003d \"GMT\" + timezoneOffset;\r\n                //                    String timezoneId \u003d \"UTC\" + timezoneOffset;\r\n                timezone \u003d TimeZone.getTimeZone(timezoneId);\r\n                String act \u003d timezone.getID();\r\n                if (!act.equals(timezoneId)) {\r\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\r\n                         *    one without. If so, don\u0027t sweat.\r\n                         *   Yes, very inefficient. Hopefully not hit often.\r\n                         *   If it becomes a perf problem, add \u0027loose\u0027 comparison instead.\r\n                         */\r\n                    String cleaned \u003d act.replace(\":\", \"\");\r\n                    if (!cleaned.equals(timezoneId)) {\r\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \u0027\" + timezoneIndicator + \"\u0027\");\r\n        }\r\n        Calendar calendar \u003d new GregorianCalendar(timezone);\r\n        calendar.setLenient(false);\r\n        calendar.set(Calendar.YEAR, year);\r\n        calendar.set(Calendar.MONTH, month - 1);\r\n        calendar.set(Calendar.DAY_OF_MONTH, day);\r\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\r\n        calendar.set(Calendar.MINUTE, minutes);\r\n        calendar.set(Calendar.SECOND, seconds);\r\n        calendar.set(Calendar.MILLISECOND, milliseconds);\r\n        pos.setIndex(offset);\r\n        return calendar.getTime();\r\n        // If we get a ParseException it\u0027ll already have the right message/offset.\r\n        // Other exception types can convert here.\r\n    } catch (IndexOutOfBoundsException e) {\r\n        fail \u003d e;\r\n    } catch (NumberFormatException e) {\r\n        fail \u003d e;\r\n    } catch (IllegalArgumentException e) {\r\n        fail \u003d e;\r\n    }\r\n    String input \u003d (date \u003d\u003d null) ? null : (\u0027\"\u0027 + date + \u0027\"\u0027);\r\n    String msg \u003d fail.getMessage();\r\n    if (msg \u003d\u003d null || msg.isEmpty()) {\r\n        msg \u003d \"(\" + fail.getClass().getName() + \")\";\r\n    }\r\n    ParseException ex \u003d new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\r\n    ex.initCause(fail);\r\n    throw ex;\r\n}",
    "indexOfNonDigit": "{\r\n    for (int i \u003d offset; i \u003c string.length(); i++) {\r\n        char c \u003d string.charAt(i);\r\n        if (c \u003c \u00270\u0027 || c \u003e \u00279\u0027)\r\n            return i;\r\n    }\r\n    return string.length();\r\n}"
  },
  "google_json\\proto\\src\\test\\java\\com\\google\\gson\\protobuf\\functional\\ProtosWithComplexAndRepeatedFieldsTest.java": {
    "testDeserializeRepeatedFieldsProto": "{\r\n    String json \u003d \"{numbers:[4,6],simples:[{msg:\u0027bar\u0027},{count:7}]}\";\r\n    ProtoWithRepeatedFields proto \u003d gson.fromJson(json, ProtoWithRepeatedFields.class);\r\n    assertEquals(4, proto.getNumbers(0));\r\n    assertEquals(6, proto.getNumbers(1));\r\n    assertEquals(\"bar\", proto.getSimples(0).getMsg());\r\n    assertEquals(7, proto.getSimples(1).getCount());\r\n}",
    "testSerializeRepeatedFields": "{\r\n    ProtoWithRepeatedFields proto \u003d ProtoWithRepeatedFields.newBuilder().addNumbers(2).addNumbers(3).addSimples(SimpleProto.newBuilder().setMsg(\"foo\").build()).addSimples(SimpleProto.newBuilder().setCount(3).build()).build();\r\n    String json \u003d gson.toJson(proto);\r\n    assertTrue(json.contains(\"[2,3]\"));\r\n    assertTrue(json.contains(\"foo\"));\r\n    assertTrue(json.contains(\"count\"));\r\n}",
    "testSerializeDifferentCaseFormat": "{\r\n    final ProtoWithDifferentCaseFormat proto \u003d ProtoWithDifferentCaseFormat.newBuilder().setAnotherField(\"foo\").addNameThatTestsCaseFormat(\"bar\").build();\r\n    final JsonObject json \u003d upperCamelGson.toJsonTree(proto).getAsJsonObject();\r\n    assertEquals(\"foo\", json.get(\"AnotherField\").getAsString());\r\n    assertEquals(\"bar\", json.get(\"NameThatTestsCaseFormat\").getAsJsonArray().get(0).getAsString());\r\n}",
    "setUp": "{\r\n    gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, ProtoTypeAdapter.newBuilder().setEnumSerialization(EnumSerialization.NUMBER).build()).create();\r\n    upperCamelGson \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, ProtoTypeAdapter.newBuilder().setFieldNameSerializationFormat(CaseFormat.LOWER_UNDERSCORE, CaseFormat.UPPER_CAMEL).build()).create();\r\n}",
    "testDeserializeDifferentCaseFormat": "{\r\n    final String json \u003d \"{NameThatTestsCaseFormat:[\u0027bar\u0027],AnotherField:\u0027foo\u0027}\";\r\n    ProtoWithDifferentCaseFormat proto \u003d upperCamelGson.fromJson(json, ProtoWithDifferentCaseFormat.class);\r\n    assertEquals(\"foo\", proto.getAnotherField());\r\n    assertEquals(\"bar\", proto.getNameThatTestsCaseFormat(0));\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonParser.java": {
    "parseReader": "{\r\n    Strictness strictness \u003d reader.getStrictness();\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    try {\r\n        return Streams.parse(reader);\r\n    } catch (StackOverflowError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source: \" + reader + \" to Json\", e);\r\n    } catch (OutOfMemoryError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source: \" + reader + \" to Json\", e);\r\n    } finally {\r\n        reader.setStrictness(strictness);\r\n    }\r\n}",
    "parseString": "{\r\n    return parseReader(new StringReader(json));\r\n}",
    "parse": "{\r\n    return parseReader(json);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\JsonNullTest.java": {
    "testDeepCopy": "{\r\n    @SuppressWarnings(\"deprecation\")\r\n    JsonNull a \u003d new JsonNull();\r\n    assertThat(a.deepCopy()).isSameInstanceAs(JsonNull.INSTANCE);\r\n    assertThat(JsonNull.INSTANCE.deepCopy()).isSameInstanceAs(JsonNull.INSTANCE);\r\n}",
    "testEqualsAndHashcode": "{\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonNull(), new JsonNull());\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonNull(), JsonNull.INSTANCE);\r\n    MoreAsserts.assertEqualsAndHashCode(JsonNull.INSTANCE, JsonNull.INSTANCE);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\ObjectTypeAdapterTest.java": {
    "testSerialize": "{\r\n    Object object \u003d new RuntimeType();\r\n    assertThat(adapter.toJson(object).replace(\"\\\"\", \"\u0027\")).isEqualTo(\"{\u0027a\u0027:5,\u0027b\u0027:[1,2,null]}\");\r\n}",
    "testDeserializeDeeplyNestedObjects": "{\r\n    int times \u003d 10000;\r\n    // {\"a\":{\"a\": ... {\"a\":null} ... }}\r\n    String json \u003d repeat(\"{\\\"a\\\":\", times) + \"null\" + repeat(\"}\", times);\r\n    int actualTimes \u003d 0;\r\n    Map\u003cString, Map\u003c?, ?\u003e\u003e current \u003d (Map\u003cString, Map\u003c?, ?\u003e\u003e) adapter.fromJson(json);\r\n    while (current !\u003d null) {\r\n        assertThat(current).hasSize(1);\r\n        actualTimes++;\r\n        current \u003d (Map\u003cString, Map\u003c?, ?\u003e\u003e) current.get(\"a\");\r\n    }\r\n    assertThat(actualTimes).isEqualTo(times);\r\n}",
    "testSerializeNullValue": "{\r\n    Map\u003cString, Object\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", null);\r\n    assertThat(adapter.toJson(map).replace(\u0027\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027a\u0027:null}\");\r\n}",
    "testDeserializeNullValue": "{\r\n    Map\u003cString, Object\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", null);\r\n    assertThat(adapter.fromJson(\"{\\\"a\\\":null}\")).isEqualTo(map);\r\n}",
    "repeat": "{\r\n    StringBuilder stringBuilder \u003d new StringBuilder(s.length() * times);\r\n    for (int i \u003d 0; i \u003c times; i++) {\r\n        stringBuilder.append(s);\r\n    }\r\n    return stringBuilder.toString();\r\n}",
    "testDeserializeDeeplyNestedArrays": "{\r\n    int times \u003d 10000;\r\n    // [[[ ... ]]]\r\n    String json \u003d repeat(\"[\", times) + repeat(\"]\", times);\r\n    int actualTimes \u003d 0;\r\n    List\u003cList\u003c?\u003e\u003e current \u003d (List\u003cList\u003c?\u003e\u003e) adapter.fromJson(json);\r\n    while (true) {\r\n        actualTimes++;\r\n        if (current.isEmpty()) {\r\n            break;\r\n        }\r\n        assertThat(current).hasSize(1);\r\n        current \u003d (List\u003cList\u003c?\u003e\u003e) current.get(0);\r\n    }\r\n    assertThat(actualTimes).isEqualTo(times);\r\n}",
    "testDeserialize": "{\r\n    Map\u003c?, ?\u003e map \u003d (Map\u003c?, ?\u003e) adapter.fromJson(\"{\\\"a\\\":5,\\\"b\\\":[1,2,null],\\\"c\\\":{\\\"x\\\":\\\"y\\\"}}\");\r\n    assertThat(map.get(\"a\")).isEqualTo(5.0);\r\n    assertThat(map.get(\"b\")).isEqualTo(Arrays.asList(1.0, 2.0, null));\r\n    assertThat(map.get(\"c\")).isEqualTo(Collections.singletonMap(\"x\", \"y\"));\r\n    assertThat(map).hasSize(3);\r\n}",
    "testSerializeObject": "{\r\n    assertThat(adapter.toJson(new Object())).isEqualTo(\"{}\");\r\n}"
  },
  "google_json\\examples\\android-proguard-example\\src\\com\\google\\gson\\examples\\android\\model\\Cart.java": {
    "getSimpleTypeName": "{\r\n    if (type \u003d\u003d null) {\r\n        return \"null\";\r\n    }\r\n    if (type instanceof Class) {\r\n        return ((Class) type).getSimpleName();\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType pType \u003d (ParameterizedType) type;\r\n        StringBuilder sb \u003d new StringBuilder(getSimpleTypeName(pType.getRawType()));\r\n        sb.append(\u0027\u003c\u0027);\r\n        boolean first \u003d true;\r\n        for (Type argumentType : pType.getActualTypeArguments()) {\r\n            if (first) {\r\n                first \u003d false;\r\n            } else {\r\n                sb.append(\u0027,\u0027);\r\n            }\r\n            sb.append(getSimpleTypeName(argumentType));\r\n        }\r\n        sb.append(\u0027\u003e\u0027);\r\n        return sb.toString();\r\n    } else if (type instanceof WildcardType) {\r\n        return \"?\";\r\n    }\r\n    return type.toString();\r\n}",
    "getBuyerName": "{\r\n    return buyerName;\r\n}",
    "getCreditCard": "{\r\n    return creditCard;\r\n}",
    "toString": "{\r\n    StringBuilder itemsText \u003d new StringBuilder();\r\n    boolean first \u003d true;\r\n    if (lineItems !\u003d null) {\r\n        try {\r\n            Class\u003c?\u003e fieldType \u003d Cart.class.getField(\"lineItems\").getType();\r\n            System.out.println(\"LineItems CLASS: \" + getSimpleTypeName(fieldType));\r\n        } catch (SecurityException e) {\r\n        } catch (NoSuchFieldException e) {\r\n        }\r\n        for (LineItem item : lineItems) {\r\n            if (first) {\r\n                first \u003d false;\r\n            } else {\r\n                itemsText.append(\"; \");\r\n            }\r\n            itemsText.append(item);\r\n        }\r\n    }\r\n    return \"[BUYER: \" + buyerName + \"; CC: \" + creditCard + \"; \" + \"LINE_ITEMS: \" + itemsText.toString() + \"]\";\r\n}",
    "getLineItems": "{\r\n    return lineItems;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessTest.java": {
    "checkPermission": "{\r\n    if (accessDeclaredMembers.equals(perm)) {\r\n        throw new SecurityException(\"Gson: no-member-access\");\r\n    }\r\n    if (suppressAccessChecks.equals(perm)) {\r\n        throw new SecurityException(\"Gson: no-suppress-access-check\");\r\n    }\r\n}",
    "read": "{\r\n    in.skipValue();\r\n    wasReadCalled.set(true);\r\n    return null;\r\n}",
    "assertInaccessibleException": "{\r\n    Gson gson \u003d new Gson();\r\n    try {\r\n        gson.fromJson(json, toDeserialize);\r\n        throw new AssertionError(\"Missing exception; test has to be run with `--illegal-access\u003ddeny`\");\r\n    } catch (JsonSyntaxException e) {\r\n        throw new AssertionError(\"Unexpected exception; test has to be run with `--illegal-access\u003ddeny`\", e);\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().endsWith(\"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#reflection-inaccessible\");\r\n        // Return exception for further assertions\r\n        return expected;\r\n    }\r\n}",
    "testInaccessibleField": "{\r\n    JsonIOException exception \u003d assertInaccessibleException(\"{}\", Throwable.class);\r\n    // Don\u0027t check exact field name because it is a JDK implementation detail\r\n    assertThat(exception).hasMessageThat().startsWith(\"Failed making field \u0027java.lang.Throwable#\");\r\n    assertThat(exception).hasMessageThat().contains(\"\u0027 accessible; either increase its visibility or\" + \" write a custom TypeAdapter for its declaring type.\");\r\n}",
    "loadClassWithDifferentClassLoader": "{\r\n    URL url \u003d c.getProtectionDomain().getCodeSource().getLocation();\r\n    URLClassLoader classLoader \u003d new URLClassLoader(new URL[] { url }, null);\r\n    return classLoader.loadClass(c.getName());\r\n}",
    "testRestrictiveSecurityManager": "{\r\n    // Must use separate class loader, otherwise permission is not checked, see Class.getDeclaredFields()\r\n    Class\u003c?\u003e clazz \u003d loadClassWithDifferentClassLoader(ClassWithPrivateMembers.class);\r\n    final Permission accessDeclaredMembers \u003d new RuntimePermission(\"accessDeclaredMembers\");\r\n    final Permission suppressAccessChecks \u003d new ReflectPermission(\"suppressAccessChecks\");\r\n    SecurityManager original \u003d System.getSecurityManager();\r\n    SecurityManager restrictiveManager \u003d new SecurityManager() {\r\n\r\n        @Override\r\n        public void checkPermission(Permission perm) {\r\n            if (accessDeclaredMembers.equals(perm)) {\r\n                throw new SecurityException(\"Gson: no-member-access\");\r\n            }\r\n            if (suppressAccessChecks.equals(perm)) {\r\n                throw new SecurityException(\"Gson: no-suppress-access-check\");\r\n            }\r\n        }\r\n    };\r\n    System.setSecurityManager(restrictiveManager);\r\n    try {\r\n        Gson gson \u003d new Gson();\r\n        try {\r\n            // Getting reflection based adapter should fail\r\n            gson.getAdapter(clazz);\r\n            fail();\r\n        } catch (SecurityException e) {\r\n            assertThat(e).hasMessageThat().isEqualTo(\"Gson: no-member-access\");\r\n        }\r\n        final AtomicBoolean wasReadCalled \u003d new AtomicBoolean(false);\r\n        gson \u003d new GsonBuilder().registerTypeAdapter(clazz, new TypeAdapter\u003cObject\u003e() {\r\n\r\n            @Override\r\n            public void write(JsonWriter out, Object value) throws IOException {\r\n                out.value(\"custom-write\");\r\n            }\r\n\r\n            @Override\r\n            public Object read(JsonReader in) throws IOException {\r\n                in.skipValue();\r\n                wasReadCalled.set(true);\r\n                return null;\r\n            }\r\n        }).create();\r\n        assertThat(gson.toJson(null, clazz)).isEqualTo(\"\\\"custom-write\\\"\");\r\n        assertThat(gson.fromJson(\"{}\", clazz)).isNull();\r\n        assertThat(wasReadCalled.get()).isTrue();\r\n    } finally {\r\n        System.setSecurityManager(original);\r\n    }\r\n}",
    "write": "{\r\n    out.value(\"custom-write\");\r\n}",
    "testSerializeInternalImplementationObject": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(Collections.emptyList());\r\n    assertThat(json).isEqualTo(\"[]\");\r\n    // But deserialization should fail\r\n    Class\u003c?\u003e internalClass \u003d Collections.emptyList().getClass();\r\n    JsonIOException exception \u003d assertInaccessibleException(\"[]\", internalClass);\r\n    // Don\u0027t check exact class name because it is a JDK implementation detail\r\n    assertThat(exception).hasMessageThat().startsWith(\"Failed making constructor \u0027\");\r\n    assertThat(exception).hasMessageThat().contains(\"\u0027 accessible; either increase its visibility or\" + \" write a custom InstanceCreator or TypeAdapter for its declaring type: \");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\MoreSpecificTypeSerializationTest.java": {
    "testMapOfSubclassFields": "{\r\n    Map\u003cString, Base\u003e map \u003d new HashMap\u003c\u003e();\r\n    map.put(\"base\", new Base(1));\r\n    map.put(\"sub\", new Sub(2, 3));\r\n    ClassWithContainersOfBaseFields target \u003d new ClassWithContainersOfBaseFields(null, map);\r\n    JsonObject json \u003d gson.toJsonTree(target).getAsJsonObject().get(\"map\").getAsJsonObject();\r\n    assertThat(json.get(\"base\").getAsJsonObject().get(\"b\").getAsInt()).isEqualTo(1);\r\n    JsonObject sub \u003d json.get(\"sub\").getAsJsonObject();\r\n    assertThat(sub.get(\"b\").getAsInt()).isEqualTo(2);\r\n    assertThat(sub.get(\"s\").getAsInt()).isEqualTo(3);\r\n}",
    "testListOfSubclassFields": "{\r\n    Collection\u003cBase\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(new Base(1));\r\n    list.add(new Sub(2, 3));\r\n    ClassWithContainersOfBaseFields target \u003d new ClassWithContainersOfBaseFields(list, null);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"{\\\"b\\\":1}\");\r\n    assertThat(json).contains(\"{\\\"s\\\":3,\\\"b\\\":2}\");\r\n}",
    "testSubclassFields": "{\r\n    ClassWithBaseFields target \u003d new ClassWithBaseFields(new Sub(1, 2));\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"b\\\":1\");\r\n    assertThat(json).contains(\"\\\"s\\\":2\");\r\n}",
    "testListOfParameterizedSubclassFields": "{\r\n    Collection\u003cParameterizedBase\u003cString\u003e\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(new ParameterizedBase\u003c\u003e(\"one\"));\r\n    list.add(new ParameterizedSub\u003c\u003e(\"two\", \"three\"));\r\n    ClassWithContainersOfParameterizedBaseFields target \u003d new ClassWithContainersOfParameterizedBaseFields(list, null);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"{\\\"t\\\":\\\"one\\\"}\");\r\n    assertThat(json).doesNotContain(\"\\\"s\\\":\");\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testMapOfParameterizedSubclassFields": "{\r\n    Map\u003cString, ParameterizedBase\u003cString\u003e\u003e map \u003d new HashMap\u003c\u003e();\r\n    map.put(\"base\", new ParameterizedBase\u003c\u003e(\"one\"));\r\n    map.put(\"sub\", new ParameterizedSub\u003c\u003e(\"two\", \"three\"));\r\n    ClassWithContainersOfParameterizedBaseFields target \u003d new ClassWithContainersOfParameterizedBaseFields(null, map);\r\n    JsonObject json \u003d gson.toJsonTree(target).getAsJsonObject().get(\"map\").getAsJsonObject();\r\n    assertThat(json.get(\"base\").getAsJsonObject().get(\"t\").getAsString()).isEqualTo(\"one\");\r\n    JsonObject sub \u003d json.get(\"sub\").getAsJsonObject();\r\n    assertThat(sub.get(\"t\").getAsString()).isEqualTo(\"two\");\r\n    assertThat(sub.get(\"s\")).isNull();\r\n}",
    "testParameterizedSubclassFields": "{\r\n    ClassWithParameterizedBaseFields target \u003d new ClassWithParameterizedBaseFields(new ParameterizedSub\u003c\u003e(\"one\", \"two\"));\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"t\\\":\\\"one\\\"\");\r\n    assertThat(json).doesNotContain(\"\\\"s\\\"\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\SerializedName.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\RuntimeTypeAdapterFactoryFunctionalTest.java": {
    "read": "{\r\n    JsonElement jsonElement \u003d Streams.parse(in);\r\n    JsonElement labelJsonElement \u003d jsonElement.getAsJsonObject().get(typeFieldName);\r\n    if (labelJsonElement \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n    }\r\n    String label \u003d labelJsonElement.getAsString();\r\n    // registration requires that subtype extends T\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) labelToDelegate.get(label);\r\n    if (delegate \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n    }\r\n    return delegate.fromJsonTree(jsonElement);\r\n}",
    "testSubclassesAutomaticallySerialized": "{\r\n    Shape shape \u003d new Circle(25);\r\n    String json \u003d gson.toJson(shape);\r\n    shape \u003d gson.fromJson(json, Shape.class);\r\n    assertThat(((Circle) shape).radius).isEqualTo(25);\r\n    shape \u003d new Square(15);\r\n    json \u003d gson.toJson(shape);\r\n    shape \u003d gson.fromJson(json, Shape.class);\r\n    assertThat(((Square) shape).side).isEqualTo(15);\r\n    assertThat(shape.type).isEqualTo(ShapeType.SQUARE);\r\n}",
    "of": "{\r\n    return new RuntimeTypeAdapterFactory\u003c\u003e(baseType, \"type\");\r\n}",
    "create": "{\r\n    if (type.getRawType() !\u003d baseType) {\r\n        return null;\r\n    }\r\n    final Map\u003cString, TypeAdapter\u003c?\u003e\u003e labelToDelegate \u003d new LinkedHashMap\u003c\u003e();\r\n    final Map\u003cClass\u003c?\u003e, TypeAdapter\u003c?\u003e\u003e subtypeToDelegate \u003d new LinkedHashMap\u003c\u003e();\r\n    for (Map.Entry\u003cString, Class\u003c?\u003e\u003e entry : labelToSubtype.entrySet()) {\r\n        TypeAdapter\u003c?\u003e delegate \u003d gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));\r\n        labelToDelegate.put(entry.getKey(), delegate);\r\n        subtypeToDelegate.put(entry.getValue(), delegate);\r\n    }\r\n    return new TypeAdapter\u003cR\u003e() {\r\n\r\n        @Override\r\n        public R read(JsonReader in) {\r\n            JsonElement jsonElement \u003d Streams.parse(in);\r\n            JsonElement labelJsonElement \u003d jsonElement.getAsJsonObject().get(typeFieldName);\r\n            if (labelJsonElement \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n            }\r\n            String label \u003d labelJsonElement.getAsString();\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) labelToDelegate.get(label);\r\n            if (delegate \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n            }\r\n            return delegate.fromJsonTree(jsonElement);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, R value) throws IOException {\r\n            Class\u003c?\u003e srcType \u003d value.getClass();\r\n            String label \u003d subtypeToLabel.get(srcType);\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) subtypeToDelegate.get(srcType);\r\n            if (delegate \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n            }\r\n            JsonObject jsonObject \u003d delegate.toJsonTree(value).getAsJsonObject();\r\n            if (!jsonObject.has(typeFieldName)) {\r\n                JsonObject clone \u003d new JsonObject();\r\n                clone.add(typeFieldName, new JsonPrimitive(label));\r\n                for (Map.Entry\u003cString, JsonElement\u003e e : jsonObject.entrySet()) {\r\n                    clone.add(e.getKey(), e.getValue());\r\n                }\r\n                jsonObject \u003d clone;\r\n            }\r\n            Streams.write(jsonObject, out);\r\n        }\r\n    };\r\n}",
    "registerSubtype": "{\r\n    return registerSubtype(type, type.getSimpleName());\r\n}",
    "write": "{\r\n    Class\u003c?\u003e srcType \u003d value.getClass();\r\n    String label \u003d subtypeToLabel.get(srcType);\r\n    // registration requires that subtype extends T\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) subtypeToDelegate.get(srcType);\r\n    if (delegate \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n    }\r\n    JsonObject jsonObject \u003d delegate.toJsonTree(value).getAsJsonObject();\r\n    if (!jsonObject.has(typeFieldName)) {\r\n        JsonObject clone \u003d new JsonObject();\r\n        clone.add(typeFieldName, new JsonPrimitive(label));\r\n        for (Map.Entry\u003cString, JsonElement\u003e e : jsonObject.entrySet()) {\r\n            clone.add(e.getKey(), e.getValue());\r\n        }\r\n        jsonObject \u003d clone;\r\n    }\r\n    Streams.write(jsonObject, out);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\Until.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\LeniencyTest.java": {
    "setUp": "{\r\n    gson \u003d new GsonBuilder().setLenient().create();\r\n}",
    "testLenientFromJson": "{\r\n    List\u003cString\u003e json \u003d gson.fromJson(\"\" + \"[ # One!\\n\" + \"  \u0027Hi\u0027 #Element!\\n\" + \"] # Array!\", new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(json).isEqualTo(singletonList(\"Hi\"));\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java": {
    "testIsAssignableFromWithNestedWildcards": "{\r\n    Type a \u003d getClass().getDeclaredField(\"listOfSetOfString\").getGenericType();\r\n    Type b \u003d getClass().getDeclaredField(\"listOfSetOfUnknown\").getGenericType();\r\n    assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n    assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n    // listOfSetOfString \u003d listOfSetOfUnknown; // doesn\u0027t compile; must be false\r\n    assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n    // listOfSetOfUnknown \u003d listOfSetOfString; // doesn\u0027t compile; must be false\r\n    assertThat(TypeToken.get(b).isAssignableFrom(a)).isFalse();\r\n}",
    "test": "{\r\n    String expectedMessage \u003d \"TypeToken type argument must not contain a type variable;\" + \" captured type variable T declared by \" + Enclosing.class + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\";\r\n    IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cT\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003cList\u003cT\u003e\u003e\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003c? extends List\u003cT\u003e\u003e\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003c? super List\u003cT\u003e\u003e\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003cT\u003e[]\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cEnclosing\u003cT\u003e.Inner\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    String systemProperty \u003d \"gson.allowCapturingTypeVariables\";\r\n    try {\r\n        // Any value other than \u0027true\u0027 should be ignored\r\n        System.setProperty(systemProperty, \"some-value\");\r\n        e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cT\u003e() {\r\n        });\r\n        assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    } finally {\r\n        System.clearProperty(systemProperty);\r\n    }\r\n    try {\r\n        System.setProperty(systemProperty, \"true\");\r\n        TypeToken\u003c?\u003e typeToken \u003d new TypeToken\u003cT\u003e() {\r\n        };\r\n        assertThat(typeToken.getType()).isEqualTo(Enclosing.class.getTypeParameters()[0]);\r\n    } finally {\r\n        System.clearProperty(systemProperty);\r\n    }\r\n}",
    "testParameterizedFactory_Invalid": "{\r\n    assertThrows(NullPointerException.class, () -\u003e TypeToken.getParameterized(null, new Type[0]));\r\n    assertThrows(NullPointerException.class, () -\u003e TypeToken.getParameterized(List.class, new Type[] { null }));\r\n    GenericArrayType arrayType \u003d (GenericArrayType) TypeToken.getArray(String.class).getType();\r\n    IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(arrayType, new Type[0]));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"rawType must be of type Class, but was java.lang.String[]\");\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(String.class, Number.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.lang.String requires 0 type arguments, but got 1\");\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(List.class, new Type[0]));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.util.List requires 1 type arguments, but got 0\");\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(List.class, String.class, String.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.util.List requires 1 type arguments, but got 2\");\r\n    // Primitive types must not be used as type argument\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(List.class, int.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument int does not satisfy bounds\" + \" for type variable E declared by \" + List.class);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(GenericWithBound.class, String.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.String does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithBound.class);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(GenericWithBound.class, Object.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Object does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithBound.class);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(GenericWithMultiBound.class, Number.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Number does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(GenericWithMultiBound.class, CharSequence.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument interface java.lang.CharSequence does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(GenericWithMultiBound.class, Object.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Object does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n    class Outer {\r\n\r\n        class NonStaticInner\u003cT\u003e {\r\n        }\r\n    }\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(Outer.NonStaticInner.class, Object.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Raw type \" + Outer.NonStaticInner.class.getName() + \" is not supported because it requires specifying an owner type\");\r\n}",
    "testTypeTokenRaw": "{\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e new TypeToken() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(\"TypeToken must be created with a type argument: new TypeToken\u003c...\u003e() {};\" + \" When using code shrinkers (ProGuard, R8, ...) make sure that generic signatures are preserved.\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#type-token-raw\");\r\n}",
    "testTypeTokenTypeVariable": "{\r\n    // Put the test code inside generic class to be able to access `T`\r\n    class Enclosing\u003cT\u003e {\r\n\r\n        class Inner {\r\n        }\r\n\r\n        void test() {\r\n            String expectedMessage \u003d \"TypeToken type argument must not contain a type variable;\" + \" captured type variable T declared by \" + Enclosing.class + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\";\r\n            IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cT\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003cList\u003cT\u003e\u003e\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003c? extends List\u003cT\u003e\u003e\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003c? super List\u003cT\u003e\u003e\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003cT\u003e[]\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cEnclosing\u003cT\u003e.Inner\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            String systemProperty \u003d \"gson.allowCapturingTypeVariables\";\r\n            try {\r\n                // Any value other than \u0027true\u0027 should be ignored\r\n                System.setProperty(systemProperty, \"some-value\");\r\n                e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cT\u003e() {\r\n                });\r\n                assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            } finally {\r\n                System.clearProperty(systemProperty);\r\n            }\r\n            try {\r\n                System.setProperty(systemProperty, \"true\");\r\n                TypeToken\u003c?\u003e typeToken \u003d new TypeToken\u003cT\u003e() {\r\n                };\r\n                assertThat(typeToken.getType()).isEqualTo(Enclosing.class.getTypeParameters()[0]);\r\n            } finally {\r\n                System.clearProperty(systemProperty);\r\n            }\r\n        }\r\n\r\n        \u003cM\u003e void testMethodTypeVariable() throws Exception {\r\n            Method testMethod \u003d Enclosing.class.getDeclaredMethod(\"testMethodTypeVariable\");\r\n            IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cM\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isAnyOf(\"TypeToken type argument must not contain a type variable;\" + \" captured type variable M declared by \" + testMethod + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\", // Note: When running this test in Eclipse IDE or with certain Java versions it seems to capture `null`\r\n            // instead of the type variable, see https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n            \"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n        }\r\n    }\r\n    new Enclosing\u003c\u003e().test();\r\n    new Enclosing\u003c\u003e().testMethodTypeVariable();\r\n    Method testMethod \u003d TypeTokenTest.class.getDeclaredMethod(\"createTypeTokenTypeVariable\");\r\n    IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e createTypeTokenTypeVariable());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"TypeToken type argument must not contain a type variable;\" + \" captured type variable M declared by \" + testMethod + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\");\r\n    // Using type variable as argument for factory methods should be allowed; this is not a type-safety\r\n    // problem because the user would have to perform unsafe casts\r\n    TypeVariable\u003c?\u003e typeVar \u003d Enclosing.class.getTypeParameters()[0];\r\n    TypeToken\u003c?\u003e typeToken \u003d TypeToken.get(typeVar);\r\n    assertThat(typeToken.getType()).isEqualTo(typeVar);\r\n    TypeToken\u003c?\u003e parameterizedTypeToken \u003d TypeToken.getParameterized(List.class, typeVar);\r\n    ParameterizedType parameterizedType \u003d (ParameterizedType) parameterizedTypeToken.getType();\r\n    assertThat(parameterizedType.getRawType()).isEqualTo(List.class);\r\n    assertThat(parameterizedType.getActualTypeArguments()).asList().containsExactly(typeVar);\r\n}",
    "testIsAssignableFromWithTypeParameters": "{\r\n    Type a \u003d getClass().getDeclaredField(\"listOfInteger\").getGenericType();\r\n    Type b \u003d getClass().getDeclaredField(\"listOfNumber\").getGenericType();\r\n    assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n    assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n    // listOfInteger \u003d listOfNumber; // doesn\u0027t compile; must be false\r\n    assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n    // listOfNumber \u003d listOfInteger; // doesn\u0027t compile; must be false\r\n    assertThat(TypeToken.get(b).isAssignableFrom(a)).isFalse();\r\n}",
    "testIsAssignableFromRawTypes": "{\r\n    assertThat(TypeToken.get(Object.class).isAssignableFrom(String.class)).isTrue();\r\n    assertThat(TypeToken.get(String.class).isAssignableFrom(Object.class)).isFalse();\r\n    assertThat(TypeToken.get(RandomAccess.class).isAssignableFrom(ArrayList.class)).isTrue();\r\n    assertThat(TypeToken.get(ArrayList.class).isAssignableFrom(RandomAccess.class)).isFalse();\r\n}",
    "createTypeTokenTypeVariable": "{\r\n    new TypeToken\u003cM\u003e() {\r\n    };\r\n}",
    "testArrayFactory": "{\r\n    TypeToken\u003c?\u003e expectedStringArray \u003d new TypeToken\u003cString[]\u003e() {\r\n    };\r\n    assertThat(TypeToken.getArray(String.class)).isEqualTo(expectedStringArray);\r\n    TypeToken\u003c?\u003e expectedListOfStringArray \u003d new TypeToken\u003cList\u003cString\u003e[]\u003e() {\r\n    };\r\n    Type listOfString \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(TypeToken.getArray(listOfString)).isEqualTo(expectedListOfStringArray);\r\n    TypeToken\u003c?\u003e expectedIntArray \u003d new TypeToken\u003cint[]\u003e() {\r\n    };\r\n    assertThat(TypeToken.getArray(int.class)).isEqualTo(expectedIntArray);\r\n    assertThrows(NullPointerException.class, () -\u003e TypeToken.getArray(null));\r\n}",
    "testTypeTokenSubSubClass": "{\r\n    class SubTypeToken\u003cT\u003e extends TypeToken\u003cString\u003e {\r\n    }\r\n    class SubSubTypeToken1\u003cT\u003e extends SubTypeToken\u003cT\u003e {\r\n    }\r\n    class SubSubTypeToken2 extends SubTypeToken\u003cInteger\u003e {\r\n    }\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e new SubTypeToken\u003cInteger\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e new SubSubTypeToken1\u003cInteger\u003e());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e new SubSubTypeToken2());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n}",
    "testTypeTokenNonAnonymousSubclass": "{\r\n    TypeToken\u003c?\u003e typeToken \u003d new CustomTypeToken();\r\n    assertThat(typeToken.getRawType()).isEqualTo(String.class);\r\n    assertThat(typeToken.getType()).isEqualTo(String.class);\r\n}",
    "testIsAssignableFromWithBasicWildcards": "{\r\n    Type a \u003d getClass().getDeclaredField(\"listOfString\").getGenericType();\r\n    Type b \u003d getClass().getDeclaredField(\"listOfUnknown\").getGenericType();\r\n    assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n    assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n    // listOfString \u003d listOfUnknown  // doesn\u0027t compile; must be false\r\n    assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n    // compiles; must be true\r\n    listOfUnknown \u003d listOfString;\r\n    // The following assertion is too difficult to support reliably, so disabling\r\n    // assertThat(TypeToken.get(b).isAssignableFrom(a)).isTrue();\r\n}",
    "testParameterizedFactory": "{\r\n    TypeToken\u003c?\u003e expectedListOfString \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(List.class, String.class)).isEqualTo(expectedListOfString);\r\n    TypeToken\u003c?\u003e expectedMapOfStringToString \u003d new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(Map.class, String.class, String.class)).isEqualTo(expectedMapOfStringToString);\r\n    TypeToken\u003c?\u003e expectedListOfListOfListOfString \u003d new TypeToken\u003cList\u003cList\u003cList\u003cString\u003e\u003e\u003e\u003e() {\r\n    };\r\n    Type listOfString \u003d TypeToken.getParameterized(List.class, String.class).getType();\r\n    Type listOfListOfString \u003d TypeToken.getParameterized(List.class, listOfString).getType();\r\n    assertThat(TypeToken.getParameterized(List.class, listOfListOfString)).isEqualTo(expectedListOfListOfListOfString);\r\n    TypeToken\u003c?\u003e expectedWithExactArg \u003d new TypeToken\u003cGenericWithBound\u003cNumber\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(GenericWithBound.class, Number.class)).isEqualTo(expectedWithExactArg);\r\n    TypeToken\u003c?\u003e expectedWithSubclassArg \u003d new TypeToken\u003cGenericWithBound\u003cInteger\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(GenericWithBound.class, Integer.class)).isEqualTo(expectedWithSubclassArg);\r\n    TypeToken\u003c?\u003e expectedSatisfyingTwoBounds \u003d new TypeToken\u003cGenericWithMultiBound\u003cClassSatisfyingBounds\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(GenericWithMultiBound.class, ClassSatisfyingBounds.class)).isEqualTo(expectedSatisfyingTwoBounds);\r\n    TypeToken\u003c?\u003e nestedTypeToken \u003d TypeToken.getParameterized(NestedGeneric.class, Integer.class);\r\n    ParameterizedType nestedParameterizedType \u003d (ParameterizedType) nestedTypeToken.getType();\r\n    // TODO: This seems to differ from how Java reflection behaves; when using TypeToken\u003cNestedGeneric\u003cInteger\u003e\u003e,\r\n    // then NestedGeneric\u003cInteger\u003e does have an owner type\r\n    assertThat(nestedParameterizedType.getOwnerType()).isNull();\r\n    assertThat(nestedParameterizedType.getRawType()).isEqualTo(NestedGeneric.class);\r\n    assertThat(nestedParameterizedType.getActualTypeArguments()).asList().containsExactly(Integer.class);\r\n    class LocalGenericClass\u003cT\u003e {\r\n    }\r\n    TypeToken\u003c?\u003e expectedLocalType \u003d new TypeToken\u003cLocalGenericClass\u003cInteger\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(LocalGenericClass.class, Integer.class)).isEqualTo(expectedLocalType);\r\n    // For legacy reasons, if requesting parameterized type for non-generic class, create a `TypeToken(Class)`\r\n    assertThat(TypeToken.getParameterized(String.class)).isEqualTo(TypeToken.get(String.class));\r\n}",
    "testMethodTypeVariable": "{\r\n    Method testMethod \u003d Enclosing.class.getDeclaredMethod(\"testMethodTypeVariable\");\r\n    IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cM\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isAnyOf(\"TypeToken type argument must not contain a type variable;\" + \" captured type variable M declared by \" + testMethod + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\", // Note: When running this test in Eclipse IDE or with certain Java versions it seems to capture `null`\r\n    // instead of the type variable, see https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n    \"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonElement.java": {
    "getAsFloat": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsBigInteger": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsByte": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsJsonObject": "{\r\n    if (isJsonObject()) {\r\n        return (JsonObject) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Object: \" + this);\r\n}",
    "getAsJsonNull": "{\r\n    if (isJsonNull()) {\r\n        return (JsonNull) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Null: \" + this);\r\n}",
    "getAsBigDecimal": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "isJsonNull": "{\r\n    return this instanceof JsonNull;\r\n}",
    "getAsNumber": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsCharacter": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsString": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "isJsonArray": "{\r\n    return this instanceof JsonArray;\r\n}",
    "getAsDouble": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsInt": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "isJsonPrimitive": "{\r\n    return this instanceof JsonPrimitive;\r\n}",
    "getAsLong": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "getAsJsonArray": "{\r\n    if (isJsonArray()) {\r\n        return (JsonArray) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Array: \" + this);\r\n}",
    "isJsonObject": "{\r\n    return this instanceof JsonObject;\r\n}",
    "getAsJsonPrimitive": "{\r\n    if (isJsonPrimitive()) {\r\n        return (JsonPrimitive) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Primitive: \" + this);\r\n}",
    "getAsBoolean": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "toString": "{\r\n    try {\r\n        StringWriter stringWriter \u003d new StringWriter();\r\n        JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n        // Make writer lenient because toString() must not fail, even if for example JsonPrimitive contains NaN\r\n        jsonWriter.setStrictness(Strictness.LENIENT);\r\n        Streams.write(this, jsonWriter);\r\n        return stringWriter.toString();\r\n    } catch (IOException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}",
    "getAsShort": "{\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\ObjectConstructor.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\JavaSerializationTest.java": {
    "testNumberIsSerializable": "{\r\n    Type type \u003d new TypeToken\u003cList\u003cNumber\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cNumber\u003e list \u003d gson.fromJson(\"[1,3.14,6.673e-11]\", type);\r\n    List\u003cNumber\u003e serialized \u003d serializedCopy(list);\r\n    assertThat(serialized.get(0).doubleValue()).isEqualTo(1.0);\r\n    assertThat(serialized.get(1).doubleValue()).isEqualTo(3.14);\r\n    assertThat(serialized.get(2).doubleValue()).isEqualTo(6.673e-11);\r\n}",
    "testMapIsSerializable": "{\r\n    Type type \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Integer\u003e map \u003d gson.fromJson(\"{\\\"b\\\":1,\\\"c\\\":2,\\\"a\\\":3}\", type);\r\n    Map\u003cString, Integer\u003e serialized \u003d serializedCopy(map);\r\n    assertThat(serialized).isEqualTo(map);\r\n    // Also check that the iteration order is retained.\r\n    assertThat(serialized.keySet()).containsExactly(\"b\", \"c\", \"a\").inOrder();\r\n}",
    "serializedCopy": "{\r\n    ByteArrayOutputStream bytesOut \u003d new ByteArrayOutputStream();\r\n    ObjectOutputStream out \u003d new ObjectOutputStream(bytesOut);\r\n    out.writeObject(object);\r\n    out.close();\r\n    ByteArrayInputStream bytesIn \u003d new ByteArrayInputStream(bytesOut.toByteArray());\r\n    ObjectInputStream in \u003d new ObjectInputStream(bytesIn);\r\n    return (T) in.readObject();\r\n}",
    "testListIsSerializable": "{\r\n    Type type \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cString\u003e list \u003d gson.fromJson(\"[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\", type);\r\n    List\u003cString\u003e serialized \u003d serializedCopy(list);\r\n    assertThat(serialized).isEqualTo(list);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\ParameterizedTypeFixtures.java": {
    "getValue": "{\r\n    return value;\r\n}",
    "serialize": "{\r\n    JsonObject json \u003d new JsonObject();\r\n    T value \u003d src.getValue();\r\n    json.add(value.getClass().getSimpleName(), context.serialize(value));\r\n    return json;\r\n}",
    "createInstance": "{\r\n    return new MyParameterizedType\u003c\u003e(instanceOfT);\r\n}",
    "getExpectedJson": "{\r\n    Class\u003cT\u003e clazz \u003d (Class\u003cT\u003e) obj.value.getClass();\r\n    boolean addQuotes \u003d !clazz.isArray() \u0026\u0026 !Primitives.unwrap(clazz).isPrimitive();\r\n    StringBuilder sb \u003d new StringBuilder(\"{\\\"\");\r\n    sb.append(obj.value.getClass().getSimpleName()).append(\"\\\":\");\r\n    if (addQuotes) {\r\n        sb.append(\"\\\"\");\r\n    }\r\n    sb.append(obj.value.toString());\r\n    if (addQuotes) {\r\n        sb.append(\"\\\"\");\r\n    }\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "hashCode": "{\r\n    return value \u003d\u003d null ? 0 : value.hashCode();\r\n}",
    "equals": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof MyParameterizedType\u003c?\u003e)) {\r\n        return false;\r\n    }\r\n    MyParameterizedType\u003c?\u003e that \u003d (MyParameterizedType\u003c?\u003e) obj;\r\n    return Objects.equal(getValue(), that.getValue());\r\n}",
    "deserialize": "{\r\n    Type genericClass \u003d ((ParameterizedType) typeOfT).getActualTypeArguments()[0];\r\n    Class\u003c?\u003e rawType \u003d $Gson$Types.getRawType(genericClass);\r\n    String className \u003d rawType.getSimpleName();\r\n    JsonElement jsonElement \u003d json.getAsJsonObject().get(className);\r\n    T value;\r\n    if (genericClass \u003d\u003d Integer.class) {\r\n        value \u003d (T) Integer.valueOf(jsonElement.getAsInt());\r\n    } else if (genericClass \u003d\u003d String.class) {\r\n        value \u003d (T) jsonElement.getAsString();\r\n    } else {\r\n        value \u003d (T) jsonElement;\r\n    }\r\n    if (Primitives.isPrimitive(genericClass)) {\r\n        PrimitiveTypeAdapter typeAdapter \u003d new PrimitiveTypeAdapter();\r\n        value \u003d (T) typeAdapter.adaptType(value, rawType);\r\n    }\r\n    return new MyParameterizedType\u003c\u003e(value);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\bind\\JsonTreeWriterTest.java": {
    "testWriteAfterClose": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setStrictness(Strictness.LENIENT);\r\n    writer.beginArray();\r\n    writer.value(\"A\");\r\n    writer.endArray();\r\n    writer.close();\r\n    try {\r\n        writer.beginArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "testSerializeNullsTrue": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setSerializeNulls(true);\r\n    writer.beginObject();\r\n    writer.name(\"A\");\r\n    writer.nullValue();\r\n    writer.endObject();\r\n    assertThat(writer.get().toString()).isEqualTo(\"{\\\"A\\\":null}\");\r\n}",
    "testOverrides": "{\r\n    List\u003cString\u003e ignoredMethods \u003d Arrays.asList(\"setLenient(boolean)\", \"isLenient()\", \"setStrictness(com.google.gson.Strictness)\", \"getStrictness()\", \"setIndent(java.lang.String)\", \"setHtmlSafe(boolean)\", \"isHtmlSafe()\", \"setFormattingStyle(com.google.gson.FormattingStyle)\", \"getFormattingStyle()\", \"setSerializeNulls(boolean)\", \"getSerializeNulls()\");\r\n    MoreAsserts.assertOverridesMethods(JsonWriter.class, JsonTreeWriter.class, ignoredMethods);\r\n}",
    "testStrictBoxedNansAndInfinities": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setStrictness(Strictness.LEGACY_STRICT);\r\n    writer.beginArray();\r\n    try {\r\n        writer.value(Float.valueOf(Float.NaN));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Float.valueOf(Float.NEGATIVE_INFINITY));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Float.valueOf(Float.POSITIVE_INFINITY));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.valueOf(Double.NaN));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.valueOf(Double.NEGATIVE_INFINITY));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.valueOf(Double.POSITIVE_INFINITY));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testArray": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginArray();\r\n    writer.value(1);\r\n    writer.value(2);\r\n    writer.value(3);\r\n    writer.endArray();\r\n    assertThat(writer.get().toString()).isEqualTo(\"[1,2,3]\");\r\n}",
    "testEmptyWriter": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    assertThat(writer.get()).isEqualTo(JsonNull.INSTANCE);\r\n}",
    "testNestedArray": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginArray();\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.beginArray();\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.endArray();\r\n    writer.endArray();\r\n    assertThat(writer.get().toString()).isEqualTo(\"[[],[[]]]\");\r\n}",
    "testTwoNames": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginObject();\r\n    writer.name(\"a\");\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e writer.name(\"a\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Did not expect a name\");\r\n}",
    "testSerializeNullsFalse": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setSerializeNulls(false);\r\n    writer.beginObject();\r\n    writer.name(\"A\");\r\n    writer.nullValue();\r\n    writer.endObject();\r\n    assertThat(writer.get().toString()).isEqualTo(\"{}\");\r\n}",
    "testLenientNansAndInfinities": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setStrictness(Strictness.LENIENT);\r\n    writer.beginArray();\r\n    writer.value(Float.NaN);\r\n    writer.value(Float.NEGATIVE_INFINITY);\r\n    writer.value(Float.POSITIVE_INFINITY);\r\n    writer.value(Double.NaN);\r\n    writer.value(Double.NEGATIVE_INFINITY);\r\n    writer.value(Double.POSITIVE_INFINITY);\r\n    writer.endArray();\r\n    assertThat(writer.get().toString()).isEqualTo(\"[NaN,-Infinity,Infinity,NaN,-Infinity,Infinity]\");\r\n}",
    "testPrematureClose": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setStrictness(Strictness.LENIENT);\r\n    writer.beginArray();\r\n    try {\r\n        writer.close();\r\n        fail();\r\n    } catch (IOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Incomplete document\");\r\n    }\r\n}",
    "testJsonValue": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginArray();\r\n    try {\r\n        writer.jsonValue(\"test\");\r\n        fail();\r\n    } catch (UnsupportedOperationException expected) {\r\n    }\r\n}",
    "testBoolMaisValue": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    Boolean bool \u003d true;\r\n    assertThat(writer.value(bool)).isEqualTo(writer);\r\n}",
    "testNameAsTopLevelValue": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e writer.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Did not expect a name\");\r\n    writer.value(12);\r\n    writer.close();\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e writer.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n}",
    "testBeginArray": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    assertThat(writer.beginArray()).isEqualTo(writer);\r\n}",
    "testStrictNansAndInfinities": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setStrictness(Strictness.LEGACY_STRICT);\r\n    writer.beginArray();\r\n    try {\r\n        writer.value(Float.NaN);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Float.NEGATIVE_INFINITY);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Float.POSITIVE_INFINITY);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.NaN);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.NEGATIVE_INFINITY);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.POSITIVE_INFINITY);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testObject": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginObject();\r\n    writer.name(\"A\").value(1);\r\n    writer.name(\"B\").value(2);\r\n    writer.endObject();\r\n    assertThat(writer.get().toString()).isEqualTo(\"{\\\"A\\\":1,\\\"B\\\":2}\");\r\n}",
    "testValueString": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    String n \u003d \"as\";\r\n    assertThat(writer.value(n)).isEqualTo(writer);\r\n}",
    "testNestedObject": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginObject();\r\n    writer.name(\"A\");\r\n    writer.beginObject();\r\n    writer.name(\"B\");\r\n    writer.beginObject();\r\n    writer.endObject();\r\n    writer.endObject();\r\n    writer.name(\"C\");\r\n    writer.beginObject();\r\n    writer.endObject();\r\n    writer.endObject();\r\n    assertThat(writer.get().toString()).isEqualTo(\"{\\\"A\\\":{\\\"B\\\":{}},\\\"C\\\":{}}\");\r\n}",
    "testBeginObject": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    assertThat(writer.beginObject()).isEqualTo(writer);\r\n}",
    "testBoolValue": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    boolean bool \u003d true;\r\n    assertThat(writer.value(bool)).isEqualTo(writer);\r\n}",
    "testNameInArray": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginArray();\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e writer.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n    writer.value(12);\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e writer.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n    writer.endArray();\r\n    assertThat(writer.get().toString()).isEqualTo(\"[12]\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\FieldAttributes.java": {
    "getDeclaringClass": "{\r\n    return field.getDeclaringClass();\r\n}",
    "getName": "{\r\n    return field.getName();\r\n}",
    "getAnnotation": "{\r\n    return field.getAnnotation(annotation);\r\n}",
    "hasModifier": "{\r\n    return (field.getModifiers() \u0026 modifier) !\u003d 0;\r\n}",
    "getDeclaredType": "{\r\n    return field.getGenericType();\r\n}",
    "getDeclaredClass": "{\r\n    return field.getType();\r\n}",
    "toString": "{\r\n    return field.toString();\r\n}",
    "getAnnotations": "{\r\n    return Arrays.asList(field.getAnnotations());\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\UnusedClass.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonObject.java": {
    "add": "{\r\n    members.put(property, value \u003d\u003d null ? JsonNull.INSTANCE : value);\r\n}",
    "getAsJsonObject": "{\r\n    return (JsonObject) members.get(memberName);\r\n}",
    "entrySet": "{\r\n    return members.entrySet();\r\n}",
    "asMap": "{\r\n    // It is safe to expose the underlying map because it disallows null keys and values\r\n    return members;\r\n}",
    "isEmpty": "{\r\n    return members.size() \u003d\u003d 0;\r\n}",
    "addProperty": "{\r\n    add(property, value \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(value));\r\n}",
    "remove": "{\r\n    return members.remove(property);\r\n}",
    "deepCopy": "{\r\n    JsonObject result \u003d new JsonObject();\r\n    for (Map.Entry\u003cString, JsonElement\u003e entry : members.entrySet()) {\r\n        result.add(entry.getKey(), entry.getValue().deepCopy());\r\n    }\r\n    return result;\r\n}",
    "size": "{\r\n    return members.size();\r\n}",
    "getAsJsonArray": "{\r\n    return (JsonArray) members.get(memberName);\r\n}",
    "getAsJsonPrimitive": "{\r\n    return (JsonPrimitive) members.get(memberName);\r\n}",
    "hashCode": "{\r\n    return members.hashCode();\r\n}",
    "get": "{\r\n    return members.get(memberName);\r\n}",
    "equals": "{\r\n    return (o \u003d\u003d this) || (o instanceof JsonObject \u0026\u0026 ((JsonObject) o).members.equals(members));\r\n}",
    "has": "{\r\n    return members.containsKey(memberName);\r\n}",
    "keySet": "{\r\n    return members.keySet();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\ExposeAnnotationExclusionStrategyTest.java": {
    "testNeverSkipExplicitlyExposedAnnotatedFields": "{\r\n    Field f \u003d createFieldAttributes(\"explicitlyExposedField\");\r\n    assertThat(excluder.excludeField(f, true)).isFalse();\r\n    assertThat(excluder.excludeField(f, false)).isFalse();\r\n}",
    "testSkipExplicitlySkippedFields": "{\r\n    Field f \u003d createFieldAttributes(\"explicitlyHiddenField\");\r\n    assertThat(excluder.excludeField(f, true)).isTrue();\r\n    assertThat(excluder.excludeField(f, false)).isTrue();\r\n}",
    "createFieldAttributes": "{\r\n    return MockObject.class.getField(fieldName);\r\n}",
    "testSkipNonAnnotatedFields": "{\r\n    Field f \u003d createFieldAttributes(\"hiddenField\");\r\n    assertThat(excluder.excludeField(f, true)).isTrue();\r\n    assertThat(excluder.excludeField(f, false)).isTrue();\r\n}",
    "testDifferentSerializeAndDeserializeField": "{\r\n    Field f \u003d createFieldAttributes(\"explicitlyDifferentModeField\");\r\n    assertThat(excluder.excludeField(f, true)).isFalse();\r\n    assertThat(excluder.excludeField(f, false)).isTrue();\r\n}",
    "testNeverSkipClasses": "{\r\n    assertThat(excluder.excludeClass(MockObject.class, true)).isFalse();\r\n    assertThat(excluder.excludeClass(MockObject.class, false)).isFalse();\r\n}",
    "testNeverSkipExposedAnnotatedFields": "{\r\n    Field f \u003d createFieldAttributes(\"exposedField\");\r\n    assertThat(excluder.excludeField(f, true)).isFalse();\r\n    assertThat(excluder.excludeField(f, false)).isFalse();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ParameterizedTypesTest.java": {
    "testParameterizedTypeGenericArraysSerialization": "{\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(1);\r\n    list.add(2);\r\n    List\u003cInteger\u003e[] arrayOfLists \u003d arrayOf(list, list);\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(null, null, null, arrayOfLists, null, null);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    assertThat(json).isEqualTo(\"{\\\"arrayOfListOfTypeParameters\\\":[[1,2],[1,2]]}\");\r\n}",
    "assertCorrectlyDeserialized": "{\r\n    @SuppressWarnings(\"unchecked\")\r\n    List\u003cQuantity\u003e list \u003d (List\u003cQuantity\u003e) object;\r\n    assertThat(list.size()).isEqualTo(1);\r\n    assertThat(list.get(0).q).isEqualTo(4);\r\n}",
    "testParameterizedTypeWithVariableTypeDeserialization": "{\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(4);\r\n    list.add(5);\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(null, null, list, null, null, null);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    ObjectWithTypeVariables\u003cInteger\u003e objAfterDeserialization \u003d gson.fromJson(json, typeOfSrc);\r\n    assertThat(json).isEqualTo(objAfterDeserialization.getExpectedJson());\r\n}",
    "testVariableTypeArrayDeserialization": "{\r\n    Integer[] array \u003d { 1, 2, 3 };\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(null, array, null, null, null, null);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    ObjectWithTypeVariables\u003cInteger\u003e objAfterDeserialization \u003d gson.fromJson(json, typeOfSrc);\r\n    assertThat(json).isEqualTo(objAfterDeserialization.getExpectedJson());\r\n}",
    "testParameterizedTypeDeserialization": "{\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n    MyParameterizedType\u003cBagOfPrimitives\u003e expected \u003d new MyParameterizedType\u003c\u003e(bag);\r\n    Type expectedType \u003d new TypeToken\u003cMyParameterizedType\u003cBagOfPrimitives\u003e\u003e() {\r\n    }.getType();\r\n    BagOfPrimitives bagDefaultInstance \u003d new BagOfPrimitives();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(expectedType, new MyParameterizedTypeInstanceCreator\u003c\u003e(bagDefaultInstance)).create();\r\n    String json \u003d expected.getExpectedJson();\r\n    MyParameterizedType\u003cBagOfPrimitives\u003e actual \u003d gson.fromJson(json, expectedType);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testParameterizedTypeWithCustomSerializer": "{\r\n    Type ptIntegerType \u003d new TypeToken\u003cMyParameterizedType\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    Type ptStringType \u003d new TypeToken\u003cMyParameterizedType\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ptIntegerType, new MyParameterizedTypeAdapter\u003cInteger\u003e()).registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter\u003cString\u003e()).create();\r\n    MyParameterizedType\u003cInteger\u003e intTarget \u003d new MyParameterizedType\u003c\u003e(10);\r\n    String json \u003d gson.toJson(intTarget, ptIntegerType);\r\n    assertThat(json).isEqualTo(MyParameterizedTypeAdapter.\u003cInteger\u003egetExpectedJson(intTarget));\r\n    MyParameterizedType\u003cString\u003e stringTarget \u003d new MyParameterizedType\u003c\u003e(\"abc\");\r\n    json \u003d gson.toJson(stringTarget, ptStringType);\r\n    assertThat(json).isEqualTo(MyParameterizedTypeAdapter.\u003cString\u003egetExpectedJson(stringTarget));\r\n}",
    "hashCode": "{\r\n    final int prime \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d prime * result + ((a \u003d\u003d null) ? 0 : a.hashCode());\r\n    result \u003d prime * result + ((b \u003d\u003d null) ? 0 : b.hashCode());\r\n    result \u003d prime * result + ((c \u003d\u003d null) ? 0 : c.hashCode());\r\n    result \u003d prime * result + ((d \u003d\u003d null) ? 0 : d.hashCode());\r\n    result \u003d prime * result + ((e \u003d\u003d null) ? 0 : e.hashCode());\r\n    return result;\r\n}",
    "testParameterizedTypesWithWriterSerialization": "{\r\n    Writer writer \u003d new StringWriter();\r\n    MyParameterizedType\u003cInteger\u003e src \u003d new MyParameterizedType\u003c\u003e(10);\r\n    Type typeOfSrc \u003d new TypeToken\u003cMyParameterizedType\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    gson.toJson(src, typeOfSrc, writer);\r\n    assertThat(writer.toString()).isEqualTo(src.getExpectedJson());\r\n}",
    "testDeepParameterizedTypeDeserialization": "{\r\n    String json \u003d \"{value:30}\";\r\n    Type type \u003d new TypeToken\u003cAmount\u003cMyQuantity\u003e\u003e() {\r\n    }.getType();\r\n    Amount\u003cMyQuantity\u003e amount \u003d gson.fromJson(json, type);\r\n    assertThat(amount.value).isEqualTo(30);\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testDeepParameterizedTypeSerialization": "{\r\n    Amount\u003cMyQuantity\u003e amount \u003d new Amount\u003c\u003e();\r\n    String json \u003d gson.toJson(amount);\r\n    assertThat(json).contains(\"value\");\r\n    assertThat(json).contains(\"30\");\r\n}",
    "testParameterizedTypesSerialization": "{\r\n    MyParameterizedType\u003cInteger\u003e src \u003d new MyParameterizedType\u003c\u003e(10);\r\n    Type typeOfSrc \u003d new TypeToken\u003cMyParameterizedType\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(src, typeOfSrc);\r\n    assertThat(json).isEqualTo(src.getExpectedJson());\r\n}",
    "testTypesWithMultipleParametersDeserialization": "{\r\n    Type typeOfTarget \u003d new TypeToken\u003cMultiParameters\u003cInteger, Float, Double, String, BagOfPrimitives\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d \"{\\\"a\\\":10,\\\"b\\\":1.0,\\\"c\\\":2.1,\\\"d\\\":\\\"abc\\\",\" + \"\\\"e\\\":{\\\"longValue\\\":0,\\\"intValue\\\":0,\\\"booleanValue\\\":false,\\\"stringValue\\\":\\\"\\\"}}\";\r\n    MultiParameters\u003cInteger, Float, Double, String, BagOfPrimitives\u003e target \u003d gson.fromJson(json, typeOfTarget);\r\n    MultiParameters\u003cInteger, Float, Double, String, BagOfPrimitives\u003e expected \u003d new MultiParameters\u003c\u003e(10, 1.0F, 2.1D, \"abc\", new BagOfPrimitives());\r\n    assertThat(target).isEqualTo(expected);\r\n}",
    "testParameterizedTypesWithCustomDeserializer": "{\r\n    Type ptIntegerType \u003d new TypeToken\u003cMyParameterizedType\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    Type ptStringType \u003d new TypeToken\u003cMyParameterizedType\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ptIntegerType, new MyParameterizedTypeAdapter\u003cInteger\u003e()).registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter\u003cString\u003e()).registerTypeAdapter(ptStringType, new MyParameterizedTypeInstanceCreator\u003c\u003e(\"\")).registerTypeAdapter(ptIntegerType, new MyParameterizedTypeInstanceCreator\u003c\u003e(0)).create();\r\n    MyParameterizedType\u003cInteger\u003e src \u003d new MyParameterizedType\u003c\u003e(10);\r\n    String json \u003d MyParameterizedTypeAdapter.\u003cInteger\u003egetExpectedJson(src);\r\n    MyParameterizedType\u003cInteger\u003e intTarget \u003d gson.fromJson(json, ptIntegerType);\r\n    assertThat(intTarget.value).isEqualTo(10);\r\n    MyParameterizedType\u003cString\u003e srcStr \u003d new MyParameterizedType\u003c\u003e(\"abc\");\r\n    json \u003d MyParameterizedTypeAdapter.\u003cString\u003egetExpectedJson(srcStr);\r\n    MyParameterizedType\u003cString\u003e stringTarget \u003d gson.fromJson(json, ptStringType);\r\n    assertThat(stringTarget.value).isEqualTo(\"abc\");\r\n}",
    "testParameterizedTypeWithReaderDeserialization": "{\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n    MyParameterizedType\u003cBagOfPrimitives\u003e expected \u003d new MyParameterizedType\u003c\u003e(bag);\r\n    Type expectedType \u003d new TypeToken\u003cMyParameterizedType\u003cBagOfPrimitives\u003e\u003e() {\r\n    }.getType();\r\n    BagOfPrimitives bagDefaultInstance \u003d new BagOfPrimitives();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(expectedType, new MyParameterizedTypeInstanceCreator\u003c\u003e(bagDefaultInstance)).create();\r\n    Reader json \u003d new StringReader(expected.getExpectedJson());\r\n    MyParameterizedType\u003cBagOfPrimitives\u003e actual \u003d gson.fromJson(json, expectedType);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testVariableTypeFieldsAndGenericArraysSerialization": "{\r\n    Integer obj \u003d 0;\r\n    Integer[] array \u003d { 1, 2, 3 };\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(4);\r\n    list.add(5);\r\n    List\u003cInteger\u003e[] arrayOfLists \u003d arrayOf(list, list);\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(obj, array, list, arrayOfLists, list, arrayOfLists);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    assertThat(json).isEqualTo(objToSerialize.getExpectedJson());\r\n}",
    "testTypesWithMultipleParametersSerialization": "{\r\n    MultiParameters\u003cInteger, Float, Double, String, BagOfPrimitives\u003e src \u003d new MultiParameters\u003c\u003e(10, 1.0F, 2.1D, \"abc\", new BagOfPrimitives());\r\n    Type typeOfSrc \u003d new TypeToken\u003cMultiParameters\u003cInteger, Float, Double, String, BagOfPrimitives\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(src, typeOfSrc);\r\n    String expected \u003d \"{\\\"a\\\":10,\\\"b\\\":1.0,\\\"c\\\":2.1,\\\"d\\\":\\\"abc\\\",\" + \"\\\"e\\\":{\\\"longValue\\\":0,\\\"intValue\\\":0,\\\"booleanValue\\\":false,\\\"stringValue\\\":\\\"\\\"}}\";\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "testGsonFromJsonTypeToken": "{\r\n    TypeToken\u003cList\u003cQuantity\u003e\u003e typeToken \u003d new TypeToken\u003cList\u003cQuantity\u003e\u003e() {\r\n    };\r\n    Type type \u003d typeToken.getType();\r\n    {\r\n        JsonObject jsonObject \u003d new JsonObject();\r\n        jsonObject.addProperty(\"q\", 4);\r\n        JsonArray jsonArray \u003d new JsonArray();\r\n        jsonArray.add(jsonObject);\r\n        assertCorrectlyDeserialized(gson.fromJson(jsonArray, typeToken));\r\n        assertCorrectlyDeserialized(gson.fromJson(jsonArray, type));\r\n    }\r\n    String json \u003d \"[{\\\"q\\\":4}]\";\r\n    {\r\n        assertCorrectlyDeserialized(gson.fromJson(json, typeToken));\r\n        assertCorrectlyDeserialized(gson.fromJson(json, type));\r\n    }\r\n    {\r\n        assertCorrectlyDeserialized(gson.fromJson(new StringReader(json), typeToken));\r\n        assertCorrectlyDeserialized(gson.fromJson(new StringReader(json), type));\r\n    }\r\n    {\r\n        JsonReader reader \u003d new JsonReader(new StringReader(json));\r\n        assertCorrectlyDeserialized(gson.fromJson(reader, typeToken));\r\n        reader \u003d new JsonReader(new StringReader(json));\r\n        assertCorrectlyDeserialized(gson.fromJson(reader, type));\r\n    }\r\n}",
    "arrayOf": "{\r\n    return args;\r\n}",
    "appendObjectsToBuilder": "{\r\n    boolean isFirst \u003d true;\r\n    for (List\u003c? extends T\u003e list : arrayOfList) {\r\n        if (!isFirst) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        isFirst \u003d false;\r\n        if (list !\u003d null) {\r\n            sb.append(\u0027[\u0027);\r\n            appendObjectsToBuilder(sb, list);\r\n            sb.append(\u0027]\u0027);\r\n        } else {\r\n            sb.append(\"null\");\r\n        }\r\n    }\r\n}",
    "testParameterizedTypeGenericArraysDeserialization": "{\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(1);\r\n    list.add(2);\r\n    List\u003cInteger\u003e[] arrayOfLists \u003d arrayOf(list, list);\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(null, null, null, arrayOfLists, null, null);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    ObjectWithTypeVariables\u003cInteger\u003e objAfterDeserialization \u003d gson.fromJson(json, typeOfSrc);\r\n    assertThat(json).isEqualTo(objAfterDeserialization.getExpectedJson());\r\n}",
    "getExpectedJson": "{\r\n    StringBuilder sb \u003d new StringBuilder().append(\"{\");\r\n    boolean needsComma \u003d false;\r\n    if (typeParameterObj !\u003d null) {\r\n        sb.append(\"\\\"typeParameterObj\\\":\").append(toString(typeParameterObj));\r\n        needsComma \u003d true;\r\n    }\r\n    if (typeParameterArray !\u003d null) {\r\n        if (needsComma) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"\\\"typeParameterArray\\\":[\");\r\n        appendObjectsToBuilder(sb, Arrays.asList(typeParameterArray));\r\n        sb.append(\u0027]\u0027);\r\n        needsComma \u003d true;\r\n    }\r\n    if (listOfTypeParameters !\u003d null) {\r\n        if (needsComma) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"\\\"listOfTypeParameters\\\":[\");\r\n        appendObjectsToBuilder(sb, listOfTypeParameters);\r\n        sb.append(\u0027]\u0027);\r\n        needsComma \u003d true;\r\n    }\r\n    if (arrayOfListOfTypeParameters !\u003d null) {\r\n        if (needsComma) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"\\\"arrayOfListOfTypeParameters\\\":[\");\r\n        appendObjectsToBuilder(sb, arrayOfListOfTypeParameters);\r\n        sb.append(\u0027]\u0027);\r\n        needsComma \u003d true;\r\n    }\r\n    if (listOfWildcardTypeParameters !\u003d null) {\r\n        if (needsComma) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"\\\"listOfWildcardTypeParameters\\\":[\");\r\n        appendObjectsToBuilder(sb, listOfWildcardTypeParameters);\r\n        sb.append(\u0027]\u0027);\r\n        needsComma \u003d true;\r\n    }\r\n    if (arrayOfListOfWildcardTypeParameters !\u003d null) {\r\n        if (needsComma) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"\\\"arrayOfListOfWildcardTypeParameters\\\":[\");\r\n        appendObjectsToBuilder(sb, arrayOfListOfWildcardTypeParameters);\r\n        sb.append(\u0027]\u0027);\r\n        needsComma \u003d true;\r\n    }\r\n    sb.append(\u0027}\u0027);\r\n    return sb.toString();\r\n}",
    "testVariableTypeFieldsAndGenericArraysDeserialization": "{\r\n    Integer obj \u003d 0;\r\n    Integer[] array \u003d { 1, 2, 3 };\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(4);\r\n    list.add(5);\r\n    List\u003cInteger\u003e[] arrayOfLists \u003d arrayOf(list, list);\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(obj, array, list, arrayOfLists, list, arrayOfLists);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    ObjectWithTypeVariables\u003cInteger\u003e objAfterDeserialization \u003d gson.fromJson(json, typeOfSrc);\r\n    assertThat(json).isEqualTo(objAfterDeserialization.getExpectedJson());\r\n}",
    "testVariableTypeDeserialization": "{\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(0, null, null, null, null, null);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    ObjectWithTypeVariables\u003cInteger\u003e objAfterDeserialization \u003d gson.fromJson(json, typeOfSrc);\r\n    assertThat(json).isEqualTo(objAfterDeserialization.getExpectedJson());\r\n}",
    "equals": "{\r\n    if (this \u003d\u003d o) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof MultiParameters\u003c?, ?, ?, ?, ?\u003e)) {\r\n        return false;\r\n    }\r\n    MultiParameters\u003c?, ?, ?, ?, ?\u003e that \u003d (MultiParameters\u003c?, ?, ?, ?, ?\u003e) o;\r\n    return Objects.equal(a, that.a) \u0026\u0026 Objects.equal(b, that.b) \u0026\u0026 Objects.equal(c, that.c) \u0026\u0026 Objects.equal(d, that.d) \u0026\u0026 Objects.equal(e, that.e);\r\n}",
    "toString": "{\r\n    return obj.toString();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java": {
    "testBlockInaccessibleJava": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_INACCESSIBLE_JAVA).create();\r\n    // Serialization should fail for classes with non-public fields\r\n    try {\r\n        gson.toJson(new File(\"a\"));\r\n        fail(\"Expected exception; test needs to be run with Java \u003e\u003d 9\");\r\n    } catch (JsonIOException expected) {\r\n        // Note: This test is rather brittle and depends on the JDK implementation\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Field \u0027java.io.File#path\u0027 is not accessible and ReflectionAccessFilter does not permit\" + \" making it accessible. Register a TypeAdapter for the declaring type, adjust the access\" + \" filter or increase the visibility of the element and its declaring type.\");\r\n    }\r\n    // But serialization should succeed for classes with only public fields.\r\n    // Not many JDK classes have mutable public fields, thank goodness, but java.awt.Point does.\r\n    Class\u003c?\u003e pointClass \u003d null;\r\n    try {\r\n        pointClass \u003d Class.forName(\"java.awt.Point\");\r\n    } catch (ClassNotFoundException e) {\r\n    }\r\n    assumeNotNull(pointClass);\r\n    Constructor\u003c?\u003e pointConstructor \u003d pointClass.getConstructor(int.class, int.class);\r\n    Object point \u003d pointConstructor.newInstance(1, 2);\r\n    String json \u003d gson.toJson(point);\r\n    assertThat(json).isEqualTo(\"{\\\"x\\\":1,\\\"y\\\":2}\");\r\n}",
    "createInstance": "{\r\n    return new ClassWithoutNoArgsConstructor(\"InstanceCreator\");\r\n}",
    "read": "{\r\n    in.skipValue();\r\n    return new ClassWithoutNoArgsConstructor(\"TypeAdapter\");\r\n}",
    "testBlockAllJavaExtendingJdkClass": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_ALL_JAVA).create();\r\n    try {\r\n        gson.toJson(new ClassExtendingJdkClass());\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class java.io.Reader\" + \" (supertype of class com.google.gson.functional.ReflectionAccessFilterTest$ClassExtendingJdkClass).\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n}",
    "testClassWithoutNoArgsConstructor": "{\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            // Even BLOCK_INACCESSIBLE should prevent usage of Unsafe for object creation\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    });\r\n    Gson gson \u003d gsonBuilder.create();\r\n    try {\r\n        gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unable to create instance of class com.google.gson.functional.ReflectionAccessFilterTest$ClassWithoutNoArgsConstructor;\" + \" ReflectionAccessFilter does not permit using reflection or Unsafe. Register an InstanceCreator\" + \" or a TypeAdapter for this type or adjust the access filter to allow using reflection.\");\r\n    }\r\n    // But should not fail when custom TypeAdapter is specified\r\n    gson \u003d gson.newBuilder().registerTypeAdapter(ClassWithoutNoArgsConstructor.class, new TypeAdapter\u003cClassWithoutNoArgsConstructor\u003e() {\r\n\r\n        @Override\r\n        public ClassWithoutNoArgsConstructor read(JsonReader in) throws IOException {\r\n            in.skipValue();\r\n            return new ClassWithoutNoArgsConstructor(\"TypeAdapter\");\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, ClassWithoutNoArgsConstructor value) {\r\n            throw new AssertionError(\"Not needed for test\");\r\n        }\r\n    }).create();\r\n    ClassWithoutNoArgsConstructor deserialized \u003d gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n    assertThat(deserialized.s).isEqualTo(\"TypeAdapter\");\r\n    // But should not fail when custom InstanceCreator is specified\r\n    gson \u003d gsonBuilder.registerTypeAdapter(ClassWithoutNoArgsConstructor.class, new InstanceCreator\u003cClassWithoutNoArgsConstructor\u003e() {\r\n\r\n        @Override\r\n        public ClassWithoutNoArgsConstructor createInstance(Type type) {\r\n            return new ClassWithoutNoArgsConstructor(\"InstanceCreator\");\r\n        }\r\n    }).create();\r\n    deserialized \u003d gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n    assertThat(deserialized.s).isEqualTo(\"InstanceCreator\");\r\n}",
    "testBlockAllCollectionInterface": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_ALL;\r\n        }\r\n    }).create();\r\n    List\u003c?\u003e deserialized \u003d gson.fromJson(\"[1.0]\", List.class);\r\n    assertThat(deserialized.get(0)).isEqualTo(1.0);\r\n}",
    "testBlockAllPartial": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_ALL;\r\n        }\r\n    }).registerTypeAdapter(OtherClass.class, new JsonSerializer\u003cOtherClass\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(OtherClass src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(123);\r\n        }\r\n    }).create();\r\n    String json \u003d gson.toJson(new OtherClass());\r\n    assertThat(json).isEqualTo(\"123\");\r\n    // But deserialization should fail\r\n    try {\r\n        gson.fromJson(\"{}\", OtherClass.class);\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class com.google.gson.functional.ReflectionAccessFilterTest$OtherClass.\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n}",
    "testBlockAllCollectionImplementation": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_ALL;\r\n        }\r\n    }).create();\r\n    List\u003c?\u003e deserialized \u003d gson.fromJson(\"[1.0]\", LinkedList.class);\r\n    assertThat(deserialized.get(0)).isEqualTo(1.0);\r\n}",
    "testBlockInaccessibleStaticField": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).// Include static fields\r\n    excludeFieldsWithModifiers(0).create();\r\n    try {\r\n        gson.toJson(new ClassWithStaticField());\r\n        fail(\"Expected exception; test needs to be run with Java \u003e\u003d 9\");\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Field \u0027com.google.gson.functional.ReflectionAccessFilterTest$ClassWithStaticField#i\u0027\" + \" is not accessible and ReflectionAccessFilter does not permit making it accessible.\" + \" Register a TypeAdapter for the declaring type, adjust the access filter or increase\" + \" the visibility of the element and its declaring type.\");\r\n    }\r\n}",
    "check": "{\r\n    return FilterResult.BLOCK_INACCESSIBLE;\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(123);\r\n}",
    "testAllowForSupertype": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).create();\r\n    // First make sure test is implemented correctly and access is blocked\r\n    try {\r\n        gson.toJson(new ExtendingClassWithPrivateField());\r\n        fail(\"Expected exception; test needs to be run with Java \u003e\u003d 9\");\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Field \u0027com.google.gson.functional.ReflectionAccessFilterTest$ClassWithPrivateField#i\u0027\" + \" is not accessible and ReflectionAccessFilter does not permit making it accessible.\" + \" Register a TypeAdapter for the declaring type, adjust the access filter or increase\" + \" the visibility of the element and its declaring type.\");\r\n    }\r\n    gson \u003d gson.newBuilder().// Allow reflective access for supertype\r\n    addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return rawClass \u003d\u003d ClassWithPrivateField.class ? FilterResult.ALLOW : FilterResult.INDECISIVE;\r\n        }\r\n    }).create();\r\n    // Inherited (inaccessible) private field should have been made accessible\r\n    String json \u003d gson.toJson(new ExtendingClassWithPrivateField());\r\n    assertThat(json).isEqualTo(\"{\\\"i\\\":1}\");\r\n}",
    "testInaccessibleNoArgsConstructor": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).create();\r\n    try {\r\n        gson.fromJson(\"{}\", ClassWithPrivateNoArgsConstructor.class);\r\n        fail(\"Expected exception; test needs to be run with Java \u003e\u003d 9\");\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unable to invoke no-args constructor of class com.google.gson.functional.ReflectionAccessFilterTest$ClassWithPrivateNoArgsConstructor;\" + \" constructor is not accessible and ReflectionAccessFilter does not permit making it accessible. Register an\" + \" InstanceCreator or a TypeAdapter for this type, change the visibility of the constructor or adjust the access filter.\");\r\n    }\r\n}",
    "testBlockInaccessibleInterface": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).create();\r\n    try {\r\n        gson.fromJson(\"{}\", Runnable.class);\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Interfaces can\u0027t be instantiated! Register an InstanceCreator or a TypeAdapter for\" + \" this type. Interface name: java.lang.Runnable\");\r\n    }\r\n}",
    "testBlockAllJava": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_ALL_JAVA).create();\r\n    // Serialization should fail for any Java class\r\n    try {\r\n        gson.toJson(Thread.currentThread());\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class java.lang.Thread.\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n}",
    "close": "{\r\n}",
    "testBlockInaccessibleJavaExtendingJdkClass": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_INACCESSIBLE_JAVA).create();\r\n    try {\r\n        gson.toJson(new ClassExtendingJdkClass());\r\n        fail(\"Expected exception; test needs to be run with Java \u003e\u003d 9\");\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Field \u0027java.io.Reader#lock\u0027 is not accessible and ReflectionAccessFilter does not permit\" + \" making it accessible. Register a TypeAdapter for the declaring type, adjust the access\" + \" filter or increase the visibility of the element and its declaring type.\");\r\n    }\r\n}",
    "write": "{\r\n    throw new AssertionError(\"Not needed for test\");\r\n}",
    "testDelegation": "{\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            // INDECISIVE in last filter should act like ALLOW\r\n            return SuperTestClass.class.isAssignableFrom(rawClass) ? FilterResult.BLOCK_ALL : FilterResult.INDECISIVE;\r\n        }\r\n    }).addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            // INDECISIVE should delegate to previous filter\r\n            return rawClass \u003d\u003d SubTestClass.class ? FilterResult.ALLOW : FilterResult.INDECISIVE;\r\n        }\r\n    }).create();\r\n    // Filter disallows SuperTestClass\r\n    try {\r\n        gson.toJson(new SuperTestClass());\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$SuperTestClass.\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n    // But registration order is reversed, so filter for SubTestClass allows reflection\r\n    String json \u003d gson.toJson(new SubTestClass());\r\n    assertThat(json).isEqualTo(\"{\\\"i\\\":1}\");\r\n    // And unrelated class should not be affected\r\n    json \u003d gson.toJson(new OtherClass());\r\n    assertThat(json).isEqualTo(\"{\\\"i\\\":2}\");\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\EnumClass.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\$Gson$Types.java": {
    "getMapKeyAndValueTypes": "{\r\n    /*\r\n     * Work around a problem with the declaration of java.util.Properties. That\r\n     * class should extend Hashtable\u003cString, String\u003e, but it\u0027s declared to\r\n     * extend Hashtable\u003cObject, Object\u003e.\r\n     */\r\n    if (context \u003d\u003d Properties.class) {\r\n        // TODO: test subclasses of Properties!\r\n        return new Type[] { String.class, String.class };\r\n    }\r\n    Type mapType \u003d getSupertype(context, contextRawType, Map.class);\r\n    // TODO: strip wildcards?\r\n    if (mapType instanceof ParameterizedType) {\r\n        ParameterizedType mapParameterizedType \u003d (ParameterizedType) mapType;\r\n        return mapParameterizedType.getActualTypeArguments();\r\n    }\r\n    return new Type[] { Object.class, Object.class };\r\n}",
    "getRawType": "{\r\n    return rawType;\r\n}",
    "hashCodeOrZero": "{\r\n    return o !\u003d null ? o.hashCode() : 0;\r\n}",
    "resolve": "{\r\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\r\n    TypeVariable\u003c?\u003e resolving \u003d null;\r\n    while (true) {\r\n        if (toResolve instanceof TypeVariable) {\r\n            TypeVariable\u003c?\u003e typeVariable \u003d (TypeVariable\u003c?\u003e) toResolve;\r\n            Type previouslyResolved \u003d visitedTypeVariables.get(typeVariable);\r\n            if (previouslyResolved !\u003d null) {\r\n                // cannot reduce due to infinite recursion\r\n                return (previouslyResolved \u003d\u003d Void.TYPE) ? toResolve : previouslyResolved;\r\n            }\r\n            // Insert a placeholder to mark the fact that we are in the process of resolving this type\r\n            visitedTypeVariables.put(typeVariable, Void.TYPE);\r\n            if (resolving \u003d\u003d null) {\r\n                resolving \u003d typeVariable;\r\n            }\r\n            toResolve \u003d resolveTypeVariable(context, contextRawType, typeVariable);\r\n            if (toResolve \u003d\u003d typeVariable) {\r\n                break;\r\n            }\r\n        } else if (toResolve instanceof Class \u0026\u0026 ((Class\u003c?\u003e) toResolve).isArray()) {\r\n            Class\u003c?\u003e original \u003d (Class\u003c?\u003e) toResolve;\r\n            Type componentType \u003d original.getComponentType();\r\n            Type newComponentType \u003d resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n            toResolve \u003d equal(componentType, newComponentType) ? original : arrayOf(newComponentType);\r\n            break;\r\n        } else if (toResolve instanceof GenericArrayType) {\r\n            GenericArrayType original \u003d (GenericArrayType) toResolve;\r\n            Type componentType \u003d original.getGenericComponentType();\r\n            Type newComponentType \u003d resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n            toResolve \u003d equal(componentType, newComponentType) ? original : arrayOf(newComponentType);\r\n            break;\r\n        } else if (toResolve instanceof ParameterizedType) {\r\n            ParameterizedType original \u003d (ParameterizedType) toResolve;\r\n            Type ownerType \u003d original.getOwnerType();\r\n            Type newOwnerType \u003d resolve(context, contextRawType, ownerType, visitedTypeVariables);\r\n            boolean changed \u003d !equal(newOwnerType, ownerType);\r\n            Type[] args \u003d original.getActualTypeArguments();\r\n            for (int t \u003d 0, length \u003d args.length; t \u003c length; t++) {\r\n                Type resolvedTypeArgument \u003d resolve(context, contextRawType, args[t], visitedTypeVariables);\r\n                if (!equal(resolvedTypeArgument, args[t])) {\r\n                    if (!changed) {\r\n                        args \u003d args.clone();\r\n                        changed \u003d true;\r\n                    }\r\n                    args[t] \u003d resolvedTypeArgument;\r\n                }\r\n            }\r\n            toResolve \u003d changed ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args) : original;\r\n            break;\r\n        } else if (toResolve instanceof WildcardType) {\r\n            WildcardType original \u003d (WildcardType) toResolve;\r\n            Type[] originalLowerBound \u003d original.getLowerBounds();\r\n            Type[] originalUpperBound \u003d original.getUpperBounds();\r\n            if (originalLowerBound.length \u003d\u003d 1) {\r\n                Type lowerBound \u003d resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\r\n                if (lowerBound !\u003d originalLowerBound[0]) {\r\n                    toResolve \u003d supertypeOf(lowerBound);\r\n                    break;\r\n                }\r\n            } else if (originalUpperBound.length \u003d\u003d 1) {\r\n                Type upperBound \u003d resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\r\n                if (upperBound !\u003d originalUpperBound[0]) {\r\n                    toResolve \u003d subtypeOf(upperBound);\r\n                    break;\r\n                }\r\n            }\r\n            toResolve \u003d original;\r\n            break;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // ensure that any in-process resolution gets updated with the final result\r\n    if (resolving !\u003d null) {\r\n        visitedTypeVariables.put(resolving, toResolve);\r\n    }\r\n    return toResolve;\r\n}",
    "getActualTypeArguments": "{\r\n    return typeArguments.clone();\r\n}",
    "getGenericSupertype": "{\r\n    if (supertype \u003d\u003d rawType) {\r\n        return context;\r\n    }\r\n    // we skip searching through interfaces if unknown is an interface\r\n    if (supertype.isInterface()) {\r\n        Class\u003c?\u003e[] interfaces \u003d rawType.getInterfaces();\r\n        for (int i \u003d 0, length \u003d interfaces.length; i \u003c length; i++) {\r\n            if (interfaces[i] \u003d\u003d supertype) {\r\n                return rawType.getGenericInterfaces()[i];\r\n            } else if (supertype.isAssignableFrom(interfaces[i])) {\r\n                return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], supertype);\r\n            }\r\n        }\r\n    }\r\n    // check our supertypes\r\n    if (!rawType.isInterface()) {\r\n        while (rawType !\u003d Object.class) {\r\n            Class\u003c?\u003e rawSupertype \u003d rawType.getSuperclass();\r\n            if (rawSupertype \u003d\u003d supertype) {\r\n                return rawType.getGenericSuperclass();\r\n            } else if (supertype.isAssignableFrom(rawSupertype)) {\r\n                return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, supertype);\r\n            }\r\n            rawType \u003d rawSupertype;\r\n        }\r\n    }\r\n    // we can\u0027t resolve this further\r\n    return supertype;\r\n}",
    "supertypeOf": "{\r\n    Type[] lowerBounds;\r\n    if (bound instanceof WildcardType) {\r\n        lowerBounds \u003d ((WildcardType) bound).getLowerBounds();\r\n    } else {\r\n        lowerBounds \u003d new Type[] { bound };\r\n    }\r\n    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\r\n}",
    "requiresOwnerType": "{\r\n    if (rawType instanceof Class\u003c?\u003e) {\r\n        Class\u003c?\u003e rawTypeAsClass \u003d (Class\u003c?\u003e) rawType;\r\n        return !Modifier.isStatic(rawTypeAsClass.getModifiers()) \u0026\u0026 rawTypeAsClass.getDeclaringClass() !\u003d null;\r\n    }\r\n    return false;\r\n}",
    "checkNotPrimitive": "{\r\n    checkArgument(!(type instanceof Class\u003c?\u003e) || !((Class\u003c?\u003e) type).isPrimitive());\r\n}",
    "getCollectionElementType": "{\r\n    Type collectionType \u003d getSupertype(context, contextRawType, Collection.class);\r\n    if (collectionType instanceof ParameterizedType) {\r\n        return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\r\n    }\r\n    return Object.class;\r\n}",
    "getGenericComponentType": "{\r\n    return componentType;\r\n}",
    "hashCode": "{\r\n    // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\r\n    return (lowerBound !\u003d null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());\r\n}",
    "getSupertype": "{\r\n    if (context instanceof WildcardType) {\r\n        // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\r\n        Type[] bounds \u003d ((WildcardType) context).getUpperBounds();\r\n        // Currently the JLS only permits one bound for wildcards so using first bound is safe\r\n        assert bounds.length \u003d\u003d 1;\r\n        context \u003d bounds[0];\r\n    }\r\n    checkArgument(supertype.isAssignableFrom(contextRawType));\r\n    return resolve(context, contextRawType, $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\r\n}",
    "indexOf": "{\r\n    for (int i \u003d 0, length \u003d array.length; i \u003c length; i++) {\r\n        if (toFind.equals(array[i])) {\r\n            return i;\r\n        }\r\n    }\r\n    throw new NoSuchElementException();\r\n}",
    "canonicalize": "{\r\n    if (type instanceof Class) {\r\n        Class\u003c?\u003e c \u003d (Class\u003c?\u003e) type;\r\n        return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType p \u003d (ParameterizedType) type;\r\n        return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments());\r\n    } else if (type instanceof GenericArrayType) {\r\n        GenericArrayType g \u003d (GenericArrayType) type;\r\n        return new GenericArrayTypeImpl(g.getGenericComponentType());\r\n    } else if (type instanceof WildcardType) {\r\n        WildcardType w \u003d (WildcardType) type;\r\n        return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\r\n    } else {\r\n        // type is either serializable as-is or unsupported\r\n        return type;\r\n    }\r\n}",
    "subtypeOf": "{\r\n    Type[] upperBounds;\r\n    if (bound instanceof WildcardType) {\r\n        upperBounds \u003d ((WildcardType) bound).getUpperBounds();\r\n    } else {\r\n        upperBounds \u003d new Type[] { bound };\r\n    }\r\n    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\r\n}",
    "arrayOf": "{\r\n    return new GenericArrayTypeImpl(componentType);\r\n}",
    "getLowerBounds": "{\r\n    return lowerBound !\u003d null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\r\n}",
    "newParameterizedTypeWithOwner": "{\r\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\r\n}",
    "getOwnerType": "{\r\n    return ownerType;\r\n}",
    "typeToString": "{\r\n    return type instanceof Class ? ((Class\u003c?\u003e) type).getName() : type.toString();\r\n}",
    "equal": "{\r\n    return Objects.equals(a, b);\r\n}",
    "declaringClassOf": "{\r\n    GenericDeclaration genericDeclaration \u003d typeVariable.getGenericDeclaration();\r\n    return genericDeclaration instanceof Class ? (Class\u003c?\u003e) genericDeclaration : null;\r\n}",
    "equals": "{\r\n    return other instanceof WildcardType \u0026\u0026 $Gson$Types.equals(this, (WildcardType) other);\r\n}",
    "toString": "{\r\n    if (lowerBound !\u003d null) {\r\n        return \"? super \" + typeToString(lowerBound);\r\n    } else if (upperBound \u003d\u003d Object.class) {\r\n        return \"?\";\r\n    } else {\r\n        return \"? extends \" + typeToString(upperBound);\r\n    }\r\n}",
    "getArrayComponentType": "{\r\n    return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class\u003c?\u003e) array).getComponentType();\r\n}",
    "resolveTypeVariable": "{\r\n    Class\u003c?\u003e declaredByRaw \u003d declaringClassOf(unknown);\r\n    // we can\u0027t reduce this further\r\n    if (declaredByRaw \u003d\u003d null) {\r\n        return unknown;\r\n    }\r\n    Type declaredBy \u003d getGenericSupertype(context, contextRawType, declaredByRaw);\r\n    if (declaredBy instanceof ParameterizedType) {\r\n        int index \u003d indexOf(declaredByRaw.getTypeParameters(), unknown);\r\n        return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\r\n    }\r\n    return unknown;\r\n}",
    "getUpperBounds": "{\r\n    return new Type[] { upperBound };\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\regression\\OSGiTest.java": {
    "testComGoogleGsonAnnotationsPackage": "{\r\n    Manifest mf \u003d findManifest(\"com.google.gson\");\r\n    String importPkg \u003d mf.getMainAttributes().getValue(\"Import-Package\");\r\n    assertWithMessage(\"Import-Package statement is there\").that(importPkg).isNotNull();\r\n    assertSubstring(\"There should be com.google.gson.annotations dependency\", importPkg, \"com.google.gson.annotations\");\r\n}",
    "findManifest": "{\r\n    List\u003cURL\u003e urls \u003d new ArrayList\u003c\u003e();\r\n    for (URL u : Collections.list(getClass().getClassLoader().getResources(\"META-INF/MANIFEST.MF\"))) {\r\n        InputStream is \u003d u.openStream();\r\n        Manifest mf \u003d new Manifest(is);\r\n        is.close();\r\n        if (pkg.equals(mf.getMainAttributes().getValue(\"Bundle-SymbolicName\"))) {\r\n            return mf;\r\n        }\r\n        urls.add(u);\r\n    }\r\n    fail(\"Cannot find \" + pkg + \" OSGi bundle manifest among: \" + urls);\r\n    return null;\r\n}",
    "assertSubstring": "{\r\n    if (wholeText.contains(subString)) {\r\n        return;\r\n    }\r\n    fail(msg + \". Expecting \" + subString + \" but was: \" + wholeText);\r\n}",
    "testSunMiscImportPackage": "{\r\n    Manifest mf \u003d findManifest(\"com.google.gson\");\r\n    String importPkg \u003d mf.getMainAttributes().getValue(\"Import-Package\");\r\n    assertWithMessage(\"Import-Package statement is there\").that(importPkg).isNotNull();\r\n    for (String dep : Splitter.on(\u0027,\u0027).split(importPkg)) {\r\n        if (dep.contains(\"sun.misc\")) {\r\n            assertSubstring(\"sun.misc import is optional\", dep, \"resolution:\u003doptional\");\r\n            return;\r\n        }\r\n    }\r\n    fail(\"There should be sun.misc dependency, but was: \" + importPkg);\r\n}"
  },
  "google_json\\graal-native-image-test\\src\\test\\java\\com\\google\\gson\\native_test\\Java17RecordReflectionTest.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\FormattingStyleTest.java": {
    "buildExpected": "{\r\n    String expected \u003d \"{\u003cEOL\u003e\u003cINDENT\u003e\\\"a\\\":\u003cCOLON_SPACE\u003e[\u003cEOL\u003e\u003cINDENT\u003e\u003cINDENT\u003e1,\u003cCOMMA_SPACE\u003e\u003cEOL\u003e\u003cINDENT\u003e\u003cINDENT\u003e2\u003cEOL\u003e\u003cINDENT\u003e]\u003cEOL\u003e}\";\r\n    String commaSpace \u003d spaceAfterSeparators \u0026\u0026 newline.isEmpty() ? \" \" : \"\";\r\n    return expected.replace(\"\u003cEOL\u003e\", newline).replace(\"\u003cINDENT\u003e\", indent).replace(\"\u003cCOLON_SPACE\u003e\", spaceAfterSeparators ? \" \" : \"\").replace(\"\u003cCOMMA_SPACE\u003e\", commaSpace);\r\n}",
    "createInput": "{\r\n    Map\u003cString, List\u003cInteger\u003e\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", Arrays.asList(1, 2));\r\n    return map;\r\n}",
    "testDefault": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    String json \u003d gson.toJson(createInput());\r\n    assertThat(json).isEqualTo(buildExpected(\"\\n\", \"  \", true));\r\n}",
    "toJson": "{\r\n    return new GsonBuilder().setFormattingStyle(style).create().toJson(obj);\r\n}",
    "testFormatPretty": "{\r\n    String json \u003d toJson(createInput(), FormattingStyle.PRETTY);\r\n    String expectedJson \u003d buildExpected(\"\\n\", \"  \", true);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Sanity check to verify that `buildExpected` works correctly\r\n    assertThat(json).isEqualTo(\"{\\n\" + \"  \\\"a\\\": [\\n\" + \"    1,\\n\" + \"    2\\n\" + \"  ]\\n\" + \"}\");\r\n}",
    "testFormatPrettySingleLine": "{\r\n    FormattingStyle style \u003d FormattingStyle.COMPACT.withSpaceAfterSeparators(true);\r\n    String json \u003d toJson(createInput(), style);\r\n    String expectedJson \u003d buildExpected(\"\", \"\", true);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Sanity check to verify that `buildExpected` works correctly\r\n    assertThat(json).isEqualTo(\"{\\\"a\\\": [1, 2]}\");\r\n}",
    "testCompactToPretty": "{\r\n    FormattingStyle style \u003d FormattingStyle.COMPACT.withNewline(\"\\n\").withIndent(\"  \").withSpaceAfterSeparators(true);\r\n    String json \u003d toJson(createInput(), style);\r\n    String expectedJson \u003d toJson(createInput(), FormattingStyle.PRETTY);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n}",
    "testVariousCombinationsParse": "{\r\n    // Mixing various indent and newline styles in the same string, to be parsed.\r\n    String jsonStringMix \u003d \"{\\r\\t\u0027a\u0027:\\r\\n[        1,2\\t]\\n}\";\r\n    TypeToken\u003cMap\u003cString, List\u003cInteger\u003e\u003e\u003e inputType \u003d new TypeToken\u003cMap\u003cString, List\u003cInteger\u003e\u003e\u003e() {\r\n    };\r\n    Map\u003cString, List\u003cInteger\u003e\u003e actualParsed;\r\n    // Test all that all combinations of newline can be parsed and generate the same INPUT.\r\n    for (String indent : TEST_INDENTS) {\r\n        for (String newline : TEST_NEWLINES) {\r\n            FormattingStyle style \u003d FormattingStyle.PRETTY.withNewline(newline).withIndent(indent);\r\n            Gson gson \u003d new GsonBuilder().setFormattingStyle(style).create();\r\n            String toParse \u003d buildExpected(newline, indent, true);\r\n            actualParsed \u003d gson.fromJson(toParse, inputType);\r\n            assertThat(actualParsed).isEqualTo(createInput());\r\n            // Parse the mixed string with the gson parsers configured with various newline / indents.\r\n            actualParsed \u003d gson.fromJson(jsonStringMix, inputType);\r\n            assertThat(actualParsed).isEqualTo(createInput());\r\n        }\r\n    }\r\n}",
    "testFormatCompact": "{\r\n    String json \u003d toJson(createInput(), FormattingStyle.COMPACT);\r\n    String expectedJson \u003d buildExpected(\"\", \"\", false);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Sanity check to verify that `buildExpected` works correctly\r\n    assertThat(json).isEqualTo(\"{\\\"a\\\":[1,2]}\");\r\n}",
    "testStyleValidations": "{\r\n    try {\r\n        // TBD if we want to accept \\u2028 and \\u2029. For now we don\u0027t because JSON specification\r\n        // does not consider them to be newlines\r\n        FormattingStyle.PRETTY.withNewline(\"\\u2028\");\r\n        fail(\"Gson should not accept anything but \\\\r and \\\\n for newline\");\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Only combinations of \\\\n and \\\\r are allowed in newline.\");\r\n    }\r\n    try {\r\n        FormattingStyle.PRETTY.withNewline(\"NL\");\r\n        fail(\"Gson should not accept anything but \\\\r and \\\\n for newline\");\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Only combinations of \\\\n and \\\\r are allowed in newline.\");\r\n    }\r\n    try {\r\n        FormattingStyle.PRETTY.withIndent(\"\\f\");\r\n        fail(\"Gson should not accept anything but space and tab for indent\");\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Only combinations of spaces and tabs are allowed in indent.\");\r\n    }\r\n}",
    "testFormat": "{\r\n    for (String newline : TEST_NEWLINES) {\r\n        for (String indent : TEST_INDENTS) {\r\n            for (boolean spaceAfterSeparators : new boolean[] { true, false }) {\r\n                FormattingStyle style \u003d FormattingStyle.COMPACT.withNewline(newline).withIndent(indent).withSpaceAfterSeparators(spaceAfterSeparators);\r\n                String json \u003d toJson(createInput(), style);\r\n                String expectedJson \u003d buildExpected(newline, indent, spaceAfterSeparators);\r\n                assertThat(json).isEqualTo(expectedJson);\r\n            }\r\n        }\r\n    }\r\n}",
    "testPrettyToCompact": "{\r\n    FormattingStyle style \u003d FormattingStyle.PRETTY.withNewline(\"\").withIndent(\"\").withSpaceAfterSeparators(false);\r\n    String json \u003d toJson(createInput(), style);\r\n    String expectedJson \u003d toJson(createInput(), FormattingStyle.COMPACT);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\RawSerializationTest.java": {
    "testParameterizedObject": "{\r\n    Bar\u003cFoo\u003e bar \u003d new Bar\u003c\u003e(new Foo(1));\r\n    String expectedJson \u003d \"{\\\"t\\\":{\\\"b\\\":1}}\";\r\n    // Ensure that serialization works without specifying the type explicitly\r\n    String json \u003d gson.toJson(bar);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Ensure that serialization also works when the type is specified explicitly\r\n    json \u003d gson.toJson(bar, new TypeToken\u003cBar\u003cFoo\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(json).isEqualTo(expectedJson);\r\n}",
    "testCollectionOfObjects": "{\r\n    Collection\u003cFoo\u003e foos \u003d Arrays.asList(new Foo(1), new Foo(2));\r\n    String json \u003d gson.toJson(foos);\r\n    assertThat(json).isEqualTo(\"[{\\\"b\\\":1},{\\\"b\\\":2}]\");\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testThreeLevelParameterizedObject": "{\r\n    Bar\u003cBar\u003cBar\u003cFoo\u003e\u003e\u003e bar \u003d new Bar\u003c\u003e(new Bar\u003c\u003e(new Bar\u003c\u003e(new Foo(1))));\r\n    String expectedJson \u003d \"{\\\"t\\\":{\\\"t\\\":{\\\"t\\\":{\\\"b\\\":1}}}}\";\r\n    // Ensure that serialization works without specifying the type explicitly\r\n    String json \u003d gson.toJson(bar);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Ensure that serialization also works when the type is specified explicitly\r\n    json \u003d gson.toJson(bar, new TypeToken\u003cBar\u003cBar\u003cBar\u003cFoo\u003e\u003e\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(json).isEqualTo(expectedJson);\r\n}",
    "testCollectionOfPrimitives": "{\r\n    Collection\u003cInteger\u003e ints \u003d Arrays.asList(1, 2, 3, 4, 5);\r\n    String json \u003d gson.toJson(ints);\r\n    assertThat(json).isEqualTo(\"[1,2,3,4,5]\");\r\n}",
    "testTwoLevelParameterizedObject": "{\r\n    Bar\u003cBar\u003cFoo\u003e\u003e bar \u003d new Bar\u003c\u003e(new Bar\u003c\u003e(new Foo(1)));\r\n    String expectedJson \u003d \"{\\\"t\\\":{\\\"t\\\":{\\\"b\\\":1}}}\";\r\n    // Ensure that serialization works without specifying the type explicitly\r\n    String json \u003d gson.toJson(bar);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Ensure that serialization also works when the type is specified explicitly\r\n    json \u003d gson.toJson(bar, new TypeToken\u003cBar\u003cBar\u003cFoo\u003e\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(json).isEqualTo(expectedJson);\r\n}"
  },
  "google_json\\proto\\src\\test\\java\\com\\google\\gson\\protobuf\\functional\\ProtosWithPrimitiveTypesTest.java": {
    "testDeserializeWithExplicitNullValue": "{\r\n    SimpleProto proto \u003d gson.fromJson(\"{msg:\u0027foo\u0027,count:null}\", SimpleProto.class);\r\n    assertEquals(\"foo\", proto.getMsg());\r\n    assertEquals(0, proto.getCount());\r\n}",
    "testDeserializeEmptyProto": "{\r\n    SimpleProto proto \u003d gson.fromJson(\"{}\", SimpleProto.class);\r\n    assertFalse(proto.hasCount());\r\n    assertFalse(proto.hasMsg());\r\n}",
    "testSerializeEmptyProto": "{\r\n    SimpleProto proto \u003d SimpleProto.newBuilder().build();\r\n    String json \u003d gson.toJson(proto);\r\n    assertEquals(\"{}\", json);\r\n}",
    "setUp": "{\r\n    gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, ProtoTypeAdapter.newBuilder().setEnumSerialization(EnumSerialization.NUMBER).build()).create();\r\n}",
    "testSerializeProto": "{\r\n    SimpleProto proto \u003d SimpleProto.newBuilder().setCount(3).setMsg(\"foo\").build();\r\n    String json \u003d gson.toJson(proto);\r\n    assertTrue(json.contains(\"\\\"msg\\\":\\\"foo\\\"\"));\r\n    assertTrue(json.contains(\"\\\"count\\\":3\"));\r\n}",
    "testDeserializeProto": "{\r\n    SimpleProto proto \u003d gson.fromJson(\"{msg:\u0027foo\u0027,count:3}\", SimpleProto.class);\r\n    assertEquals(\"foo\", proto.getMsg());\r\n    assertEquals(3, proto.getCount());\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\UncategorizedTest.java": {
    "testTrailingWhitespace": "{\r\n    List\u003cInteger\u003e integers \u003d gson.fromJson(\"[1,2,3]  \\n\\n  \", new TypeToken\u003cList\u003cInteger\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(integers).containsExactly(1, 2, 3).inOrder();\r\n}",
    "testInvalidJsonDeserializationFails": "{\r\n    try {\r\n        gson.fromJson(\"adfasdf1112,,,\\\":\", BagOfPrimitives.class);\r\n        fail(\"Bad JSON should throw a ParseException\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n    try {\r\n        gson.fromJson(\"{adfasdf1112,,,\\\":}\", BagOfPrimitives.class);\r\n        fail(\"Bad JSON should throw a ParseException\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testGsonInstanceReusableForSerializationAndDeserialization": "{\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n    String json \u003d gson.toJson(bag);\r\n    BagOfPrimitives deserialized \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(deserialized).isEqualTo(bag);\r\n}",
    "testStaticFieldsAreNotSerialized": "{\r\n    BagOfPrimitives target \u003d new BagOfPrimitives();\r\n    assertThat(gson.toJson(target)).doesNotContain(\"DEFAULT_VALUE\");\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testObjectEqualButNotSameSerialization": "{\r\n    ClassOverridingEquals objA \u003d new ClassOverridingEquals();\r\n    ClassOverridingEquals objB \u003d new ClassOverridingEquals();\r\n    objB.ref \u003d objA;\r\n    String json \u003d gson.toJson(objB);\r\n    assertThat(json).isEqualTo(objB.getExpectedJson());\r\n}",
    "testReturningDerivedClassesDuringDeserialization": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new BaseTypeAdapter()).create();\r\n    String json \u003d \"{\\\"opType\\\":\\\"OP1\\\"}\";\r\n    Base base \u003d gson.fromJson(json, Base.class);\r\n    assertThat(base).isInstanceOf(Derived1.class);\r\n    assertThat(base.opType).isEqualTo(OperationType.OP1);\r\n    json \u003d \"{\\\"opType\\\":\\\"OP2\\\"}\";\r\n    base \u003d gson.fromJson(json, Base.class);\r\n    assertThat(base).isInstanceOf(Derived2.class);\r\n    assertThat(base.opType).isEqualTo(OperationType.OP2);\r\n}",
    "deserialize": "{\r\n    String opTypeStr \u003d json.getAsJsonObject().get(\"opType\").getAsString();\r\n    OperationType opType \u003d OperationType.valueOf(opTypeStr);\r\n    switch(opType) {\r\n        case OP1:\r\n            return new Derived1();\r\n        case OP2:\r\n            return new Derived2();\r\n    }\r\n    throw new JsonParseException(\"unknown type: \" + json);\r\n}"
  },
  "google_json\\extras\\src\\test\\java\\com\\google\\gson\\interceptors\\InterceptorTest.java": {
    "testList": "{\r\n    List\u003cUser\u003e list \u003d gson.fromJson(\"[{name:\u0027bob\u0027,password:\u0027pwd\u0027}]\", new TypeToken\u003cList\u003cUser\u003e\u003e() {\r\n    }.getType());\r\n    User user \u003d list.get(0);\r\n    assertEquals(User.DEFAULT_EMAIL, user.email);\r\n}",
    "postDeserialize": "{\r\n    if (address.city \u003d\u003d null || address.state \u003d\u003d null || address.zip \u003d\u003d null) {\r\n        throw new JsonSyntaxException(\"Address city, state and zip are required fields.\");\r\n    }\r\n    if (address.firstLine \u003d\u003d null)\r\n        address.firstLine \u003d Address.DEFAULT_FIRST_LINE;\r\n}",
    "testExceptionsPropagated": "{\r\n    try {\r\n        gson.fromJson(\"{}\", User.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "read": "{\r\n    in.beginObject();\r\n    String unused1 \u003d in.nextName();\r\n    String name \u003d in.nextString();\r\n    String unused2 \u003d in.nextName();\r\n    String password \u003d in.nextString();\r\n    in.endObject();\r\n    return new User(name, password);\r\n}",
    "testTopLevelClass": "{\r\n    User user \u003d gson.fromJson(\"{name:\u0027bob\u0027,password:\u0027pwd\u0027}\", User.class);\r\n    assertEquals(User.DEFAULT_EMAIL, user.email);\r\n}",
    "testCollection": "{\r\n    Collection\u003cUser\u003e list \u003d gson.fromJson(\"[{name:\u0027bob\u0027,password:\u0027pwd\u0027}]\", new TypeToken\u003cCollection\u003cUser\u003e\u003e() {\r\n    }.getType());\r\n    User user \u003d list.iterator().next();\r\n    assertEquals(User.DEFAULT_EMAIL, user.email);\r\n}",
    "testMapKeyAndValues": "{\r\n    Type mapType \u003d new TypeToken\u003cMap\u003cUser, Address\u003e\u003e() {\r\n    }.getType();\r\n    try {\r\n        gson.fromJson(\"[[{name:\u0027bob\u0027,password:\u0027pwd\u0027},{}]]\", mapType);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n    Map\u003cUser, Address\u003e map \u003d gson.fromJson(\"[[{name:\u0027bob\u0027,password:\u0027pwd\u0027},{city:\u0027Mountain View\u0027,state:\u0027CA\u0027,zip:\u002794043\u0027}]]\", mapType);\r\n    Entry\u003cUser, Address\u003e entry \u003d map.entrySet().iterator().next();\r\n    assertEquals(User.DEFAULT_EMAIL, entry.getKey().email);\r\n    assertEquals(Address.DEFAULT_FIRST_LINE, entry.getValue().firstLine);\r\n}",
    "testDirectInvocationOfTypeAdapter": "{\r\n    TypeAdapter\u003cUserGroup\u003e adapter \u003d gson.getAdapter(UserGroup.class);\r\n    UserGroup userGroup \u003d adapter.fromJson(\"{\\\"user\\\":{\\\"name\\\":\\\"bob\\\",\\\"password\\\":\\\"pwd\\\"}}\");\r\n    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\r\n}",
    "setUp": "{\r\n    this.gson \u003d new GsonBuilder().registerTypeAdapterFactory(new InterceptorFactory()).enableComplexMapKeySerialization().create();\r\n}",
    "testField": "{\r\n    UserGroup userGroup \u003d gson.fromJson(\"{user:{name:\u0027bob\u0027,password:\u0027pwd\u0027}}\", UserGroup.class);\r\n    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\r\n}",
    "write": "{\r\n    throw new UnsupportedOperationException();\r\n}",
    "testCustomTypeAdapter": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(User.class, new TypeAdapter\u003cUser\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, User value) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public User read(JsonReader in) throws IOException {\r\n            in.beginObject();\r\n            String unused1 \u003d in.nextName();\r\n            String name \u003d in.nextString();\r\n            String unused2 \u003d in.nextName();\r\n            String password \u003d in.nextString();\r\n            in.endObject();\r\n            return new User(name, password);\r\n        }\r\n    }).registerTypeAdapterFactory(new InterceptorFactory()).create();\r\n    UserGroup userGroup \u003d gson.fromJson(\"{user:{name:\u0027bob\u0027,password:\u0027pwd\u0027}}\", UserGroup.class);\r\n    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java": {
    "addType": "{\r\n    if (type \u003d\u003d null || instanceCreator \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    instanceCreators.put(type, instanceCreator);\r\n    return this;\r\n}",
    "createInstance": "{\r\n    Graph graph \u003d graphThreadLocal.get();\r\n    if (graph \u003d\u003d null || graph.nextCreate \u003d\u003d null) {\r\n        throw new IllegalStateException(\"Unexpected call to createInstance() for \" + type);\r\n    }\r\n    InstanceCreator\u003c?\u003e creator \u003d instanceCreators.get(type);\r\n    Object result \u003d creator.createInstance(type);\r\n    graph.nextCreate.value \u003d result;\r\n    graph.nextCreate \u003d null;\r\n    return result;\r\n}",
    "read": "{\r\n    if (graph.nextCreate !\u003d null) {\r\n        throw new IllegalStateException(\"Unexpected recursive call to read() for \" + id);\r\n    }\r\n    graph.nextCreate \u003d (Element\u003cObject\u003e) this;\r\n    value \u003d typeAdapter.fromJsonTree(element);\r\n    if (value \u003d\u003d null) {\r\n        throw new IllegalStateException(\"non-null value deserialized to null: \" + element);\r\n    }\r\n}",
    "registerOn": "{\r\n    Factory factory \u003d new Factory(instanceCreators);\r\n    gsonBuilder.registerTypeAdapterFactory(factory);\r\n    for (Map.Entry\u003cType, InstanceCreator\u003c?\u003e\u003e entry : instanceCreators.entrySet()) {\r\n        gsonBuilder.registerTypeAdapter(entry.getKey(), factory);\r\n    }\r\n}",
    "create": "{\r\n    if (!instanceCreators.containsKey(type.getType())) {\r\n        return null;\r\n    }\r\n    final TypeAdapter\u003cT\u003e typeAdapter \u003d gson.getDelegateAdapter(this, type);\r\n    final TypeAdapter\u003cJsonElement\u003e elementAdapter \u003d gson.getAdapter(JsonElement.class);\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            Graph graph \u003d graphThreadLocal.get();\r\n            boolean writeEntireGraph \u003d false;\r\n            /*\r\n           * We have one of two cases:\r\n           *  1. We\u0027ve encountered the first known object in this graph. Write\r\n           *     out the graph, starting with that object.\r\n           *  2. We\u0027ve encountered another graph object in the course of #1.\r\n           *     Just write out this object\u0027s name. We\u0027ll circle back to writing\r\n           *     out the object\u0027s value as a part of #1.\r\n           */\r\n            if (graph \u003d\u003d null) {\r\n                writeEntireGraph \u003d true;\r\n                graph \u003d new Graph(new IdentityHashMap\u003cObject, Element\u003c?\u003e\u003e());\r\n            }\r\n            // graph.map guarantees consistency between value and T\r\n            @SuppressWarnings(\"unchecked\")\r\n            Element\u003cT\u003e element \u003d (Element\u003cT\u003e) graph.map.get(value);\r\n            if (element \u003d\u003d null) {\r\n                element \u003d new Element\u003c\u003e(value, graph.nextName(), typeAdapter, null);\r\n                graph.map.put(value, element);\r\n                graph.queue.add(element);\r\n            }\r\n            if (writeEntireGraph) {\r\n                graphThreadLocal.set(graph);\r\n                try {\r\n                    out.beginObject();\r\n                    Element\u003c?\u003e current;\r\n                    while ((current \u003d graph.queue.poll()) !\u003d null) {\r\n                        out.name(current.id);\r\n                        current.write(out);\r\n                    }\r\n                    out.endObject();\r\n                } finally {\r\n                    graphThreadLocal.remove();\r\n                }\r\n            } else {\r\n                out.value(element.id);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            /*\r\n           * Again we have one of two cases:\r\n           *  1. We\u0027ve encountered the first known object in this graph. Read\r\n           *     the entire graph in as a map from names to their JsonElements.\r\n           *     Then convert the first JsonElement to its Java object.\r\n           *  2. We\u0027ve encountered another graph object in the course of #1.\r\n           *     Read in its name, then deserialize its value from the\r\n           *     JsonElement in our map. We need to do this lazily because we\r\n           *     don\u0027t know which TypeAdapter to use until a value is\r\n           *     encountered in the wild.\r\n           */\r\n            String currentName \u003d null;\r\n            Graph graph \u003d graphThreadLocal.get();\r\n            boolean readEntireGraph \u003d false;\r\n            if (graph \u003d\u003d null) {\r\n                graph \u003d new Graph(new HashMap\u003cObject, Element\u003c?\u003e\u003e());\r\n                readEntireGraph \u003d true;\r\n                // read the entire tree into memory\r\n                in.beginObject();\r\n                while (in.hasNext()) {\r\n                    String name \u003d in.nextName();\r\n                    if (currentName \u003d\u003d null) {\r\n                        currentName \u003d name;\r\n                    }\r\n                    JsonElement element \u003d elementAdapter.read(in);\r\n                    graph.map.put(name, new Element\u003c\u003e(null, name, typeAdapter, element));\r\n                }\r\n                in.endObject();\r\n            } else {\r\n                currentName \u003d in.nextString();\r\n            }\r\n            if (readEntireGraph) {\r\n                graphThreadLocal.set(graph);\r\n            }\r\n            try {\r\n                // graph.map guarantees consistency between value and T\r\n                @SuppressWarnings(\"unchecked\")\r\n                Element\u003cT\u003e element \u003d (Element\u003cT\u003e) graph.map.get(currentName);\r\n                // now that we know the typeAdapter for this name, go from JsonElement to \u0027T\u0027\r\n                if (element.value \u003d\u003d null) {\r\n                    element.typeAdapter \u003d typeAdapter;\r\n                    element.read(graph);\r\n                }\r\n                return element.value;\r\n            } finally {\r\n                if (readEntireGraph) {\r\n                    graphThreadLocal.remove();\r\n                }\r\n            }\r\n        }\r\n    };\r\n}",
    "write": "{\r\n    typeAdapter.write(out, value);\r\n}",
    "nextName": "{\r\n    return \"0x\" + Integer.toHexString(map.size() + 1);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\sql\\SqlDateTypeAdapter.java": {
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String s \u003d in.nextString();\r\n    try {\r\n        Date utilDate;\r\n        synchronized (this) {\r\n            utilDate \u003d format.parse(s);\r\n        }\r\n        return new java.sql.Date(utilDate.getTime());\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as SQL Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "create": "{\r\n    return typeToken.getRawType() \u003d\u003d java.sql.Date.class ? (TypeAdapter\u003cT\u003e) new SqlDateTypeAdapter() : null;\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    String dateString;\r\n    synchronized (this) {\r\n        dateString \u003d format.format(value);\r\n    }\r\n    out.value(dateString);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReadersWritersTest.java": {
    "testTopLevelNullObjectSerializationWithWriter": "{\r\n    StringWriter writer \u003d new StringWriter();\r\n    gson.toJson(null, writer);\r\n    assertThat(writer.toString()).isEqualTo(\"null\");\r\n}",
    "testTopLevelNullObjectDeserializationWithReader": "{\r\n    StringReader reader \u003d new StringReader(\"null\");\r\n    Integer nullIntObject \u003d gson.fromJson(reader, Integer.class);\r\n    assertThat(nullIntObject).isNull();\r\n}",
    "testReadWriteTwoStrings": "{\r\n    Gson gson \u003d new Gson();\r\n    CharArrayWriter writer \u003d new CharArrayWriter();\r\n    writer.write(gson.toJson(\"one\").toCharArray());\r\n    writer.write(gson.toJson(\"two\").toCharArray());\r\n    CharArrayReader reader \u003d new CharArrayReader(writer.toCharArray());\r\n    JsonStreamParser parser \u003d new JsonStreamParser(reader);\r\n    String actualOne \u003d gson.fromJson(parser.next(), String.class);\r\n    assertThat(actualOne).isEqualTo(\"one\");\r\n    String actualTwo \u003d gson.fromJson(parser.next(), String.class);\r\n    assertThat(actualTwo).isEqualTo(\"two\");\r\n}",
    "testToJsonAppendable": "{\r\n    class CustomAppendable implements Appendable {\r\n\r\n        final StringBuilder stringBuilder \u003d new StringBuilder();\r\n\r\n        int toStringCallCount \u003d 0;\r\n\r\n        @CanIgnoreReturnValue\r\n        @Override\r\n        public Appendable append(char c) throws IOException {\r\n            stringBuilder.append(c);\r\n            return this;\r\n        }\r\n\r\n        @CanIgnoreReturnValue\r\n        @Override\r\n        public Appendable append(CharSequence csq) throws IOException {\r\n            if (csq \u003d\u003d null) {\r\n                // Requirement by Writer.append\r\n                csq \u003d \"null\";\r\n            }\r\n            append(csq, 0, csq.length());\r\n            return this;\r\n        }\r\n\r\n        @CanIgnoreReturnValue\r\n        @Override\r\n        public Appendable append(CharSequence csq, int start, int end) throws IOException {\r\n            if (csq \u003d\u003d null) {\r\n                // Requirement by Writer.append\r\n                csq \u003d \"null\";\r\n            }\r\n            // According to doc, toString() must return string representation\r\n            String s \u003d csq.toString();\r\n            toStringCallCount++;\r\n            stringBuilder.append(s, start, end);\r\n            return this;\r\n        }\r\n    }\r\n    CustomAppendable appendable \u003d new CustomAppendable();\r\n    gson.toJson(Arrays.asList(\"test\", 123, true), appendable);\r\n    // Make sure CharSequence.toString() was called at least two times to verify that\r\n    // CurrentWrite.cachedString is properly overwritten when char array changes\r\n    assertThat(appendable.toStringCallCount \u003e\u003d 2).isTrue();\r\n    assertThat(appendable.stringBuilder.toString()).isEqualTo(\"[\\\"test\\\",123,true]\");\r\n}",
    "testReaderForDeserialization": "{\r\n    BagOfPrimitives expected \u003d new BagOfPrimitives();\r\n    Reader json \u003d new StringReader(expected.getExpectedJson());\r\n    BagOfPrimitives actual \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testTopLevelNullObjectDeserializationWithReaderAndSerializeNulls": "{\r\n    Gson gson \u003d new GsonBuilder().serializeNulls().create();\r\n    StringReader reader \u003d new StringReader(\"null\");\r\n    Integer nullIntObject \u003d gson.fromJson(reader, Integer.class);\r\n    assertThat(nullIntObject).isNull();\r\n}",
    "testTopLevelNullObjectSerializationWithWriterAndSerializeNulls": "{\r\n    Gson gson \u003d new GsonBuilder().serializeNulls().create();\r\n    StringWriter writer \u003d new StringWriter();\r\n    gson.toJson(null, writer);\r\n    assertThat(writer.toString()).isEqualTo(\"null\");\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testWriterForSerialization": "{\r\n    Writer writer \u003d new StringWriter();\r\n    BagOfPrimitives src \u003d new BagOfPrimitives();\r\n    gson.toJson(src, writer);\r\n    assertThat(writer.toString()).isEqualTo(src.getExpectedJson());\r\n}",
    "testReadWriteTwoObjects": "{\r\n    Gson gson \u003d new Gson();\r\n    CharArrayWriter writer \u003d new CharArrayWriter();\r\n    BagOfPrimitives expectedOne \u003d new BagOfPrimitives(1, 1, true, \"one\");\r\n    writer.write(gson.toJson(expectedOne).toCharArray());\r\n    BagOfPrimitives expectedTwo \u003d new BagOfPrimitives(2, 2, false, \"two\");\r\n    writer.write(gson.toJson(expectedTwo).toCharArray());\r\n    CharArrayReader reader \u003d new CharArrayReader(writer.toCharArray());\r\n    JsonStreamParser parser \u003d new JsonStreamParser(reader);\r\n    BagOfPrimitives actualOne \u003d gson.fromJson(parser.next(), BagOfPrimitives.class);\r\n    assertThat(actualOne.stringValue).isEqualTo(\"one\");\r\n    BagOfPrimitives actualTwo \u003d gson.fromJson(parser.next(), BagOfPrimitives.class);\r\n    assertThat(actualTwo.stringValue).isEqualTo(\"two\");\r\n    assertThat(parser.hasNext()).isFalse();\r\n}",
    "testTypeMismatchThrowsJsonSyntaxExceptionForStrings": "{\r\n    try {\r\n        gson.fromJson(\"true\", new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "testTypeMismatchThrowsJsonSyntaxExceptionForReaders": "{\r\n    try {\r\n        gson.fromJson(new StringReader(\"true\"), new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "append": "{\r\n    if (csq \u003d\u003d null) {\r\n        // Requirement by Writer.append\r\n        csq \u003d \"null\";\r\n    }\r\n    // According to doc, toString() must return string representation\r\n    String s \u003d csq.toString();\r\n    toStringCallCount++;\r\n    stringBuilder.append(s, start, end);\r\n    return this;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\DefaultTypeAdaptersTest.java": {
    "testDefaultDateSerialization": "{\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    assertThat(json).matches(\"\\\"Sep 11, 2011,? 10:55:03\\\\hPM\\\"\");\r\n}",
    "testStringBuilderDeserialization": "{\r\n    StringBuilder sb \u003d gson.fromJson(\"\u0027abc\u0027\", StringBuilder.class);\r\n    assertThat(sb.toString()).isEqualTo(\"abc\");\r\n}",
    "testOverrideBigDecimalTypeAdapter": "{\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(BigDecimal.class, new NumberAsStringAdapter(BigDecimal.class)).create();\r\n    assertThat(gson.toJson(new BigDecimal(\"1.1\"), BigDecimal.class)).isEqualTo(\"\\\"1.1\\\"\");\r\n    assertThat(gson.fromJson(\"\\\"1.1\\\"\", BigDecimal.class)).isEqualTo(new BigDecimal(\"1.1\"));\r\n}",
    "testJsonPrimitiveDeserialization": "{\r\n    assertThat(gson.fromJson(\"5\", JsonElement.class)).isEqualTo(new JsonPrimitive(5));\r\n    assertThat(gson.fromJson(\"5\", JsonPrimitive.class)).isEqualTo(new JsonPrimitive(5));\r\n    assertThat(gson.fromJson(\"true\", JsonElement.class)).isEqualTo(new JsonPrimitive(true));\r\n    assertThat(gson.fromJson(\"true\", JsonPrimitive.class)).isEqualTo(new JsonPrimitive(true));\r\n    assertThat(gson.fromJson(\"\\\"foo\\\"\", JsonElement.class)).isEqualTo(new JsonPrimitive(\"foo\"));\r\n    assertThat(gson.fromJson(\"\\\"foo\\\"\", JsonPrimitive.class)).isEqualTo(new JsonPrimitive(\"foo\"));\r\n    assertThat(gson.fromJson(\"\\\"a\\\"\", JsonElement.class)).isEqualTo(new JsonPrimitive(\u0027a\u0027));\r\n    assertThat(gson.fromJson(\"\\\"a\\\"\", JsonPrimitive.class)).isEqualTo(new JsonPrimitive(\u0027a\u0027));\r\n}",
    "testBadValueForBigDecimalDeserialization": "{\r\n    try {\r\n        gson.fromJson(\"{\\\"value\\\"\u003d1.5e-1.0031}\", ClassWithBigDecimal.class);\r\n        fail(\"Exponent of a BigDecimal must be an integer value.\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testDateSerializationInCollection": "{\r\n    Type listOfDates \u003d new TypeToken\u003cList\u003cDate\u003e\u003e() {\r\n    }.getType();\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    try {\r\n        Gson gson \u003d new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create();\r\n        List\u003cDate\u003e dates \u003d Arrays.asList(new Date(0));\r\n        String json \u003d gson.toJson(dates, listOfDates);\r\n        assertThat(json).isEqualTo(\"[\\\"1970-01-01\\\"]\");\r\n        assertThat(gson.\u003cList\u003cDate\u003e\u003efromJson(\"[\\\"1970-01-01\\\"]\", listOfDates).get(0).getTime()).isEqualTo(0L);\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "testLocaleDeserializationWithLanguageCountry": "{\r\n    String json \u003d \"\\\"fr_CA\\\"\";\r\n    Locale locale \u003d gson.fromJson(json, Locale.class);\r\n    assertThat(locale).isEqualTo(Locale.CANADA_FRENCH);\r\n}",
    "testDateSerializationWithPattern": "{\r\n    String pattern \u003d \"yyyy-MM-dd\";\r\n    Gson gson \u003d new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    assertThat(json).isEqualTo(\"\\\"2011-09-11\\\"\");\r\n}",
    "testLocaleSerializationWithLanguageCountryVariant": "{\r\n    Locale target \u003d new Locale(\"de\", \"DE\", \"EURO\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"\\\"de_DE_EURO\\\"\");\r\n}",
    "testUrlDeserialization": "{\r\n    String urlValue \u003d \"http://google.com/\";\r\n    String json \u003d \"\u0027http:\\\\/\\\\/google.com\\\\/\u0027\";\r\n    URL target1 \u003d gson.fromJson(json, URL.class);\r\n    assertThat(target1.toExternalForm()).isEqualTo(urlValue);\r\n    URL target2 \u003d gson.fromJson(\u0027\"\u0027 + urlValue + \u0027\"\u0027, URL.class);\r\n    assertThat(target2.toExternalForm()).isEqualTo(urlValue);\r\n}",
    "testBigDecimalFieldSerialization": "{\r\n    ClassWithBigDecimal target \u003d new ClassWithBigDecimal(\"-122.01e-21\");\r\n    String json \u003d gson.toJson(target);\r\n    String actual \u003d json.substring(json.indexOf(\u0027:\u0027) + 1, json.indexOf(\u0027}\u0027));\r\n    assertThat(new BigDecimal(actual)).isEqualTo(target.value);\r\n}",
    "testUuidDeserialization": "{\r\n    String uuidValue \u003d \"c237bec1-19ef-4858-a98e-521cf0aad4c0\";\r\n    String json \u003d \u0027\"\u0027 + uuidValue + \u0027\"\u0027;\r\n    UUID target \u003d gson.fromJson(json, UUID.class);\r\n    assertThat(target.toString()).isEqualTo(uuidValue);\r\n}",
    "testUrlSerialization": "{\r\n    String urlValue \u003d \"http://google.com/\";\r\n    URL url \u003d new URL(urlValue);\r\n    assertThat(gson.toJson(url)).isEqualTo(\"\\\"http://google.com/\\\"\");\r\n}",
    "testBitSetSerialization": "{\r\n    Gson gson \u003d new Gson();\r\n    BitSet bits \u003d new BitSet();\r\n    bits.set(1);\r\n    bits.set(3, 6);\r\n    bits.set(9);\r\n    String json \u003d gson.toJson(bits);\r\n    assertThat(json).isEqualTo(\"[0,1,0,1,1,1,0,0,0,1]\");\r\n}",
    "testJsonObjectSerialization": "{\r\n    JsonObject object \u003d new JsonObject();\r\n    object.add(\"foo\", new JsonPrimitive(1));\r\n    object.add(\"bar\", new JsonPrimitive(2));\r\n    assertThat(gson.toJson(object, JsonElement.class)).isEqualTo(\"{\\\"foo\\\":1,\\\"bar\\\":2}\");\r\n}",
    "setUp": "{\r\n    this.oldTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"));\r\n    this.oldLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    gson \u003d new Gson();\r\n}",
    "testLocaleDeserializationWithLanguage": "{\r\n    String json \u003d \"\\\"en\\\"\";\r\n    Locale locale \u003d gson.fromJson(json, Locale.class);\r\n    assertThat(locale.getLanguage()).isEqualTo(\"en\");\r\n}",
    "testUuidSerialization": "{\r\n    String uuidValue \u003d \"c237bec1-19ef-4858-a98e-521cf0aad4c0\";\r\n    UUID uuid \u003d UUID.fromString(uuidValue);\r\n    assertThat(gson.toJson(uuid)).isEqualTo(\u0027\"\u0027 + uuidValue + \u0027\"\u0027);\r\n}",
    "testJsonArrayDeserialization": "{\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(new JsonPrimitive(1));\r\n    array.add(new JsonPrimitive(2));\r\n    array.add(new JsonPrimitive(3));\r\n    String json \u003d \"[1,2,3]\";\r\n    assertThat(gson.fromJson(json, JsonElement.class)).isEqualTo(array);\r\n    assertThat(gson.fromJson(json, JsonArray.class)).isEqualTo(array);\r\n}",
    "write": "{\r\n    out.value(value.toString());\r\n}",
    "testLocaleSerializationWithLanguage": "{\r\n    Locale target \u003d new Locale(\"en\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"\\\"en\\\"\");\r\n}",
    "testDefaultCalendarSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    String json \u003d gson.toJson(Calendar.getInstance());\r\n    assertThat(json).contains(\"year\");\r\n    assertThat(json).contains(\"month\");\r\n    assertThat(json).contains(\"dayOfMonth\");\r\n    assertThat(json).contains(\"hourOfDay\");\r\n    assertThat(json).contains(\"minute\");\r\n    assertThat(json).contains(\"second\");\r\n}",
    "testOverrideBigIntegerTypeAdapter": "{\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(BigInteger.class, new NumberAsStringAdapter(BigInteger.class)).create();\r\n    assertThat(gson.toJson(new BigInteger(\"123\"), BigInteger.class)).isEqualTo(\"\\\"123\\\"\");\r\n    assertThat(gson.fromJson(\"\\\"123\\\"\", BigInteger.class)).isEqualTo(new BigInteger(\"123\"));\r\n}",
    "testJsonPrimitiveSerialization": "{\r\n    assertThat(gson.toJson(new JsonPrimitive(5), JsonElement.class)).isEqualTo(\"5\");\r\n    assertThat(gson.toJson(new JsonPrimitive(true), JsonElement.class)).isEqualTo(\"true\");\r\n    assertThat(gson.toJson(new JsonPrimitive(\"foo\"), JsonElement.class)).isEqualTo(\"\\\"foo\\\"\");\r\n    assertThat(gson.toJson(new JsonPrimitive(\u0027a\u0027), JsonElement.class)).isEqualTo(\"\\\"a\\\"\");\r\n}",
    "read": "{\r\n    try {\r\n        return constructor.newInstance(in.nextString());\r\n    } catch (Exception e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}",
    "testDefaultDateSerializationUsingBuilder": "{\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    assertThat(json).matches(\"\\\"Sep 11, 2011,? 10:55:03\\\\hPM\\\"\");\r\n}",
    "testJsonNullSerialization": "{\r\n    assertThat(gson.toJson(JsonNull.INSTANCE, JsonElement.class)).isEqualTo(\"null\");\r\n    assertThat(gson.toJson(JsonNull.INSTANCE, JsonNull.class)).isEqualTo(\"null\");\r\n}",
    "testDefaultGregorianCalendarSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    GregorianCalendar cal \u003d new GregorianCalendar();\r\n    String json \u003d gson.toJson(cal);\r\n    assertThat(json).contains(\"year\");\r\n    assertThat(json).contains(\"month\");\r\n    assertThat(json).contains(\"dayOfMonth\");\r\n    assertThat(json).contains(\"hourOfDay\");\r\n    assertThat(json).contains(\"minute\");\r\n    assertThat(json).contains(\"second\");\r\n}",
    "testBigDecimalFieldDeserialization": "{\r\n    ClassWithBigDecimal expected \u003d new ClassWithBigDecimal(\"-122.01e-21\");\r\n    String json \u003d expected.getExpectedJson();\r\n    ClassWithBigDecimal actual \u003d gson.fromJson(json, ClassWithBigDecimal.class);\r\n    assertThat(actual.value).isEqualTo(expected.value);\r\n}",
    "testLocaleDeserializationWithLanguageCountryVariant": "{\r\n    String json \u003d \"\\\"de_DE_EURO\\\"\";\r\n    Locale locale \u003d gson.fromJson(json, Locale.class);\r\n    assertThat(locale.getLanguage()).isEqualTo(\"de\");\r\n    assertThat(locale.getCountry()).isEqualTo(\"DE\");\r\n    assertThat(locale.getVariant()).isEqualTo(\"EURO\");\r\n}",
    "testTreeSetSerialization": "{\r\n    TreeSet\u003cString\u003e treeSet \u003d new TreeSet\u003c\u003e();\r\n    treeSet.add(\"Value1\");\r\n    String json \u003d gson.toJson(treeSet);\r\n    assertThat(json).isEqualTo(\"[\\\"Value1\\\"]\");\r\n}",
    "testStringBuilderSerialization": "{\r\n    StringBuilder sb \u003d new StringBuilder(\"abc\");\r\n    String json \u003d gson.toJson(sb);\r\n    assertThat(json).isEqualTo(\"\\\"abc\\\"\");\r\n}",
    "testJsonNullDeserialization": "{\r\n    assertThat(gson.fromJson(\"null\", JsonElement.class)).isEqualTo(JsonNull.INSTANCE);\r\n    assertThat(gson.fromJson(\"null\", JsonNull.class)).isEqualTo(JsonNull.INSTANCE);\r\n}",
    "testUriDeserialization": "{\r\n    String uriValue \u003d \"http://google.com/\";\r\n    String json \u003d \u0027\"\u0027 + uriValue + \u0027\"\u0027;\r\n    URI target \u003d gson.fromJson(json, URI.class);\r\n    assertThat(target.toASCIIString()).isEqualTo(uriValue);\r\n}",
    "testNullJsonElementSerialization": "{\r\n    assertThat(gson.toJson(null, JsonElement.class)).isEqualTo(\"null\");\r\n    assertThat(gson.toJson(null, JsonNull.class)).isEqualTo(\"null\");\r\n}",
    "assertEqualsDate": "{\r\n    assertThat(date.getYear()).isEqualTo(year - 1900);\r\n    assertThat(date.getMonth()).isEqualTo(month);\r\n    assertThat(date.getDate()).isEqualTo(day);\r\n}",
    "assertEqualsTime": "{\r\n    assertThat(date.getHours()).isEqualTo(hours);\r\n    assertThat(date.getMinutes()).isEqualTo(minutes);\r\n    assertThat(date.getSeconds()).isEqualTo(seconds);\r\n}",
    "testClassSerialization": "{\r\n    try {\r\n        gson.toJson(String.class);\r\n        fail();\r\n    } catch (UnsupportedOperationException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Attempted to serialize java.lang.Class: java.lang.String. Forgot to register a type adapter?\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#java-lang-class-unsupported\");\r\n    }\r\n    // Override with a custom type adapter for class.\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();\r\n    assertThat(gson.toJson(String.class)).isEqualTo(\"\\\"java.lang.String\\\"\");\r\n}",
    "testStringBufferSerialization": "{\r\n    StringBuffer sb \u003d new StringBuffer(\"abc\");\r\n    String json \u003d gson.toJson(sb);\r\n    assertThat(json).isEqualTo(\"\\\"abc\\\"\");\r\n}",
    "testTreeSetDeserialization": "{\r\n    String json \u003d \"[\u0027Value1\u0027]\";\r\n    Type type \u003d new TypeToken\u003cTreeSet\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    TreeSet\u003cString\u003e treeSet \u003d gson.fromJson(json, type);\r\n    assertThat(treeSet).contains(\"Value1\");\r\n}",
    "testStringBufferDeserialization": "{\r\n    StringBuffer sb \u003d gson.fromJson(\"\u0027abc\u0027\", StringBuffer.class);\r\n    assertThat(sb.toString()).isEqualTo(\"abc\");\r\n}",
    "testNullSerialization": "{\r\n    testNullSerializationAndDeserialization(Boolean.class);\r\n    testNullSerializationAndDeserialization(Byte.class);\r\n    testNullSerializationAndDeserialization(Short.class);\r\n    testNullSerializationAndDeserialization(Integer.class);\r\n    testNullSerializationAndDeserialization(Long.class);\r\n    testNullSerializationAndDeserialization(Double.class);\r\n    testNullSerializationAndDeserialization(Float.class);\r\n    testNullSerializationAndDeserialization(Number.class);\r\n    testNullSerializationAndDeserialization(Character.class);\r\n    testNullSerializationAndDeserialization(String.class);\r\n    testNullSerializationAndDeserialization(StringBuilder.class);\r\n    testNullSerializationAndDeserialization(StringBuffer.class);\r\n    testNullSerializationAndDeserialization(BigDecimal.class);\r\n    testNullSerializationAndDeserialization(BigInteger.class);\r\n    testNullSerializationAndDeserialization(TreeSet.class);\r\n    testNullSerializationAndDeserialization(ArrayList.class);\r\n    testNullSerializationAndDeserialization(HashSet.class);\r\n    testNullSerializationAndDeserialization(Properties.class);\r\n    testNullSerializationAndDeserialization(URL.class);\r\n    testNullSerializationAndDeserialization(URI.class);\r\n    testNullSerializationAndDeserialization(UUID.class);\r\n    testNullSerializationAndDeserialization(Locale.class);\r\n    testNullSerializationAndDeserialization(InetAddress.class);\r\n    testNullSerializationAndDeserialization(BitSet.class);\r\n    testNullSerializationAndDeserialization(Date.class);\r\n    testNullSerializationAndDeserialization(GregorianCalendar.class);\r\n    testNullSerializationAndDeserialization(Calendar.class);\r\n    testNullSerializationAndDeserialization(Class.class);\r\n}",
    "testPropertiesDeserialization": "{\r\n    String json \u003d \"{foo:\u0027bar\u0027}\";\r\n    Properties props \u003d gson.fromJson(json, Properties.class);\r\n    assertThat(props.getProperty(\"foo\")).isEqualTo(\"bar\");\r\n}",
    "testBitSetDeserialization": "{\r\n    BitSet expected \u003d new BitSet();\r\n    expected.set(0);\r\n    expected.set(2, 6);\r\n    expected.set(8);\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(expected);\r\n    assertThat(gson.fromJson(json, BitSet.class)).isEqualTo(expected);\r\n    json \u003d \"[1,0,1,1,1,1,0,0,1,0,0,0]\";\r\n    assertThat(gson.fromJson(json, BitSet.class)).isEqualTo(expected);\r\n    json \u003d \"[\\\"1\\\",\\\"0\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"1\\\"]\";\r\n    assertThat(gson.fromJson(json, BitSet.class)).isEqualTo(expected);\r\n    json \u003d \"[true,false,true,true,true,true,false,false,true,false,false]\";\r\n    assertThat(gson.fromJson(json, BitSet.class)).isEqualTo(expected);\r\n    try {\r\n        gson.fromJson(\"[1, []]\", BitSet.class);\r\n        fail();\r\n    } catch (JsonSyntaxException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid bitset value type: BEGIN_ARRAY; at path $[1]\");\r\n    }\r\n    try {\r\n        gson.fromJson(\"[1, 2]\", BitSet.class);\r\n        fail();\r\n    } catch (JsonSyntaxException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid bitset value 2, expected 0 or 1; at path $[1]\");\r\n    }\r\n}",
    "testJsonObjectDeserialization": "{\r\n    JsonObject object \u003d new JsonObject();\r\n    object.add(\"foo\", new JsonPrimitive(1));\r\n    object.add(\"bar\", new JsonPrimitive(2));\r\n    String json \u003d \"{\\\"foo\\\":1,\\\"bar\\\":2}\";\r\n    JsonElement actual \u003d gson.fromJson(json, JsonElement.class);\r\n    assertThat(actual).isEqualTo(object);\r\n    JsonObject actualObj \u003d gson.fromJson(json, JsonObject.class);\r\n    assertThat(actualObj).isEqualTo(object);\r\n}",
    "testUrlNullSerialization": "{\r\n    ClassWithUrlField target \u003d new ClassWithUrlField();\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{}\");\r\n}",
    "testLocaleSerializationWithLanguageCountry": "{\r\n    Locale target \u003d Locale.CANADA_FRENCH;\r\n    assertThat(gson.toJson(target)).isEqualTo(\"\\\"fr_CA\\\"\");\r\n}",
    "testPropertiesSerialization": "{\r\n    Properties props \u003d new Properties();\r\n    props.setProperty(\"foo\", \"bar\");\r\n    String json \u003d gson.toJson(props);\r\n    String expected \u003d \"{\\\"foo\\\":\\\"bar\\\"}\";\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "testJsonElementTypeMismatch": "{\r\n    try {\r\n        gson.fromJson(\"\\\"abc\\\"\", JsonObject.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive; at path $\");\r\n    }\r\n}",
    "testUrlNullDeserialization": "{\r\n    String json \u003d \"{}\";\r\n    ClassWithUrlField target \u003d gson.fromJson(json, ClassWithUrlField.class);\r\n    assertThat(target.url).isNull();\r\n}",
    "testBigIntegerFieldDeserialization": "{\r\n    ClassWithBigInteger expected \u003d new ClassWithBigInteger(\"879697697697697697697697697697697697\");\r\n    String json \u003d expected.getExpectedJson();\r\n    ClassWithBigInteger actual \u003d gson.fromJson(json, ClassWithBigInteger.class);\r\n    assertThat(actual.value).isEqualTo(expected.value);\r\n}",
    "testDefaultDateDeserialization": "{\r\n    String json \u003d \"\u0027Dec 13, 2009 07:18:02 AM\u0027\";\r\n    Date extracted \u003d gson.fromJson(json, Date.class);\r\n    assertEqualsDate(extracted, 2009, 11, 13);\r\n    assertEqualsTime(extracted, 7, 18, 2);\r\n}",
    "testUriSerialization": "{\r\n    String uriValue \u003d \"http://google.com/\";\r\n    URI uri \u003d new URI(uriValue);\r\n    assertThat(gson.toJson(uri)).isEqualTo(\"\\\"http://google.com/\\\"\");\r\n}",
    "testDateDeserializationWithPattern": "{\r\n    String pattern \u003d \"yyyy-MM-dd\";\r\n    Gson gson \u003d new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    Date extracted \u003d gson.fromJson(json, Date.class);\r\n    assertThat(extracted.getYear()).isEqualTo(now.getYear());\r\n    assertThat(extracted.getMonth()).isEqualTo(now.getMonth());\r\n    assertThat(extracted.getDay()).isEqualTo(now.getDay());\r\n}",
    "deserialize": "{\r\n    return new Date(1315806903103L);\r\n}",
    "testJsonArraySerialization": "{\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(new JsonPrimitive(1));\r\n    array.add(new JsonPrimitive(2));\r\n    array.add(new JsonPrimitive(3));\r\n    assertThat(gson.toJson(array, JsonElement.class)).isEqualTo(\"[1,2,3]\");\r\n}",
    "testClassDeserialization": "{\r\n    try {\r\n        gson.fromJson(\"String.class\", Class.class);\r\n        fail();\r\n    } catch (UnsupportedOperationException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#java-lang-class-unsupported\");\r\n    }\r\n    // Override with a custom type adapter for class.\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();\r\n    assertThat(gson.fromJson(\"java.lang.String\", Class.class)).isAssignableTo(String.class);\r\n}",
    "testDefaultGregorianCalendarDeserialization": "{\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    String json \u003d \"{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}\";\r\n    GregorianCalendar cal \u003d gson.fromJson(json, GregorianCalendar.class);\r\n    assertThat(cal.get(Calendar.YEAR)).isEqualTo(2009);\r\n    assertThat(cal.get(Calendar.MONTH)).isEqualTo(2);\r\n    assertThat(cal.get(Calendar.DAY_OF_MONTH)).isEqualTo(11);\r\n    assertThat(cal.get(Calendar.HOUR_OF_DAY)).isEqualTo(14);\r\n    assertThat(cal.get(Calendar.MINUTE)).isEqualTo(29);\r\n    assertThat(cal.get(Calendar.SECOND)).isEqualTo(23);\r\n}",
    "testNullSerializationAndDeserialization": "{\r\n    assertThat(gson.toJson(null, c)).isEqualTo(\"null\");\r\n    assertThat(gson.fromJson(\"null\", c)).isEqualTo(null);\r\n}",
    "testBigIntegerFieldSerialization": "{\r\n    ClassWithBigInteger target \u003d new ClassWithBigInteger(\"23232323215323234234324324324324324324\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(target.getExpectedJson());\r\n}",
    "testDefaultCalendarDeserialization": "{\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    String json \u003d \"{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}\";\r\n    Calendar cal \u003d gson.fromJson(json, Calendar.class);\r\n    assertThat(cal.get(Calendar.YEAR)).isEqualTo(2009);\r\n    assertThat(cal.get(Calendar.MONTH)).isEqualTo(2);\r\n    assertThat(cal.get(Calendar.DAY_OF_MONTH)).isEqualTo(11);\r\n    assertThat(cal.get(Calendar.HOUR_OF_DAY)).isEqualTo(14);\r\n    assertThat(cal.get(Calendar.MINUTE)).isEqualTo(29);\r\n    assertThat(cal.get(Calendar.SECOND)).isEqualTo(23);\r\n}",
    "testSetSerialization": "{\r\n    Gson gson \u003d new Gson();\r\n    HashSet\u003cString\u003e s \u003d new HashSet\u003c\u003e();\r\n    s.add(\"blah\");\r\n    String json \u003d gson.toJson(s);\r\n    assertThat(json).isEqualTo(\"[\\\"blah\\\"]\");\r\n    json \u003d gson.toJson(s, Set.class);\r\n    assertThat(json).isEqualTo(\"[\\\"blah\\\"]\");\r\n}",
    "testDefaultDateDeserializationUsingBuilder": "{\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    Date extracted \u003d gson.fromJson(json, Date.class);\r\n    assertThat(extracted.toString()).isEqualTo(now.toString());\r\n}",
    "tearDown": "{\r\n    TimeZone.setDefault(oldTimeZone);\r\n    Locale.setDefault(oldLocale);\r\n}",
    "getExpectedJson": "{\r\n    return \"{\\\"value\\\":\" + value + \"}\";\r\n}",
    "testDateSerializationWithPatternNotOverridenByTypeAdapter": "{\r\n    String pattern \u003d \"yyyy-MM-dd\";\r\n    Gson gson \u003d new GsonBuilder().setDateFormat(pattern).registerTypeAdapter(Date.class, new JsonDeserializer\u003cDate\u003e() {\r\n\r\n        @Override\r\n        public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return new Date(1315806903103L);\r\n        }\r\n    }).create();\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    assertThat(json).isEqualTo(\"\\\"2011-09-11\\\"\");\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithHasArgsConstructor.java": {},
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\Main.java": {
    "testEnumSerializedName": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Enum SerializedName\", () -\u003e toJson(gson, EnumClassWithSerializedName.FIRST));\r\n    TestExecutor.run(outputConsumer, \"Read: Enum SerializedName\", () -\u003e fromJson(gson, \"\\\"two\\\"\", EnumClassWithSerializedName.class).toString());\r\n}",
    "testVersionAnnotations": "{\r\n    Gson gson \u003d new GsonBuilder().setVersion(1).create();\r\n    TestExecutor.run(outputConsumer, \"Write: Version annotations\", () -\u003e toJson(gson, new ClassWithVersionAnnotations()));\r\n}",
    "testTypeTokenWriteRead": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: TypeToken \" + description, () -\u003e gson.toJson(Arrays.asList(new ClassWithAdapter(1)), typeTokenSupplier.get().getType()));\r\n    TestExecutor.run(outputConsumer, \"Read: TypeToken \" + description, () -\u003e {\r\n        Object deserialized \u003d gson.fromJson(\"[{\\\"custom\\\": 3}]\", typeTokenSupplier.get());\r\n        return deserialized.toString();\r\n    });\r\n}",
    "testGenericClasses": "{\r\n    Gson gson \u003d new Gson();\r\n    TestExecutor.run(outputConsumer, \"Read: Generic TypeToken\", () -\u003e gson.fromJson(\"{\\\"t\\\": 1}\", new TypeToken\u003cGenericClass\u003cDummyClass\u003e\u003e() {\r\n    }).toString());\r\n    TestExecutor.run(outputConsumer, \"Read: Using Generic\", () -\u003e fromJson(gson, \"{\\\"g\\\": {\\\"t\\\": 1}}\", UsingGenericClass.class).toString());\r\n    TestExecutor.run(outputConsumer, \"Read: Using Generic TypeToken\", () -\u003e gson.fromJson(\"{\\\"g\\\": {\\\"t\\\": 1}}\", new TypeToken\u003cGenericUsingGenericClass\u003cDummyClass\u003e\u003e() {\r\n    }).toString());\r\n}",
    "testEnum": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Enum\", () -\u003e toJson(gson, EnumClass.FIRST));\r\n    TestExecutor.run(outputConsumer, \"Read: Enum\", () -\u003e fromJson(gson, \"\\\"SECOND\\\"\", EnumClass.class).toString());\r\n}",
    "toJson": "{\r\n    return gson.toJson(same(obj));\r\n}",
    "testNoJdkUnsafe": "{\r\n    Gson gson \u003d new GsonBuilder().disableJdkUnsafe().create();\r\n    TestExecutor.run(outputConsumer, \"Read: No JDK Unsafe; initial constructor value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n    TestExecutor.run(outputConsumer, \"Read: No JDK Unsafe; custom value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "testUnreferencedConstructorNoArgs": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    // No write because we\u0027re not referencing this class\u0027s constructor.\r\n    // This runs the no-args constructor.\r\n    TestExecutor.run(outputConsumer, \"Read: Unreferenced no args constructor; initial constructor value\", () -\u003e {\r\n        ClassWithUnreferencedNoArgsConstructor deserialized \u003d fromJson(gson, \"{}\", ClassWithUnreferencedNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n    TestExecutor.run(outputConsumer, \"Read: Unreferenced no args constructor; custom value\", () -\u003e {\r\n        ClassWithUnreferencedNoArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithUnreferencedNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "testUnreferencedConstructorHasArgs": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    // No write because we\u0027re not referencing this class\u0027s constructor.\r\n    // This most likely relies on JDK Unsafe (unless the shrinker rewrites the constructor in some way)\r\n    TestExecutor.run(outputConsumer, \"Read: Unreferenced constructor with args\", () -\u003e {\r\n        ClassWithUnreferencedHasArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithUnreferencedHasArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "testConstructorNoArgs": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: No args constructor\", () -\u003e toJson(gson, new ClassWithNoArgsConstructor()));\r\n    TestExecutor.run(outputConsumer, \"Read: No args constructor; initial constructor value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n    TestExecutor.run(outputConsumer, \"Read: No args constructor; custom value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "testJsonAdapterAnnotation": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: JsonAdapter on fields\", () -\u003e toJson(gson, new ClassWithJsonAdapterAnnotation(1, 2, 3, 4)));\r\n    String json \u003d \"{\\\"f1\\\": 1, \\\"f2\\\": 2, \\\"f3\\\": {\\\"s\\\": \\\"3\\\"}, \\\"f4\\\": 4}\";\r\n    TestExecutor.run(outputConsumer, \"Read: JsonAdapter on fields\", () -\u003e fromJson(gson, json, ClassWithJsonAdapterAnnotation.class).toString());\r\n}",
    "runTests": "{\r\n    // Create the TypeToken instances on demand because creation of them can fail when\r\n    // generic signatures were erased\r\n    testTypeTokenWriteRead(outputConsumer, \"anonymous\", () -\u003e new TypeToken\u003cList\u003cClassWithAdapter\u003e\u003e() {\r\n    });\r\n    testTypeTokenWriteRead(outputConsumer, \"manual\", () -\u003e TypeToken.getParameterized(List.class, ClassWithAdapter.class));\r\n    testNamedFields(outputConsumer);\r\n    testSerializedName(outputConsumer);\r\n    testConstructorNoArgs(outputConsumer);\r\n    testConstructorHasArgs(outputConsumer);\r\n    testUnreferencedConstructorNoArgs(outputConsumer);\r\n    testUnreferencedConstructorHasArgs(outputConsumer);\r\n    testNoJdkUnsafe(outputConsumer);\r\n    testEnum(outputConsumer);\r\n    testEnumSerializedName(outputConsumer);\r\n    testExposeAnnotation(outputConsumer);\r\n    testVersionAnnotations(outputConsumer);\r\n    testJsonAdapterAnnotation(outputConsumer);\r\n    testGenericClasses(outputConsumer);\r\n}",
    "testConstructorHasArgs": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Constructor with args\", () -\u003e toJson(gson, new ClassWithHasArgsConstructor(2)));\r\n    // This most likely relies on JDK Unsafe (unless the shrinker rewrites the constructor in some way)\r\n    TestExecutor.run(outputConsumer, \"Read: Constructor with args\", () -\u003e {\r\n        ClassWithHasArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithHasArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "fromJson": "{\r\n    return gson.fromJson(json, same(c));\r\n}",
    "testSerializedName": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: SerializedName\", () -\u003e toJson(gson, new ClassWithSerializedName(2)));\r\n    TestExecutor.run(outputConsumer, \"Read: SerializedName\", () -\u003e {\r\n        ClassWithSerializedName deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithSerializedName.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "testNamedFields": "{\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Named fields\", () -\u003e toJson(gson, new ClassWithNamedFields(2)));\r\n    TestExecutor.run(outputConsumer, \"Read: Named fields\", () -\u003e {\r\n        ClassWithNamedFields deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithNamedFields.class);\r\n        return Integer.toString(deserialized.myField);\r\n    });\r\n}",
    "testExposeAnnotation": "{\r\n    Gson gson \u003d new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();\r\n    TestExecutor.run(outputConsumer, \"Write: @Expose\", () -\u003e toJson(gson, new ClassWithExposeAnnotation()));\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ExposeFieldsTest.java": {
    "testExposeAnnotationSerialization": "{\r\n    ClassWithExposedFields target \u003d new ClassWithExposedFields(1, 2);\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "createInstance": "{\r\n    return new SomeObject();\r\n}",
    "testNullExposeFieldSerialization": "{\r\n    ClassWithExposedFields object \u003d new ClassWithExposedFields(null, 1);\r\n    String json \u003d gson.toJson(object);\r\n    assertThat(json).isEqualTo(object.getExpectedJson());\r\n}",
    "testNoExposedFieldSerialization": "{\r\n    ClassWithNoExposedFields obj \u003d new ClassWithNoExposedFields();\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n}",
    "testExposedInterfaceFieldDeserialization": "{\r\n    String json \u003d \"{\\\"interfaceField\\\":{}}\";\r\n    ClassWithInterfaceField obj \u003d gson.fromJson(json, ClassWithInterfaceField.class);\r\n    assertThat(obj.interfaceField).isNotNull();\r\n}",
    "getExpectedJson": "{\r\n    StringBuilder sb \u003d new StringBuilder(\"{\");\r\n    if (a !\u003d null) {\r\n        sb.append(\"\\\"a\\\":\").append(a).append(\",\");\r\n    }\r\n    sb.append(\"\\\"d\\\":\").append(d);\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "testNoExposedFieldDeserialization": "{\r\n    String json \u003d \"{a:4,b:5}\";\r\n    ClassWithNoExposedFields obj \u003d gson.fromJson(json, ClassWithNoExposedFields.class);\r\n    assertThat(obj.a).isEqualTo(0);\r\n    assertThat(obj.b).isEqualTo(1);\r\n}",
    "testArrayWithOneNullExposeFieldObjectSerialization": "{\r\n    ClassWithExposedFields object1 \u003d new ClassWithExposedFields(1, 1);\r\n    ClassWithExposedFields object2 \u003d new ClassWithExposedFields(null, 1);\r\n    ClassWithExposedFields object3 \u003d new ClassWithExposedFields(2, 2);\r\n    ClassWithExposedFields[] objects \u003d { object1, object2, object3 };\r\n    String json \u003d gson.toJson(objects);\r\n    String expected \u003d \u0027[\u0027 + object1.getExpectedJson() + \u0027,\u0027 + object2.getExpectedJson() + \u0027,\u0027 + object3.getExpectedJson() + \u0027]\u0027;\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "setUp": "{\r\n    gson \u003d new GsonBuilder().excludeFieldsWithoutExposeAnnotation().registerTypeAdapter(SomeInterface.class, new SomeInterfaceInstanceCreator()).create();\r\n}",
    "testExposeAnnotationDeserialization": "{\r\n    String json \u003d \"{a:3,b:4,d:20.0}\";\r\n    ClassWithExposedFields target \u003d gson.fromJson(json, ClassWithExposedFields.class);\r\n    assertThat(target.a).isEqualTo(3);\r\n    assertThat(target.b).isNull();\r\n    assertThat(target.d).isNotEqualTo(20);\r\n}",
    "testExposedInterfaceFieldSerialization": "{\r\n    String expected \u003d \"{\\\"interfaceField\\\":{}}\";\r\n    ClassWithInterfaceField target \u003d new ClassWithInterfaceField(new SomeObject());\r\n    String actual \u003d gson.toJson(target);\r\n    assertThat(actual).isEqualTo(expected);\r\n}"
  },
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\NonUploadingCaliperRunner.java": {
    "run": "{\r\n    // Disable result upload; Caliper uploads results to webapp by default, see https://github.com/google/caliper/issues/356\r\n    CaliperMain.main(c, concat(\"-Cresults.upload.options.url\u003d\", args));\r\n}",
    "concat": "{\r\n    if (others.length \u003d\u003d 0) {\r\n        return new String[] { first };\r\n    } else {\r\n        String[] result \u003d new String[others.length + 1];\r\n        result[0] \u003d first;\r\n        System.arraycopy(others, 0, result, 1, others.length);\r\n        return result;\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\Excluder.java": {
    "isValidSince": "{\r\n    if (annotation !\u003d null) {\r\n        double annotationVersion \u003d annotation.value();\r\n        return version \u003e\u003d annotationVersion;\r\n    }\r\n    return true;\r\n}",
    "isStatic": "{\r\n    return (clazz.getModifiers() \u0026 Modifier.STATIC) !\u003d 0;\r\n}",
    "read": "{\r\n    if (skipDeserialize) {\r\n        in.skipValue();\r\n        return null;\r\n    }\r\n    return delegate().read(in);\r\n}",
    "excludeClassInStrategy": "{\r\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\r\n    for (ExclusionStrategy exclusionStrategy : list) {\r\n        if (exclusionStrategy.shouldSkipClass(clazz)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "disableInnerClassSerialization": "{\r\n    Excluder result \u003d clone();\r\n    result.serializeInnerClasses \u003d false;\r\n    return result;\r\n}",
    "withModifiers": "{\r\n    Excluder result \u003d clone();\r\n    result.modifiers \u003d 0;\r\n    for (int modifier : modifiers) {\r\n        result.modifiers |\u003d modifier;\r\n    }\r\n    return result;\r\n}",
    "withVersion": "{\r\n    Excluder result \u003d clone();\r\n    result.version \u003d ignoreVersionsAfter;\r\n    return result;\r\n}",
    "isValidUntil": "{\r\n    if (annotation !\u003d null) {\r\n        double annotationVersion \u003d annotation.value();\r\n        return version \u003c annotationVersion;\r\n    }\r\n    return true;\r\n}",
    "excludeField": "{\r\n    if ((modifiers \u0026 field.getModifiers()) !\u003d 0) {\r\n        return true;\r\n    }\r\n    if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\r\n        return true;\r\n    }\r\n    if (field.isSynthetic()) {\r\n        return true;\r\n    }\r\n    if (requireExpose) {\r\n        Expose annotation \u003d field.getAnnotation(Expose.class);\r\n        if (annotation \u003d\u003d null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(field.getType())) {\r\n        return true;\r\n    }\r\n    if (isAnonymousOrNonStaticLocal(field.getType())) {\r\n        return true;\r\n    }\r\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\r\n    if (!list.isEmpty()) {\r\n        FieldAttributes fieldAttributes \u003d new FieldAttributes(field);\r\n        for (ExclusionStrategy exclusionStrategy : list) {\r\n            if (exclusionStrategy.shouldSkipField(fieldAttributes)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "delegate": "{\r\n    TypeAdapter\u003cT\u003e d \u003d delegate;\r\n    return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\r\n}",
    "withExclusionStrategy": "{\r\n    Excluder result \u003d clone();\r\n    if (serialization) {\r\n        result.serializationStrategies \u003d new ArrayList\u003c\u003e(serializationStrategies);\r\n        result.serializationStrategies.add(exclusionStrategy);\r\n    }\r\n    if (deserialization) {\r\n        result.deserializationStrategies \u003d new ArrayList\u003c\u003e(deserializationStrategies);\r\n        result.deserializationStrategies.add(exclusionStrategy);\r\n    }\r\n    return result;\r\n}",
    "excludeClassChecks": "{\r\n    if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\r\n        return true;\r\n    }\r\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(clazz)) {\r\n        return true;\r\n    }\r\n    return isAnonymousOrNonStaticLocal(clazz);\r\n}",
    "clone": "{\r\n    try {\r\n        return (Excluder) super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}",
    "create": "{\r\n    Class\u003c?\u003e rawType \u003d type.getRawType();\r\n    boolean excludeClass \u003d excludeClassChecks(rawType);\r\n    final boolean skipSerialize \u003d excludeClass || excludeClassInStrategy(rawType, true);\r\n    final boolean skipDeserialize \u003d excludeClass || excludeClassInStrategy(rawType, false);\r\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\r\n        return null;\r\n    }\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        /**\r\n         * The delegate is lazily created because it may not be needed, and creating it may fail.\r\n         */\r\n        private TypeAdapter\u003cT\u003e delegate;\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            if (skipDeserialize) {\r\n                in.skipValue();\r\n                return null;\r\n            }\r\n            return delegate().read(in);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (skipSerialize) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            delegate().write(out, value);\r\n        }\r\n\r\n        private TypeAdapter\u003cT\u003e delegate() {\r\n            TypeAdapter\u003cT\u003e d \u003d delegate;\r\n            return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\r\n        }\r\n    };\r\n}",
    "excludeClass": "{\r\n    return excludeClassChecks(clazz) || excludeClassInStrategy(clazz, serialize);\r\n}",
    "isAnonymousOrNonStaticLocal": "{\r\n    return !Enum.class.isAssignableFrom(clazz) \u0026\u0026 !isStatic(clazz) \u0026\u0026 (clazz.isAnonymousClass() || clazz.isLocalClass());\r\n}",
    "write": "{\r\n    if (skipSerialize) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    delegate().write(out, value);\r\n}",
    "excludeFieldsWithoutExposeAnnotation": "{\r\n    Excluder result \u003d clone();\r\n    result.requireExpose \u003d true;\r\n    return result;\r\n}",
    "isInnerClass": "{\r\n    return clazz.isMemberClass() \u0026\u0026 !isStatic(clazz);\r\n}",
    "isValidVersion": "{\r\n    return isValidSince(since) \u0026\u0026 isValidUntil(until);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\LinkedTreeMapTest.java": {
    "testEqualsAndHashCode": "{\r\n    LinkedTreeMap\u003cString, Integer\u003e map1 \u003d new LinkedTreeMap\u003c\u003e();\r\n    map1.put(\"A\", 1);\r\n    map1.put(\"B\", 2);\r\n    map1.put(\"C\", 3);\r\n    map1.put(\"D\", 4);\r\n    LinkedTreeMap\u003cString, Integer\u003e map2 \u003d new LinkedTreeMap\u003c\u003e();\r\n    map2.put(\"C\", 3);\r\n    map2.put(\"B\", 2);\r\n    map2.put(\"D\", 4);\r\n    map2.put(\"A\", 1);\r\n    MoreAsserts.assertEqualsAndHashCode(map1, map2);\r\n}",
    "testClear": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"android\");\r\n    map.put(\"c\", \"cola\");\r\n    map.put(\"b\", \"bbq\");\r\n    map.clear();\r\n    assertIterationOrder(map.keySet());\r\n    assertThat(map).hasSize(0);\r\n}",
    "testLargeSetOfRandomKeys": "{\r\n    Random random \u003d new Random(1367593214724L);\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    String[] keys \u003d new String[1000];\r\n    for (int i \u003d 0; i \u003c keys.length; i++) {\r\n        keys[i] \u003d Integer.toString(random.nextInt(), 36) + \"-\" + i;\r\n        map.put(keys[i], \"\" + i);\r\n    }\r\n    for (int i \u003d 0; i \u003c keys.length; i++) {\r\n        String key \u003d keys[i];\r\n        assertThat(map.containsKey(key)).isTrue();\r\n        assertThat(map.get(key)).isEqualTo(\"\" + i);\r\n    }\r\n}",
    "testContainsNonComparableKeyReturnsFalse": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"android\");\r\n    assertThat(map).doesNotContainKey(new Object());\r\n}",
    "testEmptyStringValues": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"\");\r\n    assertThat(map.containsKey(\"a\")).isTrue();\r\n    assertThat(map.get(\"a\")).isEqualTo(\"\");\r\n}",
    "testJavaSerialization": "{\r\n    ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\r\n    ObjectOutputStream objOut \u003d new ObjectOutputStream(out);\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", 1);\r\n    objOut.writeObject(map);\r\n    objOut.close();\r\n    ObjectInputStream objIn \u003d new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map\u003cString, Integer\u003e deserialized \u003d (Map\u003cString, Integer\u003e) objIn.readObject();\r\n    assertThat(deserialized).isEqualTo(Collections.singletonMap(\"a\", 1));\r\n}",
    "testIterationOrder": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"android\");\r\n    map.put(\"c\", \"cola\");\r\n    map.put(\"b\", \"bbq\");\r\n    assertIterationOrder(map.keySet(), \"a\", \"c\", \"b\");\r\n    assertIterationOrder(map.values(), \"android\", \"cola\", \"bbq\");\r\n}",
    "assertIterationOrder": "{\r\n    ArrayList\u003cT\u003e actualList \u003d new ArrayList\u003c\u003e();\r\n    for (T t : actual) {\r\n        actualList.add(t);\r\n    }\r\n    assertThat(actualList).isEqualTo(Arrays.asList(expected));\r\n}",
    "testContainsNullKeyIsAlwaysFalse": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    assertThat(map.containsKey(null)).isFalse();\r\n    map.put(\"a\", \"android\");\r\n    assertThat(map.containsKey(null)).isFalse();\r\n}",
    "testPutNonComparableKeyFails": "{\r\n    LinkedTreeMap\u003cObject, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    try {\r\n        map.put(new Object(), \"android\");\r\n        fail();\r\n    } catch (ClassCastException expected) {\r\n    }\r\n}",
    "testEntrySetValueNull_Forbidden": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e(false);\r\n    map.put(\"a\", \"1\");\r\n    Entry\u003cString, String\u003e entry \u003d map.entrySet().iterator().next();\r\n    try {\r\n        entry.setValue(null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n    assertThat(entry.getValue()).isEqualTo(\"1\");\r\n    assertThat(map.get(\"a\")).isEqualTo(\"1\");\r\n    assertThat(map.containsValue(null)).isFalse();\r\n}",
    "testPutNullValue_Forbidden": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e(false);\r\n    try {\r\n        map.put(\"a\", null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n    assertThat(map).hasSize(0);\r\n    assertThat(map).doesNotContainKey(\"a\");\r\n    assertThat(map.containsValue(null)).isFalse();\r\n}",
    "testEntrySetValueNull": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"1\");\r\n    assertThat(map.get(\"a\")).isEqualTo(\"1\");\r\n    Entry\u003cString, String\u003e entry \u003d map.entrySet().iterator().next();\r\n    assertThat(entry.getKey()).isEqualTo(\"a\");\r\n    assertThat(entry.getValue()).isEqualTo(\"1\");\r\n    entry.setValue(null);\r\n    assertThat(entry.getValue()).isNull();\r\n    assertThat(map.containsKey(\"a\")).isTrue();\r\n    assertThat(map.containsValue(null)).isTrue();\r\n    assertThat(map.get(\"a\")).isNull();\r\n}",
    "testPutOverrides": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    assertThat(map.put(\"d\", \"donut\")).isNull();\r\n    assertThat(map.put(\"e\", \"eclair\")).isNull();\r\n    assertThat(map.put(\"f\", \"froyo\")).isNull();\r\n    assertThat(map).hasSize(3);\r\n    assertThat(map.get(\"d\")).isEqualTo(\"donut\");\r\n    assertThat(map.put(\"d\", \"done\")).isEqualTo(\"donut\");\r\n    assertThat(map).hasSize(3);\r\n}",
    "testRemoveRootDoesNotDoubleUnlink": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"android\");\r\n    map.put(\"c\", \"cola\");\r\n    map.put(\"b\", \"bbq\");\r\n    Iterator\u003cMap.Entry\u003cString, String\u003e\u003e it \u003d map.entrySet().iterator();\r\n    it.next();\r\n    it.next();\r\n    it.next();\r\n    it.remove();\r\n    assertIterationOrder(map.keySet(), \"a\", \"c\");\r\n}",
    "testPutNullKeyFails": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    try {\r\n        map.put(null, \"android\");\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "testPutNullValue": "{\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", null);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.containsKey(\"a\")).isTrue();\r\n    assertThat(map.containsValue(null)).isTrue();\r\n    assertThat(map.get(\"a\")).isNull();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\PrintFormattingTest.java": {
    "testJsonObjectWithNullValues": "{\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"field1\", \"value1\");\r\n    obj.addProperty(\"field2\", (String) null);\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).contains(\"field1\");\r\n    assertThat(json).doesNotContain(\"field2\");\r\n}",
    "assertContainsNoWhiteSpace": "{\r\n    for (char c : str.toCharArray()) {\r\n        assertThat(Character.isWhitespace(c)).isFalse();\r\n    }\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testJsonObjectWithNullValuesSerialized": "{\r\n    gson \u003d new GsonBuilder().serializeNulls().create();\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"field1\", \"value1\");\r\n    obj.addProperty(\"field2\", (String) null);\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).contains(\"field1\");\r\n    assertThat(json).contains(\"field2\");\r\n}",
    "testCompactFormattingLeavesNoWhiteSpace": "{\r\n    List\u003cObject\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(new BagOfPrimitives());\r\n    list.add(new Nested());\r\n    list.add(new PrimitiveArray());\r\n    list.add(new ClassWithTransientFields\u003c\u003e());\r\n    String json \u003d gson.toJson(list);\r\n    assertContainsNoWhiteSpace(json);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\GenericArrayTypeTest.java": {
    "testNotEquals": "{\r\n    Type differentGenericArrayType \u003d new TypeToken\u003cList\u003cString\u003e[][]\u003e() {\r\n    }.getType();\r\n    assertThat(differentGenericArrayType.equals(ourType)).isFalse();\r\n    assertThat(ourType.equals(differentGenericArrayType)).isFalse();\r\n}",
    "setUp": "{\r\n    ourType \u003d $Gson$Types.arrayOf($Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class));\r\n}",
    "testOurTypeFunctionality": "{\r\n    Type parameterizedType \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Type genericArrayType \u003d new TypeToken\u003cList\u003cString\u003e[]\u003e() {\r\n    }.getType();\r\n    assertThat(ourType.getGenericComponentType()).isEqualTo(parameterizedType);\r\n    assertThat(ourType).isEqualTo(genericArrayType);\r\n    assertThat(ourType.hashCode()).isEqualTo(genericArrayType.hashCode());\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\extras\\examples\\rawcollections\\RawCollectionsExample.java": {
    "toString": "{\r\n    return String.format(\"(name\u003d%s, source\u003d%s)\", name, source);\r\n}",
    "main": "{\r\n    Gson gson \u003d new Gson();\r\n    Collection collection \u003d new ArrayList();\r\n    collection.add(\"hello\");\r\n    collection.add(5);\r\n    collection.add(new Event(\"GREETINGS\", \"guest\"));\r\n    String json \u003d gson.toJson(collection);\r\n    System.out.println(\"Using Gson.toJson() on a raw collection: \" + json);\r\n    JsonArray array \u003d JsonParser.parseString(json).getAsJsonArray();\r\n    String message \u003d gson.fromJson(array.get(0), String.class);\r\n    int number \u003d gson.fromJson(array.get(1), int.class);\r\n    Event event \u003d gson.fromJson(array.get(2), Event.class);\r\n    System.out.printf(\"Using Gson.fromJson() to get: %s, %d, %s\", message, number, event);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\DelegateTypeAdapterTest.java": {
    "read": "{\r\n    ++numReads;\r\n    return delegate.read(in);\r\n}",
    "setUp": "{\r\n    stats \u003d new StatsTypeAdapterFactory();\r\n    gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\r\n}",
    "create": "{\r\n    final TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            ++numWrites;\r\n            delegate.write(out, value);\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            ++numReads;\r\n            return delegate.read(in);\r\n        }\r\n    };\r\n}",
    "testDelegateInvoked": "{\r\n    List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c 10; ++i) {\r\n        bags.add(new BagOfPrimitives(i, i, i % 2 \u003d\u003d 0, String.valueOf(i)));\r\n    }\r\n    String json \u003d gson.toJson(bags);\r\n    gson.fromJson(json, new TypeToken\u003cList\u003cBagOfPrimitives\u003e\u003e() {\r\n    }.getType());\r\n    // 11: 1 list object, and 10 entries. stats invoked on all 5 fields\r\n    assertThat(stats.numReads).isEqualTo(51);\r\n    assertThat(stats.numWrites).isEqualTo(51);\r\n}",
    "testDelegateInvokedOnStrings": "{\r\n    String[] bags \u003d { \"1\", \"2\", \"3\", \"4\" };\r\n    String json \u003d gson.toJson(bags);\r\n    gson.fromJson(json, String[].class);\r\n    // 1 array object with 4 elements.\r\n    assertThat(stats.numReads).isEqualTo(5);\r\n    assertThat(stats.numWrites).isEqualTo(5);\r\n}",
    "write": "{\r\n    ++numWrites;\r\n    delegate.write(out, value);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\LongSerializationPolicyTest.java": {
    "testStringLongSerializationIntegration": "{\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\r\n    assertThat(gson.toJson(new long[] { 1L }, long[].class)).isEqualTo(\"[\\\"1\\\"]\");\r\n    assertThat(gson.toJson(new Long[] { 1L }, long[].class)).isEqualTo(\"[\\\"1\\\"]\");\r\n}",
    "testStringLongSerializationNull": "{\r\n    LongSerializationPolicy policy \u003d LongSerializationPolicy.STRING;\r\n    assertThat(policy.serialize(null).isJsonNull()).isTrue();\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(policy).create();\r\n    assertThat(gson.toJson(null, Long.class)).isEqualTo(\"null\");\r\n}",
    "testDefaultLongSerializationIntegration": "{\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.DEFAULT).create();\r\n    assertThat(gson.toJson(new long[] { 1L }, long[].class)).isEqualTo(\"[1]\");\r\n    assertThat(gson.toJson(new Long[] { 1L }, Long[].class)).isEqualTo(\"[1]\");\r\n}",
    "testStringLongSerialization": "{\r\n    JsonElement element \u003d LongSerializationPolicy.STRING.serialize(1556L);\r\n    assertThat(element.isJsonPrimitive()).isTrue();\r\n    JsonPrimitive jsonPrimitive \u003d element.getAsJsonPrimitive();\r\n    assertThat(jsonPrimitive.isNumber()).isFalse();\r\n    assertThat(jsonPrimitive.isString()).isTrue();\r\n    assertThat(element.getAsString()).isEqualTo(\"1556\");\r\n}",
    "testDefaultLongSerializationNull": "{\r\n    LongSerializationPolicy policy \u003d LongSerializationPolicy.DEFAULT;\r\n    assertThat(policy.serialize(null).isJsonNull()).isTrue();\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(policy).create();\r\n    assertThat(gson.toJson(null, Long.class)).isEqualTo(\"null\");\r\n}",
    "testDefaultLongSerialization": "{\r\n    JsonElement element \u003d LongSerializationPolicy.DEFAULT.serialize(1556L);\r\n    assertThat(element.isJsonPrimitive()).isTrue();\r\n    JsonPrimitive jsonPrimitive \u003d element.getAsJsonPrimitive();\r\n    assertThat(jsonPrimitive.isString()).isFalse();\r\n    assertThat(jsonPrimitive.isNumber()).isTrue();\r\n    assertThat(element.getAsLong()).isEqualTo(1556L);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\LazilyParsedNumberTest.java": {
    "testJavaSerialization": "{\r\n    ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\r\n    ObjectOutputStream objOut \u003d new ObjectOutputStream(out);\r\n    objOut.writeObject(new LazilyParsedNumber(\"123\"));\r\n    objOut.close();\r\n    ObjectInputStream objIn \u003d new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\r\n    Number deserialized \u003d (Number) objIn.readObject();\r\n    assertThat(deserialized).isEqualTo(new BigDecimal(\"123\"));\r\n}",
    "testHashCode": "{\r\n    LazilyParsedNumber n1 \u003d new LazilyParsedNumber(\"1\");\r\n    LazilyParsedNumber n1Another \u003d new LazilyParsedNumber(\"1\");\r\n    assertThat(n1Another.hashCode()).isEqualTo(n1.hashCode());\r\n}",
    "testEquals": "{\r\n    LazilyParsedNumber n1 \u003d new LazilyParsedNumber(\"1\");\r\n    LazilyParsedNumber n1Another \u003d new LazilyParsedNumber(\"1\");\r\n    assertThat(n1.equals(n1Another)).isTrue();\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\EnumClassWithSerializedName.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ArrayTypeAdapter.java": {
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    ArrayList\u003cE\u003e list \u003d new ArrayList\u003c\u003e();\r\n    in.beginArray();\r\n    while (in.hasNext()) {\r\n        E instance \u003d componentTypeAdapter.read(in);\r\n        list.add(instance);\r\n    }\r\n    in.endArray();\r\n    int size \u003d list.size();\r\n    // Have to copy primitives one by one to primitive array\r\n    if (componentType.isPrimitive()) {\r\n        Object array \u003d Array.newInstance(componentType, size);\r\n        for (int i \u003d 0; i \u003c size; i++) {\r\n            Array.set(array, i, list.get(i));\r\n        }\r\n        return array;\r\n    } else // But for Object[] can use ArrayList.toArray\r\n    {\r\n        @SuppressWarnings(\"unchecked\")\r\n        E[] array \u003d (E[]) Array.newInstance(componentType, size);\r\n        return list.toArray(array);\r\n    }\r\n}",
    "create": "{\r\n    Type type \u003d typeToken.getType();\r\n    if (!(type instanceof GenericArrayType || (type instanceof Class \u0026\u0026 ((Class\u003c?\u003e) type).isArray()))) {\r\n        return null;\r\n    }\r\n    Type componentType \u003d $Gson$Types.getArrayComponentType(type);\r\n    TypeAdapter\u003c?\u003e componentTypeAdapter \u003d gson.getAdapter(TypeToken.get(componentType));\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e arrayAdapter \u003d new ArrayTypeAdapter(gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\r\n    return arrayAdapter;\r\n}",
    "write": "{\r\n    if (array \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginArray();\r\n    for (int i \u003d 0, length \u003d Array.getLength(array); i \u003c length; i++) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        E value \u003d (E) Array.get(array, i);\r\n        componentTypeAdapter.write(out, value);\r\n    }\r\n    out.endArray();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\GsonBuildConfigTest.java": {
    "testEnsureGsonBuildConfigGetsUpdatedToMavenVersion": "{\r\n    assertThat(\"${project.version}\").isNotEqualTo(GsonBuildConfig.VERSION);\r\n}"
  },
  "google_json\\gson\\src\\main\\java-templates\\com\\google\\gson\\internal\\GsonBuildConfig.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonNull.java": {
    "hashCode": "{\r\n    return JsonNull.class.hashCode();\r\n}",
    "equals": "{\r\n    return other instanceof JsonNull;\r\n}",
    "deepCopy": "{\r\n    return INSTANCE;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\TroubleshootingGuide.java": {
    "createUrl": "{\r\n    return \"https://github.com/google/gson/blob/main/Troubleshooting.md#\" + id;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\MalformedJsonException.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonTreeReader.java": {
    "popStack": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}",
    "endArray": "{\r\n    expect(JsonToken.END_ARRAY);\r\n    // empty iterator\r\n    popStack();\r\n    // array\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}",
    "nextString": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.STRING \u0026\u0026 token !\u003d JsonToken.NUMBER) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\r\n    }\r\n    String result \u003d ((JsonPrimitive) popStack()).getAsString();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "beginArray": "{\r\n    expect(JsonToken.BEGIN_ARRAY);\r\n    JsonArray array \u003d (JsonArray) peekStack();\r\n    push(array.iterator());\r\n    pathIndices[stackSize - 1] \u003d 0;\r\n}",
    "nextJsonElement": "{\r\n    final JsonToken peeked \u003d peek();\r\n    if (peeked \u003d\u003d JsonToken.NAME || peeked \u003d\u003d JsonToken.END_ARRAY || peeked \u003d\u003d JsonToken.END_OBJECT || peeked \u003d\u003d JsonToken.END_DOCUMENT) {\r\n        throw new IllegalStateException(\"Unexpected \" + peeked + \" when reading a JsonElement.\");\r\n    }\r\n    final JsonElement element \u003d (JsonElement) peekStack();\r\n    skipValue();\r\n    return element;\r\n}",
    "promoteNameToValue": "{\r\n    expect(JsonToken.NAME);\r\n    Iterator\u003c?\u003e i \u003d (Iterator\u003c?\u003e) peekStack();\r\n    Map.Entry\u003c?, ?\u003e entry \u003d (Map.Entry\u003c?, ?\u003e) i.next();\r\n    push(entry.getValue());\r\n    push(new JsonPrimitive((String) entry.getKey()));\r\n}",
    "peekStack": "{\r\n    return stack[stackSize - 1];\r\n}",
    "getPath": "{\r\n    return getPath(false);\r\n}",
    "nextBoolean": "{\r\n    expect(JsonToken.BOOLEAN);\r\n    boolean result \u003d ((JsonPrimitive) popStack()).getAsBoolean();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "close": "{\r\n    stack \u003d new Object[] { SENTINEL_CLOSED };\r\n    stackSize \u003d 1;\r\n}",
    "skipValue": "{\r\n    JsonToken peeked \u003d peek();\r\n    switch(peeked) {\r\n        case NAME:\r\n            @SuppressWarnings(\"unused\")\r\n            String unused \u003d nextName(true);\r\n            break;\r\n        case END_ARRAY:\r\n            endArray();\r\n            break;\r\n        case END_OBJECT:\r\n            endObject();\r\n            break;\r\n        case END_DOCUMENT:\r\n            // Do nothing\r\n            break;\r\n        default:\r\n            popStack();\r\n            if (stackSize \u003e 0) {\r\n                pathIndices[stackSize - 1]++;\r\n            }\r\n            break;\r\n    }\r\n}",
    "read": "{\r\n    throw new AssertionError();\r\n}",
    "getPreviousPath": "{\r\n    return getPath(true);\r\n}",
    "hasNext": "{\r\n    JsonToken token \u003d peek();\r\n    return token !\u003d JsonToken.END_OBJECT \u0026\u0026 token !\u003d JsonToken.END_ARRAY \u0026\u0026 token !\u003d JsonToken.END_DOCUMENT;\r\n}",
    "nextInt": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    int result \u003d ((JsonPrimitive) peekStack()).getAsInt();\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "nextLong": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    long result \u003d ((JsonPrimitive) peekStack()).getAsLong();\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "nextDouble": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    double result \u003d ((JsonPrimitive) peekStack()).getAsDouble();\r\n    if (!isLenient() \u0026\u0026 (Double.isNaN(result) || Double.isInfinite(result))) {\r\n        throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result);\r\n    }\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "push": "{\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        int newLength \u003d stackSize * 2;\r\n        stack \u003d Arrays.copyOf(stack, newLength);\r\n        pathIndices \u003d Arrays.copyOf(pathIndices, newLength);\r\n        pathNames \u003d Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}",
    "endObject": "{\r\n    expect(JsonToken.END_OBJECT);\r\n    // Free the last path name so that it can be garbage collected\r\n    pathNames[stackSize - 1] \u003d null;\r\n    // empty iterator\r\n    popStack();\r\n    // object\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}",
    "peek": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}",
    "expect": "{\r\n    if (peek() !\u003d expected) {\r\n        throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString());\r\n    }\r\n}",
    "beginObject": "{\r\n    expect(JsonToken.BEGIN_OBJECT);\r\n    JsonObject object \u003d (JsonObject) peekStack();\r\n    push(object.entrySet().iterator());\r\n}",
    "locationString": "{\r\n    return \" at path \" + getPath();\r\n}",
    "toString": "{\r\n    return getClass().getSimpleName() + locationString();\r\n}",
    "nextName": "{\r\n    return nextName(false);\r\n}",
    "nextNull": "{\r\n    expect(JsonToken.NULL);\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\UnsafeAllocator.java": {
    "create": "{\r\n    // try JVM\r\n    // public class Unsafe {\r\n    //   public Object allocateInstance(Class\u003c?\u003e type);\r\n    // }\r\n    try {\r\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\r\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\r\n        f.setAccessible(true);\r\n        final Object unsafe \u003d f.get(null);\r\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\r\n        return new UnsafeAllocator() {\r\n\r\n            @Override\r\n            @SuppressWarnings(\"unchecked\")\r\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n                assertInstantiable(c);\r\n                return (T) allocateInstance.invoke(unsafe, c);\r\n            }\r\n        };\r\n    } catch (Exception ignored) {\r\n        // OK: try the next way\r\n    }\r\n    // try dalvikvm, post-gingerbread\r\n    // public class ObjectStreamClass {\r\n    //   private static native int getConstructorId(Class\u003c?\u003e c);\r\n    //   private static native Object newInstance(Class\u003c?\u003e instantiationClass, int methodId);\r\n    // }\r\n    try {\r\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\r\n        getConstructorId.setAccessible(true);\r\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\r\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\r\n        newInstance.setAccessible(true);\r\n        return new UnsafeAllocator() {\r\n\r\n            @Override\r\n            @SuppressWarnings(\"unchecked\")\r\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n                assertInstantiable(c);\r\n                return (T) newInstance.invoke(null, c, constructorId);\r\n            }\r\n        };\r\n    } catch (Exception ignored) {\r\n        // OK: try the next way\r\n    }\r\n    // try dalvikvm, pre-gingerbread\r\n    // public class ObjectInputStream {\r\n    //   private static native Object newInstance(\r\n    //     Class\u003c?\u003e instantiationClass, Class\u003c?\u003e constructorClass);\r\n    // }\r\n    try {\r\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\r\n        newInstance.setAccessible(true);\r\n        return new UnsafeAllocator() {\r\n\r\n            @Override\r\n            @SuppressWarnings(\"unchecked\")\r\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n                assertInstantiable(c);\r\n                return (T) newInstance.invoke(null, c, Object.class);\r\n            }\r\n        };\r\n    } catch (Exception ignored) {\r\n        // OK: try the next way\r\n    }\r\n    // give up\r\n    return new UnsafeAllocator() {\r\n\r\n        @Override\r\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\r\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c + \". Usage of JDK sun.misc.Unsafe is enabled, \" + \"but it could not be used. Make sure your runtime is configured correctly.\");\r\n        }\r\n    };\r\n}",
    "newInstance": "{\r\n    throw new UnsupportedOperationException(\"Cannot allocate \" + c + \". Usage of JDK sun.misc.Unsafe is enabled, \" + \"but it could not be used. Make sure your runtime is configured correctly.\");\r\n}",
    "assertInstantiable": "{\r\n    String exceptionMessage \u003d ConstructorConstructor.checkInstantiable(c);\r\n    if (exceptionMessage !\u003d null) {\r\n        throw new AssertionError(\"UnsafeAllocator is used for non-instantiable type: \" + exceptionMessage);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\StreamsTest.java": {
    "testWriterForAppendable": "{\r\n    StringBuilder stringBuilder \u003d new StringBuilder();\r\n    Writer writer \u003d Streams.writerForAppendable(stringBuilder);\r\n    writer.append(\u0027a\u0027);\r\n    writer.append(\u0027\\u1234\u0027);\r\n    writer.append(\"test\");\r\n    // test custom null handling mandated by `append`\r\n    writer.append(null);\r\n    writer.append(\"abcdef\", 2, 4);\r\n    // test custom null handling mandated by `append`\r\n    writer.append(null, 1, 3);\r\n    writer.append(\u0027,\u0027);\r\n    writer.write(\u0027a\u0027);\r\n    writer.write(\u0027\\u1234\u0027);\r\n    // Should only consider the 16 low-order bits\r\n    writer.write(0x4321_1234);\r\n    writer.append(\u0027,\u0027);\r\n    writer.write(\"chars\".toCharArray());\r\n    try {\r\n        writer.write((char[]) null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n    }\r\n    writer.write(\"chars\".toCharArray(), 1, 2);\r\n    try {\r\n        writer.write((char[]) null, 1, 2);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n    }\r\n    writer.append(\u0027,\u0027);\r\n    writer.write(\"string\");\r\n    try {\r\n        writer.write((String) null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n    }\r\n    writer.write(\"string\", 1, 2);\r\n    try {\r\n        writer.write((String) null, 1, 2);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n    }\r\n    String actualOutput \u003d stringBuilder.toString();\r\n    assertThat(actualOutput).isEqualTo(\"a\\u1234testnullcdul,a\\u1234\\u1234,charsha,stringtr\");\r\n    writer.flush();\r\n    writer.close();\r\n    // flush() and close() calls should have had no effect\r\n    assertThat(stringBuilder.toString()).isEqualTo(actualOutput);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\LongSerializationPolicy.java": {
    "serialize": "{\r\n    if (value \u003d\u003d null) {\r\n        return JsonNull.INSTANCE;\r\n    }\r\n    return new JsonPrimitive(value.toString());\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\interceptors\\Intercept.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\FormattingStyle.java": {
    "withSpaceAfterSeparators": "{\r\n    return new FormattingStyle(this.newline, this.indent, spaceAfterSeparators);\r\n}",
    "getIndent": "{\r\n    return this.indent;\r\n}",
    "withNewline": "{\r\n    return new FormattingStyle(newline, this.indent, this.spaceAfterSeparators);\r\n}",
    "usesSpaceAfterSeparators": "{\r\n    return this.spaceAfterSeparators;\r\n}",
    "withIndent": "{\r\n    return new FormattingStyle(this.newline, indent, this.spaceAfterSeparators);\r\n}",
    "getNewline": "{\r\n    return this.newline;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\JsonArrayTest.java": {
    "testRemove": "{\r\n    JsonArray array \u003d new JsonArray();\r\n    try {\r\n        array.remove(0);\r\n        fail();\r\n    } catch (IndexOutOfBoundsException expected) {\r\n    }\r\n    JsonPrimitive a \u003d new JsonPrimitive(\"a\");\r\n    array.add(a);\r\n    assertThat(array.remove(a)).isTrue();\r\n    assertThat(array).doesNotContain(a);\r\n    array.add(a);\r\n    array.add(new JsonPrimitive(\"b\"));\r\n    assertThat(array.remove(1).getAsString()).isEqualTo(\"b\");\r\n    assertThat(array).hasSize(1);\r\n    assertThat(array).contains(a);\r\n}",
    "testSet": "{\r\n    JsonArray array \u003d new JsonArray();\r\n    try {\r\n        array.set(0, new JsonPrimitive(1));\r\n        fail();\r\n    } catch (IndexOutOfBoundsException expected) {\r\n    }\r\n    JsonPrimitive a \u003d new JsonPrimitive(\"a\");\r\n    array.add(a);\r\n    JsonPrimitive b \u003d new JsonPrimitive(\"b\");\r\n    JsonElement oldValue \u003d array.set(0, b);\r\n    assertThat(oldValue).isEqualTo(a);\r\n    assertThat(array.get(0).getAsString()).isEqualTo(\"b\");\r\n    oldValue \u003d array.set(0, null);\r\n    assertThat(oldValue).isEqualTo(b);\r\n    assertThat(array.get(0)).isEqualTo(JsonNull.INSTANCE);\r\n    oldValue \u003d array.set(0, new JsonPrimitive(\"c\"));\r\n    assertThat(oldValue).isEqualTo(JsonNull.INSTANCE);\r\n    assertThat(array.get(0).getAsString()).isEqualTo(\"c\");\r\n    assertThat(array).hasSize(1);\r\n}",
    "testStringPrimitiveAddition": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(\"Hello\");\r\n    jsonArray.add(\"Goodbye\");\r\n    jsonArray.add(\"Thank you\");\r\n    jsonArray.add((String) null);\r\n    jsonArray.add(\"Yes\");\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[\\\"Hello\\\",\\\"Goodbye\\\",\\\"Thank you\\\",null,\\\"Yes\\\"]\");\r\n}",
    "testNullJsonElementAddition": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add((JsonElement) null);\r\n    assertThat(jsonArray.get(0)).isEqualTo(JsonNull.INSTANCE);\r\n}",
    "testFailedGetArrayValues": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(JsonParser.parseString(\"{\" + \"\\\"key1\\\":\\\"value1\\\",\" + \"\\\"key2\\\":\\\"value2\\\",\" + \"\\\"key3\\\":\\\"value3\\\",\" + \"\\\"key4\\\":\\\"value4\\\"\" + \"}\"));\r\n    try {\r\n        jsonArray.getAsBoolean();\r\n        fail(\"expected getBoolean to fail\");\r\n    } catch (UnsupportedOperationException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JsonObject\");\r\n    }\r\n    try {\r\n        jsonArray.get(-1);\r\n        fail(\"expected get to fail\");\r\n    } catch (IndexOutOfBoundsException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Index -1 out of bounds for length 1\");\r\n    }\r\n    try {\r\n        jsonArray.getAsString();\r\n        fail(\"expected getString to fail\");\r\n    } catch (UnsupportedOperationException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JsonObject\");\r\n    }\r\n    jsonArray.remove(0);\r\n    jsonArray.add(\"hello\");\r\n    try {\r\n        jsonArray.getAsDouble();\r\n        fail(\"expected getDouble to fail\");\r\n    } catch (NumberFormatException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"For input string: \\\"hello\\\"\");\r\n    }\r\n    try {\r\n        jsonArray.getAsInt();\r\n        fail(\"expected getInt to fail\");\r\n    } catch (NumberFormatException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"For input string: \\\"hello\\\"\");\r\n    }\r\n    try {\r\n        jsonArray.get(0).getAsJsonArray();\r\n        fail(\"expected getJSONArray to fail\");\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Not a JSON Array: \\\"hello\\\"\");\r\n    }\r\n    try {\r\n        jsonArray.getAsJsonObject();\r\n        fail(\"expected getJSONObject to fail\");\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Not a JSON Object: [\\\"hello\\\"]\");\r\n    }\r\n    try {\r\n        jsonArray.getAsLong();\r\n        fail(\"expected getLong to fail\");\r\n    } catch (NumberFormatException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"For input string: \\\"hello\\\"\");\r\n    }\r\n}",
    "testDoublePrimitiveAddition": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    double x \u003d 1.0;\r\n    jsonArray.add(x);\r\n    x \u003d 2.13232;\r\n    jsonArray.add(x);\r\n    x \u003d 0.121;\r\n    jsonArray.add(x);\r\n    jsonArray.add((Double) null);\r\n    x \u003d -0.00234;\r\n    jsonArray.add(x);\r\n    jsonArray.add((Double) null);\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[1.0,2.13232,0.121,null,-0.00234,null]\");\r\n}",
    "testMixedPrimitiveAddition": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(\u0027a\u0027);\r\n    jsonArray.add(\"apple\");\r\n    jsonArray.add(12121);\r\n    jsonArray.add((char) 111);\r\n    jsonArray.add((Boolean) null);\r\n    assertThat(jsonArray.get(jsonArray.size() - 1)).isEqualTo(JsonNull.INSTANCE);\r\n    jsonArray.add((Character) null);\r\n    assertThat(jsonArray.get(jsonArray.size() - 1)).isEqualTo(JsonNull.INSTANCE);\r\n    jsonArray.add(12.232);\r\n    jsonArray.add(BigInteger.valueOf(2323));\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[\\\"a\\\",\\\"apple\\\",12121,\\\"o\\\",null,null,12.232,2323]\");\r\n}",
    "testDeepCopy": "{\r\n    JsonArray original \u003d new JsonArray();\r\n    JsonArray firstEntry \u003d new JsonArray();\r\n    original.add(firstEntry);\r\n    JsonArray copy \u003d original.deepCopy();\r\n    original.add(new JsonPrimitive(\"y\"));\r\n    assertThat(copy).hasSize(1);\r\n    firstEntry.add(new JsonPrimitive(\"z\"));\r\n    assertThat(original.get(0).getAsJsonArray()).hasSize(1);\r\n    assertThat(copy.get(0).getAsJsonArray()).hasSize(0);\r\n}",
    "testNullPrimitiveAddition": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add((Character) null);\r\n    jsonArray.add((Boolean) null);\r\n    jsonArray.add((Integer) null);\r\n    jsonArray.add((Double) null);\r\n    jsonArray.add((Float) null);\r\n    jsonArray.add((BigInteger) null);\r\n    jsonArray.add((String) null);\r\n    jsonArray.add((Boolean) null);\r\n    jsonArray.add((Number) null);\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[null,null,null,null,null,null,null,null,null]\");\r\n    for (int i \u003d 0; i \u003c jsonArray.size(); i++) {\r\n        // Verify that they are actually a JsonNull and not a Java null\r\n        assertThat(jsonArray.get(i)).isEqualTo(JsonNull.INSTANCE);\r\n    }\r\n}",
    "testGetAs_WrongArraySize": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    try {\r\n        jsonArray.getAsByte();\r\n        fail();\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Array must have size 1, but has size 0\");\r\n    }\r\n    jsonArray.add(true);\r\n    jsonArray.add(false);\r\n    try {\r\n        jsonArray.getAsByte();\r\n        fail();\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Array must have size 1, but has size 2\");\r\n    }\r\n}",
    "testIsEmpty": "{\r\n    JsonArray array \u003d new JsonArray();\r\n    assertThat(array).isEmpty();\r\n    JsonPrimitive a \u003d new JsonPrimitive(\"a\");\r\n    array.add(a);\r\n    assertThat(array).isNotEmpty();\r\n    array.remove(0);\r\n    assertThat(array).isEmpty();\r\n}",
    "testIntegerPrimitiveAddition": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    int x \u003d 1;\r\n    jsonArray.add(x);\r\n    x \u003d 2;\r\n    jsonArray.add(x);\r\n    x \u003d -3;\r\n    jsonArray.add(x);\r\n    jsonArray.add((Integer) null);\r\n    x \u003d 4;\r\n    jsonArray.add(x);\r\n    x \u003d 0;\r\n    jsonArray.add(x);\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[1,2,-3,null,4,0]\");\r\n}",
    "testSameAddition": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(\u0027a\u0027);\r\n    jsonArray.add(\u0027a\u0027);\r\n    jsonArray.add(true);\r\n    jsonArray.add(true);\r\n    jsonArray.add(1212);\r\n    jsonArray.add(1212);\r\n    jsonArray.add(34.34);\r\n    jsonArray.add(34.34);\r\n    jsonArray.add((Boolean) null);\r\n    jsonArray.add((Boolean) null);\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[\\\"a\\\",\\\"a\\\",true,true,1212,1212,34.34,34.34,null,null]\");\r\n}",
    "testEqualsNonEmptyArray": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    JsonArray b \u003d new JsonArray();\r\n    new EqualsTester().addEqualityGroup(a).testEquals();\r\n    a.add(new JsonObject());\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n    b.add(new JsonObject());\r\n    MoreAsserts.assertEqualsAndHashCode(a, b);\r\n    a.add(new JsonObject());\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n    b.add(JsonNull.INSTANCE);\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n}",
    "testEqualsOnEmptyArray": "{\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonArray(), new JsonArray());\r\n}",
    "testCharPrimitiveAddition": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(\u0027a\u0027);\r\n    jsonArray.add(\u0027e\u0027);\r\n    jsonArray.add(\u0027i\u0027);\r\n    jsonArray.add((char) 111);\r\n    jsonArray.add((Character) null);\r\n    jsonArray.add(\u0027u\u0027);\r\n    jsonArray.add(\"and sometimes Y\");\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[\\\"a\\\",\\\"e\\\",\\\"i\\\",\\\"o\\\",null,\\\"u\\\",\\\"and sometimes Y\\\"]\");\r\n}",
    "testBooleanPrimitiveAddition": "{\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(true);\r\n    jsonArray.add(true);\r\n    jsonArray.add(false);\r\n    jsonArray.add(false);\r\n    jsonArray.add((Boolean) null);\r\n    jsonArray.add(true);\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[true,true,false,false,null,true]\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\JsonArrayAsListTest.java": {
    "testClear": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    list.clear();\r\n    assertThat(list).hasSize(0);\r\n    assertThat(a).hasSize(0);\r\n}",
    "testRemoveIndex": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list.remove(0)).isEqualTo(new JsonPrimitive(1));\r\n    assertThat(list).hasSize(0);\r\n    assertThat(a).hasSize(0);\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.remove(0));\r\n}",
    "testEqualsHashCode": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    MoreAsserts.assertEqualsAndHashCode(list, Collections.singletonList(new JsonPrimitive(1)));\r\n    assertThat(list.equals(Collections.emptyList())).isFalse();\r\n    assertThat(list.equals(Collections.singletonList(new JsonPrimitive(2)))).isFalse();\r\n}",
    "testSet": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    JsonElement old \u003d list.set(0, new JsonPrimitive(2));\r\n    assertThat(old).isEqualTo(new JsonPrimitive(1));\r\n    assertThat(list.get(0)).isEqualTo(new JsonPrimitive(2));\r\n    assertThat(a.get(0)).isEqualTo(new JsonPrimitive(2));\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.set(-1, new JsonPrimitive(1)));\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.set(2, new JsonPrimitive(1)));\r\n    NullPointerException e \u003d assertThrows(NullPointerException.class, () -\u003e list.set(0, null));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Element must be non-null\");\r\n}",
    "testAddAll": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    list.addAll(Arrays.asList(new JsonPrimitive(2), new JsonPrimitive(3)));\r\n    List\u003cJsonElement\u003e expectedList \u003d Arrays.\u003cJsonElement\u003easList(new JsonPrimitive(1), new JsonPrimitive(2), new JsonPrimitive(3));\r\n    assertThat(list).isEqualTo(expectedList);\r\n    assertThat(list).isEqualTo(expectedList);\r\n    NullPointerException e \u003d assertThrows(NullPointerException.class, () -\u003e list.addAll(0, Collections.\u003cJsonElement\u003esingletonList(null)));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Element must be non-null\");\r\n    e \u003d assertThrows(NullPointerException.class, () -\u003e list.addAll(Collections.\u003cJsonElement\u003esingletonList(null)));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Element must be non-null\");\r\n}",
    "testContains": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list).contains(new JsonPrimitive(1));\r\n    assertThat(list).doesNotContain(new JsonPrimitive(2));\r\n    assertThat(list).doesNotContain(null);\r\n    @SuppressWarnings({ \"unlikely-arg-type\", \"CollectionIncompatibleType\" })\r\n    boolean // should only contain JsonPrimitive(1)\r\n    containsInt \u003d list.contains(1);\r\n    assertThat(containsInt).isFalse();\r\n}",
    "testGet": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list.get(0)).isEqualTo(new JsonPrimitive(1));\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.get(-1));\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.get(2));\r\n    a.add((JsonElement) null);\r\n    assertThat(list.get(1)).isEqualTo(JsonNull.INSTANCE);\r\n}",
    "testToArray": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list.toArray()).isEqualTo(new Object[] { new JsonPrimitive(1) });\r\n    JsonElement[] array \u003d list.toArray(new JsonElement[0]);\r\n    assertThat(array).isEqualTo(new Object[] { new JsonPrimitive(1) });\r\n    array \u003d new JsonElement[1];\r\n    assertThat(list.toArray(array)).isEqualTo(array);\r\n    assertThat(array).isEqualTo(new Object[] { new JsonPrimitive(1) });\r\n    array \u003d new JsonElement[] { null, new JsonPrimitive(2) };\r\n    assertThat(list.toArray(array)).isEqualTo(array);\r\n    // Should have set existing array element to null\r\n    assertThat(array).isEqualTo(new Object[] { new JsonPrimitive(1), null });\r\n}",
    "testViewUpdates": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    a.add(1);\r\n    assertThat(list).hasSize(1);\r\n    assertThat(list.get(0)).isEqualTo(new JsonPrimitive(1));\r\n    list.add(new JsonPrimitive(2));\r\n    assertThat(a).hasSize(2);\r\n    assertThat(a.get(1)).isEqualTo(new JsonPrimitive(2));\r\n}",
    "testSize": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list).hasSize(1);\r\n    list.add(new JsonPrimitive(2));\r\n    assertThat(list).hasSize(2);\r\n}",
    "testAdd": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    list.add(0, new JsonPrimitive(2));\r\n    list.add(1, new JsonPrimitive(3));\r\n    assertThat(list.add(new JsonPrimitive(4))).isTrue();\r\n    assertThat(list.add(JsonNull.INSTANCE)).isTrue();\r\n    List\u003cJsonElement\u003e expectedList \u003d Arrays.\u003cJsonElement\u003easList(new JsonPrimitive(2), new JsonPrimitive(3), new JsonPrimitive(1), new JsonPrimitive(4), JsonNull.INSTANCE);\r\n    assertThat(list).isEqualTo(expectedList);\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.set(-1, new JsonPrimitive(1)));\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.set(list.size(), new JsonPrimitive(1)));\r\n    NullPointerException e \u003d assertThrows(NullPointerException.class, () -\u003e list.add(0, null));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Element must be non-null\");\r\n    e \u003d assertThrows(NullPointerException.class, () -\u003e list.add(null));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Element must be non-null\");\r\n}",
    "testIndexOf": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    // Add the same value twice to test indexOf vs. lastIndexOf\r\n    a.add(1);\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list.indexOf(new JsonPrimitive(1))).isEqualTo(0);\r\n    assertThat(list.indexOf(new JsonPrimitive(2))).isEqualTo(-1);\r\n    assertThat(list.indexOf(null)).isEqualTo(-1);\r\n    @SuppressWarnings({ \"unlikely-arg-type\", \"CollectionIncompatibleType\" })\r\n    int // should only contain JsonPrimitive(1)\r\n    indexOfInt \u003d list.indexOf(1);\r\n    assertThat(indexOfInt).isEqualTo(-1);\r\n    assertThat(list.lastIndexOf(new JsonPrimitive(1))).isEqualTo(1);\r\n    assertThat(list.lastIndexOf(new JsonPrimitive(2))).isEqualTo(-1);\r\n    assertThat(list.lastIndexOf(null)).isEqualTo(-1);\r\n}",
    "testRemoveElement": "{\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list.remove(new JsonPrimitive(1))).isTrue();\r\n    assertThat(list).hasSize(0);\r\n    assertThat(a).hasSize(0);\r\n    assertThat(list.remove(new JsonPrimitive(1))).isFalse();\r\n    assertThat(list.remove(null)).isFalse();\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java": {
    "buildUnexpectedTypeError": "{\r\n    // Build exception message\r\n    StringBuilder exceptionMessage \u003d new StringBuilder(\"Unexpected type. Expected one of: \");\r\n    for (Class\u003c?\u003e clazz : expected) {\r\n        exceptionMessage.append(clazz.getName()).append(\", \");\r\n    }\r\n    exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append(\u0027.\u0027);\r\n    return new AssertionError(exceptionMessage.toString());\r\n}",
    "getRawType": "{\r\n    return rawType;\r\n}",
    "getArray": "{\r\n    return new TypeToken\u003c\u003e($Gson$Types.arrayOf(componentType));\r\n}",
    "isAssignableFrom": "{\r\n    if (from \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (to.equals(from)) {\r\n        return true;\r\n    }\r\n    // First figure out the class and any type information.\r\n    Class\u003c?\u003e clazz \u003d $Gson$Types.getRawType(from);\r\n    ParameterizedType ptype \u003d null;\r\n    if (from instanceof ParameterizedType) {\r\n        ptype \u003d (ParameterizedType) from;\r\n    }\r\n    // Load up parameterized variable info if it was parameterized.\r\n    if (ptype !\u003d null) {\r\n        Type[] tArgs \u003d ptype.getActualTypeArguments();\r\n        TypeVariable\u003c?\u003e[] tParams \u003d clazz.getTypeParameters();\r\n        for (int i \u003d 0; i \u003c tArgs.length; i++) {\r\n            Type arg \u003d tArgs[i];\r\n            TypeVariable\u003c?\u003e var \u003d tParams[i];\r\n            while (arg instanceof TypeVariable\u003c?\u003e) {\r\n                TypeVariable\u003c?\u003e v \u003d (TypeVariable\u003c?\u003e) arg;\r\n                arg \u003d typeVarMap.get(v.getName());\r\n            }\r\n            typeVarMap.put(var.getName(), arg);\r\n        }\r\n        // check if they are equivalent under our current mapping.\r\n        if (typeEquals(ptype, to, typeVarMap)) {\r\n            return true;\r\n        }\r\n    }\r\n    for (Type itype : clazz.getGenericInterfaces()) {\r\n        if (isAssignableFrom(itype, to, new HashMap\u003c\u003e(typeVarMap))) {\r\n            return true;\r\n        }\r\n    }\r\n    // Interfaces didn\u0027t work, try the superclass.\r\n    Type sType \u003d clazz.getGenericSuperclass();\r\n    return isAssignableFrom(sType, to, new HashMap\u003c\u003e(typeVarMap));\r\n}",
    "matches": "{\r\n    return to.equals(from) || (from instanceof TypeVariable \u0026\u0026 to.equals(typeMap.get(((TypeVariable\u003c?\u003e) from).getName())));\r\n}",
    "getTypeTokenTypeArgument": "{\r\n    Type superclass \u003d getClass().getGenericSuperclass();\r\n    if (superclass instanceof ParameterizedType) {\r\n        ParameterizedType parameterized \u003d (ParameterizedType) superclass;\r\n        if (parameterized.getRawType() \u003d\u003d TypeToken.class) {\r\n            Type typeArgument \u003d $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\r\n            if (isCapturingTypeVariablesForbidden()) {\r\n                verifyNoTypeVariable(typeArgument);\r\n            }\r\n            return typeArgument;\r\n        }\r\n    } else // Check for raw TypeToken as superclass\r\n    if (superclass \u003d\u003d TypeToken.class) {\r\n        throw new IllegalStateException(\"TypeToken must be created with a type argument: new TypeToken\u003c...\u003e() {};\" + \" When using code shrinkers (ProGuard, R8, ...) make sure that generic signatures are preserved.\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"type-token-raw\"));\r\n    }\r\n    // User created subclass of subclass of TypeToken\r\n    throw new IllegalStateException(\"Must only create direct subclasses of TypeToken\");\r\n}",
    "getParameterized": "{\r\n    Objects.requireNonNull(rawType);\r\n    Objects.requireNonNull(typeArguments);\r\n    // Perform basic validation here because this is the only public API where users\r\n    // can create malformed parameterized types\r\n    if (!(rawType instanceof Class)) {\r\n        // See also https://bugs.openjdk.org/browse/JDK-8250659\r\n        throw new IllegalArgumentException(\"rawType must be of type Class, but was \" + rawType);\r\n    }\r\n    Class\u003c?\u003e rawClass \u003d (Class\u003c?\u003e) rawType;\r\n    TypeVariable\u003c?\u003e[] typeVariables \u003d rawClass.getTypeParameters();\r\n    int expectedArgsCount \u003d typeVariables.length;\r\n    int actualArgsCount \u003d typeArguments.length;\r\n    if (actualArgsCount !\u003d expectedArgsCount) {\r\n        throw new IllegalArgumentException(rawClass.getName() + \" requires \" + expectedArgsCount + \" type arguments, but got \" + actualArgsCount);\r\n    }\r\n    // For legacy reasons create a TypeToken(Class) if the type is not generic\r\n    if (typeArguments.length \u003d\u003d 0) {\r\n        return get(rawClass);\r\n    }\r\n    // Check for this here to avoid misleading exception thrown by ParameterizedTypeImpl\r\n    if ($Gson$Types.requiresOwnerType(rawType)) {\r\n        throw new IllegalArgumentException(\"Raw type \" + rawClass.getName() + \" is not supported because\" + \" it requires specifying an owner type\");\r\n    }\r\n    for (int i \u003d 0; i \u003c expectedArgsCount; i++) {\r\n        Type typeArgument \u003d Objects.requireNonNull(typeArguments[i], \"Type argument must not be null\");\r\n        Class\u003c?\u003e rawTypeArgument \u003d $Gson$Types.getRawType(typeArgument);\r\n        TypeVariable\u003c?\u003e typeVariable \u003d typeVariables[i];\r\n        for (Type bound : typeVariable.getBounds()) {\r\n            Class\u003c?\u003e rawBound \u003d $Gson$Types.getRawType(bound);\r\n            if (!rawBound.isAssignableFrom(rawTypeArgument)) {\r\n                throw new IllegalArgumentException(\"Type argument \" + typeArgument + \" does not satisfy bounds\" + \" for type variable \" + typeVariable + \" declared by \" + rawType);\r\n            }\r\n        }\r\n    }\r\n    return new TypeToken\u003c\u003e($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));\r\n}",
    "getType": "{\r\n    return type;\r\n}",
    "isCapturingTypeVariablesForbidden": "{\r\n    return !Objects.equals(System.getProperty(\"gson.allowCapturingTypeVariables\"), \"true\");\r\n}",
    "hashCode": "{\r\n    return this.hashCode;\r\n}",
    "equals": "{\r\n    return o instanceof TypeToken\u003c?\u003e \u0026\u0026 $Gson$Types.equals(type, ((TypeToken\u003c?\u003e) o).type);\r\n}",
    "get": "{\r\n    return new TypeToken\u003c\u003e(type);\r\n}",
    "toString": "{\r\n    return $Gson$Types.typeToString(type);\r\n}",
    "verifyNoTypeVariable": "{\r\n    if (type instanceof TypeVariable) {\r\n        TypeVariable\u003c?\u003e typeVariable \u003d (TypeVariable\u003c?\u003e) type;\r\n        throw new IllegalArgumentException(\"TypeToken type argument must not contain a type variable; captured type variable \" + typeVariable.getName() + \" declared by \" + typeVariable.getGenericDeclaration() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"typetoken-type-variable\"));\r\n    } else if (type instanceof GenericArrayType) {\r\n        verifyNoTypeVariable(((GenericArrayType) type).getGenericComponentType());\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType parameterizedType \u003d (ParameterizedType) type;\r\n        Type ownerType \u003d parameterizedType.getOwnerType();\r\n        if (ownerType !\u003d null) {\r\n            verifyNoTypeVariable(ownerType);\r\n        }\r\n        for (Type typeArgument : parameterizedType.getActualTypeArguments()) {\r\n            verifyNoTypeVariable(typeArgument);\r\n        }\r\n    } else if (type instanceof WildcardType) {\r\n        WildcardType wildcardType \u003d (WildcardType) type;\r\n        for (Type bound : wildcardType.getLowerBounds()) {\r\n            verifyNoTypeVariable(bound);\r\n        }\r\n        for (Type bound : wildcardType.getUpperBounds()) {\r\n            verifyNoTypeVariable(bound);\r\n        }\r\n    } else if (type \u003d\u003d null) {\r\n        // Occurs in Eclipse IDE and certain Java versions (e.g. Java 11.0.18) when capturing type variable\r\n        // declared by method of local class, see https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n        throw new IllegalArgumentException(\"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n    }\r\n}",
    "typeEquals": "{\r\n    if (from.getRawType().equals(to.getRawType())) {\r\n        Type[] fromArgs \u003d from.getActualTypeArguments();\r\n        Type[] toArgs \u003d to.getActualTypeArguments();\r\n        for (int i \u003d 0; i \u003c fromArgs.length; i++) {\r\n            if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\GenericClasses.java": {
    "read": "{\r\n    return new DummyClass(\"read-\" + in.nextInt());\r\n}",
    "toString": "{\r\n    return s;\r\n}",
    "write": "{\r\n    throw new UnsupportedOperationException();\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\JsonAdapter.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\Expose.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReusedTypeVariablesFullyResolveTest.java": {
    "setUp": "{\r\n    gson \u003d new GsonBuilder().create();\r\n}",
    "testGenericsPreservation": "{\r\n    TestEnumSetCollection withSet \u003d gson.fromJson(\"{\\\"collection\\\":[\\\"ONE\\\",\\\"THREE\\\"]}\", TestEnumSetCollection.class);\r\n    Iterator\u003cTestEnum\u003e iterator \u003d withSet.collection.iterator();\r\n    assertThat(withSet).isNotNull();\r\n    assertThat(withSet.collection).isNotNull();\r\n    assertThat(withSet.collection).hasSize(2);\r\n    TestEnum first \u003d iterator.next();\r\n    TestEnum second \u003d iterator.next();\r\n    assertThat(first).isInstanceOf(TestEnum.class);\r\n    assertThat(second).isInstanceOf(TestEnum.class);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ArrayTest.java": {
    "testInvalidArrayDeserialization": "{\r\n    String json \u003d \"[1, 2 3, 4, 5]\";\r\n    try {\r\n        gson.fromJson(json, int[].class);\r\n        fail(\"Gson should not deserialize array elements with missing ,\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testNullsInArrayWithSerializeNullPropertySetSerialization": "{\r\n    gson \u003d new GsonBuilder().serializeNulls().create();\r\n    String[] array \u003d { \"foo\", null, \"bar\" };\r\n    String expected \u003d \"[\\\"foo\\\",null,\\\"bar\\\"]\";\r\n    String json \u003d gson.toJson(array);\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "testMultidimensionalArraysDeserialization": "{\r\n    String json \u003d \"[[\u00273m Co\u0027,\u002771.72\u0027,\u00270.02\u0027,\u00270.03\u0027,\u00274/2 12:00am\u0027,\u0027Manufacturing\u0027],\" + \"[\u0027Alcoa Inc\u0027,\u002729.01\u0027,\u00270.42\u0027,\u00271.47\u0027,\u00274/1 12:00am\u0027,\u0027Manufacturing\u0027]]\";\r\n    String[][] items \u003d gson.fromJson(json, String[][].class);\r\n    assertThat(items[0][0]).isEqualTo(\"3m Co\");\r\n    assertThat(items[1][5]).isEqualTo(\"Manufacturing\");\r\n}",
    "testArrayOfNullDeserialization": "{\r\n    String[] values \u003d gson.fromJson(\"[null]\", String[].class);\r\n    assertThat(values[0]).isNull();\r\n}",
    "testArrayOfPrimitivesAsObjectsDeserialization": "{\r\n    String json \u003d \"[1,\u0027abc\u0027,0.3,1.1,5]\";\r\n    Object[] objs \u003d gson.fromJson(json, Object[].class);\r\n    assertThat(((Number) objs[0]).intValue()).isEqualTo(1);\r\n    assertThat(objs[1]).isEqualTo(\"abc\");\r\n    assertThat(((Number) objs[2]).doubleValue()).isEqualTo(0.3);\r\n    assertThat(new BigDecimal(objs[3].toString())).isEqualTo(new BigDecimal(\"1.1\"));\r\n    assertThat(((Number) objs[4]).shortValue()).isEqualTo(5);\r\n}",
    "testMultidimensionalPrimitiveArraysDeserialization": "{\r\n    String json \u003d \"[[1,2],[3,4]]\";\r\n    int[][] expected \u003d { { 1, 2 }, { 3, 4 } };\r\n    assertThat(gson.fromJson(json, int[][].class)).isEqualTo(expected);\r\n}",
    "testSingleStringArraySerialization": "{\r\n    String[] s \u003d { \"hello\" };\r\n    String output \u003d gson.toJson(s);\r\n    assertThat(output).isEqualTo(\"[\\\"hello\\\"]\");\r\n}",
    "testMultidimensionalObjectArraysSerialization": "{\r\n    Object[][] array \u003d { new Object[] { 1, 2 } };\r\n    assertThat(gson.toJson(array)).isEqualTo(\"[[1,2]]\");\r\n}",
    "testArrayOfCollectionSerialization": "{\r\n    StringBuilder sb \u003d new StringBuilder(\"[\");\r\n    int arraySize \u003d 3;\r\n    Type typeToSerialize \u003d new TypeToken\u003cCollection\u003cInteger\u003e[]\u003e() {\r\n    }.getType();\r\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\n    Collection\u003cInteger\u003e[] arrayOfCollection \u003d new ArrayList[arraySize];\r\n    for (int i \u003d 0; i \u003c arraySize; ++i) {\r\n        int startValue \u003d (3 * i) + 1;\r\n        sb.append(\u0027[\u0027).append(startValue).append(\u0027,\u0027).append(startValue + 1).append(\u0027]\u0027);\r\n        ArrayList\u003cInteger\u003e tmpList \u003d new ArrayList\u003c\u003e();\r\n        tmpList.add(startValue);\r\n        tmpList.add(startValue + 1);\r\n        arrayOfCollection[i] \u003d tmpList;\r\n        if (i \u003c arraySize - 1) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n    }\r\n    sb.append(\u0027]\u0027);\r\n    String json \u003d gson.toJson(arrayOfCollection, typeToSerialize);\r\n    assertThat(json).isEqualTo(sb.toString());\r\n}",
    "testMixingTypesInObjectArraySerialization": "{\r\n    Object[] array \u003d { 1, 2, new Object[] { \"one\", \"two\", 3 } };\r\n    assertThat(gson.toJson(array)).isEqualTo(\"[1,2,[\\\"one\\\",\\\"two\\\",3]]\");\r\n}",
    "testArrayOfStringsSerialization": "{\r\n    String[] target \u003d { \"Hello\", \"World\" };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[\\\"Hello\\\",\\\"World\\\"]\");\r\n}",
    "testMultidimensionalArraysSerialization": "{\r\n    String[][] items \u003d { { \"3m Co\", \"71.72\", \"0.02\", \"0.03\", \"4/2 12:00am\", \"Manufacturing\" }, { \"Alcoa Inc\", \"29.01\", \"0.42\", \"1.47\", \"4/1 12:00am\", \"Manufacturing\" } };\r\n    String json \u003d gson.toJson(items);\r\n    assertThat(json).contains(\"[[\\\"3m Co\");\r\n    assertThat(json).contains(\"Manufacturing\\\"]]\");\r\n}",
    "testTopLevelArrayOfIntsSerialization": "{\r\n    int[] target \u003d { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[1,2,3,4,5,6,7,8,9]\");\r\n}",
    "testArrayOfStringsDeserialization": "{\r\n    String json \u003d \"[\\\"Hello\\\",\\\"World\\\"]\";\r\n    String[] target \u003d gson.fromJson(json, String[].class);\r\n    assertThat(target).asList().containsExactly(\"Hello\", \"World\");\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testSingleNullInArraySerialization": "{\r\n    BagOfPrimitives[] array \u003d new BagOfPrimitives[1];\r\n    array[0] \u003d null;\r\n    String json \u003d gson.toJson(array);\r\n    assertThat(json).isEqualTo(\"[null]\");\r\n}",
    "testNullsInArrayDeserialization": "{\r\n    String json \u003d \"[\\\"foo\\\",null,\\\"bar\\\"]\";\r\n    String[] expected \u003d { \"foo\", null, \"bar\" };\r\n    String[] target \u003d gson.fromJson(json, expected.getClass());\r\n    assertThat(target).asList().containsAnyIn(expected);\r\n}",
    "testEmptyArraySerialization": "{\r\n    int[] target \u003d {};\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[]\");\r\n}",
    "testArrayElementsAreArrays": "{\r\n    Object[] stringArrays \u003d { new String[] { \"test1\", \"test2\" }, new String[] { \"test3\", \"test4\" } };\r\n    assertThat(new Gson().toJson(stringArrays)).isEqualTo(\"[[\\\"test1\\\",\\\"test2\\\"],[\\\"test3\\\",\\\"test4\\\"]]\");\r\n}",
    "testEmptyArrayDeserialization": "{\r\n    int[] actualObject \u003d gson.fromJson(\"[]\", int[].class);\r\n    assertThat(actualObject).hasLength(0);\r\n    Integer[] actualObject2 \u003d gson.fromJson(\"[]\", Integer[].class);\r\n    assertThat(actualObject2).hasLength(0);\r\n    actualObject \u003d gson.fromJson(\"[ ]\", int[].class);\r\n    assertThat(actualObject).hasLength(0);\r\n}",
    "testSingleNullInArrayDeserialization": "{\r\n    BagOfPrimitives[] array \u003d gson.fromJson(\"[null]\", BagOfPrimitives[].class);\r\n    assertThat(array).asList().containsExactly((Object) null);\r\n}",
    "testArrayOfPrimitivesAsObjectsSerialization": "{\r\n    Object[] objs \u003d new Object[] { 1, \"abc\", 0.3f, 5L };\r\n    String json \u003d gson.toJson(objs);\r\n    assertThat(json).contains(\"abc\");\r\n    assertThat(json).contains(\"0.3\");\r\n    assertThat(json).contains(\"5\");\r\n}",
    "testTopLevelArrayOfIntsDeserialization": "{\r\n    int[] expected \u003d { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    int[] actual \u003d gson.fromJson(\"[1,2,3,4,5,6,7,8,9]\", int[].class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testMultidimensionalPrimitiveArraysSerialization": "{\r\n    int[][] array \u003d { { 1, 2 }, { 3, 4 } };\r\n    assertThat(gson.toJson(array)).isEqualTo(\"[[1,2],[3,4]]\");\r\n}",
    "testNullsInArraySerialization": "{\r\n    String[] array \u003d { \"foo\", null, \"bar\" };\r\n    String expected \u003d \"[\\\"foo\\\",null,\\\"bar\\\"]\";\r\n    String json \u003d gson.toJson(array);\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "testObjectArrayWithNonPrimitivesSerialization": "{\r\n    ClassWithObjects classWithObjects \u003d new ClassWithObjects();\r\n    BagOfPrimitives bagOfPrimitives \u003d new BagOfPrimitives();\r\n    String classWithObjectsJson \u003d gson.toJson(classWithObjects);\r\n    String bagOfPrimitivesJson \u003d gson.toJson(bagOfPrimitives);\r\n    Object[] objects \u003d { classWithObjects, bagOfPrimitives };\r\n    String json \u003d gson.toJson(objects);\r\n    assertThat(json).contains(classWithObjectsJson);\r\n    assertThat(json).contains(bagOfPrimitivesJson);\r\n}",
    "testSingleStringArrayDeserialization": "{\r\n    String json \u003d \"[\\\"hello\\\"]\";\r\n    String[] arrayType \u003d gson.fromJson(json, String[].class);\r\n    assertThat(arrayType).asList().containsExactly(\"hello\");\r\n}",
    "testArrayOfCollectionDeserialization": "{\r\n    String json \u003d \"[[1,2],[3,4]]\";\r\n    Type type \u003d new TypeToken\u003cCollection\u003cInteger\u003e[]\u003e() {\r\n    }.getType();\r\n    Collection\u003cInteger\u003e[] target \u003d gson.fromJson(json, type);\r\n    assertThat(target.length).isEqualTo(2);\r\n    assertThat(target[0].toArray(new Integer[0])).isEqualTo(new Integer[] { 1, 2 });\r\n    assertThat(target[1].toArray(new Integer[0])).isEqualTo(new Integer[] { 3, 4 });\r\n}",
    "testArrayOfNullSerialization": "{\r\n    Object[] array \u003d { null };\r\n    String json \u003d gson.toJson(array);\r\n    assertThat(json).isEqualTo(\"[null]\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonDeserializer.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonPrimitive.java": {
    "getAsBigInteger": "{\r\n    return value instanceof BigInteger ? (BigInteger) value : isIntegral(this) ? BigInteger.valueOf(this.getAsNumber().longValue()) : new BigInteger(this.getAsString());\r\n}",
    "getAsFloat": "{\r\n    return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString());\r\n}",
    "getAsByte": "{\r\n    return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString());\r\n}",
    "getAsBigDecimal": "{\r\n    return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(getAsString());\r\n}",
    "isIntegral": "{\r\n    if (primitive.value instanceof Number) {\r\n        Number number \u003d (Number) primitive.value;\r\n        return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte;\r\n    }\r\n    return false;\r\n}",
    "getAsNumber": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}",
    "getAsCharacter": "{\r\n    String s \u003d getAsString();\r\n    if (s.isEmpty()) {\r\n        throw new UnsupportedOperationException(\"String value is empty\");\r\n    } else {\r\n        return s.charAt(0);\r\n    }\r\n}",
    "getAsString": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}",
    "getAsDouble": "{\r\n    return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString());\r\n}",
    "getAsInt": "{\r\n    return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString());\r\n}",
    "deepCopy": "{\r\n    return this;\r\n}",
    "isBoolean": "{\r\n    return value instanceof Boolean;\r\n}",
    "getAsLong": "{\r\n    return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString());\r\n}",
    "getAsBoolean": "{\r\n    if (isBoolean()) {\r\n        return (Boolean) value;\r\n    }\r\n    // Check to see if the value as a String is \"true\" in any case.\r\n    return Boolean.parseBoolean(getAsString());\r\n}",
    "isNumber": "{\r\n    return value instanceof Number;\r\n}",
    "hashCode": "{\r\n    if (value \u003d\u003d null) {\r\n        return 31;\r\n    }\r\n    // Using recommended hashing algorithm from Effective Java for longs and doubles\r\n    if (isIntegral(this)) {\r\n        long value \u003d getAsNumber().longValue();\r\n        return (int) (value ^ (value \u003e\u003e\u003e 32));\r\n    }\r\n    if (value instanceof Number) {\r\n        long value \u003d Double.doubleToLongBits(getAsNumber().doubleValue());\r\n        return (int) (value ^ (value \u003e\u003e\u003e 32));\r\n    }\r\n    return value.hashCode();\r\n}",
    "equals": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    JsonPrimitive other \u003d (JsonPrimitive) obj;\r\n    if (value \u003d\u003d null) {\r\n        return other.value \u003d\u003d null;\r\n    }\r\n    if (isIntegral(this) \u0026\u0026 isIntegral(other)) {\r\n        return (this.value instanceof BigInteger || other.value instanceof BigInteger) ? this.getAsBigInteger().equals(other.getAsBigInteger()) : this.getAsNumber().longValue() \u003d\u003d other.getAsNumber().longValue();\r\n    }\r\n    if (value instanceof Number \u0026\u0026 other.value instanceof Number) {\r\n        double a \u003d getAsNumber().doubleValue();\r\n        // Java standard types other than double return true for two NaN. So, need\r\n        // special handling for double.\r\n        double b \u003d other.getAsNumber().doubleValue();\r\n        return a \u003d\u003d b || (Double.isNaN(a) \u0026\u0026 Double.isNaN(b));\r\n    }\r\n    return value.equals(other.value);\r\n}",
    "isString": "{\r\n    return value instanceof String;\r\n}",
    "getAsShort": "{\r\n    return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString());\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\NullObjectAndFieldTest.java": {
    "testExplicitSerializationOfNulls": "{\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithObjects target \u003d new ClassWithObjects(null);\r\n    String actual \u003d gson.toJson(target);\r\n    String expected \u003d \"{\\\"bag\\\":null}\";\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testCustomSerializationOfNulls": "{\r\n    gsonBuilder.registerTypeAdapter(ClassWithObjects.class, new ClassWithObjectsSerializer());\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithObjects target \u003d new ClassWithObjects(new BagOfPrimitives());\r\n    String actual \u003d gson.toJson(target);\r\n    String expected \u003d \"{\\\"bag\\\":null}\";\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testAbsentJsonElementsAreSetToNull": "{\r\n    Gson gson \u003d new Gson();\r\n    ClassWithInitializedMembers target \u003d gson.fromJson(\"{array:[1,2,3]}\", ClassWithInitializedMembers.class);\r\n    assertThat(target.array).hasLength(3);\r\n    assertThat(target.array[1]).isEqualTo(2);\r\n    assertThat(target.str1).isEqualTo(ClassWithInitializedMembers.MY_STRING_DEFAULT);\r\n    assertThat(target.str2).isNull();\r\n    assertThat(target.int1).isEqualTo(ClassWithInitializedMembers.MY_INT_DEFAULT);\r\n    // test the default value of a primitive int field per JVM spec\r\n    assertThat(target.int2).isEqualTo(0);\r\n    assertThat(target.bool1).isEqualTo(ClassWithInitializedMembers.MY_BOOLEAN_DEFAULT);\r\n    // test the default value of a primitive boolean field per JVM spec\r\n    assertThat(target.bool2).isFalse();\r\n}",
    "testPrintPrintingObjectWithNulls": "{\r\n    gsonBuilder \u003d new GsonBuilder();\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String result \u003d gson.toJson(new ClassWithMembers());\r\n    assertThat(result).isEqualTo(\"{}\");\r\n    gson \u003d gsonBuilder.serializeNulls().create();\r\n    result \u003d gson.toJson(new ClassWithMembers());\r\n    assertThat(result).contains(\"\\\"str\\\":null\");\r\n}",
    "testNullWrappedPrimitiveMemberSerialization": "{\r\n    Gson gson \u003d gsonBuilder.serializeNulls().create();\r\n    ClassWithNullWrappedPrimitive target \u003d new ClassWithNullWrappedPrimitive();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"value\\\":null\");\r\n}",
    "testExplicitSerializationOfNullArrayMembers": "{\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithMembers target \u003d new ClassWithMembers();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"array\\\":null\");\r\n}",
    "testExplicitDeserializationOfNulls": "{\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithObjects target \u003d gson.fromJson(\"{\\\"bag\\\":null}\", ClassWithObjects.class);\r\n    assertThat(target.bag).isNull();\r\n}",
    "testExplicitSerializationOfNullCollectionMembers": "{\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithMembers target \u003d new ClassWithMembers();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"col\\\":null\");\r\n}",
    "testExplicitSerializationOfNullStringMembers": "{\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithMembers target \u003d new ClassWithMembers();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"str\\\":null\");\r\n}",
    "testTopLevelNullObjectSerialization": "{\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String actual \u003d gson.toJson(null);\r\n    assertThat(actual).isEqualTo(\"null\");\r\n    actual \u003d gson.toJson(null, String.class);\r\n    assertThat(actual).isEqualTo(\"null\");\r\n}",
    "serialize": "{\r\n    return context.serialize(null);\r\n}",
    "testExplicitNullSetsFieldToNullDuringDeserialization": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d \"{value:null}\";\r\n    ObjectWithField obj \u003d gson.fromJson(json, ObjectWithField.class);\r\n    assertThat(obj.value).isNull();\r\n}",
    "testCustomTypeAdapterPassesNullSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ObjectWithField.class, new JsonSerializer\u003cObjectWithField\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(ObjectWithField src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return context.serialize(null);\r\n        }\r\n    }).create();\r\n    ObjectWithField target \u003d new ObjectWithField();\r\n    target.value \u003d \"value1\";\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"value1\");\r\n}",
    "testPrintPrintingArraysWithNulls": "{\r\n    gsonBuilder \u003d new GsonBuilder();\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String result \u003d gson.toJson(new String[] { \"1\", null, \"3\" });\r\n    assertThat(result).isEqualTo(\"[\\\"1\\\",null,\\\"3\\\"]\");\r\n    gson \u003d gsonBuilder.serializeNulls().create();\r\n    result \u003d gson.toJson(new String[] { \"1\", null, \"3\" });\r\n    assertThat(result).isEqualTo(\"[\\\"1\\\",null,\\\"3\\\"]\");\r\n}",
    "testNullWrappedPrimitiveMemberDeserialization": "{\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String json \u003d \"{\u0027value\u0027:null}\";\r\n    ClassWithNullWrappedPrimitive target \u003d gson.fromJson(json, ClassWithNullWrappedPrimitive.class);\r\n    assertThat(target.value).isNull();\r\n}",
    "setUp": "{\r\n    gsonBuilder \u003d new GsonBuilder().serializeNulls();\r\n}",
    "testCustomTypeAdapterPassesNullDesrialization": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ObjectWithField.class, new JsonDeserializer\u003cObjectWithField\u003e() {\r\n\r\n        @Override\r\n        public ObjectWithField deserialize(JsonElement json, Type type, JsonDeserializationContext context) {\r\n            return context.deserialize(null, type);\r\n        }\r\n    }).create();\r\n    String json \u003d \"{value:\u0027value1\u0027}\";\r\n    ObjectWithField target \u003d gson.fromJson(json, ObjectWithField.class);\r\n    assertThat(target).isNull();\r\n}",
    "testTopLevelNullObjectDeserialization": "{\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String actual \u003d gson.fromJson(\"null\", String.class);\r\n    assertThat(actual).isNull();\r\n}",
    "deserialize": "{\r\n    return context.deserialize(null, type);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\TypeAdapter.java": {
    "toJson": "{\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    try {\r\n        toJson(stringWriter, value);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n    return stringWriter.toString();\r\n}",
    "read": "{\r\n    if (reader.peek() \u003d\u003d JsonToken.NULL) {\r\n        reader.nextNull();\r\n        return null;\r\n    }\r\n    return TypeAdapter.this.read(reader);\r\n}",
    "toJsonTree": "{\r\n    try {\r\n        JsonTreeWriter jsonWriter \u003d new JsonTreeWriter();\r\n        write(jsonWriter, value);\r\n        return jsonWriter.get();\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}",
    "fromJson": "{\r\n    return fromJson(new StringReader(json));\r\n}",
    "nullSafe": "{\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n            } else {\r\n                TypeAdapter.this.write(out, value);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader reader) throws IOException {\r\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\r\n                reader.nextNull();\r\n                return null;\r\n            }\r\n            return TypeAdapter.this.read(reader);\r\n        }\r\n    };\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        TypeAdapter.this.write(out, value);\r\n    }\r\n}",
    "fromJsonTree": "{\r\n    try {\r\n        JsonReader jsonReader \u003d new JsonTreeReader(jsonTree);\r\n        return read(jsonReader);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\TreeTypeAdaptersTest.java": {
    "getValue": "{\r\n    return value;\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(src.getValue());\r\n}",
    "getStudents": "{\r\n    return students;\r\n}",
    "testDeserializeId": "{\r\n    String json \u003d \"{courseId:1,students:[{id:1,name:\u0027first\u0027},{id:6,name:\u0027second\u0027}],\" + \"numAssignments:4,assignment:{}}\";\r\n    Course\u003cHistoryCourse\u003e target \u003d gson.fromJson(json, TYPE_COURSE_HISTORY);\r\n    assertThat(target.getStudents().get(0).id.getValue()).isEqualTo(\"1\");\r\n    assertThat(target.getStudents().get(1).id.getValue()).isEqualTo(\"6\");\r\n    assertThat(target.getId().getValue()).isEqualTo(\"1\");\r\n}",
    "setUp": "{\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(Id.class, new IdTreeTypeAdapter()).create();\r\n    course \u003d new Course\u003c\u003e(COURSE_ID, 4, new Assignment\u003cHistoryCourse\u003e(null, null), Arrays.asList(STUDENT1, STUDENT2));\r\n}",
    "getId": "{\r\n    return courseId;\r\n}",
    "testSerializeId": "{\r\n    String json \u003d gson.toJson(course, TYPE_COURSE_HISTORY);\r\n    assertThat(json).contains(String.valueOf(COURSE_ID.getValue()));\r\n    assertThat(json).contains(String.valueOf(STUDENT1_ID.getValue()));\r\n    assertThat(json).contains(String.valueOf(STUDENT2_ID.getValue()));\r\n}",
    "deserialize": "{\r\n    if (!(typeOfT instanceof ParameterizedType)) {\r\n        throw new JsonParseException(\"Id of unknown type: \" + typeOfT);\r\n    }\r\n    ParameterizedType parameterizedType \u003d (ParameterizedType) typeOfT;\r\n    // Since Id takes only one TypeVariable, the actual type corresponding to the first\r\n    // TypeVariable is the Type we are looking for\r\n    Type typeOfId \u003d parameterizedType.getActualTypeArguments()[0];\r\n    return new Id\u003c\u003e(json.getAsString(), typeOfId);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\FieldAttributesTest.java": {
    "testModifiers": "{\r\n    assertThat(fieldAttributes.hasModifier(Modifier.STATIC)).isFalse();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.FINAL)).isFalse();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.ABSTRACT)).isFalse();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.VOLATILE)).isFalse();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.PROTECTED)).isFalse();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.PUBLIC)).isTrue();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.TRANSIENT)).isTrue();\r\n}",
    "testDeclaringClass": "{\r\n    assertThat(fieldAttributes.getDeclaringClass()).isAssignableTo(Foo.class);\r\n}",
    "testNullField": "{\r\n    try {\r\n        new FieldAttributes(null);\r\n        fail(\"Field parameter can not be null\");\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "testDeclaredTypeAndClass": "{\r\n    Type expectedType \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(fieldAttributes.getDeclaredType()).isEqualTo(expectedType);\r\n    assertThat(fieldAttributes.getDeclaredClass()).isAssignableTo(List.class);\r\n}",
    "setUp": "{\r\n    fieldAttributes \u003d new FieldAttributes(Foo.class.getField(\"bar\"));\r\n}",
    "testName": "{\r\n    assertThat(fieldAttributes.getName()).isEqualTo(\"bar\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\NamingPolicyTest.java": {
    "testGsonWithNonDefaultFieldNamingPolicyDeserialiation": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();\r\n    String target \u003d \"{\\\"SomeConstantStringInstanceField\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "testGsonDuplicateNameDueToBadNamingPolicy": "{\r\n    Gson gson \u003d builder.setFieldNamingStrategy(new FieldNamingStrategy() {\r\n\r\n        @Override\r\n        public String translateName(Field f) {\r\n            return \"x\";\r\n        }\r\n    }).create();\r\n    try {\r\n        gson.toJson(new ClassWithTwoFields());\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Class com.google.gson.functional.NamingPolicyTest$ClassWithTwoFields declares multiple JSON fields named \u0027x\u0027;\" + \" conflict is caused by fields com.google.gson.functional.NamingPolicyTest$ClassWithTwoFields#a and\" + \" com.google.gson.functional.NamingPolicyTest$ClassWithTwoFields#b\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#duplicate-fields\");\r\n    }\r\n}",
    "testGsonWithLowerCaseDotPolicyDeserialiation": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();\r\n    String target \u003d \"{\\\"some.constant.string.instance.field\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "testGsonWithUpperCaseUnderscorePolicySerialization": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CASE_WITH_UNDERSCORES).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"SOME_CONSTANT_STRING_INSTANCE_FIELD\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "testGsonWithLowerCaseUnderscorePolicySerialization": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"some_constant_string_instance_field\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "translateName": "{\r\n    return f.getName().toUpperCase(Locale.ROOT);\r\n}",
    "testGsonWithLowerCaseDotPolicySerialization": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"some.constant.string.instance.field\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "testGsonWithLowerCaseDashPolicyDeserialiation": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();\r\n    String target \u003d \"{\\\"some-constant-string-instance-field\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "testComplexFieldNameStrategy": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new ClassWithComplexFieldName(10));\r\n    String escapedFieldName \u003d \"@value\\\\\\\"_s$\\\\\\\\\";\r\n    assertThat(json).isEqualTo(\"{\\\"\" + escapedFieldName + \"\\\":10}\");\r\n    ClassWithComplexFieldName obj \u003d gson.fromJson(json, ClassWithComplexFieldName.class);\r\n    assertThat(obj.value).isEqualTo(10);\r\n}",
    "testGsonWithSerializedNameFieldNamingPolicySerialization": "{\r\n    Gson gson \u003d builder.create();\r\n    ClassWithSerializedNameFields expected \u003d new ClassWithSerializedNameFields(5, 6);\r\n    String actual \u003d gson.toJson(expected);\r\n    assertThat(actual).isEqualTo(expected.getExpectedJson());\r\n}",
    "testGsonWithUpperCamelCaseSpacesPolicySerialiation": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"Some Constant String Instance Field\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "testGsonWithNonDefaultFieldNamingPolicySerialization": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"SomeConstantStringInstanceField\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "testGsonWithLowerCaseDashPolicySerialization": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"some-constant-string-instance-field\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerialization": "{\r\n    Gson gson \u003d builder.create();\r\n    try {\r\n        ClassWithDuplicateFields target \u003d new ClassWithDuplicateFields(10);\r\n        gson.toJson(target);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Class com.google.gson.functional.NamingPolicyTest$ClassWithDuplicateFields declares multiple JSON fields named \u0027a\u0027;\" + \" conflict is caused by fields com.google.gson.functional.NamingPolicyTest$ClassWithDuplicateFields#a and\" + \" com.google.gson.functional.NamingPolicyTest$ClassWithDuplicateFields#b\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#duplicate-fields\");\r\n    }\r\n}",
    "setUp": "{\r\n    builder \u003d new GsonBuilder();\r\n}",
    "testGsonWithLowerCaseUnderscorePolicyDeserialiation": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\r\n    String target \u003d \"{\\\"some_constant_string_instance_field\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "testGsonWithUpperCaseUnderscorePolicyDeserialiation": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CASE_WITH_UNDERSCORES).create();\r\n    String target \u003d \"{\\\"SOME_CONSTANT_STRING_INSTANCE_FIELD\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "testDeprecatedNamingStrategy": "{\r\n    Gson gson \u003d builder.setFieldNamingStrategy(new UpperCaseNamingStrategy()).create();\r\n    ClassWithDuplicateFields target \u003d new ClassWithDuplicateFields(10);\r\n    String actual \u003d gson.toJson(target);\r\n    assertThat(actual).isEqualTo(\"{\\\"A\\\":10}\");\r\n}",
    "testAtSignInSerializedName": "{\r\n    assertThat(new Gson().toJson(new AtName())).isEqualTo(\"{\\\"@foo\\\":\\\"bar\\\"}\");\r\n}",
    "testGsonWithSerializedNameFieldNamingPolicyDeserialization": "{\r\n    Gson gson \u003d builder.create();\r\n    ClassWithSerializedNameFields expected \u003d new ClassWithSerializedNameFields(5, 7);\r\n    ClassWithSerializedNameFields actual \u003d gson.fromJson(expected.getExpectedJson(), ClassWithSerializedNameFields.class);\r\n    assertThat(actual.f).isEqualTo(expected.f);\r\n}",
    "testGsonWithUpperCamelCaseSpacesPolicyDeserialiation": "{\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create();\r\n    String target \u003d \"{\\\"Some Constant String Instance Field\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JavaUtilTest.java": {
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testProperties": "{\r\n    Properties props \u003d gson.fromJson(\"{\u0027a\u0027:\u0027v1\u0027,\u0027b\u0027:\u0027v2\u0027}\", Properties.class);\r\n    assertThat(props.getProperty(\"a\")).isEqualTo(\"v1\");\r\n    assertThat(props.getProperty(\"b\")).isEqualTo(\"v2\");\r\n    String json \u003d gson.toJson(props);\r\n    assertThat(json).contains(\"\\\"a\\\":\\\"v1\\\"\");\r\n    assertThat(json).contains(\"\\\"b\\\":\\\"v2\\\"\");\r\n}",
    "testCurrency": "{\r\n    CurrencyHolder target \u003d gson.fromJson(\"{\u0027value\u0027:\u0027USD\u0027}\", CurrencyHolder.class);\r\n    assertThat(target.value.getCurrencyCode()).isEqualTo(\"USD\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"{\\\"value\\\":\\\"USD\\\"}\");\r\n    // null handling\r\n    target \u003d gson.fromJson(\"{\u0027value\u0027:null}\", CurrencyHolder.class);\r\n    assertThat(target.value).isNull();\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{}\");\r\n}"
  },
  "google_json\\extras\\src\\test\\java\\com\\google\\gson\\typeadapters\\PostConstructAdapterFactoryTest.java": {
    "testList": "{\r\n    MultipleSandwiches sandwiches \u003d new MultipleSandwiches(Arrays.asList(new Sandwich(\"white\", \"cheddar\"), new Sandwich(\"whole wheat\", \"swiss\")));\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(new PostConstructAdapterFactory()).create();\r\n    // Throws NullPointerException without the fix in https://github.com/google/gson/pull/1103\r\n    String json \u003d gson.toJson(sandwiches);\r\n    assertEquals(\"{\\\"sandwiches\\\":[{\\\"bread\\\":\\\"white\\\",\\\"cheese\\\":\\\"cheddar\\\"},{\\\"bread\\\":\\\"whole wheat\\\",\\\"cheese\\\":\\\"swiss\\\"}]}\", json);\r\n    MultipleSandwiches sandwichesFromJson \u003d gson.fromJson(json, MultipleSandwiches.class);\r\n    assertEquals(sandwiches, sandwichesFromJson);\r\n}",
    "test": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(new PostConstructAdapterFactory()).create();\r\n    gson.fromJson(\"{\\\"bread\\\": \\\"white\\\", \\\"cheese\\\": \\\"cheddar\\\"}\", Sandwich.class);\r\n    try {\r\n        gson.fromJson(\"{\\\"bread\\\": \\\"cheesey bread\\\", \\\"cheese\\\": \\\"swiss\\\"}\", Sandwich.class);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertEquals(\"too cheesey\", expected.getMessage());\r\n    }\r\n}",
    "equals": "{\r\n    if (o \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof MultipleSandwiches)) {\r\n        return false;\r\n    }\r\n    final MultipleSandwiches other \u003d (MultipleSandwiches) o;\r\n    if (this.sandwiches \u003d\u003d null ? other.sandwiches !\u003d null : !this.sandwiches.equals(other.sandwiches)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}",
    "validate": "{\r\n    if (bread.equals(\"cheesey bread\") \u0026\u0026 cheese !\u003d null) {\r\n        throw new IllegalArgumentException(\"too cheesey\");\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java": {
    "setFieldNamingPolicy": "{\r\n    return setFieldNamingStrategy(namingConvention);\r\n}",
    "enableComplexMapKeySerialization": "{\r\n    complexMapKeySerialization \u003d true;\r\n    return this;\r\n}",
    "disableInnerClassSerialization": "{\r\n    excluder \u003d excluder.disableInnerClassSerialization();\r\n    return this;\r\n}",
    "excludeFieldsWithModifiers": "{\r\n    Objects.requireNonNull(modifiers);\r\n    excluder \u003d excluder.withModifiers(modifiers);\r\n    return this;\r\n}",
    "setLenient": "{\r\n    return setStrictness(Strictness.LENIENT);\r\n}",
    "serializeNulls": "{\r\n    this.serializeNulls \u003d true;\r\n    return this;\r\n}",
    "disableJdkUnsafe": "{\r\n    this.useJdkUnsafe \u003d false;\r\n    return this;\r\n}",
    "generateNonExecutableJson": "{\r\n    this.generateNonExecutableJson \u003d true;\r\n    return this;\r\n}",
    "addSerializationExclusionStrategy": "{\r\n    Objects.requireNonNull(strategy);\r\n    excluder \u003d excluder.withExclusionStrategy(strategy, true, false);\r\n    return this;\r\n}",
    "registerTypeHierarchyAdapter": "{\r\n    Objects.requireNonNull(baseType);\r\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e || typeAdapter instanceof TypeAdapter\u003c?\u003e);\r\n    if (JsonElement.class.isAssignableFrom(baseType)) {\r\n        throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + baseType);\r\n    }\r\n    if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\r\n        hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\r\n    }\r\n    if (typeAdapter instanceof TypeAdapter\u003c?\u003e) {\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapterFactory factory \u003d TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter) typeAdapter);\r\n        factories.add(factory);\r\n    }\r\n    return this;\r\n}",
    "addDeserializationExclusionStrategy": "{\r\n    Objects.requireNonNull(strategy);\r\n    excluder \u003d excluder.withExclusionStrategy(strategy, false, true);\r\n    return this;\r\n}",
    "setLongSerializationPolicy": "{\r\n    this.longSerializationPolicy \u003d Objects.requireNonNull(serializationPolicy);\r\n    return this;\r\n}",
    "registerTypeAdapterFactory": "{\r\n    Objects.requireNonNull(factory);\r\n    factories.add(factory);\r\n    return this;\r\n}",
    "create": "{\r\n    List\u003cTypeAdapterFactory\u003e factories \u003d new ArrayList\u003c\u003e(this.factories.size() + this.hierarchyFactories.size() + 3);\r\n    factories.addAll(this.factories);\r\n    Collections.reverse(factories);\r\n    List\u003cTypeAdapterFactory\u003e hierarchyFactories \u003d new ArrayList\u003c\u003e(this.hierarchyFactories);\r\n    Collections.reverse(hierarchyFactories);\r\n    factories.addAll(hierarchyFactories);\r\n    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);\r\n    return new Gson(excluder, fieldNamingPolicy, new HashMap\u003c\u003e(instanceCreators), serializeNulls, complexMapKeySerialization, generateNonExecutableJson, escapeHtmlChars, formattingStyle, strictness, serializeSpecialFloatingPointValues, useJdkUnsafe, longSerializationPolicy, datePattern, dateStyle, timeStyle, new ArrayList\u003c\u003e(this.factories), new ArrayList\u003c\u003e(this.hierarchyFactories), factories, objectToNumberStrategy, numberToNumberStrategy, new ArrayList\u003c\u003e(reflectionFilters));\r\n}",
    "setFormattingStyle": "{\r\n    this.formattingStyle \u003d Objects.requireNonNull(formattingStyle);\r\n    return this;\r\n}",
    "disableHtmlEscaping": "{\r\n    this.escapeHtmlChars \u003d false;\r\n    return this;\r\n}",
    "addReflectionAccessFilter": "{\r\n    Objects.requireNonNull(filter);\r\n    reflectionFilters.addFirst(filter);\r\n    return this;\r\n}",
    "setDateFormat": "{\r\n    this.dateStyle \u003d dateStyle;\r\n    this.timeStyle \u003d timeStyle;\r\n    this.datePattern \u003d null;\r\n    return this;\r\n}",
    "setObjectToNumberStrategy": "{\r\n    this.objectToNumberStrategy \u003d Objects.requireNonNull(objectToNumberStrategy);\r\n    return this;\r\n}",
    "setVersion": "{\r\n    if (Double.isNaN(version) || version \u003c 0.0) {\r\n        throw new IllegalArgumentException(\"Invalid version: \" + version);\r\n    }\r\n    excluder \u003d excluder.withVersion(version);\r\n    return this;\r\n}",
    "setNumberToNumberStrategy": "{\r\n    this.numberToNumberStrategy \u003d Objects.requireNonNull(numberToNumberStrategy);\r\n    return this;\r\n}",
    "setFieldNamingStrategy": "{\r\n    this.fieldNamingPolicy \u003d Objects.requireNonNull(fieldNamingStrategy);\r\n    return this;\r\n}",
    "addTypeAdaptersForDate": "{\r\n    TypeAdapterFactory dateAdapterFactory;\r\n    boolean sqlTypesSupported \u003d SqlTypesSupport.SUPPORTS_SQL_TYPES;\r\n    TypeAdapterFactory sqlTimestampAdapterFactory \u003d null;\r\n    TypeAdapterFactory sqlDateAdapterFactory \u003d null;\r\n    if (datePattern !\u003d null \u0026\u0026 !datePattern.trim().isEmpty()) {\r\n        dateAdapterFactory \u003d DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(datePattern);\r\n        if (sqlTypesSupported) {\r\n            sqlTimestampAdapterFactory \u003d SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(datePattern);\r\n            sqlDateAdapterFactory \u003d SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(datePattern);\r\n        }\r\n    } else if (dateStyle !\u003d DateFormat.DEFAULT \u0026\u0026 timeStyle !\u003d DateFormat.DEFAULT) {\r\n        dateAdapterFactory \u003d DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(dateStyle, timeStyle);\r\n        if (sqlTypesSupported) {\r\n            sqlTimestampAdapterFactory \u003d SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);\r\n            sqlDateAdapterFactory \u003d SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);\r\n        }\r\n    } else {\r\n        return;\r\n    }\r\n    factories.add(dateAdapterFactory);\r\n    if (sqlTypesSupported) {\r\n        factories.add(sqlTimestampAdapterFactory);\r\n        factories.add(sqlDateAdapterFactory);\r\n    }\r\n}",
    "serializeSpecialFloatingPointValues": "{\r\n    this.serializeSpecialFloatingPointValues \u003d true;\r\n    return this;\r\n}",
    "setPrettyPrinting": "{\r\n    return setFormattingStyle(FormattingStyle.PRETTY);\r\n}",
    "registerTypeAdapter": "{\r\n    Objects.requireNonNull(type);\r\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e || typeAdapter instanceof InstanceCreator\u003c?\u003e || typeAdapter instanceof TypeAdapter\u003c?\u003e);\r\n    if (isTypeObjectOrJsonElement(type)) {\r\n        throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + type);\r\n    }\r\n    if (typeAdapter instanceof InstanceCreator\u003c?\u003e) {\r\n        instanceCreators.put(type, (InstanceCreator\u003c?\u003e) typeAdapter);\r\n    }\r\n    if (typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e) {\r\n        TypeToken\u003c?\u003e typeToken \u003d TypeToken.get(type);\r\n        factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));\r\n    }\r\n    if (typeAdapter instanceof TypeAdapter\u003c?\u003e) {\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapterFactory factory \u003d TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter) typeAdapter);\r\n        factories.add(factory);\r\n    }\r\n    return this;\r\n}",
    "isTypeObjectOrJsonElement": "{\r\n    return type instanceof Class \u0026\u0026 (type \u003d\u003d Object.class || JsonElement.class.isAssignableFrom((Class\u003c?\u003e) type));\r\n}",
    "setStrictness": "{\r\n    this.strictness \u003d Objects.requireNonNull(strictness);\r\n    return this;\r\n}",
    "excludeFieldsWithoutExposeAnnotation": "{\r\n    excluder \u003d excluder.excludeFieldsWithoutExposeAnnotation();\r\n    return this;\r\n}",
    "setExclusionStrategies": "{\r\n    Objects.requireNonNull(strategies);\r\n    for (ExclusionStrategy strategy : strategies) {\r\n        excluder \u003d excluder.withExclusionStrategy(strategy, true, true);\r\n    }\r\n    return this;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\CommentsTest.java": {
    "testParseComments": "{\r\n    String json \u003d \"[\\n\" + \"  // this is a comment\\n\" + \"  \\\"a\\\",\\n\" + \"  /* this is another comment */\\n\" + \"  \\\"b\\\",\\n\" + \"  # this is yet another comment\\n\" + \"  \\\"c\\\"\\n\" + \"]\";\r\n    List\u003cString\u003e abc \u003d new Gson().fromJson(json, new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(abc).containsExactly(\"a\", \"b\", \"c\").inOrder();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\CustomSerializerTest.java": {
    "testSerializerReturnsNull": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return null;\r\n        }\r\n    }).create();\r\n    JsonElement json \u003d gson.toJsonTree(new Base());\r\n    assertThat(json.isJsonNull()).isTrue();\r\n}",
    "serialize": "{\r\n    return null;\r\n}",
    "testSubClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstances": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new BaseSerializer()).registerTypeAdapter(Sub.class, new SubSerializer()).create();\r\n    ClassWithBaseField target \u003d new ClassWithBaseField(new Sub());\r\n    JsonObject json \u003d (JsonObject) gson.toJsonTree(target);\r\n    JsonObject base \u003d json.get(\"base\").getAsJsonObject();\r\n    assertThat(base.get(Base.SERIALIZER_KEY).getAsString()).isEqualTo(SubSerializer.NAME);\r\n}",
    "testBaseClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstances": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new BaseSerializer()).create();\r\n    ClassWithBaseField target \u003d new ClassWithBaseField(new Sub());\r\n    JsonObject json \u003d (JsonObject) gson.toJsonTree(target);\r\n    JsonObject base \u003d json.get(\"base\").getAsJsonObject();\r\n    assertThat(base.get(Base.SERIALIZER_KEY).getAsString()).isEqualTo(BaseSerializer.NAME);\r\n}",
    "testBaseClassSerializerInvokedForBaseClassFields": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new BaseSerializer()).registerTypeAdapter(Sub.class, new SubSerializer()).create();\r\n    ClassWithBaseField target \u003d new ClassWithBaseField(new Base());\r\n    JsonObject json \u003d (JsonObject) gson.toJsonTree(target);\r\n    JsonObject base \u003d json.get(\"base\").getAsJsonObject();\r\n    assertThat(base.get(Base.SERIALIZER_KEY).getAsString()).isEqualTo(BaseSerializer.NAME);\r\n}",
    "testSubClassSerializerInvokedForBaseClassFieldsHoldingArrayOfSubClassInstances": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new BaseSerializer()).registerTypeAdapter(Sub.class, new SubSerializer()).create();\r\n    ClassWithBaseArrayField target \u003d new ClassWithBaseArrayField(new Base[] { new Sub(), new Sub() });\r\n    JsonObject json \u003d (JsonObject) gson.toJsonTree(target);\r\n    JsonArray array \u003d json.get(\"base\").getAsJsonArray();\r\n    for (JsonElement element : array) {\r\n        JsonElement serializerKey \u003d element.getAsJsonObject().get(Base.SERIALIZER_KEY);\r\n        assertThat(serializerKey.getAsString()).isEqualTo(SubSerializer.NAME);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\DefaultMapJsonSerializerTest.java": {
    "testEmptyMapSerialization": "{\r\n    Type mapType \u003d new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, String\u003e emptyMap \u003d new HashMap\u003c\u003e();\r\n    JsonElement element \u003d gson.toJsonTree(emptyMap, mapType);\r\n    assertThat(element).isInstanceOf(JsonObject.class);\r\n    JsonObject emptyMapJsonObject \u003d (JsonObject) element;\r\n    assertThat(emptyMapJsonObject.entrySet()).isEmpty();\r\n}",
    "testNonEmptyMapSerialization": "{\r\n    Type mapType \u003d new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, String\u003e myMap \u003d new HashMap\u003c\u003e();\r\n    String key \u003d \"key1\";\r\n    myMap.put(key, \"value1\");\r\n    Gson gson \u003d new Gson();\r\n    JsonElement element \u003d gson.toJsonTree(myMap, mapType);\r\n    assertThat(element.isJsonObject()).isTrue();\r\n    JsonObject mapJsonObject \u003d element.getAsJsonObject();\r\n    assertThat(mapJsonObject.has(key)).isTrue();\r\n}",
    "testEmptyMapNoTypeSerialization": "{\r\n    Map\u003cString, String\u003e emptyMap \u003d new HashMap\u003c\u003e();\r\n    JsonElement element \u003d gson.toJsonTree(emptyMap, emptyMap.getClass());\r\n    assertThat(element).isInstanceOf(JsonObject.class);\r\n    JsonObject emptyMapJsonObject \u003d (JsonObject) element;\r\n    assertThat(emptyMapJsonObject.entrySet()).isEmpty();\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\package-info.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\NonNullElementWrapperList.java": {
    "add": "{\r\n    delegate.add(index, nonNull(element));\r\n}",
    "set": "{\r\n    return delegate.set(index, nonNull(element));\r\n}",
    "clear": "{\r\n    delegate.clear();\r\n}",
    "remove": "{\r\n    return delegate.remove(o);\r\n}",
    "lastIndexOf": "{\r\n    return delegate.lastIndexOf(o);\r\n}",
    "removeAll": "{\r\n    return delegate.removeAll(c);\r\n}",
    "contains": "{\r\n    return delegate.contains(o);\r\n}",
    "size": "{\r\n    return delegate.size();\r\n}",
    "hashCode": "{\r\n    return delegate.hashCode();\r\n}",
    "get": "{\r\n    return delegate.get(index);\r\n}",
    "equals": "{\r\n    return delegate.equals(o);\r\n}",
    "toArray": "{\r\n    return delegate.toArray(a);\r\n}",
    "indexOf": "{\r\n    return delegate.indexOf(o);\r\n}",
    "nonNull": "{\r\n    if (element \u003d\u003d null) {\r\n        throw new NullPointerException(\"Element must be non-null\");\r\n    }\r\n    return element;\r\n}",
    "retainAll": "{\r\n    return delegate.retainAll(c);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonSerializer.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\EnumWithObfuscatedTest.java": {
    "testEnumClassWithObfuscated": "{\r\n    for (Gender enumConstant : Gender.class.getEnumConstants()) {\r\n        try {\r\n            Gender.class.getField(enumConstant.name());\r\n            fail(\"Enum is not obfuscated\");\r\n        } catch (NoSuchFieldException ignore) {\r\n        }\r\n    }\r\n    assertThat(gson.fromJson(\"\\\"MAIL\\\"\", Gender.class)).isEqualTo(Gender.MALE);\r\n    assertThat(gson.toJson(Gender.MALE, Gender.class)).isEqualTo(\"\\\"MAIL\\\"\");\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithExposeAnnotation.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\Streams.java": {
    "writerForAppendable": "{\r\n    return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\r\n}",
    "flush": "{\r\n}",
    "setChars": "{\r\n    this.chars \u003d chars;\r\n    this.cachedString \u003d null;\r\n}",
    "length": "{\r\n    return chars.length;\r\n}",
    "toString": "{\r\n    if (cachedString \u003d\u003d null) {\r\n        cachedString \u003d new String(chars);\r\n    }\r\n    return cachedString;\r\n}",
    "parse": "{\r\n    boolean isEmpty \u003d true;\r\n    try {\r\n        JsonToken unused \u003d reader.peek();\r\n        isEmpty \u003d false;\r\n        return TypeAdapters.JSON_ELEMENT.read(reader);\r\n    } catch (EOFException e) {\r\n        /*\r\n       * For compatibility with JSON 1.5 and earlier, we return a JsonNull for\r\n       * empty documents instead of throwing.\r\n       */\r\n        if (isEmpty) {\r\n            return JsonNull.INSTANCE;\r\n        }\r\n        // The stream ended prematurely so it is likely a syntax error.\r\n        throw new JsonSyntaxException(e);\r\n    } catch (MalformedJsonException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(e);\r\n    }\r\n}",
    "subSequence": "{\r\n    return new String(chars, start, end - start);\r\n}",
    "write": "{\r\n    // Appendable.append turns null -\u003e \"null\", which is not desired here\r\n    Objects.requireNonNull(str);\r\n    appendable.append(str, off, off + len);\r\n}",
    "close": "{\r\n}",
    "append": "{\r\n    appendable.append(csq, start, end);\r\n    return this;\r\n}",
    "charAt": "{\r\n    return chars[i];\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\ToNumberPolicyTest.java": {
    "testLongOrDouble": "{\r\n    ToNumberStrategy strategy \u003d ToNumberPolicy.LONG_OR_DOUBLE;\r\n    assertThat(strategy.readNumber(fromString(\"10\"))).isEqualTo(10L);\r\n    assertThat(strategy.readNumber(fromString(\"10.1\"))).isEqualTo(10.1);\r\n    assertThat(strategy.readNumber(fromString(\"3.141592653589793238462643383279\"))).isEqualTo(3.141592653589793D);\r\n    Exception e \u003d assertThrows(MalformedJsonException.class, () -\u003e strategy.readNumber(fromString(\"1e400\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: Infinity; at path $\");\r\n    e \u003d assertThrows(JsonParseException.class, () -\u003e strategy.readNumber(fromString(\"\\\"not-a-number\\\"\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Cannot parse not-a-number; at path $\");\r\n    assertThat(strategy.readNumber(fromStringLenient(\"NaN\"))).isEqualTo(Double.NaN);\r\n    assertThat(strategy.readNumber(fromStringLenient(\"Infinity\"))).isEqualTo(Double.POSITIVE_INFINITY);\r\n    assertThat(strategy.readNumber(fromStringLenient(\"-Infinity\"))).isEqualTo(Double.NEGATIVE_INFINITY);\r\n    e \u003d assertThrows(MalformedJsonException.class, () -\u003e strategy.readNumber(fromString(\"NaN\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON at line 1 column 1 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    e \u003d assertThrows(MalformedJsonException.class, () -\u003e strategy.readNumber(fromString(\"Infinity\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON at line 1 column 1 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    e \u003d assertThrows(MalformedJsonException.class, () -\u003e strategy.readNumber(fromString(\"-Infinity\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON at line 1 column 1 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n}",
    "fromStringLenient": "{\r\n    JsonReader jsonReader \u003d fromString(json);\r\n    jsonReader.setStrictness(Strictness.LENIENT);\r\n    return jsonReader;\r\n}",
    "testLazilyParsedNumber": "{\r\n    ToNumberStrategy strategy \u003d ToNumberPolicy.LAZILY_PARSED_NUMBER;\r\n    assertThat(strategy.readNumber(fromString(\"10.1\"))).isEqualTo(new LazilyParsedNumber(\"10.1\"));\r\n    assertThat(strategy.readNumber(fromString(\"3.141592653589793238462643383279\"))).isEqualTo(new LazilyParsedNumber(\"3.141592653589793238462643383279\"));\r\n    assertThat(strategy.readNumber(fromString(\"1e400\"))).isEqualTo(new LazilyParsedNumber(\"1e400\"));\r\n}",
    "fromString": "{\r\n    return new JsonReader(new StringReader(json));\r\n}",
    "testNullsAreNeverExpected": "{\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e ToNumberPolicy.DOUBLE.readNumber(fromString(\"null\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Expected a double but was NULL at line 1 column 5 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#adapter-not-null-safe\");\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e ToNumberPolicy.LAZILY_PARSED_NUMBER.readNumber(fromString(\"null\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Expected a string but was NULL at line 1 column 5 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#adapter-not-null-safe\");\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e ToNumberPolicy.LONG_OR_DOUBLE.readNumber(fromString(\"null\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Expected a string but was NULL at line 1 column 5 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#adapter-not-null-safe\");\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e ToNumberPolicy.BIG_DECIMAL.readNumber(fromString(\"null\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Expected a string but was NULL at line 1 column 5 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#adapter-not-null-safe\");\r\n}",
    "testBigDecimal": "{\r\n    ToNumberStrategy strategy \u003d ToNumberPolicy.BIG_DECIMAL;\r\n    assertThat(strategy.readNumber(fromString(\"10.1\"))).isEqualTo(new BigDecimal(\"10.1\"));\r\n    assertThat(strategy.readNumber(fromString(\"3.141592653589793238462643383279\"))).isEqualTo(new BigDecimal(\"3.141592653589793238462643383279\"));\r\n    assertThat(strategy.readNumber(fromString(\"1e400\"))).isEqualTo(new BigDecimal(\"1e400\"));\r\n    JsonParseException e \u003d assertThrows(JsonParseException.class, () -\u003e strategy.readNumber(fromString(\"\\\"not-a-number\\\"\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Cannot parse not-a-number; at path $\");\r\n}",
    "testDouble": "{\r\n    ToNumberStrategy strategy \u003d ToNumberPolicy.DOUBLE;\r\n    assertThat(strategy.readNumber(fromString(\"10.1\"))).isEqualTo(10.1);\r\n    assertThat(strategy.readNumber(fromString(\"3.141592653589793238462643383279\"))).isEqualTo(3.141592653589793D);\r\n    MalformedJsonException e \u003d assertThrows(MalformedJsonException.class, () -\u003e strategy.readNumber(fromString(\"1e400\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: Infinity at line 1 column 6 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    assertThrows(NumberFormatException.class, () -\u003e strategy.readNumber(fromString(\"\\\"not-a-number\\\"\")));\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\NoSerializedNameMain.java": {
    "runTestHasArgsConstructor": "{\r\n    TestClassHasArgsConstructor deserialized \u003d new Gson().fromJson(\"{\\\"s\\\":\\\"value\\\"}\", same(TestClassHasArgsConstructor.class));\r\n    return deserialized.s;\r\n}",
    "runTestNoArgsConstructor": "{\r\n    TestClassNoArgsConstructor deserialized \u003d new Gson().fromJson(\"{\\\"s\\\":\\\"value\\\"}\", same(TestClassNoArgsConstructor.class));\r\n    return deserialized.s;\r\n}",
    "runTestNoJdkUnsafe": "{\r\n    Gson gson \u003d new GsonBuilder().disableJdkUnsafe().create();\r\n    TestClassNotAbstract deserialized \u003d gson.fromJson(\"{\\\"s\\\": \\\"value\\\"}\", same(TestClassNotAbstract.class));\r\n    return deserialized.s;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java": {
    "createAdapter": "{\r\n    // TODO: The exception messages created by ConstructorConstructor are currently written in the context of\r\n    // deserialization and for example suggest usage of TypeAdapter, which would not work for @JsonAdapter usage\r\n    return constructorConstructor.get(TypeToken.get(adapterClass)).construct();\r\n}",
    "getAnnotation": "{\r\n    return rawType.getAnnotation(JsonAdapter.class);\r\n}",
    "getTypeAdapter": "{\r\n    Object instance \u003d createAdapter(constructorConstructor, annotation.value());\r\n    TypeAdapter\u003c?\u003e typeAdapter;\r\n    boolean nullSafe \u003d annotation.nullSafe();\r\n    if (instance instanceof TypeAdapter) {\r\n        typeAdapter \u003d (TypeAdapter\u003c?\u003e) instance;\r\n    } else if (instance instanceof TypeAdapterFactory) {\r\n        TypeAdapterFactory factory \u003d (TypeAdapterFactory) instance;\r\n        if (isClassAnnotation) {\r\n            factory \u003d putFactoryAndGetCurrent(type.getRawType(), factory);\r\n        }\r\n        typeAdapter \u003d factory.create(gson, type);\r\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\r\n        JsonSerializer\u003c?\u003e serializer \u003d instance instanceof JsonSerializer ? (JsonSerializer\u003c?\u003e) instance : null;\r\n        JsonDeserializer\u003c?\u003e deserializer \u003d instance instanceof JsonDeserializer ? (JsonDeserializer\u003c?\u003e) instance : null;\r\n        // Uses dummy factory instances because TreeTypeAdapter needs a \u0027skipPast\u0027 factory for `Gson.getDelegateAdapter`\r\n        // call and has to differentiate there whether TreeTypeAdapter was created for @JsonAdapter on class or field\r\n        TypeAdapterFactory skipPast;\r\n        if (isClassAnnotation) {\r\n            skipPast \u003d TREE_TYPE_CLASS_DUMMY_FACTORY;\r\n        } else {\r\n            skipPast \u003d TREE_TYPE_FIELD_DUMMY_FACTORY;\r\n        }\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapter\u003c?\u003e tempAdapter \u003d new TreeTypeAdapter(serializer, deserializer, gson, type, skipPast, nullSafe);\r\n        typeAdapter \u003d tempAdapter;\r\n        // TreeTypeAdapter handles nullSafe; don\u0027t additionally call `nullSafe()`\r\n        nullSafe \u003d false;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \" + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString() + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\" + \" JsonSerializer or JsonDeserializer.\");\r\n    }\r\n    if (typeAdapter !\u003d null \u0026\u0026 nullSafe) {\r\n        typeAdapter \u003d typeAdapter.nullSafe();\r\n    }\r\n    return typeAdapter;\r\n}",
    "isClassJsonAdapterFactory": "{\r\n    Objects.requireNonNull(type);\r\n    Objects.requireNonNull(factory);\r\n    if (factory \u003d\u003d TREE_TYPE_CLASS_DUMMY_FACTORY) {\r\n        return true;\r\n    }\r\n    // Using raw type to match behavior of `create(Gson, TypeToken\u003cT\u003e)` above\r\n    Class\u003c?\u003e rawType \u003d type.getRawType();\r\n    TypeAdapterFactory existingFactory \u003d adapterFactoryMap.get(rawType);\r\n    if (existingFactory !\u003d null) {\r\n        // Checks for reference equality, like it is done by `Gson.getDelegateAdapter`\r\n        return existingFactory \u003d\u003d factory;\r\n    }\r\n    // If no factory has been created for the type yet check manually for a @JsonAdapter annotation\r\n    // which specifies a TypeAdapterFactory\r\n    // Otherwise behavior would not be consistent, depending on whether or not adapter had been requested\r\n    // before call to `isClassJsonAdapterFactory` was made\r\n    JsonAdapter annotation \u003d getAnnotation(rawType);\r\n    if (annotation \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    Class\u003c?\u003e adapterClass \u003d annotation.value();\r\n    if (!TypeAdapterFactory.class.isAssignableFrom(adapterClass)) {\r\n        return false;\r\n    }\r\n    Object adapter \u003d createAdapter(constructorConstructor, adapterClass);\r\n    TypeAdapterFactory newFactory \u003d (TypeAdapterFactory) adapter;\r\n    return putFactoryAndGetCurrent(rawType, newFactory) \u003d\u003d factory;\r\n}",
    "create": "{\r\n    Class\u003c? super T\u003e rawType \u003d targetType.getRawType();\r\n    JsonAdapter annotation \u003d getAnnotation(rawType);\r\n    if (annotation \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    return (TypeAdapter\u003cT\u003e) getTypeAdapter(constructorConstructor, gson, targetType, annotation, true);\r\n}",
    "putFactoryAndGetCurrent": "{\r\n    // Uses putIfAbsent in case multiple threads concurrently create factory\r\n    TypeAdapterFactory existingFactory \u003d adapterFactoryMap.putIfAbsent(rawType, factory);\r\n    return existingFactory !\u003d null ? existingFactory : factory;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\sql\\SqlTypesGsonTest.java": {
    "testDefaultSqlDateDeserialization": "{\r\n    String json \u003d \"\u0027Dec 3, 2009\u0027\";\r\n    java.sql.Date extracted \u003d gson.fromJson(json, java.sql.Date.class);\r\n    DefaultTypeAdaptersTest.assertEqualsDate(extracted, 2009, 11, 3);\r\n}",
    "testDefaultSqlTimeDeserialization": "{\r\n    String json \u003d \"\u00271:18:02 PM\u0027\";\r\n    Time extracted \u003d gson.fromJson(json, Time.class);\r\n    DefaultTypeAdaptersTest.assertEqualsTime(extracted, 13, 18, 2);\r\n}",
    "testDefaultSqlTimestampDeserialization": "{\r\n    String json \u003d \"\u0027Dec 3, 2009 1:18:02 PM\u0027\";\r\n    Timestamp extracted \u003d gson.fromJson(json, Timestamp.class);\r\n    DefaultTypeAdaptersTest.assertEqualsDate(extracted, 2009, 11, 3);\r\n    DefaultTypeAdaptersTest.assertEqualsTime(extracted, 13, 18, 2);\r\n}",
    "testTimestampSerialization": "{\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    try {\r\n        Timestamp timestamp \u003d new Timestamp(0L);\r\n        Gson gson \u003d new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create();\r\n        String json \u003d gson.toJson(timestamp, Timestamp.class);\r\n        assertThat(json).isEqualTo(\"\\\"1970-01-01\\\"\");\r\n        assertThat(gson.fromJson(\"\\\"1970-01-01\\\"\", Timestamp.class).getTime()).isEqualTo(0);\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "testDefaultSqlDateSerialization": "{\r\n    java.sql.Date instant \u003d new java.sql.Date(1259875082000L);\r\n    String json \u003d gson.toJson(instant);\r\n    assertThat(json).isEqualTo(\"\\\"Dec 3, 2009\\\"\");\r\n}",
    "testSqlDateSerialization": "{\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    try {\r\n        java.sql.Date sqlDate \u003d new java.sql.Date(0L);\r\n        Gson gson \u003d new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create();\r\n        String json \u003d gson.toJson(sqlDate, Timestamp.class);\r\n        assertThat(json).isEqualTo(\"\\\"1970-01-01\\\"\");\r\n        assertThat(gson.fromJson(\"\\\"1970-01-01\\\"\", java.sql.Date.class).getTime()).isEqualTo(0);\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "testDefaultSqlTimestampSerialization": "{\r\n    Timestamp now \u003d new java.sql.Timestamp(1259875082000L);\r\n    String json \u003d gson.toJson(now);\r\n    // The exact format of the serialized date-time string depends on the JDK version. The pattern\r\n    // here allows for an optional comma after the date, and what might be U+202F (Narrow No-Break\r\n    // Space) before \"PM\".\r\n    assertThat(json).matches(\"\\\"Dec 3, 2009,? 1:18:02\\\\hPM\\\"\");\r\n}",
    "testNullSerializationAndDeserialization": "{\r\n    DefaultTypeAdaptersTest.testNullSerializationAndDeserialization(gson, c);\r\n}",
    "setUp": "{\r\n    this.oldTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"));\r\n    this.oldLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    gson \u003d new Gson();\r\n}",
    "testDefaultSqlTimeSerialization": "{\r\n    Time now \u003d new Time(1259875082000L);\r\n    String json \u003d gson.toJson(now);\r\n    assertThat(json).isEqualTo(\"\\\"01:18:02 PM\\\"\");\r\n}",
    "tearDown": "{\r\n    TimeZone.setDefault(oldTimeZone);\r\n    Locale.setDefault(oldLocale);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonScope.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\JsonParserParameterizedTest.java": {
    "data": "{\r\n    return Arrays.asList(\"[]\", \"{}\", \"null\", \"1.0\", \"true\", \"\\\"string\\\"\", \"[true,1.0,null,{},2.0,{\\\"a\\\":[false]},[3.0,\\\"test\\\"],4.0]\", \"{\\\"\\\":1.0,\\\"a\\\":true,\\\"b\\\":null,\\\"c\\\":[],\\\"d\\\":{\\\"a1\\\":2.0,\\\"b2\\\":[true,{\\\"a3\\\":3.0}]},\\\"e\\\":[{\\\"f\\\":4.0},\\\"test\\\"]}\");\r\n}",
    "testParse": "{\r\n    JsonElement deserialized \u003d JsonParser.parseString(json);\r\n    String actualSerialized \u003d adapter.toJson(deserialized);\r\n    // Serialized JsonElement should be the same as original JSON\r\n    assertThat(actualSerialized).isEqualTo(json);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\SerializedNameTest.java": {
    "testFirstNameIsChosenForSerialization": "{\r\n    MyClass target \u003d new MyClass(\"v1\", \"v2\");\r\n    // Ensure name1 occurs exactly once, and name2 and name3 don\u0027t appear\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"name\\\":\\\"v1\\\",\\\"name1\\\":\\\"v2\\\"}\");\r\n}",
    "testMultipleNamesDeserializedCorrectly": "{\r\n    assertThat(gson.fromJson(\"{\u0027name\u0027:\u0027v1\u0027}\", MyClass.class).a).isEqualTo(\"v1\");\r\n    // Both name1 and name2 gets deserialized to b\r\n    assertThat(gson.fromJson(\"{\u0027name1\u0027:\u0027v11\u0027}\", MyClass.class).b).isEqualTo(\"v11\");\r\n    assertThat(gson.fromJson(\"{\u0027name2\u0027:\u0027v2\u0027}\", MyClass.class).b).isEqualTo(\"v2\");\r\n    assertThat(gson.fromJson(\"{\u0027name3\u0027:\u0027v3\u0027}\", MyClass.class).b).isEqualTo(\"v3\");\r\n}",
    "testMultipleNamesInTheSameString": "{\r\n    // The last value takes precedence\r\n    assertThat(gson.fromJson(\"{\u0027name1\u0027:\u0027v1\u0027,\u0027name2\u0027:\u0027v2\u0027,\u0027name3\u0027:\u0027v3\u0027}\", MyClass.class).b).isEqualTo(\"v3\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\metrics\\PerformanceTest.java": {
    "testLargeGsonMapRoundTrip": "{\r\n    Map\u003cLong, Long\u003e original \u003d new HashMap\u003c\u003e();\r\n    for (long i \u003d 0; i \u003c 1000000; i++) {\r\n        original.put(i, i + 1);\r\n    }\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(original);\r\n    Type longToLong \u003d new TypeToken\u003cMap\u003cLong, Long\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cLong, Long\u003e unused \u003d gson.fromJson(json, longToLong);\r\n}",
    "testSerializeExposedClasses": "{\r\n    ClassWithListOfObjects c1 \u003d new ClassWithListOfObjects(\"str\");\r\n    for (int i1 \u003d 0; i1 \u003c COLLECTION_SIZE; ++i1) {\r\n        c1.list.add(new ClassWithExposedField(\"element-\" + i1));\r\n    }\r\n    ClassWithListOfObjects c \u003d c1;\r\n    StringWriter w \u003d new StringWriter();\r\n    long t1 \u003d System.currentTimeMillis();\r\n    for (int i \u003d 0; i \u003c NUM_ITERATIONS; ++i) {\r\n        gson.toJson(c, w);\r\n    }\r\n    long t2 \u003d System.currentTimeMillis();\r\n    long avg \u003d (t2 - t1) / NUM_ITERATIONS;\r\n    System.out.printf(\"Serialize exposed classes avg time: %d ms\\n\", avg);\r\n}",
    "testLargeCollectionDeserialization": "{\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    int count \u003d 87000;\r\n    boolean first \u003d true;\r\n    sb.append(\u0027[\u0027);\r\n    for (int i \u003d 0; i \u003c count; ++i) {\r\n        if (first) {\r\n            first \u003d false;\r\n        } else {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"{name:\u0027name\").append(i).append(\"\u0027,value:\u0027value\").append(i).append(\"\u0027}\");\r\n    }\r\n    sb.append(\u0027]\u0027);\r\n    String json \u003d sb.toString();\r\n    Type collectionType \u003d new TypeToken\u003cArrayList\u003cCollectionEntry\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cCollectionEntry\u003e list \u003d gson.fromJson(json, collectionType);\r\n    assertThat(list).hasSize(count);\r\n}",
    "testByteArraySerialization": "{\r\n    for (int size \u003d 4145152; true; size +\u003d 1036288) {\r\n        byte[] ba \u003d new byte[size];\r\n        for (int i \u003d 0; i \u003c size; ++i) {\r\n            ba[i] \u003d 0x05;\r\n        }\r\n        String unused \u003d gson.toJson(ba);\r\n        System.out.printf(\"Gson could serialize a byte array of size: %d\\n\", size);\r\n    }\r\n}",
    "testDeserializeExposedClasses": "{\r\n    String json \u003d buildJsonForClassWithList();\r\n    ClassWithListOfObjects[] target \u003d new ClassWithListOfObjects[NUM_ITERATIONS];\r\n    long t1 \u003d System.currentTimeMillis();\r\n    for (int i \u003d 0; i \u003c NUM_ITERATIONS; ++i) {\r\n        target[i] \u003d gson.fromJson(json, ClassWithListOfObjects.class);\r\n    }\r\n    long t2 \u003d System.currentTimeMillis();\r\n    long avg \u003d (t2 - t1) / NUM_ITERATIONS;\r\n    System.out.printf(\"Deserialize exposed classes avg time: %d ms\\n\", avg);\r\n}",
    "testStringDeserialization": "{\r\n    StringBuilder sb \u003d new StringBuilder(8096);\r\n    sb.append(\"Error Yippie\");\r\n    while (true) {\r\n        try {\r\n            String stackTrace \u003d sb.toString();\r\n            sb.append(stackTrace);\r\n            String json \u003d \"{\\\"message\\\":\\\"Error message.\\\",\" + \"\\\"stackTrace\\\":\\\"\" + stackTrace + \"\\\"}\";\r\n            parseLongJson(json);\r\n            System.out.println(\"Gson could handle a string of size: \" + stackTrace.length());\r\n        } catch (JsonParseException expected) {\r\n            break;\r\n        }\r\n    }\r\n}",
    "testByteArrayDeserialization": "{\r\n    for (int numElements \u003d 10639296; true; numElements +\u003d 16384) {\r\n        StringBuilder sb \u003d new StringBuilder(numElements * 2);\r\n        sb.append(\"[\");\r\n        boolean first \u003d true;\r\n        for (int i \u003d 0; i \u003c numElements; ++i) {\r\n            if (first) {\r\n                first \u003d false;\r\n            } else {\r\n                sb.append(\",\");\r\n            }\r\n            sb.append(\"5\");\r\n        }\r\n        sb.append(\"]\");\r\n        String json \u003d sb.toString();\r\n        byte[] ba \u003d gson.fromJson(json, byte[].class);\r\n        System.out.printf(\"Gson could deserialize a byte array of size: %d\\n\", ba.length);\r\n    }\r\n}",
    "testDeserializeClasses": "{\r\n    String json \u003d buildJsonForClassWithList();\r\n    ClassWithList[] target \u003d new ClassWithList[NUM_ITERATIONS];\r\n    long t1 \u003d System.currentTimeMillis();\r\n    for (int i \u003d 0; i \u003c NUM_ITERATIONS; ++i) {\r\n        target[i] \u003d gson.fromJson(json, ClassWithList.class);\r\n    }\r\n    long t2 \u003d System.currentTimeMillis();\r\n    long avg \u003d (t2 - t1) / NUM_ITERATIONS;\r\n    System.out.printf(\"Deserialize classes avg time: %d ms\\n\", avg);\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testDummy": "{\r\n    // This is here to prevent Junit for complaining when we disable all tests.\r\n}",
    "testLargeObjectSerializationAndDeserialization": "{\r\n    Map\u003cString, Long\u003e largeObject \u003d new HashMap\u003c\u003e();\r\n    for (long l \u003d 0; l \u003c 100000; l++) {\r\n        largeObject.put(\"field\" + l, l);\r\n    }\r\n    long t1 \u003d System.currentTimeMillis();\r\n    String json \u003d gson.toJson(largeObject);\r\n    long t2 \u003d System.currentTimeMillis();\r\n    System.out.printf(\"Large object serialized in: %d ms\\n\", (t2 - t1));\r\n    t1 \u003d System.currentTimeMillis();\r\n    Map\u003cString, Long\u003e unused \u003d gson.fromJson(json, new TypeToken\u003cMap\u003cString, Long\u003e\u003e() {\r\n    }.getType());\r\n    t2 \u003d System.currentTimeMillis();\r\n    System.out.printf(\"Large object deserialized in: %d ms\\n\", (t2 - t1));\r\n}",
    "testLargeCollectionSerialization": "{\r\n    int count \u003d 1400000;\r\n    List\u003cCollectionEntry\u003e list \u003d new ArrayList\u003c\u003e(count);\r\n    for (int i \u003d 0; i \u003c count; ++i) {\r\n        list.add(new CollectionEntry(\"name\" + i, \"value\" + i));\r\n    }\r\n    String unused \u003d gson.toJson(list);\r\n}",
    "testSerializeClasses": "{\r\n    ClassWithList c \u003d new ClassWithList(\"str\");\r\n    for (int i \u003d 0; i \u003c COLLECTION_SIZE; ++i) {\r\n        c.list.add(new ClassWithField(\"element-\" + i));\r\n    }\r\n    StringWriter w \u003d new StringWriter();\r\n    long t1 \u003d System.currentTimeMillis();\r\n    for (int i \u003d 0; i \u003c NUM_ITERATIONS; ++i) {\r\n        gson.toJson(c, w);\r\n    }\r\n    long t2 \u003d System.currentTimeMillis();\r\n    long avg \u003d (t2 - t1) / NUM_ITERATIONS;\r\n    System.out.printf(\"Serialize classes avg time: %d ms\\n\", avg);\r\n}",
    "buildJsonForClassWithList": "{\r\n    StringBuilder sb \u003d new StringBuilder(\"{\");\r\n    sb.append(\"field:\").append(\"\u0027str\u0027,\");\r\n    sb.append(\"list:[\");\r\n    boolean first \u003d true;\r\n    for (int i \u003d 0; i \u003c COLLECTION_SIZE; ++i) {\r\n        if (first) {\r\n            first \u003d false;\r\n        } else {\r\n            sb.append(\",\");\r\n        }\r\n        sb.append(\"{field:\u0027element-\" + i + \"\u0027}\");\r\n    }\r\n    sb.append(\"]\");\r\n    sb.append(\"}\");\r\n    String json \u003d sb.toString();\r\n    return json;\r\n}",
    "parseLongJson": "{\r\n    ExceptionHolder target \u003d gson.fromJson(json, ExceptionHolder.class);\r\n    assertThat(target.message).contains(\"Error\");\r\n    assertThat(target.stackTrace).contains(\"Yippie\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\NumberTypeAdapter.java": {
    "read": "{\r\n    JsonToken jsonToken \u003d in.peek();\r\n    switch(jsonToken) {\r\n        case NULL:\r\n            in.nextNull();\r\n            return null;\r\n        case NUMBER:\r\n        case STRING:\r\n            return toNumberStrategy.readNumber(in);\r\n        default:\r\n            throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken + \"; at path \" + in.getPath());\r\n    }\r\n}",
    "newFactory": "{\r\n    final NumberTypeAdapter adapter \u003d new NumberTypeAdapter(toNumberStrategy);\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            return type.getRawType() \u003d\u003d Number.class ? (TypeAdapter\u003cT\u003e) adapter : null;\r\n        }\r\n    };\r\n}",
    "create": "{\r\n    return type.getRawType() \u003d\u003d Number.class ? (TypeAdapter\u003cT\u003e) adapter : null;\r\n}",
    "getFactory": "{\r\n    if (toNumberStrategy \u003d\u003d ToNumberPolicy.LAZILY_PARSED_NUMBER) {\r\n        return LAZILY_PARSED_NUMBER_FACTORY;\r\n    } else {\r\n        return newFactory(toNumberStrategy);\r\n    }\r\n}",
    "write": "{\r\n    out.value(value);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonTreeWriter.java": {
    "jsonValue": "{\r\n    throw new UnsupportedOperationException();\r\n}",
    "endArray": "{\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonArray) {\r\n        stack.remove(stack.size() - 1);\r\n        return this;\r\n    }\r\n    throw new IllegalStateException();\r\n}",
    "nullValue": "{\r\n    put(JsonNull.INSTANCE);\r\n    return this;\r\n}",
    "put": "{\r\n    if (pendingName !\u003d null) {\r\n        if (!value.isJsonNull() || getSerializeNulls()) {\r\n            JsonObject object \u003d (JsonObject) peek();\r\n            object.add(pendingName, value);\r\n        }\r\n        pendingName \u003d null;\r\n    } else if (stack.isEmpty()) {\r\n        product \u003d value;\r\n    } else {\r\n        JsonElement element \u003d peek();\r\n        if (element instanceof JsonArray) {\r\n            ((JsonArray) element).add(value);\r\n        } else {\r\n            throw new IllegalStateException();\r\n        }\r\n    }\r\n}",
    "peek": "{\r\n    return stack.get(stack.size() - 1);\r\n}",
    "endObject": "{\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonObject) {\r\n        stack.remove(stack.size() - 1);\r\n        return this;\r\n    }\r\n    throw new IllegalStateException();\r\n}",
    "beginArray": "{\r\n    JsonArray array \u003d new JsonArray();\r\n    put(array);\r\n    stack.add(array);\r\n    return this;\r\n}",
    "flush": "{\r\n}",
    "beginObject": "{\r\n    JsonObject object \u003d new JsonObject();\r\n    put(object);\r\n    stack.add(object);\r\n    return this;\r\n}",
    "get": "{\r\n    if (!stack.isEmpty()) {\r\n        throw new IllegalStateException(\"Expected one JSON element but was \" + stack);\r\n    }\r\n    return product;\r\n}",
    "name": "{\r\n    Objects.requireNonNull(name, \"name \u003d\u003d null\");\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException(\"Did not expect a name\");\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonObject) {\r\n        pendingName \u003d name;\r\n        return this;\r\n    }\r\n    throw new IllegalStateException(\"Please begin an object before writing a name.\");\r\n}",
    "write": "{\r\n    throw new AssertionError();\r\n}",
    "close": "{\r\n    if (!stack.isEmpty()) {\r\n        throw new IOException(\"Incomplete document\");\r\n    }\r\n    stack.add(SENTINEL_CLOSED);\r\n}",
    "value": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    if (!isLenient()) {\r\n        double d \u003d value.doubleValue();\r\n        if (Double.isNaN(d) || Double.isInfinite(d)) {\r\n            throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\r\n        }\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\TypeAdapterPrecedenceTest.java": {
    "read": "{\r\n    return new Foo(in.nextString() + \" via \" + name);\r\n}",
    "testStreamingHierarchicalFollowedByNonstreaming": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Foo.class, newTypeAdapter(\"type adapter\")).registerTypeAdapter(Foo.class, newSerializer(\"serializer\")).registerTypeAdapter(Foo.class, newDeserializer(\"deserializer\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via serializer\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via deserializer\");\r\n}",
    "newDeserializer": "{\r\n    return new JsonDeserializer\u003cFoo\u003e() {\r\n\r\n        @Override\r\n        public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n            return new Foo(json.getAsString() + \" via \" + name);\r\n        }\r\n    };\r\n}",
    "testNonstreamingHierarchicalFollowedByNonstreaming": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Foo.class, newSerializer(\"hierarchical\")).registerTypeHierarchyAdapter(Foo.class, newDeserializer(\"hierarchical\")).registerTypeAdapter(Foo.class, newSerializer(\"non hierarchical\")).registerTypeAdapter(Foo.class, newDeserializer(\"non hierarchical\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via non hierarchical\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via non hierarchical\");\r\n}",
    "testNonstreamingFollowedByNonstreaming": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, newSerializer(\"serializer 1\")).registerTypeAdapter(Foo.class, newSerializer(\"serializer 2\")).registerTypeAdapter(Foo.class, newDeserializer(\"deserializer 1\")).registerTypeAdapter(Foo.class, newDeserializer(\"deserializer 2\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via serializer 2\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via deserializer 2\");\r\n}",
    "newTypeAdapter": "{\r\n    return new TypeAdapter\u003cFoo\u003e() {\r\n\r\n        @Override\r\n        public Foo read(JsonReader in) throws IOException {\r\n            return new Foo(in.nextString() + \" via \" + name);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Foo value) throws IOException {\r\n            out.value(value.name + \" via \" + name);\r\n        }\r\n    };\r\n}",
    "testStreamingFollowedByStreaming": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, newTypeAdapter(\"type adapter 1\")).registerTypeAdapter(Foo.class, newTypeAdapter(\"type adapter 2\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via type adapter 2\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via type adapter 2\");\r\n}",
    "testSerializeNonstreamingTypeAdapterFollowedByStreamingTypeAdapter": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, newSerializer(\"serializer\")).registerTypeAdapter(Foo.class, newDeserializer(\"deserializer\")).registerTypeAdapter(Foo.class, newTypeAdapter(\"type adapter\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via type adapter\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via type adapter\");\r\n}",
    "testStreamingFollowedByNonstreaming": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, newTypeAdapter(\"type adapter\")).registerTypeAdapter(Foo.class, newSerializer(\"serializer\")).registerTypeAdapter(Foo.class, newDeserializer(\"deserializer\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via serializer\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via deserializer\");\r\n}",
    "newSerializer": "{\r\n    return new JsonSerializer\u003cFoo\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(src.name + \" via \" + name);\r\n        }\r\n    };\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(src.name + \" via \" + name);\r\n}",
    "testStreamingHierarchicalFollowedByNonstreamingHierarchical": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Foo.class, newSerializer(\"serializer\")).registerTypeHierarchyAdapter(Foo.class, newDeserializer(\"deserializer\")).registerTypeHierarchyAdapter(Foo.class, newTypeAdapter(\"type adapter\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via type adapter\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via type adapter\");\r\n}",
    "write": "{\r\n    out.value(value.name + \" via \" + name);\r\n}",
    "testStreamingFollowedByNonstreamingHierarchical": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, newTypeAdapter(\"type adapter\")).registerTypeHierarchyAdapter(Foo.class, newSerializer(\"serializer\")).registerTypeHierarchyAdapter(Foo.class, newDeserializer(\"deserializer\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via type adapter\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via type adapter\");\r\n}",
    "deserialize": "{\r\n    return new Foo(json.getAsString() + \" via \" + name);\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithVersionAnnotations.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\reflect\\ReflectionHelper.java": {
    "getCanonicalRecordConstructor": "{\r\n    throw new UnsupportedOperationException(\"Records are not supported on this JVM, this method should not be called\");\r\n}",
    "appendExecutableParameters": "{\r\n    stringBuilder.append(\u0027(\u0027);\r\n    Class\u003c?\u003e[] parameters \u003d (executable instanceof Method) ? ((Method) executable).getParameterTypes() : ((Constructor\u003c?\u003e) executable).getParameterTypes();\r\n    for (int i \u003d 0; i \u003c parameters.length; i++) {\r\n        if (i \u003e 0) {\r\n            stringBuilder.append(\", \");\r\n        }\r\n        stringBuilder.append(parameters[i].getSimpleName());\r\n    }\r\n    stringBuilder.append(\u0027)\u0027);\r\n}",
    "isRecord": "{\r\n    return false;\r\n}",
    "createExceptionForUnexpectedIllegalAccess": "{\r\n    throw new RuntimeException(\"Unexpected IllegalAccessException occurred (Gson \" + GsonBuildConfig.VERSION + \").\" + \" Certain ReflectionAccessFilter features require Java \u003e\u003d 9 to work correctly. If you are not using\" + \" ReflectionAccessFilter, report this to the Gson maintainers.\", exception);\r\n}",
    "getAccessibleObjectDescription": "{\r\n    String description;\r\n    if (object instanceof Field) {\r\n        description \u003d \"field \u0027\" + fieldToString((Field) object) + \"\u0027\";\r\n    } else if (object instanceof Method) {\r\n        Method method \u003d (Method) object;\r\n        StringBuilder methodSignatureBuilder \u003d new StringBuilder(method.getName());\r\n        appendExecutableParameters(method, methodSignatureBuilder);\r\n        String methodSignature \u003d methodSignatureBuilder.toString();\r\n        description \u003d \"method \u0027\" + method.getDeclaringClass().getName() + \"#\" + methodSignature + \"\u0027\";\r\n    } else if (object instanceof Constructor) {\r\n        description \u003d \"constructor \u0027\" + constructorToString((Constructor\u003c?\u003e) object) + \"\u0027\";\r\n    } else {\r\n        description \u003d \"\u003cunknown AccessibleObject\u003e \" + object.toString();\r\n    }\r\n    if (uppercaseFirstLetter \u0026\u0026 Character.isLowerCase(description.charAt(0))) {\r\n        description \u003d Character.toUpperCase(description.charAt(0)) + description.substring(1);\r\n    }\r\n    return description;\r\n}",
    "fieldToString": "{\r\n    return field.getDeclaringClass().getName() + \"#\" + field.getName();\r\n}",
    "constructorToString": "{\r\n    StringBuilder stringBuilder \u003d new StringBuilder(constructor.getDeclaringClass().getName());\r\n    appendExecutableParameters(constructor, stringBuilder);\r\n    return stringBuilder.toString();\r\n}",
    "getInaccessibleTroubleshootingSuffix": "{\r\n    // Class was added in Java 9, therefore cannot use instanceof\r\n    if (e.getClass().getName().equals(\"java.lang.reflect.InaccessibleObjectException\")) {\r\n        String message \u003d e.getMessage();\r\n        String troubleshootingId \u003d message !\u003d null \u0026\u0026 message.contains(\"to module com.google.gson\") ? \"reflection-inaccessible-to-module-gson\" : \"reflection-inaccessible\";\r\n        return \"\\nSee \" + TroubleshootingGuide.createUrl(troubleshootingId);\r\n    }\r\n    return \"\";\r\n}",
    "getAccessor": "{\r\n    throw new UnsupportedOperationException(\"Records are not supported on this JVM, this method should not be called\");\r\n}",
    "createExceptionForRecordReflectionException": "{\r\n    throw new RuntimeException(\"Unexpected ReflectiveOperationException occurred\" + \" (Gson \" + GsonBuildConfig.VERSION + \").\" + \" To support Java records, reflection is utilized to read out information\" + \" about records. All these invocations happens after it is established\" + \" that records exist in the JVM. This exception is unexpected behavior.\", exception);\r\n}",
    "makeAccessible": "{\r\n    try {\r\n        object.setAccessible(true);\r\n    } catch (Exception exception) {\r\n        String description \u003d getAccessibleObjectDescription(object, false);\r\n        throw new JsonIOException(\"Failed making \" + description + \" accessible; either increase its visibility\" + \" or write a custom TypeAdapter for its declaring type.\" + getInaccessibleTroubleshootingSuffix(exception), exception);\r\n    }\r\n}",
    "tryMakeAccessible": "{\r\n    try {\r\n        constructor.setAccessible(true);\r\n        return null;\r\n    } catch (Exception exception) {\r\n        return \"Failed making constructor \u0027\" + constructorToString(constructor) + \"\u0027 accessible;\" + \" either increase its visibility or write a custom InstanceCreator or TypeAdapter for\" + // Include the message since it might contain more detailed information\r\n        \" its declaring type: \" + exception.getMessage() + getInaccessibleTroubleshootingSuffix(exception);\r\n    }\r\n}",
    "getRecordComponentNames": "{\r\n    throw new UnsupportedOperationException(\"Records are not supported on this JVM, this method should not be called\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\CustomTypeAdaptersTest.java": {
    "testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            JsonObject json \u003d new JsonObject();\r\n            json.addProperty(\"value\", src.baseValue);\r\n            return json;\r\n        }\r\n    }).create();\r\n    Base b \u003d new Base();\r\n    String json \u003d gson.toJson(b);\r\n    assertThat(json).contains(\"value\");\r\n    b \u003d new Derived();\r\n    json \u003d gson.toJson(b, Base.class);\r\n    assertThat(json).contains(\"value\");\r\n    assertThat(json).doesNotContain(\"derivedValue\");\r\n}",
    "createGsonObjectWithFooTypeAdapter": "{\r\n    return new GsonBuilder().registerTypeAdapter(Foo.class, new FooTypeAdapter()).create();\r\n}",
    "testCustomAdapterInvokedForMapElementSerializationWithType": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    Type mapType \u003d new TypeToken\u003cMap\u003cString, StringHolder\u003e\u003e() {\r\n    }.getType();\r\n    StringHolder holder \u003d new StringHolder(\"Jacob\", \"Tomaw\");\r\n    Map\u003cString, StringHolder\u003e mapOfHolders \u003d new HashMap\u003c\u003e();\r\n    mapOfHolders.put(\"foo\", holder);\r\n    String json \u003d gson.toJson(mapOfHolders, mapType);\r\n    assertThat(json).contains(\"\\\"foo\\\":\\\"Jacob:Tomaw\\\"\");\r\n}",
    "testRegisterHierarchyAdapterForDate": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Date.class, new DateTypeAdapter()).create();\r\n    assertThat(gson.toJson(new Date(0))).isEqualTo(\"0\");\r\n    assertThat(gson.toJson(new java.sql.Date(0))).isEqualTo(\"0\");\r\n    assertThat(gson.fromJson(\"0\", Date.class)).isEqualTo(new Date(0));\r\n    assertThat(gson.fromJson(\"0\", java.sql.Date.class)).isEqualTo(new java.sql.Date(0));\r\n}",
    "testEnsureCustomSerializerNotInvokedForNullValues": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(DataHolder.class, new DataHolderSerializer()).create();\r\n    DataHolderWrapper target \u003d new DataHolderWrapper(new DataHolder(\"abc\"));\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"{\\\"wrappedData\\\":{\\\"myData\\\":\\\"abc\\\"}}\");\r\n}",
    "testEnsureCustomDeserializerNotInvokedForNullValues": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(DataHolder.class, new DataHolderDeserializer()).create();\r\n    String json \u003d \"{wrappedData:null}\";\r\n    DataHolderWrapper actual \u003d gson.fromJson(json, DataHolderWrapper.class);\r\n    assertThat(actual.wrappedData).isNull();\r\n}",
    "testCustomAdapterInvokedForCollectionElementSerializationWithType": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    Type setType \u003d new TypeToken\u003cSet\u003cStringHolder\u003e\u003e() {\r\n    }.getType();\r\n    StringHolder holder \u003d new StringHolder(\"Jacob\", \"Tomaw\");\r\n    Set\u003cStringHolder\u003e setOfHolders \u003d new HashSet\u003c\u003e();\r\n    setOfHolders.add(holder);\r\n    String json \u003d gson.toJson(setOfHolders, setType);\r\n    assertThat(json).contains(\"Jacob:Tomaw\");\r\n}",
    "testCustomAdapterInvokedForMapElementSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    StringHolder holder \u003d new StringHolder(\"Jacob\", \"Tomaw\");\r\n    Map\u003cString, StringHolder\u003e mapOfHolders \u003d new HashMap\u003c\u003e();\r\n    mapOfHolders.put(\"foo\", holder);\r\n    String json \u003d gson.toJson(mapOfHolders);\r\n    assertThat(json).contains(\"\\\"foo\\\":\\\"Jacob:Tomaw\\\"\");\r\n}",
    "testCustomSerializers": "{\r\n    Gson gson \u003d builder.registerTypeAdapter(ClassWithCustomTypeConverter.class, new JsonSerializer\u003cClassWithCustomTypeConverter\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(ClassWithCustomTypeConverter src, Type typeOfSrc, JsonSerializationContext context) {\r\n            JsonObject json \u003d new JsonObject();\r\n            json.addProperty(\"bag\", 5);\r\n            json.addProperty(\"value\", 25);\r\n            return json;\r\n        }\r\n    }).create();\r\n    ClassWithCustomTypeConverter target \u003d new ClassWithCustomTypeConverter();\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"bag\\\":5,\\\"value\\\":25}\");\r\n}",
    "testCustomByteArraySerializer": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(byte[].class, new JsonSerializer\u003cbyte[]\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContext context) {\r\n            StringBuilder sb \u003d new StringBuilder(src.length);\r\n            for (byte b : src) {\r\n                sb.append(b);\r\n            }\r\n            return new JsonPrimitive(sb.toString());\r\n        }\r\n    }).create();\r\n    byte[] data \u003d { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    String json \u003d gson.toJson(data);\r\n    assertThat(json).isEqualTo(\"\\\"0123456789\\\"\");\r\n}",
    "testCustomSerializerInvokedForPrimitives": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(boolean.class, new JsonSerializer\u003cBoolean\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Boolean s, Type t, JsonSerializationContext c) {\r\n            return new JsonPrimitive(s ? 1 : 0);\r\n        }\r\n    }).create();\r\n    assertThat(gson.toJson(true, boolean.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(true, Boolean.class)).isEqualTo(\"true\");\r\n}",
    "testCustomAdapterInvokedForCollectionElementSerialization": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    StringHolder holder \u003d new StringHolder(\"Jacob\", \"Tomaw\");\r\n    Set\u003cStringHolder\u003e setOfHolders \u003d new HashSet\u003c\u003e();\r\n    setOfHolders.add(holder);\r\n    String json \u003d gson.toJson(setOfHolders);\r\n    assertThat(json).contains(\"Jacob:Tomaw\");\r\n}",
    "testCustomAdapterInvokedForMapElementDeserialization": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    Type mapType \u003d new TypeToken\u003cMap\u003cString, StringHolder\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, StringHolder\u003e mapOfFoo \u003d gson.fromJson(\"{\u0027foo\u0027:\u0027Jacob:Tomaw\u0027}\", mapType);\r\n    assertThat(mapOfFoo.size()).isEqualTo(1);\r\n    StringHolder foo \u003d mapOfFoo.get(\"foo\");\r\n    assertThat(foo.part1).isEqualTo(\"Jacob\");\r\n    assertThat(foo.part2).isEqualTo(\"Tomaw\");\r\n}",
    "setUp": "{\r\n    builder \u003d new GsonBuilder();\r\n}",
    "testCustomDeserializerInvokedForPrimitives": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(boolean.class, new JsonDeserializer\u003cBoolean\u003e() {\r\n\r\n        @Override\r\n        public Boolean deserialize(JsonElement json, Type t, JsonDeserializationContext context) {\r\n            return json.getAsInt() !\u003d 0;\r\n        }\r\n    }).create();\r\n    assertThat(gson.fromJson(\"1\", boolean.class)).isEqualTo(Boolean.TRUE);\r\n    assertThat(gson.fromJson(\"true\", Boolean.class)).isEqualTo(Boolean.TRUE);\r\n}",
    "deserialize": "{\r\n    return typeOfT \u003d\u003d Date.class ? new Date(json.getAsLong()) : new java.sql.Date(json.getAsLong());\r\n}",
    "disable_testCustomSerializersOfSelf": "{\r\n    Gson gson \u003d createGsonObjectWithFooTypeAdapter();\r\n    Gson basicGson \u003d new Gson();\r\n    Foo newFooObject \u003d new Foo(1, 2L);\r\n    String jsonFromCustomSerializer \u003d gson.toJson(newFooObject);\r\n    String jsonFromGson \u003d basicGson.toJson(newFooObject);\r\n    assertThat(jsonFromCustomSerializer).isEqualTo(jsonFromGson);\r\n}",
    "testCustomTypeAdapterDoesNotAppliesToSubClasses": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            JsonObject json \u003d new JsonObject();\r\n            json.addProperty(\"value\", src.baseValue);\r\n            return json;\r\n        }\r\n    }).create();\r\n    Base b \u003d new Base();\r\n    String json \u003d gson.toJson(b);\r\n    assertThat(json).contains(\"value\");\r\n    b \u003d new Derived();\r\n    json \u003d gson.toJson(b);\r\n    assertThat(json).contains(\"derivedValue\");\r\n}",
    "createInstance": "{\r\n    //Fill up with objects that will be thrown away\r\n    return new StringHolder(\"unknown:thing\");\r\n}",
    "testCustomAdapterInvokedForCollectionElementDeserialization": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    Type setType \u003d new TypeToken\u003cSet\u003cStringHolder\u003e\u003e() {\r\n    }.getType();\r\n    Set\u003cStringHolder\u003e setOfHolders \u003d gson.fromJson(\"[\u0027Jacob:Tomaw\u0027]\", setType);\r\n    assertThat(setOfHolders.size()).isEqualTo(1);\r\n    StringHolder foo \u003d setOfHolders.iterator().next();\r\n    assertThat(foo.part1).isEqualTo(\"Jacob\");\r\n    assertThat(foo.part2).isEqualTo(\"Tomaw\");\r\n}",
    "testCustomDeserializers": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ClassWithCustomTypeConverter.class, new JsonDeserializer\u003cClassWithCustomTypeConverter\u003e() {\r\n\r\n        @Override\r\n        public ClassWithCustomTypeConverter deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n            JsonObject jsonObject \u003d json.getAsJsonObject();\r\n            int value \u003d jsonObject.get(\"bag\").getAsInt();\r\n            return new ClassWithCustomTypeConverter(new BagOfPrimitives(value, value, false, \"\"), value);\r\n        }\r\n    }).create();\r\n    String json \u003d \"{\\\"bag\\\":5,\\\"value\\\":25}\";\r\n    ClassWithCustomTypeConverter target \u003d gson.fromJson(json, ClassWithCustomTypeConverter.class);\r\n    assertThat(target.getBag().getIntValue()).isEqualTo(5);\r\n}",
    "testCustomNestedDeserializers": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(BagOfPrimitives.class, new JsonDeserializer\u003cBagOfPrimitives\u003e() {\r\n\r\n        @Override\r\n        public BagOfPrimitives deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            int value \u003d json.getAsInt();\r\n            return new BagOfPrimitives(value, value, false, \"\");\r\n        }\r\n    }).create();\r\n    String json \u003d \"{\\\"bag\\\":7,\\\"value\\\":25}\";\r\n    ClassWithCustomTypeConverter target \u003d gson.fromJson(json, ClassWithCustomTypeConverter.class);\r\n    assertThat(target.getBag().getIntValue()).isEqualTo(7);\r\n}",
    "disable_testCustomDeserializersOfSelf": "{\r\n    Gson gson \u003d createGsonObjectWithFooTypeAdapter();\r\n    Gson basicGson \u003d new Gson();\r\n    Foo expectedFoo \u003d new Foo(1, 2L);\r\n    String json \u003d basicGson.toJson(expectedFoo);\r\n    Foo newFooObject \u003d gson.fromJson(json, Foo.class);\r\n    assertThat(newFooObject.key).isEqualTo(expectedFoo.key);\r\n    assertThat(newFooObject.value).isEqualTo(expectedFoo.value);\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(src.getTime());\r\n}",
    "testCustomNestedSerializers": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(BagOfPrimitives.class, new JsonSerializer\u003cBagOfPrimitives\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(BagOfPrimitives src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(6);\r\n        }\r\n    }).create();\r\n    ClassWithCustomTypeConverter target \u003d new ClassWithCustomTypeConverter();\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"bag\\\":6,\\\"value\\\":10}\");\r\n}",
    "testCustomByteArrayDeserializerAndInstanceCreator": "{\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder().registerTypeAdapter(byte[].class, new JsonDeserializer\u003cbyte[]\u003e() {\r\n\r\n        @Override\r\n        public byte[] deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            String str \u003d json.getAsString();\r\n            byte[] data \u003d new byte[str.length()];\r\n            for (int i \u003d 0; i \u003c data.length; ++i) {\r\n                data[i] \u003d Byte.parseByte(\"\" + str.charAt(i));\r\n            }\r\n            return data;\r\n        }\r\n    });\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String json \u003d \"\u00270123456789\u0027\";\r\n    byte[] actual \u003d gson.fromJson(json, byte[].class);\r\n    byte[] expected \u003d { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    for (int i \u003d 0; i \u003c actual.length; ++i) {\r\n        assertThat(actual[i]).isEqualTo(expected[i]);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\sql\\SqlTimeTypeAdapter.java": {
    "read": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String s \u003d in.nextString();\r\n    try {\r\n        synchronized (this) {\r\n            Date date \u003d format.parse(s);\r\n            return new Time(date.getTime());\r\n        }\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as SQL Time; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "create": "{\r\n    return typeToken.getRawType() \u003d\u003d Time.class ? (TypeAdapter\u003cT\u003e) new SqlTimeTypeAdapter() : null;\r\n}",
    "write": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    String timeString;\r\n    synchronized (this) {\r\n        timeString \u003d format.format(value);\r\n    }\r\n    out.value(timeString);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\MapTypeAdapterFactory.java": {
    "getKeyAdapter": "{\r\n    return (keyType \u003d\u003d boolean.class || keyType \u003d\u003d Boolean.class) ? TypeAdapters.BOOLEAN_AS_STRING : context.getAdapter(TypeToken.get(keyType));\r\n}",
    "keyToString": "{\r\n    if (keyElement.isJsonPrimitive()) {\r\n        JsonPrimitive primitive \u003d keyElement.getAsJsonPrimitive();\r\n        if (primitive.isNumber()) {\r\n            return String.valueOf(primitive.getAsNumber());\r\n        } else if (primitive.isBoolean()) {\r\n            return Boolean.toString(primitive.getAsBoolean());\r\n        } else if (primitive.isString()) {\r\n            return primitive.getAsString();\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (keyElement.isJsonNull()) {\r\n        return \"null\";\r\n    } else {\r\n        throw new AssertionError();\r\n    }\r\n}",
    "read": "{\r\n    JsonToken peek \u003d in.peek();\r\n    if (peek \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    Map\u003cK, V\u003e map \u003d constructor.construct();\r\n    if (peek \u003d\u003d JsonToken.BEGIN_ARRAY) {\r\n        in.beginArray();\r\n        while (in.hasNext()) {\r\n            // entry array\r\n            in.beginArray();\r\n            K key \u003d keyTypeAdapter.read(in);\r\n            V value \u003d valueTypeAdapter.read(in);\r\n            V replaced \u003d map.put(key, value);\r\n            if (replaced !\u003d null) {\r\n                throw new JsonSyntaxException(\"duplicate key: \" + key);\r\n            }\r\n            in.endArray();\r\n        }\r\n        in.endArray();\r\n    } else {\r\n        in.beginObject();\r\n        while (in.hasNext()) {\r\n            JsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\r\n            K key \u003d keyTypeAdapter.read(in);\r\n            V value \u003d valueTypeAdapter.read(in);\r\n            V replaced \u003d map.put(key, value);\r\n            if (replaced !\u003d null) {\r\n                throw new JsonSyntaxException(\"duplicate key: \" + key);\r\n            }\r\n        }\r\n        in.endObject();\r\n    }\r\n    return map;\r\n}",
    "create": "{\r\n    Type type \u003d typeToken.getType();\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    if (!Map.class.isAssignableFrom(rawType)) {\r\n        return null;\r\n    }\r\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawType);\r\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\r\n    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e // we don\u0027t define a type parameter for the key or value types\r\n    result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\r\n    return result;\r\n}",
    "write": "{\r\n    if (map \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    if (!complexMapKeySerialization) {\r\n        out.beginObject();\r\n        for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) {\r\n            out.name(String.valueOf(entry.getKey()));\r\n            valueTypeAdapter.write(out, entry.getValue());\r\n        }\r\n        out.endObject();\r\n        return;\r\n    }\r\n    boolean hasComplexKeys \u003d false;\r\n    List\u003cJsonElement\u003e keys \u003d new ArrayList\u003c\u003e(map.size());\r\n    List\u003cV\u003e values \u003d new ArrayList\u003c\u003e(map.size());\r\n    for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) {\r\n        JsonElement keyElement \u003d keyTypeAdapter.toJsonTree(entry.getKey());\r\n        keys.add(keyElement);\r\n        values.add(entry.getValue());\r\n        hasComplexKeys |\u003d keyElement.isJsonArray() || keyElement.isJsonObject();\r\n    }\r\n    if (hasComplexKeys) {\r\n        out.beginArray();\r\n        for (int i \u003d 0, size \u003d keys.size(); i \u003c size; i++) {\r\n            // entry array\r\n            out.beginArray();\r\n            Streams.write(keys.get(i), out);\r\n            valueTypeAdapter.write(out, values.get(i));\r\n            out.endArray();\r\n        }\r\n        out.endArray();\r\n    } else {\r\n        out.beginObject();\r\n        for (int i \u003d 0, size \u003d keys.size(); i \u003c size; i++) {\r\n            JsonElement keyElement \u003d keys.get(i);\r\n            out.name(keyToString(keyElement));\r\n            valueTypeAdapter.write(out, values.get(i));\r\n        }\r\n        out.endObject();\r\n    }\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithNamedFields.java": {},
  "google_json\\extras\\src\\test\\java\\com\\google\\gson\\typeadapters\\UtcDateTypeAdapterTest.java": {
    "testLocalTimeZone": "{\r\n    Date expected \u003d new Date();\r\n    String json \u003d gson.toJson(expected);\r\n    Date actual \u003d gson.fromJson(json, Date.class);\r\n    assertEquals(expected.getTime(), actual.getTime());\r\n}",
    "testUtcWithJdk7Default": "{\r\n    Date expected \u003d new Date();\r\n    SimpleDateFormat iso8601Format \u003d new SimpleDateFormat(\"yyyy-MM-dd\u0027T\u0027HH:mm:ss.SSSXXX\", Locale.US);\r\n    iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n    String expectedJson \u003d \"\\\"\" + iso8601Format.format(expected) + \"\\\"\";\r\n    String actualJson \u003d gson.toJson(expected);\r\n    assertEquals(expectedJson, actualJson);\r\n    Date actual \u003d gson.fromJson(expectedJson, Date.class);\r\n    assertEquals(expected.getTime(), actual.getTime());\r\n}",
    "testNullDateSerialization": "{\r\n    String json \u003d gson.toJson(null, Date.class);\r\n    assertEquals(\"null\", json);\r\n}",
    "testDifferentTimeZones": "{\r\n    for (String timeZone : TimeZone.getAvailableIDs()) {\r\n        Calendar cal \u003d Calendar.getInstance(TimeZone.getTimeZone(timeZone));\r\n        Date expected \u003d cal.getTime();\r\n        String json \u003d gson.toJson(expected);\r\n        // System.out.println(json + \": \" + timeZone);\r\n        Date actual \u003d gson.fromJson(json, Date.class);\r\n        assertEquals(expected.getTime(), actual.getTime());\r\n    }\r\n}",
    "testWellFormedParseException": "{\r\n    try {\r\n        gson.fromJson(\"2017-06-20T14:32:30\", Date.class);\r\n        fail(\"No exception\");\r\n    } catch (JsonParseException exe) {\r\n        assertEquals(\"java.text.ParseException: Failed to parse date [\u00272017-06-20T14\u0027]: 2017-06-20T14\", exe.getMessage());\r\n    }\r\n}",
    "testUtcDatesOnJdkBefore1_7": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Date.class, new UtcDateTypeAdapter()).create();\r\n    Date unused \u003d gson.fromJson(\"\u00272014-12-05T04:00:00.000Z\u0027\", Date.class);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\$Gson$Preconditions.java": {
    "checkNotNull": "{\r\n    if (obj \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return obj;\r\n}",
    "checkArgument": "{\r\n    if (!condition) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\Java17RecordTest.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\JsonParserTest.java": {
    "testParseDeeplyNestedArrays": "{\r\n    int times \u003d 10000;\r\n    // [[[ ... ]]]\r\n    String json \u003d repeat(\"[\", times) + repeat(\"]\", times);\r\n    int actualTimes \u003d 0;\r\n    JsonArray current \u003d JsonParser.parseString(json).getAsJsonArray();\r\n    while (true) {\r\n        actualTimes++;\r\n        if (current.isEmpty()) {\r\n            break;\r\n        }\r\n        assertThat(current.size()).isEqualTo(1);\r\n        current \u003d current.get(0).getAsJsonArray();\r\n    }\r\n    assertThat(actualTimes).isEqualTo(times);\r\n}",
    "testStrict": "{\r\n    JsonReader reader \u003d new JsonReader(new StringReader(\"faLsE\"));\r\n    Strictness strictness \u003d Strictness.STRICT;\r\n    // Strictness is ignored by JsonParser later; always parses in lenient mode\r\n    reader.setStrictness(strictness);\r\n    assertThat(JsonParser.parseReader(reader)).isEqualTo(new JsonPrimitive(false));\r\n    // Original strictness was restored\r\n    assertThat(reader.getStrictness()).isEqualTo(strictness);\r\n}",
    "testParseMixedArray": "{\r\n    String json \u003d \"[{},13,\\\"stringValue\\\"]\";\r\n    JsonElement e \u003d JsonParser.parseString(json);\r\n    assertThat(e.isJsonArray()).isTrue();\r\n    JsonArray array \u003d e.getAsJsonArray();\r\n    assertThat(array.get(0).toString()).isEqualTo(\"{}\");\r\n    assertThat(array.get(1).getAsInt()).isEqualTo(13);\r\n    assertThat(array.get(2).getAsString()).isEqualTo(\"stringValue\");\r\n}",
    "testParseEmptyWhitespaceInput": "{\r\n    JsonElement e \u003d JsonParser.parseString(\"     \");\r\n    assertThat(e.isJsonNull()).isTrue();\r\n}",
    "testParseInvalidJson": "{\r\n    assertThrows(JsonSyntaxException.class, () -\u003e JsonParser.parseString(\"[[]\"));\r\n}",
    "testParseDeeplyNestedObjects": "{\r\n    int times \u003d 10000;\r\n    // {\"a\":{\"a\": ... {\"a\":null} ... }}\r\n    String json \u003d repeat(\"{\\\"a\\\":\", times) + \"null\" + repeat(\"}\", times);\r\n    int actualTimes \u003d 0;\r\n    JsonObject current \u003d JsonParser.parseString(json).getAsJsonObject();\r\n    while (true) {\r\n        assertThat(current.size()).isEqualTo(1);\r\n        actualTimes++;\r\n        JsonElement next \u003d current.get(\"a\");\r\n        if (next.isJsonNull()) {\r\n            break;\r\n        } else {\r\n            current \u003d next.getAsJsonObject();\r\n        }\r\n    }\r\n    assertThat(actualTimes).isEqualTo(times);\r\n}",
    "testParseString": "{\r\n    String json \u003d \"{a:10,b:\u0027c\u0027}\";\r\n    JsonElement e \u003d JsonParser.parseString(json);\r\n    assertThat(e.isJsonObject()).isTrue();\r\n    assertThat(e.getAsJsonObject().get(\"a\").getAsInt()).isEqualTo(10);\r\n    assertThat(e.getAsJsonObject().get(\"b\").getAsString()).isEqualTo(\"c\");\r\n}",
    "testParseUnquotedMultiWordStringFails": "{\r\n    assertThrows(JsonSyntaxException.class, () -\u003e JsonParser.parseString(\"Test is a test..blah blah\"));\r\n}",
    "testParseEmptyString": "{\r\n    JsonElement e \u003d JsonParser.parseString(\"\\\"   \\\"\");\r\n    assertThat(e.isJsonPrimitive()).isTrue();\r\n    assertThat(e.getAsString()).isEqualTo(\"   \");\r\n}",
    "repeat": "{\r\n    StringBuilder stringBuilder \u003d new StringBuilder(s.length() * times);\r\n    for (int i \u003d 0; i \u003c times; i++) {\r\n        stringBuilder.append(s);\r\n    }\r\n    return stringBuilder.toString();\r\n}",
    "testParseReader": "{\r\n    StringReader reader \u003d new StringReader(\"{a:10,b:\u0027c\u0027}\");\r\n    JsonElement e \u003d JsonParser.parseReader(reader);\r\n    assertThat(e.isJsonObject()).isTrue();\r\n    assertThat(e.getAsJsonObject().get(\"a\").getAsInt()).isEqualTo(10);\r\n    assertThat(e.getAsJsonObject().get(\"b\").getAsString()).isEqualTo(\"c\");\r\n}",
    "testReadWriteTwoObjects": "{\r\n    Gson gson \u003d new Gson();\r\n    CharArrayWriter writer \u003d new CharArrayWriter();\r\n    BagOfPrimitives expectedOne \u003d new BagOfPrimitives(1, 1, true, \"one\");\r\n    writer.write(gson.toJson(expectedOne).toCharArray());\r\n    BagOfPrimitives expectedTwo \u003d new BagOfPrimitives(2, 2, false, \"two\");\r\n    writer.write(gson.toJson(expectedTwo).toCharArray());\r\n    CharArrayReader reader \u003d new CharArrayReader(writer.toCharArray());\r\n    JsonReader parser \u003d new JsonReader(reader);\r\n    parser.setStrictness(Strictness.LENIENT);\r\n    JsonElement element1 \u003d Streams.parse(parser);\r\n    JsonElement element2 \u003d Streams.parse(parser);\r\n    BagOfPrimitives actualOne \u003d gson.fromJson(element1, BagOfPrimitives.class);\r\n    assertThat(actualOne.stringValue).isEqualTo(\"one\");\r\n    BagOfPrimitives actualTwo \u003d gson.fromJson(element2, BagOfPrimitives.class);\r\n    assertThat(actualTwo.stringValue).isEqualTo(\"two\");\r\n}",
    "testParseUnquotedSingleWordStringFails": "{\r\n    assertThat(JsonParser.parseString(\"Test\").getAsString()).isEqualTo(\"Test\");\r\n}",
    "testParseUnquotedStringArrayFails": "{\r\n    JsonElement element \u003d JsonParser.parseString(\"[a,b,c]\");\r\n    assertThat(element.getAsJsonArray().get(0).getAsString()).isEqualTo(\"a\");\r\n    assertThat(element.getAsJsonArray().get(1).getAsString()).isEqualTo(\"b\");\r\n    assertThat(element.getAsJsonArray().get(2).getAsString()).isEqualTo(\"c\");\r\n    assertThat(element.getAsJsonArray()).hasSize(3);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LazilyParsedNumber.java": {
    "intValue": "{\r\n    try {\r\n        return Integer.parseInt(value);\r\n    } catch (NumberFormatException e) {\r\n        try {\r\n            return (int) Long.parseLong(value);\r\n        } catch (NumberFormatException nfe) {\r\n            return new BigDecimal(value).intValue();\r\n        }\r\n    }\r\n}",
    "hashCode": "{\r\n    return value.hashCode();\r\n}",
    "equals": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof LazilyParsedNumber) {\r\n        LazilyParsedNumber other \u003d (LazilyParsedNumber) obj;\r\n        return value.equals(other.value);\r\n    }\r\n    return false;\r\n}",
    "floatValue": "{\r\n    return Float.parseFloat(value);\r\n}",
    "toString": "{\r\n    return value;\r\n}",
    "doubleValue": "{\r\n    return Double.parseDouble(value);\r\n}",
    "writeReplace": "{\r\n    return new BigDecimal(value);\r\n}",
    "longValue": "{\r\n    try {\r\n        return Long.parseLong(value);\r\n    } catch (NumberFormatException e) {\r\n        return new BigDecimal(value).longValue();\r\n    }\r\n}",
    "readObject": "{\r\n    // Don\u0027t permit directly deserializing this class; writeReplace() should have written a replacement\r\n    throw new InvalidObjectException(\"Deserialization is unsupported\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\ReflectionAccessFilter.java": {
    "check": "{\r\n    return ReflectionAccessFilterHelper.isAnyPlatformType(rawClass) ? FilterResult.BLOCK_ALL : FilterResult.INDECISIVE;\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\package-info.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonStreamParser.java": {
    "next": "{\r\n    if (!hasNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    try {\r\n        return Streams.parse(parser);\r\n    } catch (StackOverflowError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\r\n    } catch (OutOfMemoryError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\r\n    }\r\n}",
    "hasNext": "{\r\n    synchronized (lock) {\r\n        try {\r\n            return parser.peek() !\u003d JsonToken.END_DOCUMENT;\r\n        } catch (MalformedJsonException e) {\r\n            throw new JsonSyntaxException(e);\r\n        } catch (IOException e) {\r\n            throw new JsonIOException(e);\r\n        }\r\n    }\r\n}",
    "remove": "{\r\n    throw new UnsupportedOperationException();\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\FieldNamingPolicy.java": {
    "separateCamelCase": "{\r\n    StringBuilder translation \u003d new StringBuilder();\r\n    for (int i \u003d 0, length \u003d name.length(); i \u003c length; i++) {\r\n        char character \u003d name.charAt(i);\r\n        if (Character.isUpperCase(character) \u0026\u0026 translation.length() !\u003d 0) {\r\n            translation.append(separator);\r\n        }\r\n        translation.append(character);\r\n    }\r\n    return translation.toString();\r\n}",
    "translateName": "{\r\n    return separateCamelCase(f.getName(), \u0027.\u0027).toLowerCase(Locale.ENGLISH);\r\n}",
    "upperCaseFirstLetter": "{\r\n    int length \u003d s.length();\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        char c \u003d s.charAt(i);\r\n        if (Character.isLetter(c)) {\r\n            if (Character.isUpperCase(c)) {\r\n                return s;\r\n            }\r\n            char uppercased \u003d Character.toUpperCase(c);\r\n            // For leading letter only need one substring\r\n            if (i \u003d\u003d 0) {\r\n                return uppercased + s.substring(1);\r\n            } else {\r\n                return s.substring(0, i) + uppercased + s.substring(i + 1);\r\n            }\r\n        }\r\n    }\r\n    return s;\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\ObjectTypeAdapterParameterizedTest.java": {
    "data": "{\r\n    return Arrays.asList(\"[]\", \"{}\", \"null\", \"1.0\", \"true\", \"\\\"string\\\"\", \"[true,1.0,null,{},2.0,{\\\"a\\\":[false]},[3.0,\\\"test\\\"],4.0]\", \"{\\\"\\\":1.0,\\\"a\\\":true,\\\"b\\\":null,\\\"c\\\":[],\\\"d\\\":{\\\"a1\\\":2.0,\\\"b2\\\":[true,{\\\"a3\\\":3.0}]},\\\"e\\\":[{\\\"f\\\":4.0},\\\"test\\\"]}\");\r\n}",
    "testReadWrite": "{\r\n    Object deserialized \u003d adapter.fromJson(json);\r\n    String actualSerialized \u003d adapter.toJson(deserialized);\r\n    // Serialized Object should be the same as original JSON\r\n    assertThat(actualSerialized).isEqualTo(json);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\package-info.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\JsonParseException.java": {},
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\Gson.java": {
    "excluder": "{\r\n    return excluder;\r\n}",
    "assertFullConsumption": "{\r\n    try {\r\n        if (obj !\u003d null \u0026\u0026 reader.peek() !\u003d JsonToken.END_DOCUMENT) {\r\n            throw new JsonSyntaxException(\"JSON document was not fully consumed.\");\r\n        }\r\n    } catch (MalformedJsonException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}",
    "longAdapter": "{\r\n    if (longSerializationPolicy \u003d\u003d LongSerializationPolicy.DEFAULT) {\r\n        return TypeAdapters.LONG;\r\n    }\r\n    return new TypeAdapter\u003cNumber\u003e() {\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return in.nextLong();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            out.value(value.toString());\r\n        }\r\n    };\r\n}",
    "atomicLongArrayAdapter": "{\r\n    return new TypeAdapter\u003cAtomicLongArray\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, AtomicLongArray value) throws IOException {\r\n            out.beginArray();\r\n            for (int i \u003d 0, length \u003d value.length(); i \u003c length; i++) {\r\n                longAdapter.write(out, value.get(i));\r\n            }\r\n            out.endArray();\r\n        }\r\n\r\n        @Override\r\n        public AtomicLongArray read(JsonReader in) throws IOException {\r\n            List\u003cLong\u003e list \u003d new ArrayList\u003c\u003e();\r\n            in.beginArray();\r\n            while (in.hasNext()) {\r\n                long value \u003d longAdapter.read(in).longValue();\r\n                list.add(value);\r\n            }\r\n            in.endArray();\r\n            int length \u003d list.size();\r\n            AtomicLongArray array \u003d new AtomicLongArray(length);\r\n            for (int i \u003d 0; i \u003c length; ++i) {\r\n                array.set(i, list.get(i));\r\n            }\r\n            return array;\r\n        }\r\n    }.nullSafe();\r\n}",
    "doubleAdapter": "{\r\n    if (serializeSpecialFloatingPointValues) {\r\n        return TypeAdapters.DOUBLE;\r\n    }\r\n    return new TypeAdapter\u003cNumber\u003e() {\r\n\r\n        @Override\r\n        public Double read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return in.nextDouble();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            double doubleValue \u003d value.doubleValue();\r\n            checkValidFloatingPoint(doubleValue);\r\n            out.value(doubleValue);\r\n        }\r\n    };\r\n}",
    "delegate": "{\r\n    TypeAdapter\u003cT\u003e delegate \u003d this.delegate;\r\n    if (delegate \u003d\u003d null) {\r\n        // Can occur when adapter is leaked to other thread or when adapter is used for (de-)serialization\r\n        // directly within the TypeAdapterFactory which requested it\r\n        throw new IllegalStateException(\"Adapter for type with cyclic dependency has been used\" + \" before dependency has been resolved\");\r\n    }\r\n    return delegate;\r\n}",
    "serializeNulls": "{\r\n    return serializeNulls;\r\n}",
    "fieldNamingStrategy": "{\r\n    return fieldNamingStrategy;\r\n}",
    "atomicLongAdapter": "{\r\n    return new TypeAdapter\u003cAtomicLong\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, AtomicLong value) throws IOException {\r\n            longAdapter.write(out, value.get());\r\n        }\r\n\r\n        @Override\r\n        public AtomicLong read(JsonReader in) throws IOException {\r\n            Number value \u003d longAdapter.read(in);\r\n            return new AtomicLong(value.longValue());\r\n        }\r\n    }.nullSafe();\r\n}",
    "newJsonWriter": "{\r\n    if (generateNonExecutableJson) {\r\n        writer.write(JSON_NON_EXECUTABLE_PREFIX);\r\n    }\r\n    JsonWriter jsonWriter \u003d new JsonWriter(writer);\r\n    jsonWriter.setFormattingStyle(formattingStyle);\r\n    jsonWriter.setHtmlSafe(htmlSafe);\r\n    jsonWriter.setStrictness(strictness \u003d\u003d null ? Strictness.LEGACY_STRICT : strictness);\r\n    jsonWriter.setSerializeNulls(serializeNulls);\r\n    return jsonWriter;\r\n}",
    "toJsonTree": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    toJson(src, typeOfSrc, writer);\r\n    return writer.get();\r\n}",
    "write": "{\r\n    delegate().write(out, value);\r\n}",
    "getDelegateAdapter": "{\r\n    Objects.requireNonNull(skipPast, \"skipPast must not be null\");\r\n    Objects.requireNonNull(type, \"type must not be null\");\r\n    if (jsonAdapterFactory.isClassJsonAdapterFactory(type, skipPast)) {\r\n        skipPast \u003d jsonAdapterFactory;\r\n    }\r\n    boolean skipPastFound \u003d false;\r\n    for (TypeAdapterFactory factory : factories) {\r\n        if (!skipPastFound) {\r\n            if (factory \u003d\u003d skipPast) {\r\n                skipPastFound \u003d true;\r\n            }\r\n            continue;\r\n        }\r\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\r\n        if (candidate !\u003d null) {\r\n            return candidate;\r\n        }\r\n    }\r\n    if (skipPastFound) {\r\n        throw new IllegalArgumentException(\"GSON cannot serialize or deserialize \" + type);\r\n    } else {\r\n        // Probably a factory from @JsonAdapter on a field\r\n        return getAdapter(type);\r\n    }\r\n}",
    "getAdapter": "{\r\n    return getAdapter(TypeToken.get(type));\r\n}",
    "read": "{\r\n    return delegate().read(in);\r\n}",
    "floatAdapter": "{\r\n    if (serializeSpecialFloatingPointValues) {\r\n        return TypeAdapters.FLOAT;\r\n    }\r\n    return new TypeAdapter\u003cNumber\u003e() {\r\n\r\n        @Override\r\n        public Float read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return (float) in.nextDouble();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            float floatValue \u003d value.floatValue();\r\n            checkValidFloatingPoint(floatValue);\r\n            // For backward compatibility don\u0027t call `JsonWriter.value(float)` because that method has\r\n            // been newly added and not all custom JsonWriter implementations might override it yet\r\n            Number floatNumber \u003d value instanceof Float ? value : floatValue;\r\n            out.value(floatNumber);\r\n        }\r\n    };\r\n}",
    "checkValidFloatingPoint": "{\r\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\r\n        throw new IllegalArgumentException(value + \" is not a valid double value as per JSON specification. To override this\" + \" behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.\");\r\n    }\r\n}",
    "newBuilder": "{\r\n    return new GsonBuilder(this);\r\n}",
    "newJsonReader": "{\r\n    JsonReader jsonReader \u003d new JsonReader(reader);\r\n    jsonReader.setStrictness(strictness \u003d\u003d null ? Strictness.LEGACY_STRICT : strictness);\r\n    return jsonReader;\r\n}",
    "setDelegate": "{\r\n    if (delegate !\u003d null) {\r\n        throw new AssertionError(\"Delegate is already set\");\r\n    }\r\n    delegate \u003d typeAdapter;\r\n}",
    "toJson": "{\r\n    Strictness oldStrictness \u003d writer.getStrictness();\r\n    boolean oldHtmlSafe \u003d writer.isHtmlSafe();\r\n    boolean oldSerializeNulls \u003d writer.getSerializeNulls();\r\n    writer.setHtmlSafe(htmlSafe);\r\n    writer.setSerializeNulls(serializeNulls);\r\n    if (this.strictness !\u003d null) {\r\n        writer.setStrictness(this.strictness);\r\n    } else if (writer.getStrictness() !\u003d Strictness.STRICT) {\r\n        writer.setStrictness(Strictness.LENIENT);\r\n    }\r\n    try {\r\n        Streams.write(jsonElement, writer);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    } catch (AssertionError e) {\r\n        throw new AssertionError(\"AssertionError (GSON \" + GsonBuildConfig.VERSION + \"): \" + e.getMessage(), e);\r\n    } finally {\r\n        writer.setStrictness(oldStrictness);\r\n        writer.setHtmlSafe(oldHtmlSafe);\r\n        writer.setSerializeNulls(oldSerializeNulls);\r\n    }\r\n}",
    "getSerializationDelegate": "{\r\n    return delegate();\r\n}",
    "fromJson": "{\r\n    if (json \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    return fromJson(new JsonTreeReader(json), typeOfT);\r\n}",
    "toString": "{\r\n    return \"{serializeNulls:\" + serializeNulls + \",factories:\" + factories + \",instanceCreators:\" + constructorConstructor + \"}\";\r\n}",
    "htmlSafe": "{\r\n    return htmlSafe;\r\n}"
  },
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\SerializationBenchmark.java": {
    "timeObjectSerialization": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        gson.toJson(bag);\r\n    }\r\n}",
    "setUp": "{\r\n    this.gson \u003d pretty ? new GsonBuilder().setPrettyPrinting().create() : new Gson();\r\n    this.bag \u003d new BagOfPrimitives(10L, 1, false, \"foo\");\r\n}",
    "main": "{\r\n    NonUploadingCaliperRunner.run(SerializationBenchmark.class, args);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\VersionExclusionStrategyTest.java": {
    "testNewerVersion": "{\r\n    Excluder excluder \u003d Excluder.DEFAULT.withVersion(VERSION + 5);\r\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\r\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\r\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\r\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\r\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\r\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\r\n}",
    "testSameVersion": "{\r\n    Excluder excluder \u003d Excluder.DEFAULT.withVersion(VERSION);\r\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\r\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\r\n    // Until version is exclusive\r\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\r\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\r\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isFalse();\r\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isFalse();\r\n}",
    "testOlderVersion": "{\r\n    Excluder excluder \u003d Excluder.DEFAULT.withVersion(VERSION - 5);\r\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isTrue();\r\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isTrue();\r\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isFalse();\r\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isFalse();\r\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\r\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\ConstructorConstructorTest.java": {
    "testGet_Interface": "{\r\n    ObjectConstructor\u003cInterface\u003e constructor \u003d constructorConstructor.get(TypeToken.get(Interface.class));\r\n    try {\r\n        constructor.construct();\r\n        fail(\"Expected exception\");\r\n    } catch (RuntimeException exception) {\r\n        assertThat(exception).hasMessageThat().isEqualTo(\"Interfaces can\u0027t be instantiated!\" + \" Register an InstanceCreator or a TypeAdapter for this type.\" + \" Interface name: com.google.gson.internal.ConstructorConstructorTest$Interface\");\r\n    }\r\n}",
    "testGet_AbstractClassNoArgConstructor": "{\r\n    ObjectConstructor\u003cAbstractClass\u003e constructor \u003d constructorConstructor.get(TypeToken.get(AbstractClass.class));\r\n    try {\r\n        constructor.construct();\r\n        fail(\"Expected exception\");\r\n    } catch (RuntimeException exception) {\r\n        assertThat(exception).hasMessageThat().isEqualTo(\"Abstract classes can\u0027t be instantiated!\" + \" Adjust the R8 configuration or register an InstanceCreator or a TypeAdapter for this type.\" + \" Class name: com.google.gson.internal.ConstructorConstructorTest$AbstractClass\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#r8-abstract-class\");\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\ToNumberStrategy.java": {},
  "google_json\\extras\\src\\test\\java\\com\\google\\gson\\graph\\GraphAdapterBuilderTest.java": {
    "testDeserializationWithMultipleTypes": "{\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(Company.class).addType(Employee.class).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String json \u003d \"{\u00270x1\u0027:{\u0027name\u0027:\u0027Google\u0027,\u0027employees\u0027:[\u00270x2\u0027,\u00270x3\u0027]},\" + \"\u00270x2\u0027:{\u0027name\u0027:\u0027Jesse\u0027,\u0027company\u0027:\u00270x1\u0027},\" + \"\u00270x3\u0027:{\u0027name\u0027:\u0027Joel\u0027,\u0027company\u0027:\u00270x1\u0027}}\";\r\n    Company company \u003d gson.fromJson(json, Company.class);\r\n    assertEquals(\"Google\", company.name);\r\n    Employee jesse \u003d company.employees.get(0);\r\n    assertEquals(\"Jesse\", jesse.name);\r\n    assertEquals(company, jesse.company);\r\n    Employee joel \u003d company.employees.get(1);\r\n    assertEquals(\"Joel\", joel.name);\r\n    assertEquals(company, joel.company);\r\n}",
    "testSerializeListOfLists": "{\r\n    Type listOfListsType \u003d new TypeToken\u003cList\u003cList\u003c?\u003e\u003e\u003e() {\r\n    }.getType();\r\n    Type listOfAnyType \u003d new TypeToken\u003cList\u003c?\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cList\u003c?\u003e\u003e listOfLists \u003d new ArrayList\u003c\u003e();\r\n    listOfLists.add(listOfLists);\r\n    listOfLists.add(new ArrayList\u003c\u003e());\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(listOfListsType).addType(listOfAnyType).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String json \u003d gson.toJson(listOfLists, listOfListsType);\r\n    assertEquals(\"{\u00270x1\u0027:[\u00270x1\u0027,\u00270x2\u0027],\u00270x2\u0027:[]}\", json.replace(\u0027\"\u0027, \u0027\\\u0027\u0027));\r\n}",
    "testSerializationWithMultipleTypes": "{\r\n    Company google \u003d new Company(\"Google\");\r\n    // Employee constructor adds `this` to the given Company object\r\n    Employee unused1 \u003d new Employee(\"Jesse\", google);\r\n    Employee unused2 \u003d new Employee(\"Joel\", google);\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(Company.class).addType(Employee.class).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    assertEquals(\"{\u00270x1\u0027:{\u0027name\u0027:\u0027Google\u0027,\u0027employees\u0027:[\u00270x2\u0027,\u00270x3\u0027]},\" + \"\u00270x2\u0027:{\u0027name\u0027:\u0027Jesse\u0027,\u0027company\u0027:\u00270x1\u0027},\" + \"\u00270x3\u0027:{\u0027name\u0027:\u0027Joel\u0027,\u0027company\u0027:\u00270x1\u0027}}\", gson.toJson(google).replace(\u0027\"\u0027, \u0027\\\u0027\u0027));\r\n}",
    "testDeserializationDirectSelfReference": "{\r\n    String json \u003d \"{\u00270x1\u0027:{\u0027name\u0027:\u0027SUICIDE\u0027,\u0027beats\u0027:\u00270x1\u0027}}\";\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(Roshambo.class).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    Roshambo suicide \u003d gson.fromJson(json, Roshambo.class);\r\n    assertEquals(\"SUICIDE\", suicide.name);\r\n    assertSame(suicide, suicide.beats);\r\n}",
    "testSerialization": "{\r\n    Roshambo rock \u003d new Roshambo(\"ROCK\");\r\n    Roshambo scissors \u003d new Roshambo(\"SCISSORS\");\r\n    Roshambo paper \u003d new Roshambo(\"PAPER\");\r\n    rock.beats \u003d scissors;\r\n    scissors.beats \u003d paper;\r\n    paper.beats \u003d rock;\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(Roshambo.class).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    assertEquals(\"{\u00270x1\u0027:{\u0027name\u0027:\u0027ROCK\u0027,\u0027beats\u0027:\u00270x2\u0027},\" + \"\u00270x2\u0027:{\u0027name\u0027:\u0027SCISSORS\u0027,\u0027beats\u0027:\u00270x3\u0027},\" + \"\u00270x3\u0027:{\u0027name\u0027:\u0027PAPER\u0027,\u0027beats\u0027:\u00270x1\u0027}}\", gson.toJson(rock).replace(\u0027\"\u0027, \u0027\\\u0027\u0027));\r\n}",
    "testDeserialization": "{\r\n    String json \u003d \"{\u00270x1\u0027:{\u0027name\u0027:\u0027ROCK\u0027,\u0027beats\u0027:\u00270x2\u0027},\" + \"\u00270x2\u0027:{\u0027name\u0027:\u0027SCISSORS\u0027,\u0027beats\u0027:\u00270x3\u0027},\" + \"\u00270x3\u0027:{\u0027name\u0027:\u0027PAPER\u0027,\u0027beats\u0027:\u00270x1\u0027}}\";\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(Roshambo.class).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    Roshambo rock \u003d gson.fromJson(json, Roshambo.class);\r\n    assertEquals(\"ROCK\", rock.name);\r\n    Roshambo scissors \u003d rock.beats;\r\n    assertEquals(\"SCISSORS\", scissors.name);\r\n    Roshambo paper \u003d scissors.beats;\r\n    assertEquals(\"PAPER\", paper.name);\r\n    assertSame(rock, paper.beats);\r\n}",
    "testDeserializeListOfLists": "{\r\n    Type listOfAnyType \u003d new TypeToken\u003cList\u003c?\u003e\u003e() {\r\n    }.getType();\r\n    Type listOfListsType \u003d new TypeToken\u003cList\u003cList\u003c?\u003e\u003e\u003e() {\r\n    }.getType();\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(listOfListsType).addType(listOfAnyType).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    List\u003cList\u003c?\u003e\u003e listOfLists \u003d gson.fromJson(\"{\u00270x1\u0027:[\u00270x1\u0027,\u00270x2\u0027],\u00270x2\u0027:[]}\", listOfListsType);\r\n    assertEquals(2, listOfLists.size());\r\n    assertSame(listOfLists, listOfLists.get(0));\r\n    assertEquals(Collections.emptyList(), listOfLists.get(1));\r\n}"
  },
  "google_json\\examples\\android-proguard-example\\src\\com\\google\\gson\\examples\\android\\model\\LineItem.java": {
    "getCurrencyCode": "{\r\n    return currencyCode;\r\n}",
    "getName": "{\r\n    return name;\r\n}",
    "getQuantity": "{\r\n    return quantity;\r\n}",
    "getPriceInMicros": "{\r\n    return priceInMicros;\r\n}",
    "toString": "{\r\n    return String.format(\"(item: %s, qty: %s, price: %.2f %s)\", name, quantity, priceInMicros / 1000000d, currencyCode);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\package-info.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java": {
    "testDelegating_SameFactoryClass_OnClassAndField": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(String.class, new TypeAdapter\u003cString\u003e() {\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            return in.nextString() + \"-str\";\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            out.value(value + \"-str\");\r\n        }\r\n    }).create();\r\n    // Should use both factories, and therefore have `{\"custom\": ... }` once for class and once for the field,\r\n    // and for field also properly delegate to custom String adapter defined above\r\n    WithDelegatingFactoryOnClassAndField deserialized \u003d gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"de\\\"}}}\", WithDelegatingFactoryOnClassAndField.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de-str\");\r\n    WithDelegatingFactoryOnClassAndField serialized \u003d new WithDelegatingFactoryOnClassAndField(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"se-str\\\"}}}\");\r\n}",
    "testDelegating_SameFactoryInstance": "{\r\n    WithDelegatingFactory.Factory factory \u003d new WithDelegatingFactory.Factory();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(factory).// Always provides same instance for factory\r\n    registerTypeAdapter(WithDelegatingFactory.Factory.class, (InstanceCreator\u003c?\u003e) type -\u003e factory).create();\r\n    // Current Gson.getDelegateAdapter implementation cannot tell when call is related to @JsonAdapter\r\n    // or not, it can only work based on the `skipPast` factory, so if the same factory instance is used\r\n    // the one registered with `GsonBuilder.registerTypeAdapterFactory` actually skips past the @JsonAdapter\r\n    // one, so the JSON string is `{\"custom\": ...}` instead of `{\"custom\":{\"custom\":...}}`\r\n    WithDelegatingFactory\u003c?\u003e deserialized \u003d gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelegatingFactory\u003cString\u003e serialized \u003d new WithDelegatingFactory\u003c\u003e(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n}",
    "testAdapterCreatedByJdkUnsafe": "{\r\n    String json \u003d new Gson().toJson(new CreatedByJdkUnsafe());\r\n    assertThat(json).isEqualTo(\"false\");\r\n}",
    "testJsonAdapterInvoked": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new A(\"bar\"));\r\n    assertThat(json).isEqualTo(\"\\\"jsonAdapter\\\"\");\r\n    // Also invoke the JsonAdapter javadoc sample\r\n    json \u003d gson.toJson(new User(\"Inderjeet\", \"Singh\"));\r\n    assertThat(json).isEqualTo(\"{\\\"name\\\":\\\"Inderjeet Singh\\\"}\");\r\n    User user \u003d gson.fromJson(\"{\u0027name\u0027:\u0027Joel Leitch\u0027}\", User.class);\r\n    assertThat(user.firstName).isEqualTo(\"Joel\");\r\n    assertThat(user.lastName).isEqualTo(\"Leitch\");\r\n    json \u003d gson.toJson(Foo.BAR);\r\n    assertThat(json).isEqualTo(\"\\\"bar\\\"\");\r\n    Foo baz \u003d gson.fromJson(\"\\\"baz\\\"\", Foo.class);\r\n    assertThat(baz).isEqualTo(Foo.BAZ);\r\n}",
    "testJsonDeserializer": "{\r\n    Gson gson \u003d new Gson();\r\n    WithJsonDeserializer deserialized \u003d gson.fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithJsonDeserializer.class);\r\n    // Uses custom deserializer which always uses \"123\" as field value\r\n    assertThat(deserialized.f).isEqualTo(\"123\");\r\n    // Verify that delegate serializer (reflection serializer) is used\r\n    String json \u003d gson.toJson(new WithJsonDeserializer(\"abc\"));\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":\\\"abc\\\"}\");\r\n}",
    "testJsonSerializer": "{\r\n    Gson gson \u003d new Gson();\r\n    // Verify that delegate deserializer (reflection deserializer) is used\r\n    WithJsonSerializer deserialized \u003d gson.fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithJsonSerializer.class);\r\n    assertThat(deserialized.f).isEqualTo(\"test\");\r\n    String json \u003d gson.toJson(new WithJsonSerializer());\r\n    // Uses custom serializer which always returns `true`\r\n    assertThat(json).isEqualTo(\"true\");\r\n}",
    "delegate": "{\r\n    return gson.getDelegateAdapter(Factory.this, type);\r\n}",
    "testSuperclassTypeAdapterNotInvoked": "{\r\n    String json \u003d new Gson().toJson(new B(\"bar\"));\r\n    assertThat(json).doesNotContain(\"jsonAdapter\");\r\n}",
    "testIncorrectTypeAdapterFails": "{\r\n    try {\r\n        String json \u003d new Gson().toJson(new ClassWithIncorrectJsonAdapter(\"bar\"));\r\n        fail(json);\r\n    } catch (ClassCastException expected) {\r\n    }\r\n}",
    "create": "{\r\n    TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            // Perform custom deserialization\r\n            in.beginObject();\r\n            assertThat(in.nextName()).isEqualTo(\"custom\");\r\n            T t \u003d delegate.read(in);\r\n            in.endObject();\r\n            return t;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            // Perform custom serialization\r\n            out.beginObject();\r\n            out.name(\"custom\");\r\n            delegate.write(out, value);\r\n            out.endObject();\r\n        }\r\n    };\r\n}",
    "write": "{\r\n    // Perform custom serialization\r\n    out.beginObject();\r\n    out.name(\"custom\");\r\n    delegate.write(out, value);\r\n    out.endObject();\r\n}",
    "deserialize": "{\r\n    return new WithJsonDeserializer(\"123\");\r\n}",
    "testNullSafeObject": "{\r\n    Gson gson \u003d new Gson();\r\n    NullableClass fromJson \u003d gson.fromJson(\"null\", NullableClass.class);\r\n    assertThat(fromJson).isNull();\r\n    fromJson \u003d gson.fromJson(\"\\\"ignored\\\"\", NullableClass.class);\r\n    assertThat(fromJson).isNotNull();\r\n    String json \u003d gson.toJson(null, NullableClass.class);\r\n    assertThat(json).isEqualTo(\"null\");\r\n    json \u003d gson.toJson(new NullableClass());\r\n    assertThat(json).isEqualTo(\"\\\"nullable\\\"\");\r\n}",
    "read": "{\r\n    // Perform custom deserialization\r\n    in.beginObject();\r\n    assertThat(in.nextName()).isEqualTo(\"custom\");\r\n    T t \u003d delegate.read(in);\r\n    in.endObject();\r\n    return t;\r\n}",
    "testIncorrectJsonAdapterType": "{\r\n    try {\r\n        new Gson().toJson(new D());\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testDelegatingAdapterFactory": "{\r\n    @SuppressWarnings(\"unchecked\")\r\n    WithDelegatingFactory\u003cString\u003e deserialized \u003d new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    deserialized \u003d new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", new TypeToken\u003cWithDelegatingFactory\u003cString\u003e\u003e() {\r\n    });\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelegatingFactory\u003cString\u003e serialized \u003d new WithDelegatingFactory\u003c\u003e(\"se\");\r\n    assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n}",
    "testDelegating_SameFactoryInstance_OnClassAndField": "{\r\n    WithDelegatingFactoryOnClassAndField.Factory factory \u003d new WithDelegatingFactoryOnClassAndField.Factory();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(String.class, new TypeAdapter\u003cString\u003e() {\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            return in.nextString() + \"-str\";\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            out.value(value + \"-str\");\r\n        }\r\n    }).// Always provides same instance for factory\r\n    registerTypeAdapter(WithDelegatingFactoryOnClassAndField.Factory.class, (InstanceCreator\u003c?\u003e) type -\u003e factory).create();\r\n    // Because field type (`String`) differs from declaring class, JsonAdapterAnnotationTypeAdapterFactory does\r\n    // not confuse factories and this behaves as expected: Both the declaring class and the field each have\r\n    // `{\"custom\": ...}` and delegation for the field to the custom String adapter defined above works properly\r\n    WithDelegatingFactoryOnClassAndField deserialized \u003d gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"de\\\"}}}\", WithDelegatingFactoryOnClassAndField.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de-str\");\r\n    WithDelegatingFactoryOnClassAndField serialized \u003d new WithDelegatingFactoryOnClassAndField(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"se-str\\\"}}}\");\r\n}",
    "testRegisteredAdapterOverridesJsonAdapter": "{\r\n    TypeAdapter\u003cA\u003e typeAdapter \u003d new TypeAdapter\u003cA\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, A value) throws IOException {\r\n            out.value(\"registeredAdapter\");\r\n        }\r\n\r\n        @Override\r\n        public A read(JsonReader in) throws IOException {\r\n            return new A(in.nextString());\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(A.class, typeAdapter).create();\r\n    String json \u003d gson.toJson(new A(\"abcd\"));\r\n    assertThat(json).isEqualTo(\"\\\"registeredAdapter\\\"\");\r\n}",
    "testRegisteredDeserializerOverridesJsonAdapter": "{\r\n    JsonDeserializer\u003cA\u003e deserializer \u003d new JsonDeserializer\u003cA\u003e() {\r\n\r\n        @Override\r\n        public A deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return new A(\"registeredDeserializer\");\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(A.class, deserializer).create();\r\n    String json \u003d gson.toJson(new A(\"abcd\"));\r\n    assertThat(json).isEqualTo(\"\\\"jsonAdapter\\\"\");\r\n    A target \u003d gson.fromJson(\"abcd\", A.class);\r\n    assertThat(target.value).isEqualTo(\"registeredDeserializer\");\r\n}",
    "testDelegating_SameFactoryClass": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(new WithDelegatingFactory.Factory()).create();\r\n    // Should use both factories, and therefore have `{\"custom\": ... }` twice\r\n    WithDelegatingFactory\u003c?\u003e deserialized \u003d gson.fromJson(\"{\\\"custom\\\":{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelegatingFactory\u003cString\u003e serialized \u003d new WithDelegatingFactory\u003c\u003e(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}}\");\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(wasInitialized);\r\n}",
    "testFactoryReturningNull": "{\r\n    Gson gson \u003d new Gson();\r\n    assertThat(gson.fromJson(\"null\", WithNullReturningFactory.class)).isNull();\r\n    assertThat(gson.toJson(null, WithNullReturningFactory.class)).isEqualTo(\"null\");\r\n    TypeToken\u003cWithNullReturningFactory\u003cString\u003e\u003e stringTypeArg \u003d new TypeToken\u003cWithNullReturningFactory\u003cString\u003e\u003e() {\r\n    };\r\n    WithNullReturningFactory\u003c?\u003e deserialized \u003d gson.fromJson(\"\\\"a\\\"\", stringTypeArg);\r\n    assertThat(deserialized.t).isEqualTo(\"custom-read:a\");\r\n    assertThat(gson.fromJson(\"null\", stringTypeArg)).isNull();\r\n    assertThat(gson.toJson(new WithNullReturningFactory\u003c\u003e(\"b\"), stringTypeArg.getType())).isEqualTo(\"\\\"custom-write:b\\\"\");\r\n    assertThat(gson.toJson(null, stringTypeArg.getType())).isEqualTo(\"null\");\r\n    // Factory should return `null` for this type and Gson should fall back to reflection-based adapter\r\n    TypeToken\u003cWithNullReturningFactory\u003cInteger\u003e\u003e numberTypeArg \u003d new TypeToken\u003cWithNullReturningFactory\u003cInteger\u003e\u003e() {\r\n    };\r\n    deserialized \u003d gson.fromJson(\"{\\\"t\\\":1}\", numberTypeArg);\r\n    assertThat(deserialized.t).isEqualTo(1);\r\n    assertThat(gson.toJson(new WithNullReturningFactory\u003c\u003e(2), numberTypeArg.getType())).isEqualTo(\"{\\\"t\\\":2}\");\r\n}",
    "testDelegatingAdapterFactory_Delayed": "{\r\n    WithDelayedDelegatingFactory deserialized \u003d new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelayedDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelayedDelegatingFactory serialized \u003d new WithDelayedDelegatingFactory(\"se\");\r\n    assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n}",
    "testAdapterCreatedByInstanceCreator": "{\r\n    CreatedByInstanceCreator.Serializer serializer \u003d new CreatedByInstanceCreator.Serializer(\"custom\");\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(CreatedByInstanceCreator.Serializer.class, (InstanceCreator\u003c?\u003e) t -\u003e serializer).create();\r\n    String json \u003d gson.toJson(new CreatedByInstanceCreator());\r\n    assertThat(json).isEqualTo(\"\\\"custom\\\"\");\r\n}",
    "testRegisteredSerializerOverridesJsonAdapter": "{\r\n    JsonSerializer\u003cA\u003e serializer \u003d new JsonSerializer\u003cA\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(A src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"registeredSerializer\");\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(A.class, serializer).create();\r\n    String json \u003d gson.toJson(new A(\"abcd\"));\r\n    assertThat(json).isEqualTo(\"\\\"registeredSerializer\\\"\");\r\n    A target \u003d gson.fromJson(\"abcd\", A.class);\r\n    assertThat(target.value).isEqualTo(\"jsonAdapter\");\r\n}",
    "testJsonAdapterFactoryInvoked": "{\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new C(\"bar\"));\r\n    assertThat(json).isEqualTo(\"\\\"jsonAdapterFactory\\\"\");\r\n    C c \u003d gson.fromJson(\"\\\"bar\\\"\", C.class);\r\n    assertThat(c.value).isEqualTo(\"jsonAdapterFactory\");\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\EscapingTest.java": {
    "testEscapingQuotesInStringArray": "{\r\n    String[] valueWithQuotes \u003d { \"beforeQuote\\\"afterQuote\" };\r\n    String jsonRepresentation \u003d gson.toJson(valueWithQuotes);\r\n    String[] target \u003d gson.fromJson(jsonRepresentation, String[].class);\r\n    assertThat(target.length).isEqualTo(1);\r\n    assertThat(target[0]).isEqualTo(valueWithQuotes[0]);\r\n}",
    "testGsonDoubleDeserialization": "{\r\n    BagOfPrimitives expected \u003d new BagOfPrimitives(3L, 4, true, \"value1\");\r\n    String json \u003d gson.toJson(gson.toJson(expected));\r\n    String value \u003d gson.fromJson(json, String.class);\r\n    BagOfPrimitives actual \u003d gson.fromJson(value, BagOfPrimitives.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "testEscapeAllHtmlCharacters": "{\r\n    List\u003cString\u003e strings \u003d new ArrayList\u003c\u003e();\r\n    strings.add(\"\u003c\");\r\n    strings.add(\"\u003e\");\r\n    strings.add(\"\u003d\");\r\n    strings.add(\"\u0026\");\r\n    strings.add(\"\u0027\");\r\n    strings.add(\"\\\"\");\r\n    assertThat(gson.toJson(strings)).isEqualTo(\"[\\\"\\\\u003c\\\",\\\"\\\\u003e\\\",\\\"\\\\u003d\\\",\\\"\\\\u0026\\\",\\\"\\\\u0027\\\",\\\"\\\\\\\"\\\"]\");\r\n}",
    "setUp": "{\r\n    gson \u003d new Gson();\r\n}",
    "testGsonAcceptsEscapedAndNonEscapedJsonDeserialization": "{\r\n    Gson escapeHtmlGson \u003d new GsonBuilder().create();\r\n    Gson noEscapeHtmlGson \u003d new GsonBuilder().disableHtmlEscaping().create();\r\n    BagOfPrimitives target \u003d new BagOfPrimitives(1L, 1, true, \"test\u0027 / w\u0027ith\\\" / \\\\ \u003cscript\u003e\");\r\n    String escapedJsonForm \u003d escapeHtmlGson.toJson(target);\r\n    String nonEscapedJsonForm \u003d noEscapeHtmlGson.toJson(target);\r\n    assertThat(escapedJsonForm.equals(nonEscapedJsonForm)).isFalse();\r\n    assertThat(noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)).isEqualTo(target);\r\n    assertThat(escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)).isEqualTo(target);\r\n}",
    "testEscapingObjectFields": "{\r\n    BagOfPrimitives objWithPrimitives \u003d new BagOfPrimitives(1L, 1, true, \"test with\\\" \u003cscript\u003e\");\r\n    String jsonRepresentation \u003d gson.toJson(objWithPrimitives);\r\n    assertThat(jsonRepresentation).doesNotContain(\"\u003c\");\r\n    assertThat(jsonRepresentation).doesNotContain(\"\u003e\");\r\n    assertThat(jsonRepresentation).contains(\"\\\\\\\"\");\r\n    BagOfPrimitives expectedObject \u003d gson.fromJson(jsonRepresentation, BagOfPrimitives.class);\r\n    assertThat(objWithPrimitives.getExpectedJson()).isEqualTo(expectedObject.getExpectedJson());\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\JsonObjectTest.java": {
    "testAddingAndRemovingObjectProperties": "{\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    String propertyName \u003d \"property\";\r\n    assertThat(jsonObj.has(propertyName)).isFalse();\r\n    assertThat(jsonObj.get(propertyName)).isNull();\r\n    JsonPrimitive value \u003d new JsonPrimitive(\"blah\");\r\n    jsonObj.add(propertyName, value);\r\n    assertThat(jsonObj.get(propertyName)).isEqualTo(value);\r\n    JsonElement removedElement \u003d jsonObj.remove(propertyName);\r\n    assertThat(removedElement).isEqualTo(value);\r\n    assertThat(jsonObj.has(propertyName)).isFalse();\r\n    assertThat(jsonObj.get(propertyName)).isNull();\r\n    assertThat(jsonObj.remove(propertyName)).isNull();\r\n}",
    "testEqualsNonEmptyObject": "{\r\n    JsonObject a \u003d new JsonObject();\r\n    JsonObject b \u003d new JsonObject();\r\n    new EqualsTester().addEqualityGroup(a).testEquals();\r\n    a.add(\"foo\", new JsonObject());\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n    b.add(\"foo\", new JsonObject());\r\n    MoreAsserts.assertEqualsAndHashCode(a, b);\r\n    a.add(\"bar\", new JsonObject());\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n    b.add(\"bar\", JsonNull.INSTANCE);\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n}",
    "testAddingNullPropertyValue": "{\r\n    String propertyName \u003d \"property\";\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.add(propertyName, null);\r\n    assertThat(jsonObj.has(propertyName)).isTrue();\r\n    JsonElement jsonElement \u003d jsonObj.get(propertyName);\r\n    assertThat(jsonElement).isNotNull();\r\n    assertThat(jsonElement.isJsonNull()).isTrue();\r\n}",
    "testWritePropertyWithEmptyStringName": "{\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.add(\"\", new JsonPrimitive(true));\r\n    assertThat(new Gson().toJson(jsonObj)).isEqualTo(\"{\\\"\\\":true}\");\r\n}",
    "testAddingCharacterProperties": "{\r\n    String propertyName \u003d \"property\";\r\n    char value \u003d \u0027a\u0027;\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.addProperty(propertyName, value);\r\n    assertThat(jsonObj.has(propertyName)).isTrue();\r\n    JsonElement jsonElement \u003d jsonObj.get(propertyName);\r\n    assertThat(jsonElement).isNotNull();\r\n    assertThat(jsonElement.getAsString()).isEqualTo(String.valueOf(value));\r\n    @SuppressWarnings(\"deprecation\")\r\n    char character \u003d jsonElement.getAsCharacter();\r\n    assertThat(character).isEqualTo(value);\r\n}",
    "testAddingBooleanProperties": "{\r\n    String propertyName \u003d \"property\";\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.addProperty(propertyName, true);\r\n    assertThat(jsonObj.has(propertyName)).isTrue();\r\n    JsonElement jsonElement \u003d jsonObj.get(propertyName);\r\n    assertThat(jsonElement).isNotNull();\r\n    assertThat(jsonElement.getAsBoolean()).isTrue();\r\n}",
    "testEntrySet": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    assertThat(o.entrySet()).hasSize(0);\r\n    o.addProperty(\"b\", true);\r\n    Set\u003c?\u003e expectedEntries \u003d Collections.singleton(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(true)));\r\n    assertThat(o.entrySet()).isEqualTo(expectedEntries);\r\n    assertThat(o.entrySet()).hasSize(1);\r\n    o.addProperty(\"a\", false);\r\n    // Insertion order should be preserved by entrySet()\r\n    List\u003c?\u003e expectedEntriesList \u003d Arrays.asList(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(true)), new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(false)));\r\n    assertThat(new ArrayList\u003c\u003e(o.entrySet())).isEqualTo(expectedEntriesList);\r\n    Iterator\u003cEntry\u003cString, JsonElement\u003e\u003e iterator \u003d o.entrySet().iterator();\r\n    // Test behavior of Entry.setValue\r\n    for (int i \u003d 0; i \u003c o.size(); i++) {\r\n        Entry\u003cString, JsonElement\u003e entry \u003d iterator.next();\r\n        entry.setValue(new JsonPrimitive(i));\r\n        assertThat(entry.getValue()).isEqualTo(new JsonPrimitive(i));\r\n    }\r\n    expectedEntriesList \u003d Arrays.asList(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(0)), new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(1)));\r\n    assertThat(new ArrayList\u003c\u003e(o.entrySet())).isEqualTo(expectedEntriesList);\r\n    Entry\u003cString, JsonElement\u003e entry \u003d o.entrySet().iterator().next();\r\n    try {\r\n        // null value is not permitted, only JsonNull is supported\r\n        // This intentionally deviates from the behavior of the other JsonObject methods which\r\n        // implicitly convert null -\u003e JsonNull, to match more closely the contract of Map.Entry\r\n        entry.setValue(null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n    assertThat(entry.getValue()).isNotNull();\r\n    o.addProperty(\"key1\", 1);\r\n    o.addProperty(\"key2\", 2);\r\n    Deque\u003c?\u003e expectedEntriesQueue \u003d new ArrayDeque\u003c\u003e(Arrays.asList(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(0)), new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(1)), new SimpleEntry\u003c\u003e(\"key1\", new JsonPrimitive(1)), new SimpleEntry\u003c\u003e(\"key2\", new JsonPrimitive(2))));\r\n    // Note: Must wrap in ArrayList because Deque implementations do not implement `equals`\r\n    assertThat(new ArrayList\u003c\u003e(o.entrySet())).isEqualTo(new ArrayList\u003c\u003e(expectedEntriesQueue));\r\n    iterator \u003d o.entrySet().iterator();\r\n    // Remove entries one by one\r\n    for (int i \u003d o.size(); i \u003e\u003d 1; i--) {\r\n        assertThat(iterator.hasNext()).isTrue();\r\n        assertThat(iterator.next()).isEqualTo(expectedEntriesQueue.getFirst());\r\n        iterator.remove();\r\n        expectedEntriesQueue.removeFirst();\r\n        assertThat(o.size()).isEqualTo(i - 1);\r\n        assertThat(new ArrayList\u003c\u003e(o.entrySet())).isEqualTo(new ArrayList\u003c\u003e(expectedEntriesQueue));\r\n    }\r\n}",
    "testAddingStringProperties": "{\r\n    String propertyName \u003d \"property\";\r\n    String value \u003d \"blah\";\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.addProperty(propertyName, value);\r\n    assertThat(jsonObj.has(propertyName)).isTrue();\r\n    JsonElement jsonElement \u003d jsonObj.get(propertyName);\r\n    assertThat(jsonElement).isNotNull();\r\n    assertThat(jsonElement.getAsString()).isEqualTo(value);\r\n}",
    "testReadPropertyWithEmptyStringName": "{\r\n    JsonObject jsonObj \u003d JsonParser.parseString(\"{\\\"\\\":true}\").getAsJsonObject();\r\n    assertThat(jsonObj.get(\"\").getAsBoolean()).isTrue();\r\n}",
    "testEqualsOnEmptyObject": "{\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonObject(), new JsonObject());\r\n}",
    "testAddingNullOrEmptyPropertyName": "{\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    try {\r\n        jsonObj.add(null, JsonNull.INSTANCE);\r\n        fail(\"Should not allow null property names.\");\r\n    } catch (NullPointerException expected) {\r\n    }\r\n    jsonObj.add(\"\", JsonNull.INSTANCE);\r\n    jsonObj.add(\"   \\t\", JsonNull.INSTANCE);\r\n}",
    "testEqualsHashCodeIgnoringOrder": "{\r\n    JsonObject a \u003d new JsonObject();\r\n    JsonObject b \u003d new JsonObject();\r\n    a.addProperty(\"1\", true);\r\n    b.addProperty(\"2\", false);\r\n    a.addProperty(\"2\", false);\r\n    b.addProperty(\"1\", true);\r\n    assertThat(new ArrayList\u003c\u003e(a.keySet())).containsExactly(\"1\", \"2\").inOrder();\r\n    assertThat(new ArrayList\u003c\u003e(b.keySet())).containsExactly(\"2\", \"1\").inOrder();\r\n    MoreAsserts.assertEqualsAndHashCode(a, b);\r\n}",
    "testDeepCopy": "{\r\n    JsonObject original \u003d new JsonObject();\r\n    JsonArray firstEntry \u003d new JsonArray();\r\n    original.add(\"key\", firstEntry);\r\n    JsonObject copy \u003d original.deepCopy();\r\n    firstEntry.add(new JsonPrimitive(\"z\"));\r\n    assertThat(original.get(\"key\").getAsJsonArray()).hasSize(1);\r\n    assertThat(copy.get(\"key\").getAsJsonArray()).hasSize(0);\r\n}",
    "testKeySet": "{\r\n    JsonObject a \u003d new JsonObject();\r\n    assertThat(a.keySet()).hasSize(0);\r\n    a.add(\"foo\", new JsonArray());\r\n    a.add(\"bar\", new JsonObject());\r\n    assertThat(a.size()).isEqualTo(2);\r\n    assertThat(a.keySet()).hasSize(2);\r\n    assertThat(a.keySet()).containsExactly(\"foo\", \"bar\").inOrder();\r\n    a.addProperty(\"1\", true);\r\n    a.addProperty(\"2\", false);\r\n    // Insertion order should be preserved by keySet()\r\n    Deque\u003cString\u003e expectedKeys \u003d new ArrayDeque\u003c\u003e(Arrays.asList(\"foo\", \"bar\", \"1\", \"2\"));\r\n    // Note: Must wrap in ArrayList because Deque implementations do not implement `equals`\r\n    assertThat(new ArrayList\u003c\u003e(a.keySet())).isEqualTo(new ArrayList\u003c\u003e(expectedKeys));\r\n    Iterator\u003cString\u003e iterator \u003d a.keySet().iterator();\r\n    // Remove keys one by one\r\n    for (int i \u003d a.size(); i \u003e\u003d 1; i--) {\r\n        assertThat(iterator.hasNext()).isTrue();\r\n        assertThat(iterator.next()).isEqualTo(expectedKeys.getFirst());\r\n        iterator.remove();\r\n        expectedKeys.removeFirst();\r\n        assertThat(a.size()).isEqualTo(i - 1);\r\n        assertThat(new ArrayList\u003c\u003e(a.keySet())).isEqualTo(new ArrayList\u003c\u003e(expectedKeys));\r\n    }\r\n}",
    "testPropertyWithQuotes": "{\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.add(\"a\\\"b\", new JsonPrimitive(\"c\\\"d\"));\r\n    String json \u003d new Gson().toJson(jsonObj);\r\n    assertThat(json).isEqualTo(\"{\\\"a\\\\\\\"b\\\":\\\"c\\\\\\\"d\\\"}\");\r\n}",
    "testIsEmpty": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    assertThat(o.isEmpty()).isTrue();\r\n    o.add(\"Hello\", new JsonPrimitive(1));\r\n    assertThat(o.isEmpty()).isFalse();\r\n    o.remove(\"Hello\");\r\n    assertThat(o.isEmpty()).isTrue();\r\n}",
    "testSize": "{\r\n    JsonObject o \u003d new JsonObject();\r\n    assertThat(o.size()).isEqualTo(0);\r\n    o.add(\"Hello\", new JsonPrimitive(1));\r\n    assertThat(o.size()).isEqualTo(1);\r\n    o.add(\"Hi\", new JsonPrimitive(1));\r\n    assertThat(o.size()).isEqualTo(2);\r\n    o.remove(\"Hello\");\r\n    assertThat(o.size()).isEqualTo(1);\r\n}"
  },
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\ParseBenchmark.java": {
    "getResourceFile": "{\r\n    URL url \u003d ParseBenchmark.class.getResource(path);\r\n    if (url \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Resource \" + path + \" does not exist\");\r\n    }\r\n    File file \u003d new File(url.toURI());\r\n    if (!file.isFile()) {\r\n        throw new IllegalArgumentException(\"Resource \" + path + \" is not a file\");\r\n    }\r\n    return file;\r\n}",
    "timeParse": "{\r\n    for (int i \u003d 0; i \u003c reps; i++) {\r\n        parser.parse(text, document);\r\n    }\r\n}",
    "readToken": "{\r\n    while (true) {\r\n        switch(reader.peek()) {\r\n            case BEGIN_ARRAY:\r\n                reader.beginArray();\r\n                break;\r\n            case END_ARRAY:\r\n                reader.endArray();\r\n                break;\r\n            case BEGIN_OBJECT:\r\n                reader.beginObject();\r\n                break;\r\n            case END_OBJECT:\r\n                reader.endObject();\r\n                break;\r\n            case NAME:\r\n                reader.nextName();\r\n                break;\r\n            case BOOLEAN:\r\n                reader.nextBoolean();\r\n                break;\r\n            case NULL:\r\n                reader.nextNull();\r\n                break;\r\n            case NUMBER:\r\n                reader.nextLong();\r\n                break;\r\n            case STRING:\r\n                reader.nextString();\r\n                break;\r\n            case END_DOCUMENT:\r\n                return;\r\n            default:\r\n                throw new IllegalArgumentException(\"Unexpected token\" + reader.peek());\r\n        }\r\n    }\r\n}",
    "setUp": "{\r\n    text \u003d resourceToString(document.name() + \".json\").toCharArray();\r\n    parser \u003d api.newParser();\r\n}",
    "main": "{\r\n    NonUploadingCaliperRunner.run(ParseBenchmark.class, args);\r\n}",
    "toString": "{\r\n    return userId;\r\n}",
    "newParser": "{\r\n    return new GsonBindParser();\r\n}",
    "parse": "{\r\n    mapper.readValue(new CharArrayReader(data), document.jacksonType);\r\n}",
    "resourceToString": "{\r\n    ZipFile zipFile \u003d new ZipFile(getResourceFile(\"/ParseBenchmarkData.zip\"));\r\n    try {\r\n        ZipEntry zipEntry \u003d zipFile.getEntry(fileName);\r\n        Reader reader \u003d new InputStreamReader(zipFile.getInputStream(zipEntry), StandardCharsets.UTF_8);\r\n        char[] buffer \u003d new char[8192];\r\n        StringWriter writer \u003d new StringWriter();\r\n        int count;\r\n        while ((count \u003d reader.read(buffer)) !\u003d -1) {\r\n            writer.write(buffer, 0, count);\r\n        }\r\n        reader.close();\r\n        return writer.toString();\r\n    } finally {\r\n        zipFile.close();\r\n    }\r\n}"
  },
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\interceptors\\InterceptorFactory.java": {
    "read": "{\r\n    T result \u003d delegate.read(in);\r\n    postDeserializer.postDeserialize(result);\r\n    return result;\r\n}",
    "create": "{\r\n    Intercept intercept \u003d type.getRawType().getAnnotation(Intercept.class);\r\n    if (intercept \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n    return new InterceptorAdapter\u003c\u003e(delegate, intercept);\r\n}",
    "write": "{\r\n    delegate.write(out, value);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\stream\\JsonReaderTest.java": {
    "testVeryLongUnterminatedString": "{\r\n    char[] stringChars \u003d new char[1024 * 16];\r\n    Arrays.fill(stringChars, \u0027x\u0027);\r\n    String string \u003d new String(stringChars);\r\n    String json \u003d \"[\" + string;\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(string);\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (EOFException expected) {\r\n    }\r\n}",
    "testEscapedNewlineAllowedInDefaultMode": "{\r\n    String json \u003d \"\\\"\\\\\\n\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    assertThat(reader.nextString()).isEqualTo(\"\\n\");\r\n}",
    "testReadEmptyArray": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.hasNext()).isFalse();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testPeekLargerThanLongMinValue": "{\r\n    @SuppressWarnings(\"FloatingPointLiteralPrecision\")\r\n    double d \u003d -9223372036854775809d;\r\n    JsonReader reader \u003d new JsonReader(reader(\"[-9223372036854775809]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextDouble()).isEqualTo(d);\r\n}",
    "testVeryLongUnquotedLiteral": "{\r\n    String literal \u003d \"a\" + repeat(\u0027b\u0027, 8192) + \"c\";\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\" + literal + \"]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(literal);\r\n    reader.endArray();\r\n}",
    "testReadArray": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true, true]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testStringAsNumberWithNonDigitExponent": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[123eb]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n}",
    "testIntegerMismatchFailuresDoNotAdvance": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[1.5]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextDouble()).isEqualTo(1.5d);\r\n    reader.endArray();\r\n}",
    "testSkipDouble": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":-123.456e-789,\\\"b\\\":123456789.0}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    reader.skipValue();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testStrictCommentsWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[// comment \\n true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[# comment \\n true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[/* comment */ true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "testStrictUnquotedNamesWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{a:true}\"));\r\n    reader.beginObject();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $.\");\r\n    }\r\n}",
    "testCapitalizedNullFailWhenStrict": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"NULL\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextNull);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n    reader \u003d new JsonReader(reader(\"nulL\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    expected \u003d assertThrows(IOException.class, reader::nextNull);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n}",
    "testUnescapingTruncatedCharacters": "{\r\n    String json \u003d \"[\\\"\\\\u000\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unterminated escape sequence at line 1 column 5 path $[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testNegativeZero": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[-0]\"));\r\n    reader.setStrictness(Strictness.LEGACY_STRICT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    assertThat(reader.nextString()).isEqualTo(\"-0\");\r\n}",
    "testMalformedNumbers": "{\r\n    assertNotANumber(\"-\");\r\n    assertNotANumber(\".\");\r\n    // plus sign is not allowed for integer part\r\n    assertNotANumber(\"+1\");\r\n    // leading 0 is not allowed for integer part\r\n    assertNotANumber(\"00\");\r\n    assertNotANumber(\"01\");\r\n    // exponent lacks digit\r\n    assertNotANumber(\"e\");\r\n    assertNotANumber(\"0e\");\r\n    assertNotANumber(\".e\");\r\n    assertNotANumber(\"0.e\");\r\n    assertNotANumber(\"-.0e\");\r\n    // no integer\r\n    assertNotANumber(\"e1\");\r\n    assertNotANumber(\".e1\");\r\n    assertNotANumber(\"-e1\");\r\n    // trailing characters\r\n    assertNotANumber(\"1x\");\r\n    assertNotANumber(\"1.1x\");\r\n    assertNotANumber(\"1e1x\");\r\n    assertNotANumber(\"1ex\");\r\n    assertNotANumber(\"1.1ex\");\r\n    assertNotANumber(\"1.1e1x\");\r\n    // fraction has no digit\r\n    assertNotANumber(\"0.\");\r\n    assertNotANumber(\"-0.\");\r\n    assertNotANumber(\"0.e1\");\r\n    assertNotANumber(\"-0.e1\");\r\n    // no leading digit\r\n    assertNotANumber(\".0\");\r\n    assertNotANumber(\"-.0\");\r\n    assertNotANumber(\".0e1\");\r\n    assertNotANumber(\"-.0e1\");\r\n}",
    "testSkipValueAtArrayEnd": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[]\"));\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "testLenientComments": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[// comment \\n true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader \u003d new JsonReader(reader(\"[# comment \\n true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader \u003d new JsonReader(reader(\"[/* comment */ true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n}",
    "testStrictNameValueSeparator": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003dtrue}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003d\u003etrue}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n}",
    "testStrictSingleQuotedStringsWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\u0027a\u0027]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "testStrictExtraCommasInMaps": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":\\\"b\\\",}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"b\");\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected name at line 1 column 11 path $.a\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testCapitalizedTrueFailWhenStrict": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"TRUE\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextBoolean);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n    reader \u003d new JsonReader(reader(\"True\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    expected \u003d assertThrows(IOException.class, reader::nextBoolean);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n}",
    "testStrictUnquotedNames": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{a:true}\"));\r\n    reader.beginObject();\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $.\");\r\n    }\r\n}",
    "testDoubles": "{\r\n    String json \u003d \"[-0.0,\" + \"1.0,\" + \"1.7976931348623157E308,\" + \"4.9E-324,\" + \"0.0,\" + \"0.00,\" + \"-0.5,\" + \"2.2250738585072014E-308,\" + \"3.141592653589793,\" + \"2.718281828459045,\" + \"0,\" + \"0.01,\" + \"0e0,\" + \"1e+0,\" + \"1e-0,\" + // leading 0 is allowed for exponent\r\n    \"1e0000,\" + \"1e00001,\" + \"1e+1]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    assertThat(reader.nextDouble()).isEqualTo(-0.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.7976931348623157E308);\r\n    assertThat(reader.nextDouble()).isEqualTo(4.9E-324);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(-0.5);\r\n    assertThat(reader.nextDouble()).isEqualTo(2.2250738585072014E-308);\r\n    assertThat(reader.nextDouble()).isEqualTo(3.141592653589793);\r\n    assertThat(reader.nextDouble()).isEqualTo(2.718281828459045);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.01);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(10.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(10.0);\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testPrematureEndOfInput": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":true,\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (EOFException expected) {\r\n    }\r\n}",
    "testPeekLargerThanLongMaxValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[9223372036854775808]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException e) {\r\n    }\r\n}",
    "testSkipVeryLongQuotedString": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\\"\" + repeat(\u0027x\u0027, 8192) + \"\\\"]\"));\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    reader.endArray();\r\n}",
    "testSkipTopLevelQuotedString": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"\\\"\" + repeat(\u0027x\u0027, 8192) + \"\\\"\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testStrictMultipleTopLevelValues": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[] []\"));\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 5 path $\");\r\n    }\r\n}",
    "testLenientExtraCommasInMaps": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":\\\"b\\\",}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"b\");\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected name at line 1 column 11 path $.a\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testStrictSemicolonDelimitedNameValuePair": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":true;\\\"b\\\":true}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        boolean unused \u003d reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n}",
    "testStrictSemicolonDelimitedNameValuePairWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":true;\\\"b\\\":true}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n}",
    "testSkipVeryLongUnquotedString": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\" + repeat(\u0027x\u0027, 8192) + \"]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    reader.endArray();\r\n}",
    "testSkipObject": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": { \\\"c\\\": [], \\\"d\\\": [true, true, {}] }, \\\"b\\\": \\\"banana\\\"}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    reader.skipValue();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testLongLargerThanMaxLongThatWrapsAround": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[22233720368547758070]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n}",
    "testNextFailuresDoNotAdvance": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":true}\"));\r\n    reader.beginObject();\r\n    try {\r\n        String unused \u003d reader.nextString();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a string\", \"NAME\", \"line 1 column 3 path $.\");\r\n    }\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        String unused \u003d reader.nextName();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a name\", \"BOOLEAN\", \"line 1 column 10 path $.a\");\r\n    }\r\n    try {\r\n        reader.beginArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"BEGIN_ARRAY\", \"BOOLEAN\", \"line 1 column 10 path $.a\");\r\n    }\r\n    try {\r\n        reader.endArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"END_ARRAY\", \"BOOLEAN\", \"line 1 column 10 path $.a\");\r\n    }\r\n    try {\r\n        reader.beginObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"BEGIN_OBJECT\", \"BOOLEAN\", \"line 1 column 10 path $.a\");\r\n    }\r\n    try {\r\n        reader.endObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"END_OBJECT\", \"BOOLEAN\", \"line 1 column 10 path $.a\");\r\n    }\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a string\", \"END_OBJECT\", \"line 1 column 11 path $.a\");\r\n    }\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a name\", \"END_OBJECT\", \"line 1 column 11 path $.a\");\r\n    }\r\n    try {\r\n        reader.beginArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"BEGIN_ARRAY\", \"END_OBJECT\", \"line 1 column 11 path $.a\");\r\n    }\r\n    try {\r\n        reader.endArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"END_ARRAY\", \"END_OBJECT\", \"line 1 column 11 path $.a\");\r\n    }\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    reader.close();\r\n}",
    "testStrictVeryLongNumber": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[0.\" + repeat(\u00279\u0027, 8192) + \"]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "testStrictNonExecutePrefix": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\")]}\u0027\\n []\"));\r\n    try {\r\n        reader.beginArray();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 1 path $\");\r\n    }\r\n}",
    "assertDocument": "{\r\n    JsonReader reader \u003d new JsonReader(reader(document));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    for (Object expectation : expectations) {\r\n        if (expectation \u003d\u003d BEGIN_OBJECT) {\r\n            reader.beginObject();\r\n        } else if (expectation \u003d\u003d BEGIN_ARRAY) {\r\n            reader.beginArray();\r\n        } else if (expectation \u003d\u003d END_OBJECT) {\r\n            reader.endObject();\r\n        } else if (expectation \u003d\u003d END_ARRAY) {\r\n            reader.endArray();\r\n        } else if (expectation \u003d\u003d NAME) {\r\n            assertThat(reader.nextName()).isEqualTo(\"name\");\r\n        } else if (expectation \u003d\u003d BOOLEAN) {\r\n            assertThat(reader.nextBoolean()).isFalse();\r\n        } else if (expectation \u003d\u003d STRING) {\r\n            assertThat(reader.nextString()).isEqualTo(\"string\");\r\n        } else if (expectation \u003d\u003d NUMBER) {\r\n            assertThat(reader.nextInt()).isEqualTo(123);\r\n        } else if (expectation \u003d\u003d NULL) {\r\n            reader.nextNull();\r\n        } else if (expectation instanceof Class \u0026\u0026 Exception.class.isAssignableFrom((Class\u003c?\u003e) expectation)) {\r\n            try {\r\n                reader.peek();\r\n                fail();\r\n            } catch (Exception expected) {\r\n                assertThat(expected.getClass()).isEqualTo((Class\u003c?\u003e) expectation);\r\n            }\r\n        } else {\r\n            throw new AssertionError(\"Unsupported expectation value: \" + expectation);\r\n        }\r\n    }\r\n}",
    "testSkipObjectNameSingleQuoted": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\u0027a\u0027: 1}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n}",
    "testStrictMultipleTopLevelValuesWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[] []\"));\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 5 path $\");\r\n    }\r\n}",
    "testHasNextEndOfDocument": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.hasNext()).isFalse();\r\n}",
    "testSkipValueAtObjectEnd": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "testReaderDoesNotTreatU2028U2029AsNewline": "{\r\n    // This test shows that the JSON string [\\n\"whatever\"] is seen as valid\r\n    // And the JSON string [\\u2028\"whatever\"] is not.\r\n    String jsonInvalid2028 \u003d \"[\\u2028\\\"whatever\\\"]\";\r\n    JsonReader readerInvalid2028 \u003d new JsonReader(reader(jsonInvalid2028));\r\n    readerInvalid2028.beginArray();\r\n    assertThrows(IOException.class, readerInvalid2028::nextString);\r\n    String jsonInvalid2029 \u003d \"[\\u2029\\\"whatever\\\"]\";\r\n    JsonReader readerInvalid2029 \u003d new JsonReader(reader(jsonInvalid2029));\r\n    readerInvalid2029.beginArray();\r\n    assertThrows(IOException.class, readerInvalid2029::nextString);\r\n    String jsonValid \u003d \"[\\n\\\"whatever\\\"]\";\r\n    JsonReader readerValid \u003d new JsonReader(reader(jsonValid));\r\n    readerValid.beginArray();\r\n    assertThat(readerValid.nextString()).isEqualTo(\"whatever\");\r\n    // And even in STRICT mode U+2028 and U+2029 are not considered control characters\r\n    // and can appear unescaped in JSON string\r\n    String jsonValid2028And2029 \u003d \"\\\"whatever\\u2028\\u2029\\\"\";\r\n    JsonReader readerValid2028And2029 \u003d new JsonReader(reader(jsonValid2028And2029));\r\n    readerValid2028And2029.setStrictness(Strictness.STRICT);\r\n    assertThat(readerValid2028And2029.nextString()).isEqualTo(\"whatever\\u2028\\u2029\");\r\n}",
    "testSetStrictnessNull": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    assertThrows(NullPointerException.class, () -\u003e reader.setStrictness(null));\r\n}",
    "testPeekMuchLargerThanLongMinValue": "{\r\n    @SuppressWarnings(\"FloatingPointLiteralPrecision\")\r\n    double d \u003d -92233720368547758080d;\r\n    JsonReader reader \u003d new JsonReader(reader(\"[-92233720368547758080]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextDouble()).isEqualTo(d);\r\n}",
    "testReadObject": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": \\\"android\\\", \\\"b\\\": \\\"banana\\\"}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"android\");\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    assertThat(reader.nextString()).isEqualTo(\"banana\");\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testLenientSemicolonDelimitedNameValuePair": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":true;\\\"b\\\":true}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n}",
    "testVeryLongUnquotedString": "{\r\n    char[] stringChars \u003d new char[1024 * 16];\r\n    Arrays.fill(stringChars, \u0027x\u0027);\r\n    String string \u003d new String(stringChars);\r\n    String json \u003d \"[\" + string + \"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(string);\r\n    reader.endArray();\r\n}",
    "testSkipInteger": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":123456789,\\\"b\\\":-123456789}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    reader.skipValue();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testLenientVeryLongNumber": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[0.\" + repeat(\u00279\u0027, 8192) + \"]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.STRING);\r\n    assertThat(reader.nextDouble()).isEqualTo(1d);\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testStrictSingleQuotedNamesWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\u0027a\u0027:true}\"));\r\n    reader.beginObject();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $.\");\r\n    }\r\n}",
    "testDeeplyNestedArrays": "{\r\n    // this is nested 40 levels deep; Gson is tuned for nesting is 30 levels deep or fewer\r\n    JsonReader reader \u003d new JsonReader(reader(\"[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\"));\r\n    for (int i \u003d 0; i \u003c 40; i++) {\r\n        reader.beginArray();\r\n    }\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]\" + \"[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]\");\r\n    for (int i \u003d 0; i \u003c 40; i++) {\r\n        reader.endArray();\r\n    }\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testLenientSingleQuotedStrings": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\u0027a\u0027]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"a\");\r\n}",
    "testSkipObjectName": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": 1}\"));\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n}",
    "testStringEndingInSlash": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"/\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected value at line 1 column 1 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testMixedCaseLiterals": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[True,TruE,False,FALSE,NULL,nulL]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextBoolean()).isFalse();\r\n    assertThat(reader.nextBoolean()).isFalse();\r\n    reader.nextNull();\r\n    reader.nextNull();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testStrictModeFailsToParseUnescapedControlCharacter": "{\r\n    String json \u003d \"\\\"\\0\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextString);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n    json \u003d \"\\\"\\t\\\"\";\r\n    reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    expected \u003d assertThrows(IOException.class, reader::nextString);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n    json \u003d \"\\\"\\u001F\\\"\";\r\n    reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    expected \u003d assertThrows(IOException.class, reader::nextString);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n}",
    "testStringAsNumberWithTruncatedExponent": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[123e]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n}",
    "assertUnexpectedStructureError": "{\r\n    String troubleshootingId \u003d actualToken.equals(\"NULL\") ? \"adapter-not-null-safe\" : \"unexpected-json-structure\";\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"Expected \" + expectedToken + \" but was \" + actualToken + \" at \" + expectedLocation + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#\" + troubleshootingId);\r\n}",
    "reader": "{\r\n    /* if (true) */\r\n    return new StringReader(s);\r\n    /* return new Reader() {\r\n      int position \u003d 0;\r\n      @Override public int read(char[] buffer, int offset, int count) throws IOException {\r\n        if (position \u003d\u003d s.length()) {\r\n          return -1;\r\n        } else if (count \u003e 0) {\r\n          buffer[offset] \u003d s.charAt(position++);\r\n          return 1;\r\n        } else {\r\n          throw new IllegalArgumentException();\r\n        }\r\n      }\r\n      @Override public void close() throws IOException {\r\n      }\r\n    }; */\r\n}",
    "testQuotedNumberWithEscape": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\\"12\\\\u00334\\\"]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n    assertThat(reader.nextInt()).isEqualTo(1234);\r\n}",
    "testTopLevelValueTypes": "{\r\n    JsonReader reader1 \u003d new JsonReader(reader(\"true\"));\r\n    assertThat(reader1.nextBoolean()).isTrue();\r\n    assertThat(reader1.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    JsonReader reader2 \u003d new JsonReader(reader(\"false\"));\r\n    assertThat(reader2.nextBoolean()).isFalse();\r\n    assertThat(reader2.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    JsonReader reader3 \u003d new JsonReader(reader(\"null\"));\r\n    assertThat(reader3.peek()).isEqualTo(JsonToken.NULL);\r\n    reader3.nextNull();\r\n    assertThat(reader3.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    JsonReader reader4 \u003d new JsonReader(reader(\"123\"));\r\n    assertThat(reader4.nextInt()).isEqualTo(123);\r\n    assertThat(reader4.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    JsonReader reader5 \u003d new JsonReader(reader(\"123.4\"));\r\n    assertThat(reader5.nextDouble()).isEqualTo(123.4);\r\n    assertThat(reader5.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    JsonReader reader6 \u003d new JsonReader(reader(\"\\\"a\\\"\"));\r\n    assertThat(reader6.nextString()).isEqualTo(\"a\");\r\n    assertThat(reader6.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testStrictUnquotedStringsWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[a]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "testLenientMultipleTopLevelValues": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[] true {}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testStringAsNumberWithDigitAndNonDigitExponent": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[123e4b]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n}",
    "testUnterminatedStringFailure": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\\"string\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.STRING);\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unterminated string at line 1 column 9 path $[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testStrictQuotedNonFiniteDoubles": "{\r\n    String json \u003d \"[\\\"NaN\\\"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: NaN at line 1 column 7 path $[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testFailWithPositionOverCStyleComment": "{\r\n    testFailWithPosition(\"Expected value at line 6 column 12 path $[1]\", \"\\n\\n/* foo\\n*\\n*\\r\\nbar */[\\\"a\\\",}\");\r\n}",
    "testFailWithPositionDeepPath": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[1,{\\\"a\\\":[2,3,}\"));\r\n    reader.beginArray();\r\n    int unused1 \u003d reader.nextInt();\r\n    reader.beginObject();\r\n    String unused2 \u003d reader.nextName();\r\n    reader.beginArray();\r\n    int unused3 \u003d reader.nextInt();\r\n    int unused4 \u003d reader.nextInt();\r\n    try {\r\n        JsonToken unused5 \u003d reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected value at line 1 column 14 path $[1].a[2]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testReadEmptyObject": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.hasNext()).isFalse();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testStrictComments": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[// comment \\n true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[# comment \\n true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[/* comment */ true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "assertStrictError": "{\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON at \" + expectedLocation + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n}",
    "testSkipValueAfterEndOfDocument": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "testCapitalizedFalseFailWhenStrict": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"FALSE\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextBoolean);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n    reader \u003d new JsonReader(reader(\"FaLse\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    expected \u003d assertThrows(IOException.class, reader::nextBoolean);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n}",
    "testNullLiteralIsNotAString": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[null]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a string\", \"NULL\", \"line 1 column 6 path $[0]\");\r\n    }\r\n}",
    "testStrictSemicolonDelimitedArrayWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true;true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "testSkipObjectNameUnquoted": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{a: 1}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n}",
    "testCharacterUnescaping": "{\r\n    String json \u003d \"[\\\"a\\\",\" + \"\\\"a\\\\\\\"\\\",\" + \"\\\"\\\\\\\"\\\",\" + \"\\\":\\\",\" + \"\\\",\\\",\" + \"\\\"\\\\b\\\",\" + \"\\\"\\\\f\\\",\" + \"\\\"\\\\n\\\",\" + \"\\\"\\\\r\\\",\" + \"\\\"\\\\t\\\",\" + \"\\\" \\\",\" + \"\\\"\\\\\\\\\\\",\" + \"\\\"{\\\",\" + \"\\\"}\\\",\" + \"\\\"[\\\",\" + \"\\\"]\\\",\" + \"\\\"\\\\u0000\\\",\" + \"\\\"\\\\u0019\\\",\" + \"\\\"\\\\u20AC\\\"\" + \"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"a\\\"\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\\"\");\r\n    assertThat(reader.nextString()).isEqualTo(\":\");\r\n    assertThat(reader.nextString()).isEqualTo(\",\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\b\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\f\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\n\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\r\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\t\");\r\n    assertThat(reader.nextString()).isEqualTo(\" \");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\\\\");\r\n    assertThat(reader.nextString()).isEqualTo(\"{\");\r\n    assertThat(reader.nextString()).isEqualTo(\"}\");\r\n    assertThat(reader.nextString()).isEqualTo(\"[\");\r\n    assertThat(reader.nextString()).isEqualTo(\"]\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\0\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\u0019\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\u20AC\");\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testStringWithLeadingSlash": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"/x\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected value at line 1 column 1 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testHighPrecisionLong": "{\r\n    String json \u003d \"[9223372036854775806.000]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    assertThat(reader.nextLong()).isEqualTo(9223372036854775806L);\r\n    reader.endArray();\r\n}",
    "testLenientUnquotedNames": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{a:true}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n}",
    "testLongs": "{\r\n    String json \u003d \"[0,0,0,\" + \"1,1,1,\" + \"-1,-1,-1,\" + \"-9223372036854775808,\" + \"9223372036854775807]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    assertThat(reader.nextLong()).isEqualTo(0L);\r\n    assertThat(reader.nextInt()).isEqualTo(0);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.0);\r\n    assertThat(reader.nextLong()).isEqualTo(1L);\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextLong()).isEqualTo(-1L);\r\n    assertThat(reader.nextInt()).isEqualTo(-1);\r\n    assertThat(reader.nextDouble()).isEqualTo(-1.0);\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextLong()).isEqualTo(Long.MIN_VALUE);\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextLong()).isEqualTo(Long.MAX_VALUE);\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testMalformedDocuments": "{\r\n    assertDocument(\"{]\", BEGIN_OBJECT, MalformedJsonException.class);\r\n    assertDocument(\"{,\", BEGIN_OBJECT, MalformedJsonException.class);\r\n    assertDocument(\"{{\", BEGIN_OBJECT, MalformedJsonException.class);\r\n    assertDocument(\"{[\", BEGIN_OBJECT, MalformedJsonException.class);\r\n    assertDocument(\"{:\", BEGIN_OBJECT, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\",\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\",\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\":}\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"::\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\":,\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d}\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e}\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e\\\"string\\\":\", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e\\\"string\\\"\u003d\", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e\\\"string\\\"\u003d\u003e\", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e\\\"string\\\",\", BEGIN_OBJECT, NAME, STRING, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e\\\"string\\\",\\\"name\\\"\", BEGIN_OBJECT, NAME, STRING, NAME);\r\n    assertDocument(\"[}\", BEGIN_ARRAY, MalformedJsonException.class);\r\n    assertDocument(\"[,]\", BEGIN_ARRAY, NULL, NULL, END_ARRAY);\r\n    assertDocument(\"{\", BEGIN_OBJECT, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\"\", BEGIN_OBJECT, NAME, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\",\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\u0027name\u0027\", BEGIN_OBJECT, NAME, EOFException.class);\r\n    assertDocument(\"{\u0027name\u0027,\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{name\", BEGIN_OBJECT, NAME, EOFException.class);\r\n    assertDocument(\"[\", BEGIN_ARRAY, EOFException.class);\r\n    assertDocument(\"[string\", BEGIN_ARRAY, STRING, EOFException.class);\r\n    assertDocument(\"[\\\"string\\\"\", BEGIN_ARRAY, STRING, EOFException.class);\r\n    assertDocument(\"[\u0027string\u0027\", BEGIN_ARRAY, STRING, EOFException.class);\r\n    assertDocument(\"[123\", BEGIN_ARRAY, NUMBER, EOFException.class);\r\n    assertDocument(\"[123,\", BEGIN_ARRAY, NUMBER, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":123\", BEGIN_OBJECT, NAME, NUMBER, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":123,\", BEGIN_OBJECT, NAME, NUMBER, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":\\\"string\\\"\", BEGIN_OBJECT, NAME, STRING, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":\\\"string\\\",\", BEGIN_OBJECT, NAME, STRING, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":\u0027string\u0027\", BEGIN_OBJECT, NAME, STRING, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":\u0027string\u0027,\", BEGIN_OBJECT, NAME, STRING, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":false\", BEGIN_OBJECT, NAME, BOOLEAN, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":false,,\", BEGIN_OBJECT, NAME, BOOLEAN, MalformedJsonException.class);\r\n}",
    "testLenientSingleQuotedNames": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\u0027a\u0027:true}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n}",
    "testTopLevelValueTypeWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"true\"));\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testNonStrictModeParsesUnescapedControlCharacter": "{\r\n    String json \u003d \"\\\"\\t\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    assertThat(reader.nextString()).isEqualTo(\"\\t\");\r\n}",
    "testReadAcrossBuffers": "{\r\n    StringBuilder sb \u003d new StringBuilder(\"#\");\r\n    for (int i \u003d 0; i \u003c JsonReader.BUFFER_SIZE - 3; i++) {\r\n        sb.append(\u0027 \u0027);\r\n    }\r\n    sb.append(\"\\n)]}\u0027\\n3\");\r\n    JsonReader reader \u003d new JsonReader(reader(sb.toString()));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    JsonToken token \u003d reader.peek();\r\n    assertThat(token).isEqualTo(JsonToken.NUMBER);\r\n}",
    "testStrictModeAllowsOtherControlCharacters": "{\r\n    // JSON specification only forbids control characters U+0000 - U+001F, other control characters should be allowed\r\n    String json \u003d \"\\\"\\u007F\\u009F\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    assertThat(reader.nextString()).isEqualTo(\"\\u007F\\u009F\");\r\n}",
    "testPeekLongMaxValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[9223372036854775807]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    assertThat(reader.nextLong()).isEqualTo(9223372036854775807L);\r\n}",
    "testLenientPartialNonExecutePrefix": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\")]}\u0027 []\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    assertThat(reader.nextString()).isEqualTo(\")\");\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unexpected value at line 1 column 3 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testDeeplyNestedObjects": "{\r\n    // Build a JSON document structured like {\"a\":{\"a\":{\"a\":{\"a\":true}}}}, but 40 levels deep\r\n    String array \u003d \"{\\\"a\\\":%s}\";\r\n    String json \u003d \"true\";\r\n    for (int i \u003d 0; i \u003c 40; i++) {\r\n        json \u003d String.format(array, json);\r\n    }\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    for (int i \u003d 0; i \u003c 40; i++) {\r\n        reader.beginObject();\r\n        assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    }\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a\" + \".a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    for (int i \u003d 0; i \u003c 40; i++) {\r\n        reader.endObject();\r\n    }\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testUnterminatedObject": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":\\\"android\\\"x\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"android\");\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unterminated object at line 1 column 16 path $.a\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testStrictUnnecessaryArraySeparatorsWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true,,true]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 8 path $[1]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[,true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[true,]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 8 path $[1]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[,]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "assertNotANumber": "{\r\n    JsonReader reader \u003d new JsonReader(reader(s));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.STRING);\r\n    assertThat(reader.nextString()).isEqualTo(s);\r\n    JsonReader strictReader \u003d new JsonReader(reader(s));\r\n    try {\r\n        strictReader.nextDouble();\r\n        fail(\"Should have failed reading \" + s + \" as double\");\r\n    } catch (MalformedJsonException e) {\r\n        assertThat(e).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON\");\r\n    }\r\n}",
    "testLenientNonExecutePrefix": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\")]}\u0027\\n []\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testPeekingUnquotedStringsPrefixedWithBooleans": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[truey]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a boolean\", \"STRING\", \"line 1 column 2 path $[0]\");\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"truey\");\r\n    reader.endArray();\r\n}",
    "testSkipArray": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": [\\\"one\\\", \\\"two\\\", \\\"three\\\"], \\\"b\\\": 123}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    assertThat(reader.nextInt()).isEqualTo(123);\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testDocumentWithCommentEndingInSlash": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"/* foo *//\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected value at line 1 column 10 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testPeekLongMinValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[-9223372036854775808]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    assertThat(reader.nextLong()).isEqualTo(-9223372036854775808L);\r\n}",
    "testStrictUnnecessaryArraySeparators": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true,,true]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 8 path $[1]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[,true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[true,]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 8 path $[1]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[,]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "testStrictNonExecutePrefixWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\")]}\u0027\\n []\"));\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 1 path $\");\r\n    }\r\n}",
    "testFailWithPositionOverUnquotedString": "{\r\n    testFailWithPosition(\"Expected value at line 5 column 2 path $[1]\", \"[\\n\\nabcd\\n\\n,}\");\r\n}",
    "testVeryLongQuotedString": "{\r\n    char[] stringChars \u003d new char[1024 * 16];\r\n    Arrays.fill(stringChars, \u0027x\u0027);\r\n    String string \u003d new String(stringChars);\r\n    String json \u003d \"[\\\"\" + string + \"\\\"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(string);\r\n    reader.endArray();\r\n}",
    "testFailWithPositionGreaterThanBufferSize": "{\r\n    String spaces \u003d repeat(\u0027 \u0027, 8192);\r\n    testFailWithPosition(\"Expected value at line 6 column 5 path $[1]\", \"[\\n\\n\" + spaces + \"\\n\\n\\n\\\"a\\\",}]\");\r\n}",
    "testLenientNonFiniteDoubles": "{\r\n    String json \u003d \"[NaN, -Infinity, Infinity]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(Double.isNaN(reader.nextDouble())).isTrue();\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.NEGATIVE_INFINITY);\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.POSITIVE_INFINITY);\r\n    reader.endArray();\r\n}",
    "testSkipObjectAfterPeek": "{\r\n    String json \u003d \"{\" + \"  \\\"one\\\": { \\\"num\\\": 1 }\" + \", \\\"two\\\": { \\\"num\\\": 2 }\" + \", \\\"three\\\": { \\\"num\\\": 3 }\" + \"}\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"one\");\r\n    assertThat(reader.peek()).isEqualTo(BEGIN_OBJECT);\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"two\");\r\n    assertThat(reader.peek()).isEqualTo(BEGIN_OBJECT);\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"three\");\r\n    reader.skipValue();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testBomForbiddenAsOtherCharacterInDocument": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\ufeff]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.endArray();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "testFailWithPositionOverHashEndOfLineComment": "{\r\n    testFailWithPosition(\"Expected value at line 5 column 6 path $[1]\", \"\\n# foo\\n\\n#bar\\r\\n[\\\"a\\\",}\");\r\n}",
    "testSkipArrayAfterPeek": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": [\\\"one\\\", \\\"two\\\", \\\"three\\\"], \\\"b\\\": 123}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.peek()).isEqualTo(BEGIN_ARRAY);\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    assertThat(reader.nextInt()).isEqualTo(123);\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testLenientQuotedNonFiniteDoubles": "{\r\n    String json \u003d \"[\\\"NaN\\\", \\\"-Infinity\\\", \\\"Infinity\\\"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(Double.isNaN(reader.nextDouble())).isTrue();\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.NEGATIVE_INFINITY);\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.POSITIVE_INFINITY);\r\n    reader.endArray();\r\n}",
    "testEmptyStringName": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"\\\":true}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    assertThat(reader.peek()).isEqualTo(BEGIN_OBJECT);\r\n    reader.beginObject();\r\n    assertThat(reader.peek()).isEqualTo(NAME);\r\n    assertThat(reader.nextName()).isEqualTo(\"\");\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.BOOLEAN);\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_OBJECT);\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testLenientNonExecutePrefixWithLeadingWhitespace": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"\\r\\n \\t)]}\u0027\\n []\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testFailWithEscapedNewlineCharacter": "{\r\n    testFailWithPosition(\"Expected value at line 5 column 3 path $[1]\", \"[\\n\\n\\\"\\\\\\n\\n\\\",}\");\r\n}",
    "testMissingValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected value at line 1 column 6 path $.a\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testStrictNameValueSeparatorWithSkipValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003dtrue}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003d\u003etrue}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n}",
    "testLenientSemicolonDelimitedArray": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true;true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n}",
    "testLenientUnquotedStrings": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[a]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"a\");\r\n}",
    "testIntegersWithFractionalPartSpecified": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[1.0,1.0,1.0]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.nextLong()).isEqualTo(1L);\r\n}",
    "testLenientNameValueSeparator": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003dtrue}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003d\u003etrue}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n}",
    "testLongLargerThanMinLongThatWrapsAround": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[-22233720368547758070]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n}",
    "testStrictSingleQuotedStrings": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\u0027a\u0027]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "testSkipTopLevelObject": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": [\\\"one\\\", \\\"two\\\", \\\"three\\\"], \\\"b\\\": 123}\"));\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testInvalidJsonInput": "{\r\n    String json \u003d \"{\\n\" + \"   \\\"h\\\\ello\\\": true,\\n\" + \"   \\\"foo\\\": [\\\"world\\\"]\\n\" + \"}\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginObject();\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Invalid escape sequence at line 2 column 8 path $.\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testPrematurelyClosed": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":[]}\"));\r\n    reader.beginObject();\r\n    reader.close();\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"JsonReader is closed\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\":[]}\"));\r\n    reader.close();\r\n    try {\r\n        reader.beginObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"JsonReader is closed\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\":true}\"));\r\n    reader.beginObject();\r\n    String unused1 \u003d reader.nextName();\r\n    JsonToken unused2 \u003d reader.peek();\r\n    reader.close();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"JsonReader is closed\");\r\n    }\r\n}",
    "testStrictNonFiniteDoubles": "{\r\n    String json \u003d \"[NaN]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "testStringNullIsNotNull": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\\"null\\\"]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"null\", \"STRING\", \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "testBomIgnoredAsFirstCharacterOfDocument": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"\\ufeff[]\"));\r\n    reader.beginArray();\r\n    reader.endArray();\r\n}",
    "testNumberWithOctalPrefix": "{\r\n    String json \u003d \"[01]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"TODO\");\r\n    }\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"TODO\");\r\n    }\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"TODO\");\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"01\");\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "repeat": "{\r\n    char[] array \u003d new char[count];\r\n    Arrays.fill(array, c);\r\n    return new String(array);\r\n}",
    "testUnescapingInvalidCharacters": "{\r\n    String json \u003d \"[\\\"\\\\u000g\\\"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Malformed Unicode escape \\\\u000g at line 1 column 5 path $[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testBooleans": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true,false]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextBoolean()).isFalse();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testHelloWorld": "{\r\n    String json \u003d \"{\\n\" + \"   \\\"hello\\\": true,\\n\" + \"   \\\"foo\\\": [\\\"world\\\"]\\n\" + \"}\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"hello\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextName()).isEqualTo(\"foo\");\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"world\");\r\n    reader.endArray();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testPeekingUnquotedStringsPrefixedWithIntegers": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[12.34e5x]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"12.34e5x\");\r\n}",
    "testFailWithPositionIsOffsetByBom": "{\r\n    testFailWithPosition(\"Expected value at line 1 column 6 path $[1]\", \"\\ufeff[\\\"a\\\",}]\");\r\n}",
    "testSetStrictness": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    assertThat(reader.getStrictness()).isEqualTo(Strictness.STRICT);\r\n}",
    "testNulls": "{\r\n    try {\r\n        new JsonReader(null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "testEscapeCharacterQuoteWithoutStrictMode": "{\r\n    String json \u003d \"\\\"\\\\\u0027\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    assertThat(reader.nextString()).isEqualTo(\"\u0027\");\r\n}",
    "testUnescapingTruncatedSequence": "{\r\n    String json \u003d \"[\\\"\\\\\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unterminated escape sequence at line 1 column 4 path $[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "testLenientUnnecessaryArraySeparators": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true,,true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.nextNull();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.endArray();\r\n    reader \u003d new JsonReader(reader(\"[,true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.nextNull();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.endArray();\r\n    reader \u003d new JsonReader(reader(\"[true,]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.nextNull();\r\n    reader.endArray();\r\n    reader \u003d new JsonReader(reader(\"[,]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.nextNull();\r\n    reader.nextNull();\r\n    reader.endArray();\r\n}",
    "testStrictUnquotedStrings": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[a]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "testStrictNonFiniteDoublesWithSkipValue": "{\r\n    String json \u003d \"[NaN]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "testSetLenientTrue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.setLenient(true);\r\n    assertThat(reader.getStrictness()).isEqualTo(Strictness.LENIENT);\r\n}",
    "testStrictSemicolonDelimitedArray": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true;true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        boolean unused \u003d reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "testFailWithPositionOverSlashSlashEndOfLineComment": "{\r\n    testFailWithPosition(\"Expected value at line 5 column 6 path $[1]\", \"\\n// foo\\n\\n//bar\\r\\n[\\\"a\\\",}\");\r\n}",
    "testEscapedNewlineNotAllowedInStrictMode": "{\r\n    String json \u003d \"\\\"\\\\\\n\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextString);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Cannot escape a newline character in strict mode\");\r\n}",
    "testSkipTopLevelUnquotedString": "{\r\n    JsonReader reader \u003d new JsonReader(reader(repeat(\u0027x\u0027, 8192)));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "testEmptyString": "{\r\n    try {\r\n        new JsonReader(reader(\"\")).beginArray();\r\n        fail();\r\n    } catch (EOFException expected) {\r\n    }\r\n    try {\r\n        new JsonReader(reader(\"\")).beginObject();\r\n        fail();\r\n    } catch (EOFException expected) {\r\n    }\r\n}",
    "testFailWithPositionOverQuotedString": "{\r\n    testFailWithPosition(\"Expected value at line 5 column 3 path $[1]\", \"[\\\"foo\\nbar\\r\\nbaz\\n\\\",\\n  }\");\r\n}",
    "testStrictSingleQuotedNames": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\u0027a\u0027:true}\"));\r\n    reader.beginObject();\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $.\");\r\n    }\r\n}",
    "testSetLenientFalse": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.setLenient(false);\r\n    assertThat(reader.getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n}",
    "testEscapeCharacterQuoteInStrictMode": "{\r\n    String json \u003d \"\\\"\\\\\u0027\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextString);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Invalid escaped character \\\"\u0027\\\" in strict mode\");\r\n}",
    "testCommentsInStringValue": "{\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\\"// comment\\\"]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"// comment\");\r\n    reader.endArray();\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\":\\\"#someComment\\\"}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"#someComment\");\r\n    reader.endObject();\r\n    reader \u003d new JsonReader(reader(\"{\\\"#//a\\\":\\\"#some //Comment\\\"}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"#//a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"#some //Comment\");\r\n    reader.endObject();\r\n}",
    "testFailWithPosition": "{\r\n    // Validate that it works reading the string normally.\r\n    JsonReader reader1 \u003d new JsonReader(reader(json));\r\n    reader1.setStrictness(Strictness.LENIENT);\r\n    reader1.beginArray();\r\n    String unused1 \u003d reader1.nextString();\r\n    try {\r\n        JsonToken unused2 \u003d reader1.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(message + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n    // Also validate that it works when skipping.\r\n    JsonReader reader2 \u003d new JsonReader(reader(json));\r\n    reader2.setStrictness(Strictness.LENIENT);\r\n    reader2.beginArray();\r\n    reader2.skipValue();\r\n    try {\r\n        JsonToken unused3 \u003d reader2.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(message + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\InnerClassExclusionStrategyTest.java": {
    "testIncludeStaticNestedClassObject": "{\r\n    Class\u003c?\u003e clazz \u003d staticNestedClass.getClass();\r\n    assertThat(excluder.excludeClass(clazz, true)).isFalse();\r\n}",
    "testExcludeInnerClassField": "{\r\n    Field f \u003d getClass().getField(\"innerClass\");\r\n    assertThat(excluder.excludeField(f, true)).isTrue();\r\n}",
    "testExcludeInnerClassObject": "{\r\n    Class\u003c?\u003e clazz \u003d innerClass.getClass();\r\n    assertThat(excluder.excludeClass(clazz, true)).isTrue();\r\n}",
    "testIncludeStaticNestedClassField": "{\r\n    Field f \u003d getClass().getField(\"staticNestedClass\");\r\n    assertThat(excluder.excludeField(f, true)).isFalse();\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\UnsafeAllocatorInstantiationTest.java": {
    "testInterfaceInstantiation": "{\r\n    AssertionError e \u003d assertThrows(AssertionError.class, () -\u003e UnsafeAllocator.INSTANCE.newInstance(Interface.class));\r\n    assertThat(e).hasMessageThat().startsWith(\"UnsafeAllocator is used for non-instantiable type\");\r\n}",
    "testAbstractClassInstantiation": "{\r\n    AssertionError e \u003d assertThrows(AssertionError.class, () -\u003e UnsafeAllocator.INSTANCE.newInstance(AbstractClass.class));\r\n    assertThat(e).hasMessageThat().startsWith(\"UnsafeAllocator is used for non-instantiable type\");\r\n}",
    "testConcreteClassInstantiation": "{\r\n    ConcreteClass instance \u003d UnsafeAllocator.INSTANCE.newInstance(ConcreteClass.class);\r\n    assertThat(instance).isNotNull();\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\package-info.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\common\\MoreAsserts.java": {
    "getMethodSignature": "{\r\n    StringBuilder builder \u003d new StringBuilder(method.getName());\r\n    builder.append(\u0027(\u0027);\r\n    String sep \u003d \"\";\r\n    for (Class\u003c?\u003e paramType : method.getParameterTypes()) {\r\n        builder.append(sep).append(paramType.getName());\r\n        sep \u003d \",\";\r\n    }\r\n    builder.append(\u0027)\u0027);\r\n    return builder.toString();\r\n}",
    "assertEqualsAndHashCode": "{\r\n    Assert.assertTrue(a.equals(b));\r\n    Assert.assertTrue(b.equals(a));\r\n    Assert.assertEquals(a.hashCode(), b.hashCode());\r\n    Assert.assertFalse(a.equals(null));\r\n    Assert.assertFalse(a.equals(new Object()));\r\n}",
    "isProtectedOrPublic": "{\r\n    int modifiers \u003d method.getModifiers();\r\n    return Modifier.isProtected(modifiers) || Modifier.isPublic(modifiers);\r\n}",
    "assertOverridesMethods": "{\r\n    Set\u003cString\u003e requiredOverriddenMethods \u003d new LinkedHashSet\u003c\u003e();\r\n    for (Method method : baseClass.getDeclaredMethods()) {\r\n        // Note: Do not filter out `final` methods; maybe they should not be `final` and subclass needs\r\n        // to override them\r\n        if (isProtectedOrPublic(method)) {\r\n            requiredOverriddenMethods.add(getMethodSignature(method));\r\n        }\r\n    }\r\n    for (Method method : subClass.getDeclaredMethods()) {\r\n        requiredOverriddenMethods.remove(getMethodSignature(method));\r\n    }\r\n    for (String ignoredMethod : ignoredMethods) {\r\n        boolean foundIgnored \u003d requiredOverriddenMethods.remove(ignoredMethod);\r\n        if (!foundIgnored) {\r\n            throw new IllegalArgumentException(\"Method \u0027\" + ignoredMethod + \"\u0027 does not exist or is already overridden\");\r\n        }\r\n    }\r\n    if (!requiredOverriddenMethods.isEmpty()) {\r\n        Assert.fail(subClass.getSimpleName() + \" must override these methods: \" + requiredOverriddenMethods);\r\n    }\r\n}",
    "assertContains": "{\r\n    for (T entry : collection) {\r\n        if (entry.equals(value)) {\r\n            return;\r\n        }\r\n    }\r\n    Assert.fail(value + \" not present in \" + collection);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\PrettyPrintingTest.java": {
    "testEmptyMapField": "{\r\n    ClassWithMap obj \u003d new ClassWithMap();\r\n    obj.map \u003d new LinkedHashMap\u003c\u003e();\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).contains(\"{\\n  \\\"map\\\": {},\\n  \\\"value\\\": 2\\n}\");\r\n}",
    "print": "{\r\n    if (DEBUG) {\r\n        System.out.println(msg);\r\n    }\r\n}",
    "testPrettyPrintArrayOfObjects": "{\r\n    ArrayOfObjects target \u003d new ArrayOfObjects();\r\n    String json \u003d gson.toJson(target);\r\n    print(json);\r\n}",
    "setUp": "{\r\n    gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n}",
    "testPrettyPrintArrayOfPrimitiveArrays": "{\r\n    int[][] ints \u003d new int[][] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 }, { 9, 0 }, { 10 } };\r\n    String json \u003d gson.toJson(ints);\r\n    assertThat(json).isEqualTo(\"[\\n  [\\n    1,\\n    2\\n  ],\\n  [\\n    3,\\n    4\\n  ],\\n  [\\n    5,\\n    6\\n  ],\" + \"\\n  [\\n    7,\\n    8\\n  ],\\n  [\\n    9,\\n    0\\n  ],\\n  [\\n    10\\n  ]\\n]\");\r\n}",
    "testPrettyPrintList": "{\r\n    BagOfPrimitives b \u003d new BagOfPrimitives();\r\n    List\u003cBagOfPrimitives\u003e listOfB \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c 15; ++i) {\r\n        listOfB.add(b);\r\n    }\r\n    Type typeOfSrc \u003d new TypeToken\u003cList\u003cBagOfPrimitives\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(listOfB, typeOfSrc);\r\n    print(json);\r\n}",
    "testMultipleArrays": "{\r\n    int[][][] ints \u003d new int[][][] { { { 1 }, { 2 } } };\r\n    String json \u003d gson.toJson(ints);\r\n    assertThat(json).isEqualTo(\"[\\n  [\\n    [\\n      1\\n    ],\\n    [\\n      2\\n    ]\\n  ]\\n]\");\r\n}",
    "testPrettyPrintListOfPrimitiveArrays": "{\r\n    List\u003cInteger[]\u003e list \u003d Arrays.asList(new Integer[][] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 }, { 9, 0 }, { 10 } });\r\n    String json \u003d gson.toJson(list);\r\n    assertThat(json).isEqualTo(\"[\\n  [\\n    1,\\n    2\\n  ],\\n  [\\n    3,\\n    4\\n  ],\\n  [\\n    5,\\n    6\\n  ],\" + \"\\n  [\\n    7,\\n    8\\n  ],\\n  [\\n    9,\\n    0\\n  ],\\n  [\\n    10\\n  ]\\n]\");\r\n}",
    "testMap": "{\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"abc\", 1);\r\n    map.put(\"def\", 5);\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\n  \\\"abc\\\": 1,\\n  \\\"def\\\": 5\\n}\");\r\n}",
    "testPrettyPrintArrayOfPrimitives": "{\r\n    int[] ints \u003d new int[] { 1, 2, 3, 4, 5 };\r\n    String json \u003d gson.toJson(ints);\r\n    assertThat(json).isEqualTo(\"[\\n  1,\\n  2,\\n  3,\\n  4,\\n  5\\n]\");\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\InstanceCreator.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\GsonTypesTest.java": {
    "testNewParameterizedTypeWithoutOwner": "{\r\n    // List\u003cA\u003e. List is a top-level class\r\n    ParameterizedType type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, List.class, A.class);\r\n    assertThat(type.getOwnerType()).isNull();\r\n    assertThat(type.getRawType()).isEqualTo(List.class);\r\n    assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);\r\n    // A\u003cB\u003e. A is a static inner class.\r\n    type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, A.class, B.class);\r\n    assertThat(getFirstTypeArgument(type)).isEqualTo(B.class);\r\n    IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, // NonStaticInner\u003cA\u003e is not allowed without owner\r\n    () -\u003e $Gson$Types.newParameterizedTypeWithOwner(null, NonStaticInner.class, A.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must specify owner type for \" + NonStaticInner.class);\r\n    type \u003d $Gson$Types.newParameterizedTypeWithOwner(GsonTypesTest.class, NonStaticInner.class, A.class);\r\n    assertThat(type.getOwnerType()).isEqualTo(GsonTypesTest.class);\r\n    assertThat(type.getRawType()).isEqualTo(NonStaticInner.class);\r\n    assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);\r\n    final class D {\r\n    }\r\n    // D\u003cA\u003e is allowed since D has no owner type\r\n    type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, D.class, A.class);\r\n    assertThat(type.getOwnerType()).isNull();\r\n    assertThat(type.getRawType()).isEqualTo(D.class);\r\n    assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);\r\n    // A\u003cD\u003e is allowed.\r\n    type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, A.class, D.class);\r\n    assertThat(getFirstTypeArgument(type)).isEqualTo(D.class);\r\n}",
    "testGetFirstTypeArgument": "{\r\n    assertThat(getFirstTypeArgument(A.class)).isNull();\r\n    Type type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, A.class, B.class, C.class);\r\n    assertThat(getFirstTypeArgument(type)).isEqualTo(B.class);\r\n}",
    "getFirstTypeArgument": "{\r\n    if (!(type instanceof ParameterizedType))\r\n        return null;\r\n    ParameterizedType ptype \u003d (ParameterizedType) type;\r\n    Type[] actualTypeArguments \u003d ptype.getActualTypeArguments();\r\n    if (actualTypeArguments.length \u003d\u003d 0)\r\n        return null;\r\n    return $Gson$Types.canonicalize(actualTypeArguments[0]);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\FieldNamingPolicyTest.java": {
    "testUpperCaseFirstLetter": "{\r\n    // Map from original -\u003e expected\r\n    String[][] argumentPairs \u003d { { \"a\", \"A\" }, { \"ab\", \"Ab\" }, { \"AB\", \"AB\" }, { \"_a\", \"_A\" }, { \"_ab\", \"_Ab\" }, { \"__\", \"__\" }, { \"_1\", \"_1\" }, // Not a letter, but has uppercase variant (should not be uppercased)\r\n    // See https://github.com/google/gson/issues/1965\r\n    { \"\\u2170\", \"\\u2170\" }, { \"_\\u2170\", \"_\\u2170\" }, { \"\\u2170a\", \"\\u2170A\" } };\r\n    for (String[] pair : argumentPairs) {\r\n        assertThat(FieldNamingPolicy.upperCaseFirstLetter(pair[0])).isEqualTo(pair[1]);\r\n    }\r\n}",
    "testSeparateCamelCase": "{\r\n    // Map from original -\u003e expected\r\n    String[][] argumentPairs \u003d { { \"a\", \"a\" }, { \"ab\", \"ab\" }, { \"Ab\", \"Ab\" }, { \"aB\", \"a_B\" }, { \"AB\", \"A_B\" }, { \"A_B\", \"A__B\" }, { \"firstSecondThird\", \"first_Second_Third\" }, { \"__\", \"__\" }, { \"_123\", \"_123\" } };\r\n    for (String[] pair : argumentPairs) {\r\n        assertThat(FieldNamingPolicy.separateCamelCase(pair[0], \u0027_\u0027)).isEqualTo(pair[1]);\r\n    }\r\n}",
    "testUpperCasingLocaleIndependent": "{\r\n    class Dummy {\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        int i;\r\n    }\r\n    FieldNamingPolicy[] policies \u003d { FieldNamingPolicy.UPPER_CAMEL_CASE, FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES, FieldNamingPolicy.UPPER_CASE_WITH_UNDERSCORES };\r\n    Field field \u003d Dummy.class.getDeclaredField(\"i\");\r\n    String name \u003d field.getName();\r\n    String expected \u003d name.toUpperCase(Locale.ROOT);\r\n    Locale oldLocale \u003d Locale.getDefault();\r\n    // Set Turkish as Locale which has special case conversion rules\r\n    Locale.setDefault(new Locale(\"tr\"));\r\n    try {\r\n        // Verify that default Locale has different case conversion rules\r\n        assertWithMessage(\"Test setup is broken\").that(name.toUpperCase(Locale.getDefault())).doesNotMatch(expected);\r\n        for (FieldNamingPolicy policy : policies) {\r\n            // Should ignore default Locale\r\n            assertWithMessage(\"Unexpected conversion for %s\", policy).that(policy.translateName(field)).matches(expected);\r\n        }\r\n    } finally {\r\n        Locale.setDefault(oldLocale);\r\n    }\r\n}",
    "testLowerCasingLocaleIndependent": "{\r\n    class Dummy {\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        int I;\r\n    }\r\n    FieldNamingPolicy[] policies \u003d { FieldNamingPolicy.LOWER_CASE_WITH_DASHES, FieldNamingPolicy.LOWER_CASE_WITH_DOTS, FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES };\r\n    Field field \u003d Dummy.class.getDeclaredField(\"I\");\r\n    String name \u003d field.getName();\r\n    String expected \u003d name.toLowerCase(Locale.ROOT);\r\n    Locale oldLocale \u003d Locale.getDefault();\r\n    // Set Turkish as Locale which has special case conversion rules\r\n    Locale.setDefault(new Locale(\"tr\"));\r\n    try {\r\n        // Verify that default Locale has different case conversion rules\r\n        assertWithMessage(\"Test setup is broken\").that(name.toLowerCase(Locale.getDefault())).doesNotMatch(expected);\r\n        for (FieldNamingPolicy policy : policies) {\r\n            // Should ignore default Locale\r\n            assertWithMessage(\"Unexpected conversion for %s\", policy).that(policy.translateName(field)).matches(expected);\r\n        }\r\n    } finally {\r\n        Locale.setDefault(oldLocale);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\SecurityTest.java": {
    "setUp": "{\r\n    gsonBuilder \u003d new GsonBuilder();\r\n}",
    "testNonExecutableJsonDeserialization": "{\r\n    String json \u003d JSON_NON_EXECUTABLE_PREFIX + \"{longValue:1}\";\r\n    Gson gson \u003d gsonBuilder.create();\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.longValue).isEqualTo(1);\r\n}",
    "testJsonWithNonExectuableTokenWithRegularGsonDeserialization": "{\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String json \u003d JSON_NON_EXECUTABLE_PREFIX + \"{stringValue:\u0027)]}\\\\u0027\\\\n\u0027}\";\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.stringValue).isEqualTo(\")]}\u0027\\n\");\r\n}",
    "testNonExecutableJsonSerialization": "{\r\n    Gson gson \u003d gsonBuilder.generateNonExecutableJson().create();\r\n    String json \u003d gson.toJson(new BagOfPrimitives());\r\n    assertThat(json.startsWith(JSON_NON_EXECUTABLE_PREFIX)).isTrue();\r\n}",
    "testJsonWithNonExectuableTokenSerialization": "{\r\n    Gson gson \u003d gsonBuilder.generateNonExecutableJson().create();\r\n    String json \u003d gson.toJson(JSON_NON_EXECUTABLE_PREFIX);\r\n    assertThat(json).contains(\")]}\u0027\\n\");\r\n}",
    "testJsonWithNonExectuableTokenWithConfiguredGsonDeserialization": "{\r\n    // Gson should be able to deserialize a stream with non-exectuable token even if it is created\r\n    Gson gson \u003d gsonBuilder.generateNonExecutableJson().create();\r\n    String json \u003d JSON_NON_EXECUTABLE_PREFIX + \"{intValue:2,stringValue:\u0027)]}\\\\u0027\\\\n\u0027}\";\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.stringValue).isEqualTo(\")]}\u0027\\n\");\r\n    assertThat(target.intValue).isEqualTo(2);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java": {
    "replaceTop": "{\r\n    stack[stackSize - 1] \u003d topOfStack;\r\n}",
    "string": "{\r\n    String[] replacements \u003d htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\r\n    out.write(\u0027\\\"\u0027);\r\n    int last \u003d 0;\r\n    int length \u003d value.length();\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        char c \u003d value.charAt(i);\r\n        String replacement;\r\n        if (c \u003c 128) {\r\n            replacement \u003d replacements[c];\r\n            if (replacement \u003d\u003d null) {\r\n                continue;\r\n            }\r\n        } else if (c \u003d\u003d \u0027\\u2028\u0027) {\r\n            replacement \u003d \"\\\\u2028\";\r\n        } else if (c \u003d\u003d \u0027\\u2029\u0027) {\r\n            replacement \u003d \"\\\\u2029\";\r\n        } else {\r\n            continue;\r\n        }\r\n        if (last \u003c i) {\r\n            out.write(value, last, i - last);\r\n        }\r\n        out.write(replacement);\r\n        last \u003d i + 1;\r\n    }\r\n    if (last \u003c length) {\r\n        out.write(value, last, length - last);\r\n    }\r\n    out.write(\u0027\\\"\u0027);\r\n}",
    "beforeValue": "{\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (strictness !\u003d Strictness.LENIENT) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(formattedComma);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(formattedColon);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}",
    "isLenient": "{\r\n    return strictness \u003d\u003d Strictness.LENIENT;\r\n}",
    "jsonValue": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.append(value);\r\n    return this;\r\n}",
    "endArray": "{\r\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \u0027]\u0027);\r\n}",
    "setLenient": "{\r\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\r\n}",
    "nullValue": "{\r\n    if (deferredName !\u003d null) {\r\n        if (serializeNulls) {\r\n            writeDeferredName();\r\n        } else {\r\n            deferredName \u003d null;\r\n            // skip the name and the value\r\n            return this;\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.write(\"null\");\r\n    return this;\r\n}",
    "beforeName": "{\r\n    int context \u003d peek();\r\n    if (context \u003d\u003d NONEMPTY_OBJECT) {\r\n        // first in object\r\n        out.write(formattedComma);\r\n    } else if (context !\u003d EMPTY_OBJECT) {\r\n        // not in an object!\r\n        throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n    newline();\r\n    replaceTop(DANGLING_NAME);\r\n}",
    "newline": "{\r\n    if (usesEmptyNewlineAndIndent) {\r\n        return;\r\n    }\r\n    out.write(formattingStyle.getNewline());\r\n    for (int i \u003d 1, size \u003d stackSize; i \u003c size; i++) {\r\n        out.write(formattingStyle.getIndent());\r\n    }\r\n}",
    "beginArray": "{\r\n    writeDeferredName();\r\n    return open(EMPTY_ARRAY, \u0027[\u0027);\r\n}",
    "flush": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        throw new IllegalStateException(\"JsonWriter is closed.\");\r\n    }\r\n    out.flush();\r\n}",
    "setIndent": "{\r\n    if (indent.isEmpty()) {\r\n        setFormattingStyle(FormattingStyle.COMPACT);\r\n    } else {\r\n        setFormattingStyle(FormattingStyle.PRETTY.withIndent(indent));\r\n    }\r\n}",
    "setFormattingStyle": "{\r\n    this.formattingStyle \u003d Objects.requireNonNull(formattingStyle);\r\n    this.formattedComma \u003d \",\";\r\n    if (this.formattingStyle.usesSpaceAfterSeparators()) {\r\n        this.formattedColon \u003d \": \";\r\n        // Only add space if no newline is written\r\n        if (this.formattingStyle.getNewline().isEmpty()) {\r\n            this.formattedComma \u003d \", \";\r\n        }\r\n    } else {\r\n        this.formattedColon \u003d \":\";\r\n    }\r\n    this.usesEmptyNewlineAndIndent \u003d this.formattingStyle.getNewline().isEmpty() \u0026\u0026 this.formattingStyle.getIndent().isEmpty();\r\n}",
    "writeDeferredName": "{\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}",
    "close": "{\r\n    out.close();\r\n    int size \u003d stackSize;\r\n    if (size \u003e 1 || (size \u003d\u003d 1 \u0026\u0026 stack[size - 1] !\u003d NONEMPTY_DOCUMENT)) {\r\n        throw new IOException(\"Incomplete document\");\r\n    }\r\n    stackSize \u003d 0;\r\n}",
    "value": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    String string \u003d value.toString();\r\n    if (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\")) {\r\n        if (strictness !\u003d Strictness.LENIENT) {\r\n            throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + string);\r\n        }\r\n    } else {\r\n        Class\u003c? extends Number\u003e numberClass \u003d value.getClass();\r\n        // Validate that string is valid before writing it directly to JSON output\r\n        if (!isTrustedNumberType(numberClass) \u0026\u0026 !VALID_JSON_NUMBER_PATTERN.matcher(string).matches()) {\r\n            throw new IllegalArgumentException(\"String created by \" + numberClass + \" is not a valid JSON number: \" + string);\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.append(string);\r\n    return this;\r\n}",
    "setSerializeNulls": "{\r\n    this.serializeNulls \u003d serializeNulls;\r\n}",
    "setHtmlSafe": "{\r\n    this.htmlSafe \u003d htmlSafe;\r\n}",
    "getFormattingStyle": "{\r\n    return formattingStyle;\r\n}",
    "getStrictness": "{\r\n    return strictness;\r\n}",
    "push": "{\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        stack \u003d Arrays.copyOf(stack, stackSize * 2);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}",
    "endObject": "{\r\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \u0027}\u0027);\r\n}",
    "peek": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        throw new IllegalStateException(\"JsonWriter is closed.\");\r\n    }\r\n    return stack[stackSize - 1];\r\n}",
    "isTrustedNumberType": "{\r\n    // Note: Don\u0027t consider LazilyParsedNumber trusted because it could contain\r\n    // an arbitrary malformed string\r\n    return c \u003d\u003d Integer.class || c \u003d\u003d Long.class || c \u003d\u003d Double.class || c \u003d\u003d Float.class || c \u003d\u003d Byte.class || c \u003d\u003d Short.class || c \u003d\u003d BigDecimal.class || c \u003d\u003d BigInteger.class || c \u003d\u003d AtomicInteger.class || c \u003d\u003d AtomicLong.class;\r\n}",
    "beginObject": "{\r\n    writeDeferredName();\r\n    return open(EMPTY_OBJECT, \u0027{\u0027);\r\n}",
    "getSerializeNulls": "{\r\n    return serializeNulls;\r\n}",
    "name": "{\r\n    Objects.requireNonNull(name, \"name \u003d\u003d null\");\r\n    if (deferredName !\u003d null) {\r\n        throw new IllegalStateException(\"Already wrote a name, expecting a value.\");\r\n    }\r\n    int context \u003d peek();\r\n    if (context !\u003d EMPTY_OBJECT \u0026\u0026 context !\u003d NONEMPTY_OBJECT) {\r\n        throw new IllegalStateException(\"Please begin an object before writing a name.\");\r\n    }\r\n    deferredName \u003d name;\r\n    return this;\r\n}",
    "isHtmlSafe": "{\r\n    return htmlSafe;\r\n}",
    "setStrictness": "{\r\n    this.strictness \u003d Objects.requireNonNull(strictness);\r\n}",
    "open": "{\r\n    beforeValue();\r\n    push(empty);\r\n    out.write(openBracket);\r\n    return this;\r\n}"
  },
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithUnreferencedHasArgsConstructor.java": {},
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\bind\\DefaultDateTypeAdapterTest.java": {
    "assertParsed": "{\r\n    TypeAdapter\u003cDate\u003e adapter \u003d dateAdapter(adapterFactory);\r\n    assertWithMessage(date).that(adapter.fromJson(toLiteral(date))).isEqualTo(new Date(0));\r\n    assertWithMessage(\"ISO 8601\").that(adapter.fromJson(toLiteral(\"1970-01-01T00:00:00Z\"))).isEqualTo(new Date(0));\r\n}",
    "dateAdapter": "{\r\n    TypeAdapter\u003cDate\u003e adapter \u003d adapterFactory.create(new Gson(), TypeToken.get(Date.class));\r\n    assertThat(adapter).isNotNull();\r\n    return adapter;\r\n}",
    "assertFormattingAlwaysEmitsUsLocale": "{\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(locale);\r\n    try {\r\n        // The patterns here attempt to accommodate minor date-time formatting differences between JDK\r\n        // versions. Ideally Gson would serialize in a way that is independent of the JDK version.\r\n        // Note: \\h means \"horizontal space\", because some JDK versions use Narrow No Break Space\r\n        // (U+202F) before the AM or PM indication.\r\n        String utcFull \u003d \"(Coordinated Universal Time|UTC)\";\r\n        assertFormatted(\"Jan 1, 1970,? 12:00:00\\\\hAM\", DateType.DATE.createDefaultsAdapterFactory());\r\n        assertFormatted(\"1/1/70\", DateType.DATE.createAdapterFactory(DateFormat.SHORT));\r\n        assertFormatted(\"Jan 1, 1970\", DateType.DATE.createAdapterFactory(DateFormat.MEDIUM));\r\n        assertFormatted(\"January 1, 1970\", DateType.DATE.createAdapterFactory(DateFormat.LONG));\r\n        assertFormatted(\"1/1/70,? 12:00\\\\hAM\", DateType.DATE.createAdapterFactory(DateFormat.SHORT, DateFormat.SHORT));\r\n        assertFormatted(\"Jan 1, 1970,? 12:00:00\\\\hAM\", DateType.DATE.createAdapterFactory(DateFormat.MEDIUM, DateFormat.MEDIUM));\r\n        assertFormatted(\"January 1, 1970(,| at)? 12:00:00\\\\hAM UTC\", DateType.DATE.createAdapterFactory(DateFormat.LONG, DateFormat.LONG));\r\n        assertFormatted(\"Thursday, January 1, 1970(,| at)? 12:00:00\\\\hAM \" + utcFull, DateType.DATE.createAdapterFactory(DateFormat.FULL, DateFormat.FULL));\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "testParsingDatesFormattedWithUsLocale": "{\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    try {\r\n        assertParsed(\"Jan 1, 1970 0:00:00 AM\", DateType.DATE.createDefaultsAdapterFactory());\r\n        assertParsed(\"1/1/70\", DateType.DATE.createAdapterFactory(DateFormat.SHORT));\r\n        assertParsed(\"Jan 1, 1970\", DateType.DATE.createAdapterFactory(DateFormat.MEDIUM));\r\n        assertParsed(\"January 1, 1970\", DateType.DATE.createAdapterFactory(DateFormat.LONG));\r\n        assertParsed(\"1/1/70 0:00 AM\", DateType.DATE.createAdapterFactory(DateFormat.SHORT, DateFormat.SHORT));\r\n        assertParsed(\"Jan 1, 1970 0:00:00 AM\", DateType.DATE.createAdapterFactory(DateFormat.MEDIUM, DateFormat.MEDIUM));\r\n        assertParsed(\"January 1, 1970 0:00:00 AM UTC\", DateType.DATE.createAdapterFactory(DateFormat.LONG, DateFormat.LONG));\r\n        assertParsed(\"Thursday, January 1, 1970 0:00:00 AM UTC\", DateType.DATE.createAdapterFactory(DateFormat.FULL, DateFormat.FULL));\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "toLiteral": "{\r\n    return \u0027\"\u0027 + s + \u0027\"\u0027;\r\n}",
    "testParsingDatesFormattedWithSystemLocale": "{\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.FRANCE);\r\n    try {\r\n        Date date \u003d new Date(0);\r\n        assertParsed(DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM).format(date), DateType.DATE.createDefaultsAdapterFactory());\r\n        assertParsed(DateFormat.getDateInstance(DateFormat.SHORT).format(date), DateType.DATE.createAdapterFactory(DateFormat.SHORT));\r\n        assertParsed(DateFormat.getDateInstance(DateFormat.MEDIUM).format(date), DateType.DATE.createAdapterFactory(DateFormat.MEDIUM));\r\n        assertParsed(DateFormat.getDateInstance(DateFormat.LONG).format(date), DateType.DATE.createAdapterFactory(DateFormat.LONG));\r\n        assertParsed(DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT).format(date), DateType.DATE.createAdapterFactory(DateFormat.SHORT, DateFormat.SHORT));\r\n        assertParsed(DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM).format(date), DateType.DATE.createAdapterFactory(DateFormat.MEDIUM, DateFormat.MEDIUM));\r\n        assertParsed(DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG).format(date), DateType.DATE.createAdapterFactory(DateFormat.LONG, DateFormat.LONG));\r\n        assertParsed(DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(date), DateType.DATE.createAdapterFactory(DateFormat.FULL, DateFormat.FULL));\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "testNullValue": "{\r\n    TypeAdapter\u003cDate\u003e adapter \u003d dateAdapter(DateType.DATE.createDefaultsAdapterFactory());\r\n    assertThat(adapter.fromJson(\"null\")).isNull();\r\n    assertThat(adapter.toJson(null)).isEqualTo(\"null\");\r\n}",
    "testUnexpectedToken": "{\r\n    try {\r\n        TypeAdapter\u003cDate\u003e adapter \u003d dateAdapter(DateType.DATE.createDefaultsAdapterFactory());\r\n        adapter.fromJson(\"{}\");\r\n        fail(\"Unexpected token should fail.\");\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "testFormattingInEnUs": "{\r\n    assertFormattingAlwaysEmitsUsLocale(Locale.US);\r\n}",
    "testDateDeserializationISO8601": "{\r\n    TypeAdapterFactory adapterFactory \u003d DateType.DATE.createDefaultsAdapterFactory();\r\n    assertParsed(\"1970-01-01T00:00:00.000Z\", adapterFactory);\r\n    assertParsed(\"1970-01-01T00:00Z\", adapterFactory);\r\n    assertParsed(\"1970-01-01T00:00:00+00:00\", adapterFactory);\r\n    assertParsed(\"1970-01-01T01:00:00+01:00\", adapterFactory);\r\n    assertParsed(\"1970-01-01T01:00:00+01\", adapterFactory);\r\n}",
    "testDateSerialization": "{\r\n    int dateStyle \u003d DateFormat.LONG;\r\n    TypeAdapter\u003cDate\u003e dateTypeAdapter \u003d dateAdapter(DateType.DATE.createAdapterFactory(dateStyle));\r\n    DateFormat formatter \u003d DateFormat.getDateInstance(dateStyle, Locale.US);\r\n    Date currentDate \u003d new Date();\r\n    String dateString \u003d dateTypeAdapter.toJson(currentDate);\r\n    assertThat(dateString).isEqualTo(toLiteral(formatter.format(currentDate)));\r\n}",
    "assertFormatted": "{\r\n    TypeAdapter\u003cDate\u003e adapter \u003d dateAdapter(adapterFactory);\r\n    String json \u003d adapter.toJson(new Date(0));\r\n    assertThat(json).matches(toLiteral(formattedPattern));\r\n}",
    "testDatePattern": "{\r\n    String pattern \u003d \"yyyy-MM-dd\";\r\n    TypeAdapter\u003cDate\u003e dateTypeAdapter \u003d dateAdapter(DateType.DATE.createAdapterFactory(pattern));\r\n    DateFormat formatter \u003d new SimpleDateFormat(pattern);\r\n    Date currentDate \u003d new Date();\r\n    String dateString \u003d dateTypeAdapter.toJson(currentDate);\r\n    assertThat(dateString).isEqualTo(toLiteral(formatter.format(currentDate)));\r\n}",
    "testFormatUsesDefaultTimezone": "{\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    try {\r\n        assertFormatted(\"Dec 31, 1969,? 4:00:00\\\\hPM\", DateType.DATE.createDefaultsAdapterFactory());\r\n        assertParsed(\"Dec 31, 1969 4:00:00 PM\", DateType.DATE.createDefaultsAdapterFactory());\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "testFormattingInFr": "{\r\n    assertFormattingAlwaysEmitsUsLocale(Locale.FRANCE);\r\n}",
    "testInvalidDatePattern": "{\r\n    try {\r\n        DateType.DATE.createAdapterFactory(\"I am a bad Date pattern....\");\r\n        fail(\"Invalid date pattern should fail.\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\functional\\TypeVariableTest.java": {
    "testBasicTypeVariables": "{\r\n    Gson gson \u003d new Gson();\r\n    Blue blue1 \u003d new Blue(true);\r\n    String json \u003d gson.toJson(blue1);\r\n    Blue blue2 \u003d gson.fromJson(json, Blue.class);\r\n    assertThat(blue2).isEqualTo(blue1);\r\n}",
    "testAdvancedTypeVariables": "{\r\n    Gson gson \u003d new Gson();\r\n    Bar bar1 \u003d new Bar(\"someString\", 1, true);\r\n    ArrayList\u003cInteger\u003e arrayList \u003d new ArrayList\u003c\u003e();\r\n    arrayList.add(1);\r\n    arrayList.add(2);\r\n    arrayList.add(3);\r\n    bar1.map.put(\"key1\", arrayList);\r\n    bar1.map.put(\"key2\", new ArrayList\u003cInteger\u003e());\r\n    String json \u003d gson.toJson(bar1);\r\n    Bar bar2 \u003d gson.fromJson(json, Bar.class);\r\n    assertThat(bar2).isEqualTo(bar1);\r\n}",
    "equals": "{\r\n    if (!(o instanceof Foo\u003c?, ?\u003e)) {\r\n        return false;\r\n    }\r\n    Foo\u003cS, T\u003e realFoo \u003d (Foo\u003cS, T\u003e) o;\r\n    return redField.equals(realFoo.redField) \u0026\u0026 someTField.equals(realFoo.someTField) \u0026\u0026 someSField.equals(realFoo.someSField) \u0026\u0026 map.equals(realFoo.map);\r\n}",
    "testTypeVariablesViaTypeParameter": "{\r\n    Gson gson \u003d new Gson();\r\n    Foo\u003cString, Integer\u003e original \u003d new Foo\u003c\u003e(\"e\", 5, false);\r\n    original.map.put(\"f\", Arrays.asList(6, 7));\r\n    Type type \u003d new TypeToken\u003cFoo\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(original, type);\r\n    assertThat(json).isEqualTo(\"{\\\"someSField\\\":\\\"e\\\",\\\"someTField\\\":5,\\\"map\\\":{\\\"f\\\":[6,7]},\\\"redField\\\":false}\");\r\n    assertThat(gson.\u003cFoo\u003cString, Integer\u003e\u003efromJson(json, type)).isEqualTo(original);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\bind\\RecursiveTypesResolveTest.java": {
    "testRecursiveTypeVariablesResolve1": "{\r\n    @SuppressWarnings(\"rawtypes\")\r\n    TypeAdapter\u003cTestType\u003e adapter \u003d new Gson().getAdapter(TestType.class);\r\n    assertThat(adapter).isNotNull();\r\n}",
    "testSuperSubtype": "{\r\n    assertThat($Gson$Types.supertypeOf($Gson$Types.subtypeOf(Number.class))).isEqualTo($Gson$Types.subtypeOf(Object.class));\r\n}",
    "testSubSupertype": "{\r\n    assertThat($Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class))).isEqualTo($Gson$Types.subtypeOf(Object.class));\r\n}",
    "testRecursiveTypeVariablesResolve12": "{\r\n    @SuppressWarnings(\"rawtypes\")\r\n    TypeAdapter\u003cTestType2\u003e adapter \u003d new Gson().getAdapter(TestType2.class);\r\n    assertThat(adapter).isNotNull();\r\n}",
    "testDoubleSupertype": "{\r\n    assertThat($Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class))).isEqualTo($Gson$Types.supertypeOf(Number.class));\r\n}",
    "testRecursiveResolveSimple": "{\r\n    @SuppressWarnings(\"rawtypes\")\r\n    TypeAdapter\u003cFoo1\u003e adapter \u003d new Gson().getAdapter(Foo1.class);\r\n    assertThat(adapter).isNotNull();\r\n}",
    "testDoubleSubtype": "{\r\n    assertThat($Gson$Types.subtypeOf($Gson$Types.subtypeOf(Number.class))).isEqualTo($Gson$Types.subtypeOf(Number.class));\r\n}"
  },
  "google_json\\proto\\src\\main\\java\\com\\google\\gson\\protobuf\\ProtoTypeAdapter.java": {
    "addSerializedNameExtension": "{\r\n    serializedNameExtensions.add(requireNonNull(serializedNameExtension));\r\n    return this;\r\n}",
    "getCachedMethod": "{\r\n    ConcurrentMap\u003cClass\u003c?\u003e, Method\u003e mapOfMethods \u003d mapOfMapOfMethods.get(methodName);\r\n    if (mapOfMethods \u003d\u003d null) {\r\n        mapOfMethods \u003d new MapMaker().makeMap();\r\n        ConcurrentMap\u003cClass\u003c?\u003e, Method\u003e previous \u003d mapOfMapOfMethods.putIfAbsent(methodName, mapOfMethods);\r\n        mapOfMethods \u003d previous \u003d\u003d null ? mapOfMethods : previous;\r\n    }\r\n    Method method \u003d mapOfMethods.get(clazz);\r\n    if (method \u003d\u003d null) {\r\n        method \u003d clazz.getMethod(methodName, methodParamTypes);\r\n        mapOfMethods.putIfAbsent(clazz, method);\r\n        // NB: it doesn\u0027t matter which method we return in the event of a race.\r\n    }\r\n    return method;\r\n}",
    "getEnumValue": "{\r\n    if (enumSerialization \u003d\u003d EnumSerialization.NAME) {\r\n        return getCustSerializedEnumValue(enumDesc.getOptions(), enumDesc.getName());\r\n    } else {\r\n        return enumDesc.getNumber();\r\n    }\r\n}",
    "newBuilder": "{\r\n    return new Builder(EnumSerialization.NAME, CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_CAMEL);\r\n}",
    "serialize": "{\r\n    JsonObject ret \u003d new JsonObject();\r\n    final Map\u003cFieldDescriptor, Object\u003e fields \u003d src.getAllFields();\r\n    for (Map.Entry\u003cFieldDescriptor, Object\u003e fieldPair : fields.entrySet()) {\r\n        final FieldDescriptor desc \u003d fieldPair.getKey();\r\n        String name \u003d getCustSerializedName(desc.getOptions(), desc.getName());\r\n        if (desc.getType() \u003d\u003d ENUM_TYPE) {\r\n            // Enum collections are also returned as ENUM_TYPE\r\n            if (fieldPair.getValue() instanceof Collection) {\r\n                // Build the array to avoid infinite loop\r\n                JsonArray array \u003d new JsonArray();\r\n                @SuppressWarnings(\"unchecked\")\r\n                Collection\u003cEnumValueDescriptor\u003e enumDescs \u003d (Collection\u003cEnumValueDescriptor\u003e) fieldPair.getValue();\r\n                for (EnumValueDescriptor enumDesc : enumDescs) {\r\n                    array.add(context.serialize(getEnumValue(enumDesc)));\r\n                    ret.add(name, array);\r\n                }\r\n            } else {\r\n                EnumValueDescriptor enumDesc \u003d ((EnumValueDescriptor) fieldPair.getValue());\r\n                ret.add(name, context.serialize(getEnumValue(enumDesc)));\r\n            }\r\n        } else {\r\n            ret.add(name, context.serialize(fieldPair.getValue()));\r\n        }\r\n    }\r\n    return ret;\r\n}",
    "findValueByNameAndExtension": "{\r\n    if (enumSerialization \u003d\u003d EnumSerialization.NAME) {\r\n        // With enum name\r\n        for (EnumValueDescriptor enumDesc : desc.getValues()) {\r\n            String enumValue \u003d getCustSerializedEnumValue(enumDesc.getOptions(), enumDesc.getName());\r\n            if (enumValue.equals(jsonElement.getAsString())) {\r\n                return enumDesc;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(String.format(\"Unrecognized enum name: %s\", jsonElement.getAsString()));\r\n    } else {\r\n        // With enum value\r\n        EnumValueDescriptor fieldValue \u003d desc.findValueByNumber(jsonElement.getAsInt());\r\n        if (fieldValue \u003d\u003d null) {\r\n            throw new IllegalArgumentException(String.format(\"Unrecognized enum value: %d\", jsonElement.getAsInt()));\r\n        }\r\n        return fieldValue;\r\n    }\r\n}",
    "build": "{\r\n    return new ProtoTypeAdapter(enumSerialization, protoFormat, jsonFormat, serializedNameExtensions, serializedEnumValueExtensions);\r\n}",
    "setFieldNameSerializationFormat": "{\r\n    this.protoFormat \u003d fromFieldNameFormat;\r\n    this.jsonFormat \u003d toFieldNameFormat;\r\n    return this;\r\n}",
    "getCustSerializedEnumValue": "{\r\n    for (Extension\u003cEnumValueOptions, String\u003e extension : serializedEnumValueExtensions) {\r\n        if (options.hasExtension(extension)) {\r\n            return options.getExtension(extension);\r\n        }\r\n    }\r\n    return defaultValue;\r\n}",
    "getCustSerializedName": "{\r\n    for (Extension\u003cFieldOptions, String\u003e extension : serializedNameExtensions) {\r\n        if (options.hasExtension(extension)) {\r\n            return options.getExtension(extension);\r\n        }\r\n    }\r\n    return protoFormat.to(jsonFormat, defaultName);\r\n}",
    "setEnumSerialization": "{\r\n    this.enumSerialization \u003d requireNonNull(enumSerialization);\r\n    return this;\r\n}",
    "addSerializedEnumValueExtension": "{\r\n    serializedEnumValueExtensions.add(requireNonNull(serializedEnumValueExtension));\r\n    return this;\r\n}",
    "deserialize": "{\r\n    try {\r\n        JsonObject jsonObject \u003d json.getAsJsonObject();\r\n        @SuppressWarnings(\"unchecked\")\r\n        Class\u003c? extends Message\u003e protoClass \u003d (Class\u003c? extends Message\u003e) typeOfT;\r\n        if (DynamicMessage.class.isAssignableFrom(protoClass)) {\r\n            throw new IllegalStateException(\"only generated messages are supported\");\r\n        }\r\n        try {\r\n            // Invoke the ProtoClass.newBuilder() method\r\n            Message.Builder protoBuilder \u003d (Message.Builder) getCachedMethod(protoClass, \"newBuilder\").invoke(null);\r\n            Message defaultInstance \u003d (Message) getCachedMethod(protoClass, \"getDefaultInstance\").invoke(null);\r\n            Descriptor protoDescriptor \u003d (Descriptor) getCachedMethod(protoClass, \"getDescriptor\").invoke(null);\r\n            // Call setters on all of the available fields\r\n            for (FieldDescriptor fieldDescriptor : protoDescriptor.getFields()) {\r\n                String jsonFieldName \u003d getCustSerializedName(fieldDescriptor.getOptions(), fieldDescriptor.getName());\r\n                JsonElement jsonElement \u003d jsonObject.get(jsonFieldName);\r\n                if (jsonElement !\u003d null \u0026\u0026 !jsonElement.isJsonNull()) {\r\n                    // Do not reuse jsonFieldName here, it might have a custom value\r\n                    Object fieldValue;\r\n                    if (fieldDescriptor.getType() \u003d\u003d ENUM_TYPE) {\r\n                        if (jsonElement.isJsonArray()) {\r\n                            // Handling array\r\n                            Collection\u003cEnumValueDescriptor\u003e enumCollection \u003d new ArrayList\u003c\u003e(jsonElement.getAsJsonArray().size());\r\n                            for (JsonElement element : jsonElement.getAsJsonArray()) {\r\n                                enumCollection.add(findValueByNameAndExtension(fieldDescriptor.getEnumType(), element));\r\n                            }\r\n                            fieldValue \u003d enumCollection;\r\n                        } else {\r\n                            // No array, just a plain value\r\n                            fieldValue \u003d findValueByNameAndExtension(fieldDescriptor.getEnumType(), jsonElement);\r\n                        }\r\n                        protoBuilder.setField(fieldDescriptor, fieldValue);\r\n                    } else if (fieldDescriptor.isRepeated()) {\r\n                        // If the type is an array, then we have to grab the type from the class.\r\n                        // protobuf java field names are always lower camel case\r\n                        String protoArrayFieldName \u003d protoFormat.to(CaseFormat.LOWER_CAMEL, fieldDescriptor.getName()) + \"_\";\r\n                        Field protoArrayField \u003d protoClass.getDeclaredField(protoArrayFieldName);\r\n                        Type protoArrayFieldType \u003d protoArrayField.getGenericType();\r\n                        fieldValue \u003d context.deserialize(jsonElement, protoArrayFieldType);\r\n                        protoBuilder.setField(fieldDescriptor, fieldValue);\r\n                    } else {\r\n                        Object field \u003d defaultInstance.getField(fieldDescriptor);\r\n                        fieldValue \u003d context.deserialize(jsonElement, field.getClass());\r\n                        protoBuilder.setField(fieldDescriptor, fieldValue);\r\n                    }\r\n                }\r\n            }\r\n            return protoBuilder.build();\r\n        } catch (SecurityException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (NoSuchMethodException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (IllegalArgumentException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new JsonParseException(e);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new JsonParseException(\"Error while parsing proto\", e);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\bind\\JsonTreeReaderTest.java": {
    "testSkipValue_atObjectEnd": "{\r\n    JsonTreeReader reader \u003d new JsonTreeReader(new JsonObject());\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "testOverrides": "{\r\n    List\u003cString\u003e ignoredMethods \u003d Arrays.asList(\"setLenient(boolean)\", \"isLenient()\", \"setStrictness(com.google.gson.Strictness)\", \"getStrictness()\");\r\n    MoreAsserts.assertOverridesMethods(JsonReader.class, JsonTreeReader.class, ignoredMethods);\r\n}",
    "testSkipValue_filledJsonObject": "{\r\n    JsonObject jsonObject \u003d new JsonObject();\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(\u0027c\u0027);\r\n    jsonArray.add(\"text\");\r\n    jsonObject.add(\"a\", jsonArray);\r\n    jsonObject.addProperty(\"b\", true);\r\n    jsonObject.addProperty(\"i\", 1);\r\n    jsonObject.add(\"n\", JsonNull.INSTANCE);\r\n    JsonObject jsonObject2 \u003d new JsonObject();\r\n    jsonObject2.addProperty(\"n\", 2L);\r\n    jsonObject.add(\"o\", jsonObject2);\r\n    jsonObject.addProperty(\"s\", \"text\");\r\n    JsonTreeReader in \u003d new JsonTreeReader(jsonObject);\r\n    in.skipValue();\r\n    assertThat(in.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(in.getPath()).isEqualTo(\"$\");\r\n}",
    "testSkipValue_name": "{\r\n    JsonObject jsonObject \u003d new JsonObject();\r\n    jsonObject.addProperty(\"a\", \"value\");\r\n    JsonTreeReader in \u003d new JsonTreeReader(jsonObject);\r\n    in.beginObject();\r\n    in.skipValue();\r\n    assertThat(in.peek()).isEqualTo(JsonToken.STRING);\r\n    assertThat(in.getPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    assertThat(in.nextString()).isEqualTo(\"value\");\r\n}",
    "testCustomJsonElementSubclass": "{\r\n    // superclass constructor\r\n    @SuppressWarnings(\"deprecation\")\r\n    class CustomSubclass extends JsonElement {\r\n\r\n        @Override\r\n        public JsonElement deepCopy() {\r\n            return this;\r\n        }\r\n    }\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(new CustomSubclass());\r\n    JsonTreeReader reader \u003d new JsonTreeReader(array);\r\n    reader.beginArray();\r\n    try {\r\n        // Should fail due to custom JsonElement subclass\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Custom JsonElement subclass \" + CustomSubclass.class.getName() + \" is not supported\");\r\n    }\r\n}",
    "testSkipValue_emptyJsonObject": "{\r\n    JsonTreeReader in \u003d new JsonTreeReader(new JsonObject());\r\n    in.skipValue();\r\n    assertThat(in.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(in.getPath()).isEqualTo(\"$\");\r\n}",
    "testHasNext_endOfDocument": "{\r\n    JsonTreeReader reader \u003d new JsonTreeReader(new JsonObject());\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.hasNext()).isFalse();\r\n}",
    "testSkipValue_atArrayEnd": "{\r\n    JsonTreeReader reader \u003d new JsonTreeReader(new JsonArray());\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "testSkipValue_afterEndOfDocument": "{\r\n    JsonTreeReader reader \u003d new JsonTreeReader(new JsonObject());\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "deepCopy": "{\r\n    return this;\r\n}"
  },
  "google_json\\extras\\src\\test\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactoryTest.java": {
    "testRuntimeTypeIsBaseType": "{\r\n    TypeAdapterFactory rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(BillingInstrument.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(rta).create();\r\n    BillingInstrument original \u003d new BillingInstrument(\"Jesse\");\r\n    assertEquals(\"{\\\"type\\\":\\\"BillingInstrument\\\",\\\"ownerName\\\":\\\"Jesse\\\"}\", gson.toJson(original, BillingInstrument.class));\r\n    BillingInstrument deserialized \u003d gson.fromJson(\"{type:\u0027BillingInstrument\u0027,ownerName:\u0027Jesse\u0027}\", BillingInstrument.class);\r\n    assertEquals(\"Jesse\", deserialized.ownerName);\r\n}",
    "testNullTypeFieldName": "{\r\n    try {\r\n        RuntimeTypeAdapterFactory.of(BillingInstrument.class, null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "testDuplicateSubtype": "{\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class);\r\n    rta.registerSubtype(CreditCard.class, \"CC\");\r\n    try {\r\n        rta.registerSubtype(CreditCard.class, \"Visa\");\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testDeserializeMissingTypeField": "{\r\n    TypeAdapterFactory billingAdapter \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(CreditCard.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(billingAdapter).create();\r\n    try {\r\n        gson.fromJson(\"{ownerName:\u0027Jesse\u0027}\", BillingInstrument.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testDeserializeMissingSubtype": "{\r\n    TypeAdapterFactory billingAdapter \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(BankTransfer.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(billingAdapter).create();\r\n    try {\r\n        gson.fromJson(\"{type:\u0027CreditCard\u0027,ownerName:\u0027Jesse\u0027}\", BillingInstrument.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testNullBaseType": "{\r\n    try {\r\n        RuntimeTypeAdapterFactory.of(null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "testNullSubtype": "{\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class);\r\n    try {\r\n        rta.registerSubtype(null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "testSerializeMissingSubtype": "{\r\n    TypeAdapterFactory billingAdapter \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(BankTransfer.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(billingAdapter).create();\r\n    try {\r\n        gson.toJson(new CreditCard(\"Jesse\", 456), BillingInstrument.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testSerializeCollidingTypeFieldName": "{\r\n    TypeAdapterFactory billingAdapter \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class, \"cvv\").registerSubtype(CreditCard.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(billingAdapter).create();\r\n    try {\r\n        gson.toJson(new CreditCard(\"Jesse\", 456), BillingInstrument.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "testDuplicateLabel": "{\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class);\r\n    rta.registerSubtype(CreditCard.class, \"CC\");\r\n    try {\r\n        rta.registerSubtype(BankTransfer.class, \"CC\");\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "testRuntimeTypeAdapter": "{\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(CreditCard.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(rta).create();\r\n    CreditCard original \u003d new CreditCard(\"Jesse\", 234);\r\n    assertEquals(\"{\\\"type\\\":\\\"CreditCard\\\",\\\"cvv\\\":234,\\\"ownerName\\\":\\\"Jesse\\\"}\", gson.toJson(original, BillingInstrument.class));\r\n    BillingInstrument deserialized \u003d gson.fromJson(\"{type:\u0027CreditCard\u0027,cvv:234,ownerName:\u0027Jesse\u0027}\", BillingInstrument.class);\r\n    assertEquals(\"Jesse\", deserialized.ownerName);\r\n    assertTrue(deserialized instanceof CreditCard);\r\n}",
    "testSerializeWrappedNullValue": "{\r\n    TypeAdapterFactory billingAdapter \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(CreditCard.class).registerSubtype(BankTransfer.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(billingAdapter).create();\r\n    String serialized \u003d gson.toJson(new BillingInstrumentWrapper(null), BillingInstrumentWrapper.class);\r\n    BillingInstrumentWrapper deserialized \u003d gson.fromJson(serialized, BillingInstrumentWrapper.class);\r\n    assertNull(deserialized.instrument);\r\n}",
    "testNullLabel": "{\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class);\r\n    try {\r\n        rta.registerSubtype(CreditCard.class, null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "testRuntimeTypeAdapterRecognizeSubtypes": "{\r\n    // We don\u0027t have an explicit factory for CreditCard.class, but we do have one for\r\n    // BillingInstrument.class that has recognizeSubtypes(). So it should recognize CreditCard, and\r\n    // when we call gson.toJson(original) below, without an explicit type, it should be invoked.\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).recognizeSubtypes().registerSubtype(CreditCard.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(rta).create();\r\n    CreditCard original \u003d new CreditCard(\"Jesse\", 234);\r\n    assertEquals(\"{\\\"type\\\":\\\"CreditCard\\\",\\\"cvv\\\":234,\\\"ownerName\\\":\\\"Jesse\\\"}\", gson.toJson(original));\r\n    BillingInstrument deserialized \u003d gson.fromJson(\"{type:\u0027CreditCard\u0027,cvv:234,ownerName:\u0027Jesse\u0027}\", BillingInstrument.class);\r\n    assertEquals(\"Jesse\", deserialized.ownerName);\r\n    assertTrue(deserialized instanceof CreditCard);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\PreJava9DateFormatProvider.java": {
    "getDatePartOfDateTimePattern": "{\r\n    switch(dateStyle) {\r\n        case DateFormat.SHORT:\r\n            return \"M/d/yy\";\r\n        case DateFormat.MEDIUM:\r\n            return \"MMM d, yyyy\";\r\n        case DateFormat.LONG:\r\n            return \"MMMM d, yyyy\";\r\n        case DateFormat.FULL:\r\n            return \"EEEE, MMMM d, yyyy\";\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown DateFormat style: \" + dateStyle);\r\n    }\r\n}",
    "getUSDateFormat": "{\r\n    return new SimpleDateFormat(getDateFormatPattern(style), Locale.US);\r\n}",
    "getTimePartOfDateTimePattern": "{\r\n    switch(timeStyle) {\r\n        case DateFormat.SHORT:\r\n            return \"h:mm a\";\r\n        case DateFormat.MEDIUM:\r\n            return \"h:mm:ss a\";\r\n        case DateFormat.FULL:\r\n        case DateFormat.LONG:\r\n            return \"h:mm:ss a z\";\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown DateFormat style: \" + timeStyle);\r\n    }\r\n}",
    "getUSDateTimeFormat": "{\r\n    String pattern \u003d getDatePartOfDateTimePattern(dateStyle) + \" \" + getTimePartOfDateTimePattern(timeStyle);\r\n    return new SimpleDateFormat(pattern, Locale.US);\r\n}",
    "getDateFormatPattern": "{\r\n    switch(style) {\r\n        case DateFormat.SHORT:\r\n            return \"M/d/yy\";\r\n        case DateFormat.MEDIUM:\r\n            return \"MMM d, y\";\r\n        case DateFormat.LONG:\r\n            return \"MMMM d, y\";\r\n        case DateFormat.FULL:\r\n            return \"EEEE, MMMM d, y\";\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown DateFormat style: \" + style);\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\internal\\bind\\Java17ReflectiveTypeAdapterFactoryTest.java": {
    "read": "{\r\n    final String name \u003d in.nextString();\r\n    // This type adapter is only used for Group and User Principal, both of which are implemented by PrincipalImpl.\r\n    @SuppressWarnings(\"unchecked\")\r\n    T principal \u003d (T) new Java17ReflectionHelperTest.PrincipalImpl(name);\r\n    return principal;\r\n}",
    "setUp": "{\r\n    unixDomainPrincipalClass \u003d Class.forName(\"jdk.net.UnixDomainPrincipal\");\r\n}",
    "testCustomAdapterForRecords": "{\r\n    Gson gson \u003d new Gson();\r\n    TypeAdapter\u003c?\u003e recordAdapter \u003d gson.getAdapter(unixDomainPrincipalClass);\r\n    TypeAdapter\u003c?\u003e defaultReflectionAdapter \u003d gson.getAdapter(DummyClass.class);\r\n    assertThat(defaultReflectionAdapter.getClass()).isNotEqualTo(recordAdapter.getClass());\r\n}",
    "testSerializeRecords": "{\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(UserPrincipal.class, new PrincipalTypeAdapter\u003c\u003e()).registerTypeAdapter(GroupPrincipal.class, new PrincipalTypeAdapter\u003c\u003e()).create();\r\n    UserPrincipal userPrincipal \u003d gson.fromJson(\"\\\"user\\\"\", UserPrincipal.class);\r\n    GroupPrincipal groupPrincipal \u003d gson.fromJson(\"\\\"group\\\"\", GroupPrincipal.class);\r\n    Object recordInstance \u003d unixDomainPrincipalClass.getDeclaredConstructor(UserPrincipal.class, GroupPrincipal.class).newInstance(userPrincipal, groupPrincipal);\r\n    String serialized \u003d gson.toJson(recordInstance);\r\n    Object deserializedRecordInstance \u003d gson.fromJson(serialized, unixDomainPrincipalClass);\r\n    assertThat(deserializedRecordInstance).isEqualTo(recordInstance);\r\n    assertThat(serialized).isEqualTo(\"{\\\"user\\\":\\\"user\\\",\\\"group\\\":\\\"group\\\"}\");\r\n}",
    "write": "{\r\n    out.value(principal.getName());\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\SerializationDelegatingTypeAdapter.java": {},
  "google_json\\shrinker-test\\src\\test\\java\\com\\google\\gson\\it\\ShrinkingIT.java": {
    "testNoSerializedName_NoArgsConstructor": "{\r\n    runTest(\"com.example.NoSerializedNameMain\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTestNoArgsConstructor\");\r\n        if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\r\n            Object result \u003d m.invoke(null);\r\n            assertThat(result).isEqualTo(\"value\");\r\n        } else {\r\n            // R8 performs more aggressive optimizations\r\n            Exception e \u003d assertThrows(InvocationTargetException.class, () -\u003e m.invoke(null));\r\n            assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Abstract classes can\u0027t be instantiated! Adjust the R8 configuration or register an InstanceCreator\" + \" or a TypeAdapter for this type. Class name: com.example.NoSerializedNameMain$TestClassNoArgsConstructor\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#r8-abstract-class\");\r\n        }\r\n    });\r\n}",
    "testNoSerializedName_NoArgsConstructorNoJdkUnsafe": "{\r\n    runTest(\"com.example.NoSerializedNameMain\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTestNoJdkUnsafe\");\r\n        if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\r\n            Object result \u003d m.invoke(null);\r\n            assertThat(result).isEqualTo(\"value\");\r\n        } else {\r\n            // R8 performs more aggressive optimizations\r\n            Exception e \u003d assertThrows(InvocationTargetException.class, () -\u003e m.invoke(null));\r\n            assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Unable to create instance of class com.example.NoSerializedNameMain$TestClassNotAbstract;\" + \" usage of JDK Unsafe is disabled. Registering an InstanceCreator or a TypeAdapter for this type,\" + \" adding a no-args constructor, or enabling usage of JDK Unsafe may fix this problem. Or adjust\" + \" your R8 configuration to keep the no-args constructor of the class.\");\r\n        }\r\n    });\r\n}",
    "jarsToTest": "{\r\n    return Arrays.asList(PROGUARD_RESULT_PATH, R8_RESULT_PATH);\r\n}",
    "verifyJarExists": "{\r\n    if (!Files.isRegularFile(jarToTest)) {\r\n        fail(\"JAR file \" + jarToTest + \" does not exist; run this test with `mvn clean verify`\");\r\n    }\r\n}",
    "test": "{\r\n    StringBuilder output \u003d new StringBuilder();\r\n    runTest(\"com.example.Main\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTests\", BiConsumer.class);\r\n        m.invoke(null, (BiConsumer\u003cString, String\u003e) (name, content) -\u003e output.append(name + \"\\n\" + content + \"\\n\u003d\u003d\u003d\\n\"));\r\n    });\r\n    assertThat(output.toString()).isEqualTo(String.join(\"\\n\", \"Write: TypeToken anonymous\", \"[\", \"  {\", \"    \\\"custom\\\": 1\", \"  }\", \"]\", \"\u003d\u003d\u003d\", \"Read: TypeToken anonymous\", \"[ClassWithAdapter[3]]\", \"\u003d\u003d\u003d\", \"Write: TypeToken manual\", \"[\", \"  {\", \"    \\\"custom\\\": 1\", \"  }\", \"]\", \"\u003d\u003d\u003d\", \"Read: TypeToken manual\", \"[ClassWithAdapter[3]]\", \"\u003d\u003d\u003d\", \"Write: Named fields\", \"{\", \"  \\\"myField\\\": 2,\", \"  \\\"notAccessedField\\\": -1\", \"}\", \"\u003d\u003d\u003d\", \"Read: Named fields\", \"3\", \"\u003d\u003d\u003d\", \"Write: SerializedName\", \"{\", \"  \\\"myField\\\": 2,\", \"  \\\"notAccessed\\\": -1\", \"}\", \"\u003d\u003d\u003d\", \"Read: SerializedName\", \"3\", \"\u003d\u003d\u003d\", \"Write: No args constructor\", \"{\", \"  \\\"myField\\\": -3\", \"}\", \"\u003d\u003d\u003d\", \"Read: No args constructor; initial constructor value\", \"-3\", \"\u003d\u003d\u003d\", \"Read: No args constructor; custom value\", \"3\", \"\u003d\u003d\u003d\", \"Write: Constructor with args\", \"{\", \"  \\\"myField\\\": 2\", \"}\", \"\u003d\u003d\u003d\", \"Read: Constructor with args\", \"3\", \"\u003d\u003d\u003d\", \"Read: Unreferenced no args constructor; initial constructor value\", \"-3\", \"\u003d\u003d\u003d\", \"Read: Unreferenced no args constructor; custom value\", \"3\", \"\u003d\u003d\u003d\", \"Read: Unreferenced constructor with args\", \"3\", \"\u003d\u003d\u003d\", \"Read: No JDK Unsafe; initial constructor value\", \"-3\", \"\u003d\u003d\u003d\", \"Read: No JDK Unsafe; custom value\", \"3\", \"\u003d\u003d\u003d\", \"Write: Enum\", \"\\\"FIRST\\\"\", \"\u003d\u003d\u003d\", \"Read: Enum\", \"SECOND\", \"\u003d\u003d\u003d\", \"Write: Enum SerializedName\", \"\\\"one\\\"\", \"\u003d\u003d\u003d\", \"Read: Enum SerializedName\", \"SECOND\", \"\u003d\u003d\u003d\", \"Write: @Expose\", \"{\\\"i\\\":0}\", \"\u003d\u003d\u003d\", \"Write: Version annotations\", \"{\\\"i1\\\":0,\\\"i4\\\":0}\", \"\u003d\u003d\u003d\", \"Write: JsonAdapter on fields\", \"{\", \"  \\\"f\\\": \\\"adapter-null\\\",\", \"  \\\"f1\\\": \\\"adapter-1\\\",\", \"  \\\"f2\\\": \\\"factory-2\\\",\", \"  \\\"f3\\\": \\\"serializer-3\\\",\", // For f4 only a JsonDeserializer is registered, so serialization falls back to reflection\r\n    \"  \\\"f4\\\": {\", \"    \\\"s\\\": \\\"4\\\"\", \"  }\", \"}\", \"\u003d\u003d\u003d\", \"Read: JsonAdapter on fields\", // For f3 only a JsonSerializer is registered, so for deserialization value is read as is using reflection\r\n    \"ClassWithJsonAdapterAnnotation[f1\u003dadapter-1, f2\u003dfactory-2, f3\u003d3, f4\u003ddeserializer-4]\", \"\u003d\u003d\u003d\", \"Read: Generic TypeToken\", \"{t\u003dread-1}\", \"\u003d\u003d\u003d\", \"Read: Using Generic\", \"{g\u003d{t\u003dread-1}}\", \"\u003d\u003d\u003d\", \"Read: Using Generic TypeToken\", \"{g\u003d{t\u003dread-1}}\", \"\u003d\u003d\u003d\", \"\"));\r\n}",
    "testNoSerializedName_HasArgsConstructor": "{\r\n    runTest(\"com.example.NoSerializedNameMain\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTestHasArgsConstructor\");\r\n        if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\r\n            Object result \u003d m.invoke(null);\r\n            assertThat(result).isEqualTo(\"value\");\r\n        } else {\r\n            // R8 performs more aggressive optimizations\r\n            Exception e \u003d assertThrows(InvocationTargetException.class, () -\u003e m.invoke(null));\r\n            assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Abstract classes can\u0027t be instantiated! Adjust the R8 configuration or register an InstanceCreator\" + \" or a TypeAdapter for this type. Class name: com.example.NoSerializedNameMain$TestClassHasArgsConstructor\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#r8-abstract-class\");\r\n        }\r\n    });\r\n}",
    "runTest": "{\r\n    // Use bootstrap class loader; load all custom classes from JAR and not\r\n    // from dependencies of this test\r\n    ClassLoader classLoader \u003d null;\r\n    // Load the shrunken and obfuscated JARs with a separate class loader, then load\r\n    // the main test class from it and let the test action invoke its test methods\r\n    try (URLClassLoader loader \u003d new URLClassLoader(new URL[] { jarToTest.toUri().toURL() }, classLoader)) {\r\n        Class\u003c?\u003e c \u003d loader.loadClass(className);\r\n        testAction.run(c);\r\n    }\r\n}",
    "testUnusedClassRemoved": "{\r\n    // For some reason this test only works for R8 but not for ProGuard; ProGuard keeps the unused class\r\n    assumeTrue(jarToTest.equals(R8_RESULT_PATH));\r\n    String className \u003d UnusedClass.class.getName();\r\n    ClassNotFoundException e \u003d assertThrows(ClassNotFoundException.class, () -\u003e {\r\n        runTest(className, c -\u003e {\r\n            fail(\"Class should have been removed during shrinking: \" + c);\r\n        });\r\n    });\r\n    assertThat(e).hasMessageThat().contains(className);\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\com\\google\\gson\\annotations\\Since.java": {},
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithSerializedName.java": {},
  "google_json\\shrinker-test\\src\\main\\java\\com\\example\\ClassWithJsonAdapterAnnotation.java": {
    "serialize": "{\r\n    return new JsonPrimitive(\"serializer-\" + src.s);\r\n}",
    "read": "{\r\n    return new DummyClass(\"factory-\" + in.nextInt());\r\n}",
    "create": "{\r\n    // the code below is not type-safe, but does not matter for this test\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cT\u003e r \u003d (TypeAdapter\u003cT\u003e) new TypeAdapter\u003cDummyClass\u003e() {\r\n\r\n        @Override\r\n        public DummyClass read(JsonReader in) throws IOException {\r\n            return new DummyClass(\"factory-\" + in.nextInt());\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, DummyClass value) throws IOException {\r\n            out.value(\"factory-\" + value.s);\r\n        }\r\n    };\r\n    return r;\r\n}",
    "toString": "{\r\n    return s;\r\n}",
    "write": "{\r\n    out.value(\"factory-\" + value.s);\r\n}",
    "deserialize": "{\r\n    return new DummyClass(\"deserializer-\" + json.getAsInt());\r\n}"
  },
  "google_json\\metrics\\src\\main\\java\\com\\google\\gson\\metrics\\CollectionsDeserializationBenchmark.java": {
    "timeCollectionsDefault": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        gson.fromJson(json, LIST_TYPE_TOKEN);\r\n    }\r\n}",
    "setUp": "{\r\n    this.gson \u003d new Gson();\r\n    List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c 100; ++i) {\r\n        bags.add(new BagOfPrimitives(10L, 1, false, \"foo\"));\r\n    }\r\n    this.json \u003d gson.toJson(bags, LIST_TYPE);\r\n}",
    "main": "{\r\n    NonUploadingCaliperRunner.run(CollectionsDeserializationBenchmark.class, args);\r\n}",
    "timeCollectionsStreaming": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginArray();\r\n        List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n        while (jr.hasNext()) {\r\n            jr.beginObject();\r\n            long longValue \u003d 0;\r\n            int intValue \u003d 0;\r\n            boolean booleanValue \u003d false;\r\n            String stringValue \u003d null;\r\n            while (jr.hasNext()) {\r\n                String name \u003d jr.nextName();\r\n                if (name.equals(\"longValue\")) {\r\n                    longValue \u003d jr.nextLong();\r\n                } else if (name.equals(\"intValue\")) {\r\n                    intValue \u003d jr.nextInt();\r\n                } else if (name.equals(\"booleanValue\")) {\r\n                    booleanValue \u003d jr.nextBoolean();\r\n                } else if (name.equals(\"stringValue\")) {\r\n                    stringValue \u003d jr.nextString();\r\n                } else {\r\n                    throw new IOException(\"Unexpected name: \" + name);\r\n                }\r\n            }\r\n            jr.endObject();\r\n            bags.add(new BagOfPrimitives(longValue, intValue, booleanValue, stringValue));\r\n        }\r\n        jr.endArray();\r\n    }\r\n}",
    "timeCollectionsReflectionStreaming": "{\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginArray();\r\n        List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n        while (jr.hasNext()) {\r\n            jr.beginObject();\r\n            BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n            while (jr.hasNext()) {\r\n                String name \u003d jr.nextName();\r\n                for (Field field : BagOfPrimitives.class.getDeclaredFields()) {\r\n                    if (field.getName().equals(name)) {\r\n                        Class\u003c?\u003e fieldType \u003d field.getType();\r\n                        if (fieldType.equals(long.class)) {\r\n                            field.setLong(bag, jr.nextLong());\r\n                        } else if (fieldType.equals(int.class)) {\r\n                            field.setInt(bag, jr.nextInt());\r\n                        } else if (fieldType.equals(boolean.class)) {\r\n                            field.setBoolean(bag, jr.nextBoolean());\r\n                        } else if (fieldType.equals(String.class)) {\r\n                            field.set(bag, jr.nextString());\r\n                        } else {\r\n                            throw new RuntimeException(\"Unexpected: type: \" + fieldType + \", name: \" + name);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            jr.endObject();\r\n            bags.add(bag);\r\n        }\r\n        jr.endArray();\r\n    }\r\n}"
  },
  "google_json\\gson\\src\\main\\java\\module-info.java": {},
  "google_json\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java": {
    "read": "{\r\n    JsonElement jsonElement \u003d jsonElementAdapter.read(in);\r\n    JsonElement labelJsonElement;\r\n    if (maintainType) {\r\n        labelJsonElement \u003d jsonElement.getAsJsonObject().get(typeFieldName);\r\n    } else {\r\n        labelJsonElement \u003d jsonElement.getAsJsonObject().remove(typeFieldName);\r\n    }\r\n    if (labelJsonElement \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n    }\r\n    String label \u003d labelJsonElement.getAsString();\r\n    // registration requires that subtype extends T\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) labelToDelegate.get(label);\r\n    if (delegate \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n    }\r\n    return delegate.fromJsonTree(jsonElement);\r\n}",
    "of": "{\r\n    return new RuntimeTypeAdapterFactory\u003c\u003e(baseType, \"type\", false);\r\n}",
    "recognizeSubtypes": "{\r\n    this.recognizeSubtypes \u003d true;\r\n    return this;\r\n}",
    "create": "{\r\n    if (type \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    Class\u003c?\u003e rawType \u003d type.getRawType();\r\n    boolean handle \u003d recognizeSubtypes ? baseType.isAssignableFrom(rawType) : baseType.equals(rawType);\r\n    if (!handle) {\r\n        return null;\r\n    }\r\n    final TypeAdapter\u003cJsonElement\u003e jsonElementAdapter \u003d gson.getAdapter(JsonElement.class);\r\n    final Map\u003cString, TypeAdapter\u003c?\u003e\u003e labelToDelegate \u003d new LinkedHashMap\u003c\u003e();\r\n    final Map\u003cClass\u003c?\u003e, TypeAdapter\u003c?\u003e\u003e subtypeToDelegate \u003d new LinkedHashMap\u003c\u003e();\r\n    for (Map.Entry\u003cString, Class\u003c?\u003e\u003e entry : labelToSubtype.entrySet()) {\r\n        TypeAdapter\u003c?\u003e delegate \u003d gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));\r\n        labelToDelegate.put(entry.getKey(), delegate);\r\n        subtypeToDelegate.put(entry.getValue(), delegate);\r\n    }\r\n    return new TypeAdapter\u003cR\u003e() {\r\n\r\n        @Override\r\n        public R read(JsonReader in) throws IOException {\r\n            JsonElement jsonElement \u003d jsonElementAdapter.read(in);\r\n            JsonElement labelJsonElement;\r\n            if (maintainType) {\r\n                labelJsonElement \u003d jsonElement.getAsJsonObject().get(typeFieldName);\r\n            } else {\r\n                labelJsonElement \u003d jsonElement.getAsJsonObject().remove(typeFieldName);\r\n            }\r\n            if (labelJsonElement \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n            }\r\n            String label \u003d labelJsonElement.getAsString();\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) labelToDelegate.get(label);\r\n            if (delegate \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n            }\r\n            return delegate.fromJsonTree(jsonElement);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, R value) throws IOException {\r\n            Class\u003c?\u003e srcType \u003d value.getClass();\r\n            String label \u003d subtypeToLabel.get(srcType);\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) subtypeToDelegate.get(srcType);\r\n            if (delegate \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n            }\r\n            JsonObject jsonObject \u003d delegate.toJsonTree(value).getAsJsonObject();\r\n            if (maintainType) {\r\n                jsonElementAdapter.write(out, jsonObject);\r\n                return;\r\n            }\r\n            JsonObject clone \u003d new JsonObject();\r\n            if (jsonObject.has(typeFieldName)) {\r\n                throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \" because it already defines a field named \" + typeFieldName);\r\n            }\r\n            clone.add(typeFieldName, new JsonPrimitive(label));\r\n            for (Map.Entry\u003cString, JsonElement\u003e e : jsonObject.entrySet()) {\r\n                clone.add(e.getKey(), e.getValue());\r\n            }\r\n            jsonElementAdapter.write(out, clone);\r\n        }\r\n    }.nullSafe();\r\n}",
    "registerSubtype": "{\r\n    return registerSubtype(type, type.getSimpleName());\r\n}",
    "write": "{\r\n    Class\u003c?\u003e srcType \u003d value.getClass();\r\n    String label \u003d subtypeToLabel.get(srcType);\r\n    // registration requires that subtype extends T\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) subtypeToDelegate.get(srcType);\r\n    if (delegate \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n    }\r\n    JsonObject jsonObject \u003d delegate.toJsonTree(value).getAsJsonObject();\r\n    if (maintainType) {\r\n        jsonElementAdapter.write(out, jsonObject);\r\n        return;\r\n    }\r\n    JsonObject clone \u003d new JsonObject();\r\n    if (jsonObject.has(typeFieldName)) {\r\n        throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \" because it already defines a field named \" + typeFieldName);\r\n    }\r\n    clone.add(typeFieldName, new JsonPrimitive(label));\r\n    for (Map.Entry\u003cString, JsonElement\u003e e : jsonObject.entrySet()) {\r\n        clone.add(e.getKey(), e.getValue());\r\n    }\r\n    jsonElementAdapter.write(out, clone);\r\n}"
  },
  "google_json\\gson\\src\\test\\java\\com\\google\\gson\\GsonTypeAdapterTest.java": {
    "testDefaultTypeAdapterThrowsParseException": "{\r\n    try {\r\n        gson.fromJson(\"{\\\"abc\\\":123}\", BigInteger.class);\r\n        fail(\"Should have thrown a JsonParseException\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "serialize": "{\r\n    return new JsonPrimitive(src.incrementAndGet());\r\n}",
    "testTypeAdapterDoesNotAffectNonAdaptedTypes": "{\r\n    String expected \u003d \"blah\";\r\n    String actual \u003d gson.toJson(expected);\r\n    assertThat(actual).isEqualTo(\"\\\"\" + expected + \"\\\"\");\r\n    actual \u003d gson.fromJson(actual, String.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "assertSerialized": "{\r\n    JsonDeserializer\u003cAbstract\u003e deserializer \u003d new JsonDeserializer\u003cAbstract\u003e() {\r\n\r\n        @Override\r\n        public Abstract deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            throw new AssertionError();\r\n        }\r\n    };\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    if (registerAbstractDeserializer) {\r\n        builder.registerTypeAdapter(Abstract.class, deserializer);\r\n    }\r\n    if (registerAbstractHierarchyDeserializer) {\r\n        builder.registerTypeHierarchyAdapter(Abstract.class, deserializer);\r\n    }\r\n    Gson gson \u003d builder.create();\r\n    assertThat(gson.toJson(instance, instanceType)).isEqualTo(expected);\r\n}",
    "setUp": "{\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(AtomicLong.class, new ExceptionTypeAdapter()).registerTypeAdapter(AtomicInteger.class, new AtomicIntegerTypeAdapter()).create();\r\n}",
    "testDeserializerForAbstractClass": "{\r\n    Concrete instance \u003d new Concrete();\r\n    instance.a \u003d \"android\";\r\n    instance.b \u003d \"beep\";\r\n    assertSerialized(\"{\\\"a\\\":\\\"android\\\"}\", Abstract.class, true, true, instance);\r\n    assertSerialized(\"{\\\"a\\\":\\\"android\\\"}\", Abstract.class, true, false, instance);\r\n    assertSerialized(\"{\\\"a\\\":\\\"android\\\"}\", Abstract.class, false, true, instance);\r\n    assertSerialized(\"{\\\"a\\\":\\\"android\\\"}\", Abstract.class, false, false, instance);\r\n    assertSerialized(\"{\\\"b\\\":\\\"beep\\\",\\\"a\\\":\\\"android\\\"}\", Concrete.class, true, true, instance);\r\n    assertSerialized(\"{\\\"b\\\":\\\"beep\\\",\\\"a\\\":\\\"android\\\"}\", Concrete.class, true, false, instance);\r\n    assertSerialized(\"{\\\"b\\\":\\\"beep\\\",\\\"a\\\":\\\"android\\\"}\", Concrete.class, false, true, instance);\r\n    assertSerialized(\"{\\\"b\\\":\\\"beep\\\",\\\"a\\\":\\\"android\\\"}\", Concrete.class, false, false, instance);\r\n}",
    "testTypeAdapterThrowsException": "{\r\n    try {\r\n        gson.toJson(new AtomicLong(0));\r\n        fail(\"Type Adapter should have thrown an exception\");\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    // Verify that serializer is made null-safe, i.e. it is not called for null\r\n    assertThat(gson.toJson(null, AtomicLong.class)).isEqualTo(\"null\");\r\n    try {\r\n        gson.fromJson(\"123\", AtomicLong.class);\r\n        fail(\"Type Adapter should have thrown an exception\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n    // Verify that deserializer is made null-safe, i.e. it is not called for null\r\n    assertThat(gson.fromJson(JsonNull.INSTANCE, AtomicLong.class)).isNull();\r\n}",
    "testTypeAdapterProperlyConvertsTypes": "{\r\n    int intialValue \u003d 1;\r\n    AtomicInteger atomicInt \u003d new AtomicInteger(intialValue);\r\n    String json \u003d gson.toJson(atomicInt);\r\n    assertThat(Integer.parseInt(json)).isEqualTo(intialValue + 1);\r\n    atomicInt \u003d gson.fromJson(json, AtomicInteger.class);\r\n    assertThat(atomicInt.get()).isEqualTo(intialValue);\r\n}",
    "deserialize": "{\r\n    throw new AssertionError();\r\n}"
  }
}