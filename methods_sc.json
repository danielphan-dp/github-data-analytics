[
  {
    "sourceCode": "@Override\r\npublic void onCreate(Bundle icicle) {\r\n    super.onCreate(icicle);\r\n    setContentView(R.layout.main);\r\n    TextView tv \u003d (TextView) findViewById(R.id.tv);\r\n    Gson gson \u003d new Gson();\r\n    Cart cart \u003d buildCart();\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\"Gson.toJson() example: \\n\");\r\n    sb.append(\"  Cart Object: \").append(cart).append(\"\\n\");\r\n    sb.append(\"  Cart JSON: \").append(gson.toJson(cart)).append(\"\\n\");\r\n    sb.append(\"\\n\\nGson.fromJson() example: \\n\");\r\n    String json \u003d \"{buyer:\u0027Happy Camper\u0027,creditCard:\u00274111-1111-1111-1111\u0027,\" + \"lineItems:[{name:\u0027nails\u0027,priceInMicros:100000,quantity:100,currencyCode:\u0027USD\u0027}]}\";\r\n    sb.append(\"Cart JSON: \").append(json).append(\"\\n\");\r\n    sb.append(\"Cart Object: \").append(gson.fromJson(json, Cart.class)).append(\"\\n\");\r\n    tv.setText(sb.toString());\r\n    tv.invalidate();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.GsonProguardExampleActivity",
      "methodName": "onCreate",
      "parameterTypes": [
        "Bundle"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private Cart buildCart() {\r\n    List\u003cLineItem\u003e lineItems \u003d new ArrayList\u003c\u003e();\r\n    lineItems.add(new LineItem(\"hammer\", 1, 12000000, \"USD\"));\r\n    return new Cart(lineItems, \"Happy Buyer\", \"4111-1111-1111-1111\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.GsonProguardExampleActivity",
      "methodName": "buildCart",
      "parameterTypes": [],
      "returnType": "Cart"
    }
  },
  {
    "sourceCode": "public List\u003cLineItem\u003e getLineItems() {\r\n    return lineItems;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.model.Cart",
      "methodName": "getLineItems",
      "parameterTypes": [],
      "returnType": "List\u003cLineItem\u003e"
    }
  },
  {
    "sourceCode": "public String getBuyerName() {\r\n    return buyerName;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.model.Cart",
      "methodName": "getBuyerName",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public String getCreditCard() {\r\n    return creditCard;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.model.Cart",
      "methodName": "getCreditCard",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    StringBuilder itemsText \u003d new StringBuilder();\r\n    boolean first \u003d true;\r\n    if (lineItems !\u003d null) {\r\n        try {\r\n            Class\u003c?\u003e fieldType \u003d Cart.class.getField(\"lineItems\").getType();\r\n            System.out.println(\"LineItems CLASS: \" + getSimpleTypeName(fieldType));\r\n        } catch (SecurityException e) {\r\n        } catch (NoSuchFieldException e) {\r\n        }\r\n        for (LineItem item : lineItems) {\r\n            if (first) {\r\n                first \u003d false;\r\n            } else {\r\n                itemsText.append(\"; \");\r\n            }\r\n            itemsText.append(item);\r\n        }\r\n    }\r\n    return \"[BUYER: \" + buyerName + \"; CC: \" + creditCard + \"; \" + \"LINE_ITEMS: \" + itemsText.toString() + \"]\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.model.Cart",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\npublic static String getSimpleTypeName(Type type) {\r\n    if (type \u003d\u003d null) {\r\n        return \"null\";\r\n    }\r\n    if (type instanceof Class) {\r\n        return ((Class) type).getSimpleName();\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType pType \u003d (ParameterizedType) type;\r\n        StringBuilder sb \u003d new StringBuilder(getSimpleTypeName(pType.getRawType()));\r\n        sb.append(\u0027\u003c\u0027);\r\n        boolean first \u003d true;\r\n        for (Type argumentType : pType.getActualTypeArguments()) {\r\n            if (first) {\r\n                first \u003d false;\r\n            } else {\r\n                sb.append(\u0027,\u0027);\r\n            }\r\n            sb.append(getSimpleTypeName(argumentType));\r\n        }\r\n        sb.append(\u0027\u003e\u0027);\r\n        return sb.toString();\r\n    } else if (type instanceof WildcardType) {\r\n        return \"?\";\r\n    }\r\n    return type.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.model.Cart",
      "methodName": "getSimpleTypeName",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public String getName() {\r\n    return name;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.model.LineItem",
      "methodName": "getName",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public int getQuantity() {\r\n    return quantity;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.model.LineItem",
      "methodName": "getQuantity",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public long getPriceInMicros() {\r\n    return priceInMicros;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.model.LineItem",
      "methodName": "getPriceInMicros",
      "parameterTypes": [],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "public String getCurrencyCode() {\r\n    return currencyCode;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.model.LineItem",
      "methodName": "getCurrencyCode",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return String.format(\"(item: %s, qty: %s, price: %.2f %s)\", name, quantity, priceInMicros / 1000000d, currencyCode);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.examples.android.model.LineItem",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return String.format(\"(name\u003d%s, source\u003d%s)\", name, source);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.extras.examples.rawcollections.RawCollectionsExample.Event",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\npublic static void main(String[] args) {\r\n    Gson gson \u003d new Gson();\r\n    Collection collection \u003d new ArrayList();\r\n    collection.add(\"hello\");\r\n    collection.add(5);\r\n    collection.add(new Event(\"GREETINGS\", \"guest\"));\r\n    String json \u003d gson.toJson(collection);\r\n    System.out.println(\"Using Gson.toJson() on a raw collection: \" + json);\r\n    JsonArray array \u003d JsonParser.parseString(json).getAsJsonArray();\r\n    String message \u003d gson.fromJson(array.get(0), String.class);\r\n    int number \u003d gson.fromJson(array.get(1), int.class);\r\n    Event event \u003d gson.fromJson(array.get(2), Event.class);\r\n    System.out.printf(\"Using Gson.fromJson() to get: %s, %d, %s\", message, number, event);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.extras.examples.rawcollections.RawCollectionsExample",
      "methodName": "main",
      "parameterTypes": [
        "String[]"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Object createInstance(Type type) {\r\n    return objectConstructor.construct();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "public GraphAdapterBuilder addType(Type type) {\r\n    final ObjectConstructor\u003c?\u003e objectConstructor \u003d constructorConstructor.get(TypeToken.get(type));\r\n    InstanceCreator\u003cObject\u003e instanceCreator \u003d new InstanceCreator\u003cObject\u003e() {\r\n\r\n        @Override\r\n        public Object createInstance(Type type) {\r\n            return objectConstructor.construct();\r\n        }\r\n    };\r\n    return addType(type, instanceCreator);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder",
      "methodName": "addType",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "GraphAdapterBuilder"
    }
  },
  {
    "sourceCode": "public GraphAdapterBuilder addType(Type type, InstanceCreator\u003c?\u003e instanceCreator) {\r\n    if (type \u003d\u003d null || instanceCreator \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    instanceCreators.put(type, instanceCreator);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder",
      "methodName": "addType",
      "parameterTypes": [
        "Type",
        "InstanceCreator\u003c?\u003e"
      ],
      "returnType": "GraphAdapterBuilder"
    }
  },
  {
    "sourceCode": "public void registerOn(GsonBuilder gsonBuilder) {\r\n    Factory factory \u003d new Factory(instanceCreators);\r\n    gsonBuilder.registerTypeAdapterFactory(factory);\r\n    for (Map.Entry\u003cType, InstanceCreator\u003c?\u003e\u003e entry : instanceCreators.entrySet()) {\r\n        gsonBuilder.registerTypeAdapter(entry.getKey(), factory);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder",
      "methodName": "registerOn",
      "parameterTypes": [
        "GsonBuilder"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    Graph graph \u003d graphThreadLocal.get();\r\n    boolean writeEntireGraph \u003d false;\r\n    /*\r\n           * We have one of two cases:\r\n           *  1. We\u0027ve encountered the first known object in this graph. Write\r\n           *     out the graph, starting with that object.\r\n           *  2. We\u0027ve encountered another graph object in the course of #1.\r\n           *     Just write out this object\u0027s name. We\u0027ll circle back to writing\r\n           *     out the object\u0027s value as a part of #1.\r\n           */\r\n    if (graph \u003d\u003d null) {\r\n        writeEntireGraph \u003d true;\r\n        graph \u003d new Graph(new IdentityHashMap\u003cObject, Element\u003c?\u003e\u003e());\r\n    }\r\n    // graph.map guarantees consistency between value and T\r\n    @SuppressWarnings(\"unchecked\")\r\n    Element\u003cT\u003e element \u003d (Element\u003cT\u003e) graph.map.get(value);\r\n    if (element \u003d\u003d null) {\r\n        element \u003d new Element\u003c\u003e(value, graph.nextName(), typeAdapter, null);\r\n        graph.map.put(value, element);\r\n        graph.queue.add(element);\r\n    }\r\n    if (writeEntireGraph) {\r\n        graphThreadLocal.set(graph);\r\n        try {\r\n            out.beginObject();\r\n            Element\u003c?\u003e current;\r\n            while ((current \u003d graph.queue.poll()) !\u003d null) {\r\n                out.name(current.id);\r\n                current.write(out);\r\n            }\r\n            out.endObject();\r\n        } finally {\r\n            graphThreadLocal.remove();\r\n        }\r\n    } else {\r\n        out.value(element.id);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder.Factory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    /*\r\n           * Again we have one of two cases:\r\n           *  1. We\u0027ve encountered the first known object in this graph. Read\r\n           *     the entire graph in as a map from names to their JsonElements.\r\n           *     Then convert the first JsonElement to its Java object.\r\n           *  2. We\u0027ve encountered another graph object in the course of #1.\r\n           *     Read in its name, then deserialize its value from the\r\n           *     JsonElement in our map. We need to do this lazily because we\r\n           *     don\u0027t know which TypeAdapter to use until a value is\r\n           *     encountered in the wild.\r\n           */\r\n    String currentName \u003d null;\r\n    Graph graph \u003d graphThreadLocal.get();\r\n    boolean readEntireGraph \u003d false;\r\n    if (graph \u003d\u003d null) {\r\n        graph \u003d new Graph(new HashMap\u003cObject, Element\u003c?\u003e\u003e());\r\n        readEntireGraph \u003d true;\r\n        // read the entire tree into memory\r\n        in.beginObject();\r\n        while (in.hasNext()) {\r\n            String name \u003d in.nextName();\r\n            if (currentName \u003d\u003d null) {\r\n                currentName \u003d name;\r\n            }\r\n            JsonElement element \u003d elementAdapter.read(in);\r\n            graph.map.put(name, new Element\u003c\u003e(null, name, typeAdapter, element));\r\n        }\r\n        in.endObject();\r\n    } else {\r\n        currentName \u003d in.nextString();\r\n    }\r\n    if (readEntireGraph) {\r\n        graphThreadLocal.set(graph);\r\n    }\r\n    try {\r\n        // graph.map guarantees consistency between value and T\r\n        @SuppressWarnings(\"unchecked\")\r\n        Element\u003cT\u003e element \u003d (Element\u003cT\u003e) graph.map.get(currentName);\r\n        // now that we know the typeAdapter for this name, go from JsonElement to \u0027T\u0027\r\n        if (element.value \u003d\u003d null) {\r\n            element.typeAdapter \u003d typeAdapter;\r\n            element.read(graph);\r\n        }\r\n        return element.value;\r\n    } finally {\r\n        if (readEntireGraph) {\r\n            graphThreadLocal.remove();\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder.Factory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    if (!instanceCreators.containsKey(type.getType())) {\r\n        return null;\r\n    }\r\n    final TypeAdapter\u003cT\u003e typeAdapter \u003d gson.getDelegateAdapter(this, type);\r\n    final TypeAdapter\u003cJsonElement\u003e elementAdapter \u003d gson.getAdapter(JsonElement.class);\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            Graph graph \u003d graphThreadLocal.get();\r\n            boolean writeEntireGraph \u003d false;\r\n            /*\r\n           * We have one of two cases:\r\n           *  1. We\u0027ve encountered the first known object in this graph. Write\r\n           *     out the graph, starting with that object.\r\n           *  2. We\u0027ve encountered another graph object in the course of #1.\r\n           *     Just write out this object\u0027s name. We\u0027ll circle back to writing\r\n           *     out the object\u0027s value as a part of #1.\r\n           */\r\n            if (graph \u003d\u003d null) {\r\n                writeEntireGraph \u003d true;\r\n                graph \u003d new Graph(new IdentityHashMap\u003cObject, Element\u003c?\u003e\u003e());\r\n            }\r\n            // graph.map guarantees consistency between value and T\r\n            @SuppressWarnings(\"unchecked\")\r\n            Element\u003cT\u003e element \u003d (Element\u003cT\u003e) graph.map.get(value);\r\n            if (element \u003d\u003d null) {\r\n                element \u003d new Element\u003c\u003e(value, graph.nextName(), typeAdapter, null);\r\n                graph.map.put(value, element);\r\n                graph.queue.add(element);\r\n            }\r\n            if (writeEntireGraph) {\r\n                graphThreadLocal.set(graph);\r\n                try {\r\n                    out.beginObject();\r\n                    Element\u003c?\u003e current;\r\n                    while ((current \u003d graph.queue.poll()) !\u003d null) {\r\n                        out.name(current.id);\r\n                        current.write(out);\r\n                    }\r\n                    out.endObject();\r\n                } finally {\r\n                    graphThreadLocal.remove();\r\n                }\r\n            } else {\r\n                out.value(element.id);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            /*\r\n           * Again we have one of two cases:\r\n           *  1. We\u0027ve encountered the first known object in this graph. Read\r\n           *     the entire graph in as a map from names to their JsonElements.\r\n           *     Then convert the first JsonElement to its Java object.\r\n           *  2. We\u0027ve encountered another graph object in the course of #1.\r\n           *     Read in its name, then deserialize its value from the\r\n           *     JsonElement in our map. We need to do this lazily because we\r\n           *     don\u0027t know which TypeAdapter to use until a value is\r\n           *     encountered in the wild.\r\n           */\r\n            String currentName \u003d null;\r\n            Graph graph \u003d graphThreadLocal.get();\r\n            boolean readEntireGraph \u003d false;\r\n            if (graph \u003d\u003d null) {\r\n                graph \u003d new Graph(new HashMap\u003cObject, Element\u003c?\u003e\u003e());\r\n                readEntireGraph \u003d true;\r\n                // read the entire tree into memory\r\n                in.beginObject();\r\n                while (in.hasNext()) {\r\n                    String name \u003d in.nextName();\r\n                    if (currentName \u003d\u003d null) {\r\n                        currentName \u003d name;\r\n                    }\r\n                    JsonElement element \u003d elementAdapter.read(in);\r\n                    graph.map.put(name, new Element\u003c\u003e(null, name, typeAdapter, element));\r\n                }\r\n                in.endObject();\r\n            } else {\r\n                currentName \u003d in.nextString();\r\n            }\r\n            if (readEntireGraph) {\r\n                graphThreadLocal.set(graph);\r\n            }\r\n            try {\r\n                // graph.map guarantees consistency between value and T\r\n                @SuppressWarnings(\"unchecked\")\r\n                Element\u003cT\u003e element \u003d (Element\u003cT\u003e) graph.map.get(currentName);\r\n                // now that we know the typeAdapter for this name, go from JsonElement to \u0027T\u0027\r\n                if (element.value \u003d\u003d null) {\r\n                    element.typeAdapter \u003d typeAdapter;\r\n                    element.read(graph);\r\n                }\r\n                return element.value;\r\n            } finally {\r\n                if (readEntireGraph) {\r\n                    graphThreadLocal.remove();\r\n                }\r\n            }\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder.Factory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Hook for the graph adapter to get a reference to a deserialized value\r\n * before that value is fully populated. This is useful to deserialize\r\n * values that directly or indirectly reference themselves: we can hand\r\n * out an instance before read() returns.\r\n *\r\n * \u003cp\u003eGson should only ever call this method when we\u0027re expecting it to;\r\n * that is only when we\u0027ve called back into Gson to deserialize a tree.\r\n */\r\n@Override\r\npublic Object createInstance(Type type) {\r\n    Graph graph \u003d graphThreadLocal.get();\r\n    if (graph \u003d\u003d null || graph.nextCreate \u003d\u003d null) {\r\n        throw new IllegalStateException(\"Unexpected call to createInstance() for \" + type);\r\n    }\r\n    InstanceCreator\u003c?\u003e creator \u003d instanceCreators.get(type);\r\n    Object result \u003d creator.createInstance(type);\r\n    graph.nextCreate.value \u003d result;\r\n    graph.nextCreate \u003d null;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder.Factory",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a unique name for an element to be inserted into the graph.\r\n */\r\npublic String nextName() {\r\n    return \"0x\" + Integer.toHexString(map.size() + 1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder.Graph",
      "methodName": "nextName",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "void write(JsonWriter out) throws IOException {\r\n    typeAdapter.write(out, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder.Element",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\nvoid read(Graph graph) {\r\n    if (graph.nextCreate !\u003d null) {\r\n        throw new IllegalStateException(\"Unexpected recursive call to read() for \" + id);\r\n    }\r\n    graph.nextCreate \u003d (Element\u003cObject\u003e) this;\r\n    value \u003d typeAdapter.fromJsonTree(element);\r\n    if (value \u003d\u003d null) {\r\n        throw new IllegalStateException(\"non-null value deserialized to null: \" + element);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilder.Element",
      "methodName": "read",
      "parameterTypes": [
        "Graph"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    Intercept intercept \u003d type.getRawType().getAnnotation(Intercept.class);\r\n    if (intercept \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n    return new InterceptorAdapter\u003c\u003e(delegate, intercept);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    delegate.write(out, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorFactory.InterceptorAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    T result \u003d delegate.read(in);\r\n    postDeserializer.postDeserialize(result);\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorFactory.InterceptorAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * This method is called by Gson after the object has been deserialized from Json.\r\n */\r\npublic void postDeserialize(T object);",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.JsonPostDeserializer",
      "methodName": "postDeserialize",
      "parameterTypes": [
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// copied from https://gist.github.com/swankjesse/20df26adaf639ed7fd160f145a0b661a\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    for (Class\u003c?\u003e t \u003d type.getRawType(); (t !\u003d Object.class) \u0026\u0026 (t.getSuperclass() !\u003d null); t \u003d t.getSuperclass()) {\r\n        for (Method m : t.getDeclaredMethods()) {\r\n            if (m.isAnnotationPresent(PostConstruct.class)) {\r\n                m.setAccessible(true);\r\n                TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n                return new PostConstructAdapter\u003c\u003e(delegate, m);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.PostConstructAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    T result \u003d delegate.read(in);\r\n    if (result !\u003d null) {\r\n        try {\r\n            method.invoke(result);\r\n        } catch (IllegalAccessException e) {\r\n            throw new AssertionError();\r\n        } catch (InvocationTargetException e) {\r\n            if (e.getCause() instanceof RuntimeException)\r\n                throw (RuntimeException) e.getCause();\r\n            throw new RuntimeException(e.getCause());\r\n        }\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.PostConstructAdapterFactory.PostConstructAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    delegate.write(out, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.PostConstructAdapterFactory.PostConstructAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a new runtime type adapter using for {@code baseType} using {@code\r\n * typeFieldName} as the type field name. Type field names are case sensitive.\r\n *\r\n * @param maintainType true if the type field should be included in deserialized objects\r\n */\r\npublic static \u003cT\u003e RuntimeTypeAdapterFactory\u003cT\u003e of(Class\u003cT\u003e baseType, String typeFieldName, boolean maintainType) {\r\n    return new RuntimeTypeAdapterFactory\u003c\u003e(baseType, typeFieldName, maintainType);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactory",
      "methodName": "of",
      "parameterTypes": [
        "Class\u003cT\u003e",
        "String",
        "boolean"
      ],
      "returnType": "RuntimeTypeAdapterFactory\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a new runtime type adapter using for {@code baseType} using {@code\r\n * typeFieldName} as the type field name. Type field names are case sensitive.\r\n */\r\npublic static \u003cT\u003e RuntimeTypeAdapterFactory\u003cT\u003e of(Class\u003cT\u003e baseType, String typeFieldName) {\r\n    return new RuntimeTypeAdapterFactory\u003c\u003e(baseType, typeFieldName, false);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactory",
      "methodName": "of",
      "parameterTypes": [
        "Class\u003cT\u003e",
        "String"
      ],
      "returnType": "RuntimeTypeAdapterFactory\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a new runtime type adapter for {@code baseType} using {@code \"type\"} as\r\n * the type field name.\r\n */\r\npublic static \u003cT\u003e RuntimeTypeAdapterFactory\u003cT\u003e of(Class\u003cT\u003e baseType) {\r\n    return new RuntimeTypeAdapterFactory\u003c\u003e(baseType, \"type\", false);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactory",
      "methodName": "of",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "RuntimeTypeAdapterFactory\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Ensures that this factory will handle not just the given {@code baseType}, but any subtype\r\n * of that type.\r\n */\r\n@CanIgnoreReturnValue\r\npublic RuntimeTypeAdapterFactory\u003cT\u003e recognizeSubtypes() {\r\n    this.recognizeSubtypes \u003d true;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactory",
      "methodName": "recognizeSubtypes",
      "parameterTypes": [],
      "returnType": "RuntimeTypeAdapterFactory\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Registers {@code type} identified by {@code label}. Labels are case\r\n * sensitive.\r\n *\r\n * @throws IllegalArgumentException if either {@code type} or {@code label}\r\n *     have already been registered on this type adapter.\r\n */\r\n@CanIgnoreReturnValue\r\npublic RuntimeTypeAdapterFactory\u003cT\u003e registerSubtype(Class\u003c? extends T\u003e type, String label) {\r\n    if (type \u003d\u003d null || label \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {\r\n        throw new IllegalArgumentException(\"types and labels must be unique\");\r\n    }\r\n    labelToSubtype.put(label, type);\r\n    subtypeToLabel.put(type, label);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactory",
      "methodName": "registerSubtype",
      "parameterTypes": [
        "Class\u003c? extends T\u003e",
        "String"
      ],
      "returnType": "RuntimeTypeAdapterFactory\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Registers {@code type} identified by its {@link Class#getSimpleName simple\r\n * name}. Labels are case sensitive.\r\n *\r\n * @throws IllegalArgumentException if either {@code type} or its simple name\r\n *     have already been registered on this type adapter.\r\n */\r\n@CanIgnoreReturnValue\r\npublic RuntimeTypeAdapterFactory\u003cT\u003e registerSubtype(Class\u003c? extends T\u003e type) {\r\n    return registerSubtype(type, type.getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactory",
      "methodName": "registerSubtype",
      "parameterTypes": [
        "Class\u003c? extends T\u003e"
      ],
      "returnType": "RuntimeTypeAdapterFactory\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic R read(JsonReader in) throws IOException {\r\n    JsonElement jsonElement \u003d jsonElementAdapter.read(in);\r\n    JsonElement labelJsonElement;\r\n    if (maintainType) {\r\n        labelJsonElement \u003d jsonElement.getAsJsonObject().get(typeFieldName);\r\n    } else {\r\n        labelJsonElement \u003d jsonElement.getAsJsonObject().remove(typeFieldName);\r\n    }\r\n    if (labelJsonElement \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n    }\r\n    String label \u003d labelJsonElement.getAsString();\r\n    // registration requires that subtype extends T\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) labelToDelegate.get(label);\r\n    if (delegate \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n    }\r\n    return delegate.fromJsonTree(jsonElement);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "R"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, R value) throws IOException {\r\n    Class\u003c?\u003e srcType \u003d value.getClass();\r\n    String label \u003d subtypeToLabel.get(srcType);\r\n    // registration requires that subtype extends T\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) subtypeToDelegate.get(srcType);\r\n    if (delegate \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n    }\r\n    JsonObject jsonObject \u003d delegate.toJsonTree(value).getAsJsonObject();\r\n    if (maintainType) {\r\n        jsonElementAdapter.write(out, jsonObject);\r\n        return;\r\n    }\r\n    JsonObject clone \u003d new JsonObject();\r\n    if (jsonObject.has(typeFieldName)) {\r\n        throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \" because it already defines a field named \" + typeFieldName);\r\n    }\r\n    clone.add(typeFieldName, new JsonPrimitive(label));\r\n    for (Map.Entry\u003cString, JsonElement\u003e e : jsonObject.entrySet()) {\r\n        clone.add(e.getKey(), e.getValue());\r\n    }\r\n    jsonElementAdapter.write(out, clone);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "R"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cR\u003e TypeAdapter\u003cR\u003e create(Gson gson, TypeToken\u003cR\u003e type) {\r\n    if (type \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    Class\u003c?\u003e rawType \u003d type.getRawType();\r\n    boolean handle \u003d recognizeSubtypes ? baseType.isAssignableFrom(rawType) : baseType.equals(rawType);\r\n    if (!handle) {\r\n        return null;\r\n    }\r\n    final TypeAdapter\u003cJsonElement\u003e jsonElementAdapter \u003d gson.getAdapter(JsonElement.class);\r\n    final Map\u003cString, TypeAdapter\u003c?\u003e\u003e labelToDelegate \u003d new LinkedHashMap\u003c\u003e();\r\n    final Map\u003cClass\u003c?\u003e, TypeAdapter\u003c?\u003e\u003e subtypeToDelegate \u003d new LinkedHashMap\u003c\u003e();\r\n    for (Map.Entry\u003cString, Class\u003c?\u003e\u003e entry : labelToSubtype.entrySet()) {\r\n        TypeAdapter\u003c?\u003e delegate \u003d gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));\r\n        labelToDelegate.put(entry.getKey(), delegate);\r\n        subtypeToDelegate.put(entry.getValue(), delegate);\r\n    }\r\n    return new TypeAdapter\u003cR\u003e() {\r\n\r\n        @Override\r\n        public R read(JsonReader in) throws IOException {\r\n            JsonElement jsonElement \u003d jsonElementAdapter.read(in);\r\n            JsonElement labelJsonElement;\r\n            if (maintainType) {\r\n                labelJsonElement \u003d jsonElement.getAsJsonObject().get(typeFieldName);\r\n            } else {\r\n                labelJsonElement \u003d jsonElement.getAsJsonObject().remove(typeFieldName);\r\n            }\r\n            if (labelJsonElement \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n            }\r\n            String label \u003d labelJsonElement.getAsString();\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) labelToDelegate.get(label);\r\n            if (delegate \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n            }\r\n            return delegate.fromJsonTree(jsonElement);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, R value) throws IOException {\r\n            Class\u003c?\u003e srcType \u003d value.getClass();\r\n            String label \u003d subtypeToLabel.get(srcType);\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) subtypeToDelegate.get(srcType);\r\n            if (delegate \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n            }\r\n            JsonObject jsonObject \u003d delegate.toJsonTree(value).getAsJsonObject();\r\n            if (maintainType) {\r\n                jsonElementAdapter.write(out, jsonObject);\r\n                return;\r\n            }\r\n            JsonObject clone \u003d new JsonObject();\r\n            if (jsonObject.has(typeFieldName)) {\r\n                throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \" because it already defines a field named \" + typeFieldName);\r\n            }\r\n            clone.add(typeFieldName, new JsonPrimitive(label));\r\n            for (Map.Entry\u003cString, JsonElement\u003e e : jsonObject.entrySet()) {\r\n                clone.add(e.getKey(), e.getValue());\r\n            }\r\n            jsonElementAdapter.write(out, clone);\r\n        }\r\n    }.nullSafe();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cR\u003e"
      ],
      "returnType": "TypeAdapter\u003cR\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Date date) throws IOException {\r\n    if (date \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        String value \u003d format(date, true, UTC_TIME_ZONE);\r\n        out.value(value);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Date"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Date read(JsonReader in) throws IOException {\r\n    try {\r\n        switch(in.peek()) {\r\n            case NULL:\r\n                in.nextNull();\r\n                return null;\r\n            default:\r\n                String date \u003d in.nextString();\r\n                // Instead of using iso8601Format.parse(value), we use Jackson\u0027s date parsing\r\n                // This is because Android doesn\u0027t support XXX because it is JDK 1.6\r\n                return parse(date, new ParsePosition(0));\r\n        }\r\n    } catch (ParseException e) {\r\n        throw new JsonParseException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Date"
    }
  },
  {
    "sourceCode": "/**\r\n * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\r\n *\r\n * @param date the date to format\r\n * @param millis true to include millis precision otherwise false\r\n * @param tz timezone to use for the formatting (GMT will produce \u0027Z\u0027)\r\n * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\r\n */\r\nprivate static String format(Date date, boolean millis, TimeZone tz) {\r\n    Calendar calendar \u003d new GregorianCalendar(tz, Locale.US);\r\n    calendar.setTime(date);\r\n    // estimate capacity of buffer as close as we can (yeah, that\u0027s pedantic ;)\r\n    int capacity \u003d \"yyyy-MM-ddThh:mm:ss\".length();\r\n    capacity +\u003d millis ? \".sss\".length() : 0;\r\n    capacity +\u003d tz.getRawOffset() \u003d\u003d 0 ? \"Z\".length() : \"+hh:mm\".length();\r\n    StringBuilder formatted \u003d new StringBuilder(capacity);\r\n    padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\r\n    formatted.append(\u0027T\u0027);\r\n    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\r\n    if (millis) {\r\n        formatted.append(\u0027.\u0027);\r\n        padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\r\n    }\r\n    int offset \u003d tz.getOffset(calendar.getTimeInMillis());\r\n    if (offset !\u003d 0) {\r\n        int hours \u003d Math.abs((offset / (60 * 1000)) / 60);\r\n        int minutes \u003d Math.abs((offset / (60 * 1000)) % 60);\r\n        formatted.append(offset \u003c 0 ? \u0027-\u0027 : \u0027+\u0027);\r\n        padInt(formatted, hours, \"hh\".length());\r\n        formatted.append(\u0027:\u0027);\r\n        padInt(formatted, minutes, \"mm\".length());\r\n    } else {\r\n        formatted.append(\u0027Z\u0027);\r\n    }\r\n    return formatted.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapter",
      "methodName": "format",
      "parameterTypes": [
        "Date",
        "boolean",
        "TimeZone"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Zero pad a number to a specified length\r\n *\r\n * @param buffer buffer to use for padding\r\n * @param value the integer value to pad if necessary.\r\n * @param length the length of the string we should zero pad\r\n */\r\nprivate static void padInt(StringBuilder buffer, int value, int length) {\r\n    String strValue \u003d Integer.toString(value);\r\n    for (int i \u003d length - strValue.length(); i \u003e 0; i--) {\r\n        buffer.append(\u00270\u0027);\r\n    }\r\n    buffer.append(strValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapter",
      "methodName": "padInt",
      "parameterTypes": [
        "StringBuilder",
        "int",
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Parse a date from ISO-8601 formatted string. It expects a format\r\n * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\r\n *\r\n * @param date ISO string to parse in the appropriate format.\r\n * @param pos The position to start parsing from, updated to where parsing stopped.\r\n * @return the parsed date\r\n * @throws ParseException if the date is not in the appropriate format\r\n */\r\nprivate static Date parse(String date, ParsePosition pos) throws ParseException {\r\n    Exception fail \u003d null;\r\n    try {\r\n        int offset \u003d pos.getIndex();\r\n        // extract year\r\n        int year \u003d parseInt(date, offset, offset +\u003d 4);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract month\r\n        int month \u003d parseInt(date, offset, offset +\u003d 2);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract day\r\n        int day \u003d parseInt(date, offset, offset +\u003d 2);\r\n        // default time value\r\n        int hour \u003d 0;\r\n        int minutes \u003d 0;\r\n        int seconds \u003d 0;\r\n        // always use 0 otherwise returned date will include millis of current time\r\n        int milliseconds \u003d 0;\r\n        if (checkOffset(date, offset, \u0027T\u0027)) {\r\n            // extract hours, minutes, seconds and milliseconds\r\n            hour \u003d parseInt(date, offset +\u003d 1, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            minutes \u003d parseInt(date, offset, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            // second and milliseconds can be optional\r\n            if (date.length() \u003e offset) {\r\n                char c \u003d date.charAt(offset);\r\n                if (c !\u003d \u0027Z\u0027 \u0026\u0026 c !\u003d \u0027+\u0027 \u0026\u0026 c !\u003d \u0027-\u0027) {\r\n                    seconds \u003d parseInt(date, offset, offset +\u003d 2);\r\n                    // milliseconds can be optional in the format\r\n                    if (checkOffset(date, offset, \u0027.\u0027)) {\r\n                        milliseconds \u003d parseInt(date, offset +\u003d 1, offset +\u003d 3);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // extract timezone\r\n        String timezoneId;\r\n        if (date.length() \u003c\u003d offset) {\r\n            throw new IllegalArgumentException(\"No time zone indicator\");\r\n        }\r\n        char timezoneIndicator \u003d date.charAt(offset);\r\n        if (timezoneIndicator \u003d\u003d \u0027+\u0027 || timezoneIndicator \u003d\u003d \u0027-\u0027) {\r\n            String timezoneOffset \u003d date.substring(offset);\r\n            timezoneId \u003d GMT_ID + timezoneOffset;\r\n            offset +\u003d timezoneOffset.length();\r\n        } else if (timezoneIndicator \u003d\u003d \u0027Z\u0027) {\r\n            timezoneId \u003d GMT_ID;\r\n            offset +\u003d 1;\r\n        } else {\r\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \" + timezoneIndicator);\r\n        }\r\n        TimeZone timezone \u003d TimeZone.getTimeZone(timezoneId);\r\n        if (!timezone.getID().equals(timezoneId)) {\r\n            throw new IndexOutOfBoundsException();\r\n        }\r\n        Calendar calendar \u003d new GregorianCalendar(timezone);\r\n        calendar.setLenient(false);\r\n        calendar.set(Calendar.YEAR, year);\r\n        calendar.set(Calendar.MONTH, month - 1);\r\n        calendar.set(Calendar.DAY_OF_MONTH, day);\r\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\r\n        calendar.set(Calendar.MINUTE, minutes);\r\n        calendar.set(Calendar.SECOND, seconds);\r\n        calendar.set(Calendar.MILLISECOND, milliseconds);\r\n        pos.setIndex(offset);\r\n        return calendar.getTime();\r\n        // If we get a ParseException it\u0027ll already have the right message/offset.\r\n        // Other exception types can convert here.\r\n    } catch (IndexOutOfBoundsException e) {\r\n        fail \u003d e;\r\n    } catch (NumberFormatException e) {\r\n        fail \u003d e;\r\n    } catch (IllegalArgumentException e) {\r\n        fail \u003d e;\r\n    }\r\n    String input \u003d (date \u003d\u003d null) ? null : (\"\u0027\" + date + \"\u0027\");\r\n    throw new ParseException(\"Failed to parse date [\" + input + \"]: \" + fail.getMessage(), pos.getIndex());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapter",
      "methodName": "parse",
      "parameterTypes": [
        "String",
        "ParsePosition"
      ],
      "returnType": "Date"
    }
  },
  {
    "sourceCode": "/**\r\n * Check if the expected character exist at the given offset in the value.\r\n *\r\n * @param value the string to check at the specified offset\r\n * @param offset the offset to look for the expected character\r\n * @param expected the expected character\r\n * @return true if the expected character exist at the given offset\r\n */\r\nprivate static boolean checkOffset(String value, int offset, char expected) {\r\n    return (offset \u003c value.length()) \u0026\u0026 (value.charAt(offset) \u003d\u003d expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapter",
      "methodName": "checkOffset",
      "parameterTypes": [
        "String",
        "int",
        "char"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Parse an integer located between 2 given offsets in a string\r\n *\r\n * @param value the string to parse\r\n * @param beginIndex the start index for the integer in the string\r\n * @param endIndex the end index for the integer in the string\r\n * @return the int\r\n * @throws NumberFormatException if the value is not a number\r\n */\r\nprivate static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\r\n    if (beginIndex \u003c 0 || endIndex \u003e value.length() || beginIndex \u003e endIndex) {\r\n        throw new NumberFormatException(value);\r\n    }\r\n    // use same logic as in Integer.parseInt() but less generic we\u0027re not supporting negative values\r\n    int i \u003d beginIndex;\r\n    int result \u003d 0;\r\n    int digit;\r\n    if (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value);\r\n        }\r\n        result \u003d -digit;\r\n    }\r\n    while (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value);\r\n        }\r\n        result *\u003d 10;\r\n        result -\u003d digit;\r\n    }\r\n    return -result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapter",
      "methodName": "parseInt",
      "parameterTypes": [
        "String",
        "int",
        "int"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerialization() {\r\n    Roshambo rock \u003d new Roshambo(\"ROCK\");\r\n    Roshambo scissors \u003d new Roshambo(\"SCISSORS\");\r\n    Roshambo paper \u003d new Roshambo(\"PAPER\");\r\n    rock.beats \u003d scissors;\r\n    scissors.beats \u003d paper;\r\n    paper.beats \u003d rock;\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(Roshambo.class).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    assertEquals(\"{\u00270x1\u0027:{\u0027name\u0027:\u0027ROCK\u0027,\u0027beats\u0027:\u00270x2\u0027},\" + \"\u00270x2\u0027:{\u0027name\u0027:\u0027SCISSORS\u0027,\u0027beats\u0027:\u00270x3\u0027},\" + \"\u00270x3\u0027:{\u0027name\u0027:\u0027PAPER\u0027,\u0027beats\u0027:\u00270x1\u0027}}\", gson.toJson(rock).replace(\u0027\"\u0027, \u0027\\\u0027\u0027));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilderTest",
      "methodName": "testSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserialization() {\r\n    String json \u003d \"{\u00270x1\u0027:{\u0027name\u0027:\u0027ROCK\u0027,\u0027beats\u0027:\u00270x2\u0027},\" + \"\u00270x2\u0027:{\u0027name\u0027:\u0027SCISSORS\u0027,\u0027beats\u0027:\u00270x3\u0027},\" + \"\u00270x3\u0027:{\u0027name\u0027:\u0027PAPER\u0027,\u0027beats\u0027:\u00270x1\u0027}}\";\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(Roshambo.class).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    Roshambo rock \u003d gson.fromJson(json, Roshambo.class);\r\n    assertEquals(\"ROCK\", rock.name);\r\n    Roshambo scissors \u003d rock.beats;\r\n    assertEquals(\"SCISSORS\", scissors.name);\r\n    Roshambo paper \u003d scissors.beats;\r\n    assertEquals(\"PAPER\", paper.name);\r\n    assertSame(rock, paper.beats);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilderTest",
      "methodName": "testDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializationDirectSelfReference() {\r\n    String json \u003d \"{\u00270x1\u0027:{\u0027name\u0027:\u0027SUICIDE\u0027,\u0027beats\u0027:\u00270x1\u0027}}\";\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(Roshambo.class).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    Roshambo suicide \u003d gson.fromJson(json, Roshambo.class);\r\n    assertEquals(\"SUICIDE\", suicide.name);\r\n    assertSame(suicide, suicide.beats);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilderTest",
      "methodName": "testDeserializationDirectSelfReference",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeListOfLists() {\r\n    Type listOfListsType \u003d new TypeToken\u003cList\u003cList\u003c?\u003e\u003e\u003e() {\r\n    }.getType();\r\n    Type listOfAnyType \u003d new TypeToken\u003cList\u003c?\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cList\u003c?\u003e\u003e listOfLists \u003d new ArrayList\u003c\u003e();\r\n    listOfLists.add(listOfLists);\r\n    listOfLists.add(new ArrayList\u003c\u003e());\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(listOfListsType).addType(listOfAnyType).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String json \u003d gson.toJson(listOfLists, listOfListsType);\r\n    assertEquals(\"{\u00270x1\u0027:[\u00270x1\u0027,\u00270x2\u0027],\u00270x2\u0027:[]}\", json.replace(\u0027\"\u0027, \u0027\\\u0027\u0027));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilderTest",
      "methodName": "testSerializeListOfLists",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeListOfLists() {\r\n    Type listOfAnyType \u003d new TypeToken\u003cList\u003c?\u003e\u003e() {\r\n    }.getType();\r\n    Type listOfListsType \u003d new TypeToken\u003cList\u003cList\u003c?\u003e\u003e\u003e() {\r\n    }.getType();\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(listOfListsType).addType(listOfAnyType).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    List\u003cList\u003c?\u003e\u003e listOfLists \u003d gson.fromJson(\"{\u00270x1\u0027:[\u00270x1\u0027,\u00270x2\u0027],\u00270x2\u0027:[]}\", listOfListsType);\r\n    assertEquals(2, listOfLists.size());\r\n    assertSame(listOfLists, listOfLists.get(0));\r\n    assertEquals(Collections.emptyList(), listOfLists.get(1));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilderTest",
      "methodName": "testDeserializeListOfLists",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializationWithMultipleTypes() {\r\n    Company google \u003d new Company(\"Google\");\r\n    // Employee constructor adds `this` to the given Company object\r\n    Employee unused1 \u003d new Employee(\"Jesse\", google);\r\n    Employee unused2 \u003d new Employee(\"Joel\", google);\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(Company.class).addType(Employee.class).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    assertEquals(\"{\u00270x1\u0027:{\u0027name\u0027:\u0027Google\u0027,\u0027employees\u0027:[\u00270x2\u0027,\u00270x3\u0027]},\" + \"\u00270x2\u0027:{\u0027name\u0027:\u0027Jesse\u0027,\u0027company\u0027:\u00270x1\u0027},\" + \"\u00270x3\u0027:{\u0027name\u0027:\u0027Joel\u0027,\u0027company\u0027:\u00270x1\u0027}}\", gson.toJson(google).replace(\u0027\"\u0027, \u0027\\\u0027\u0027));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilderTest",
      "methodName": "testSerializationWithMultipleTypes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializationWithMultipleTypes() {\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    new GraphAdapterBuilder().addType(Company.class).addType(Employee.class).registerOn(gsonBuilder);\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String json \u003d \"{\u00270x1\u0027:{\u0027name\u0027:\u0027Google\u0027,\u0027employees\u0027:[\u00270x2\u0027,\u00270x3\u0027]},\" + \"\u00270x2\u0027:{\u0027name\u0027:\u0027Jesse\u0027,\u0027company\u0027:\u00270x1\u0027},\" + \"\u00270x3\u0027:{\u0027name\u0027:\u0027Joel\u0027,\u0027company\u0027:\u00270x1\u0027}}\";\r\n    Company company \u003d gson.fromJson(json, Company.class);\r\n    assertEquals(\"Google\", company.name);\r\n    Employee jesse \u003d company.employees.get(0);\r\n    assertEquals(\"Jesse\", jesse.name);\r\n    assertEquals(company, jesse.company);\r\n    Employee joel \u003d company.employees.get(1);\r\n    assertEquals(\"Joel\", joel.name);\r\n    assertEquals(company, joel.company);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.graph.GraphAdapterBuilderTest",
      "methodName": "testDeserializationWithMultipleTypes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    this.gson \u003d new GsonBuilder().registerTypeAdapterFactory(new InterceptorFactory()).enableComplexMapKeySerialization().create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExceptionsPropagated() {\r\n    try {\r\n        gson.fromJson(\"{}\", User.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "testExceptionsPropagated",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelClass() {\r\n    User user \u003d gson.fromJson(\"{name:\u0027bob\u0027,password:\u0027pwd\u0027}\", User.class);\r\n    assertEquals(User.DEFAULT_EMAIL, user.email);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "testTopLevelClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testList() {\r\n    List\u003cUser\u003e list \u003d gson.fromJson(\"[{name:\u0027bob\u0027,password:\u0027pwd\u0027}]\", new TypeToken\u003cList\u003cUser\u003e\u003e() {\r\n    }.getType());\r\n    User user \u003d list.get(0);\r\n    assertEquals(User.DEFAULT_EMAIL, user.email);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "testList",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCollection() {\r\n    Collection\u003cUser\u003e list \u003d gson.fromJson(\"[{name:\u0027bob\u0027,password:\u0027pwd\u0027}]\", new TypeToken\u003cCollection\u003cUser\u003e\u003e() {\r\n    }.getType());\r\n    User user \u003d list.iterator().next();\r\n    assertEquals(User.DEFAULT_EMAIL, user.email);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "testCollection",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapKeyAndValues() {\r\n    Type mapType \u003d new TypeToken\u003cMap\u003cUser, Address\u003e\u003e() {\r\n    }.getType();\r\n    try {\r\n        gson.fromJson(\"[[{name:\u0027bob\u0027,password:\u0027pwd\u0027},{}]]\", mapType);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n    Map\u003cUser, Address\u003e map \u003d gson.fromJson(\"[[{name:\u0027bob\u0027,password:\u0027pwd\u0027},{city:\u0027Mountain View\u0027,state:\u0027CA\u0027,zip:\u002794043\u0027}]]\", mapType);\r\n    Entry\u003cUser, Address\u003e entry \u003d map.entrySet().iterator().next();\r\n    assertEquals(User.DEFAULT_EMAIL, entry.getKey().email);\r\n    assertEquals(Address.DEFAULT_FIRST_LINE, entry.getValue().firstLine);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "testMapKeyAndValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testField() {\r\n    UserGroup userGroup \u003d gson.fromJson(\"{user:{name:\u0027bob\u0027,password:\u0027pwd\u0027}}\", UserGroup.class);\r\n    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "testField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, User value) throws IOException {\r\n    throw new UnsupportedOperationException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "User"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic User read(JsonReader in) throws IOException {\r\n    in.beginObject();\r\n    String unused1 \u003d in.nextName();\r\n    String name \u003d in.nextString();\r\n    String unused2 \u003d in.nextName();\r\n    String password \u003d in.nextString();\r\n    in.endObject();\r\n    return new User(name, password);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "User"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomTypeAdapter() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(User.class, new TypeAdapter\u003cUser\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, User value) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public User read(JsonReader in) throws IOException {\r\n            in.beginObject();\r\n            String unused1 \u003d in.nextName();\r\n            String name \u003d in.nextString();\r\n            String unused2 \u003d in.nextName();\r\n            String password \u003d in.nextString();\r\n            in.endObject();\r\n            return new User(name, password);\r\n        }\r\n    }).registerTypeAdapterFactory(new InterceptorFactory()).create();\r\n    UserGroup userGroup \u003d gson.fromJson(\"{user:{name:\u0027bob\u0027,password:\u0027pwd\u0027}}\", UserGroup.class);\r\n    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "testCustomTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDirectInvocationOfTypeAdapter() throws Exception {\r\n    TypeAdapter\u003cUserGroup\u003e adapter \u003d gson.getAdapter(UserGroup.class);\r\n    UserGroup userGroup \u003d adapter.fromJson(\"{\\\"user\\\":{\\\"name\\\":\\\"bob\\\",\\\"password\\\":\\\"pwd\\\"}}\");\r\n    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest",
      "methodName": "testDirectInvocationOfTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void postDeserialize(User user) {\r\n    if (user.name \u003d\u003d null || user.password \u003d\u003d null) {\r\n        throw new JsonSyntaxException(\"name and password are required fields.\");\r\n    }\r\n    if (user.email \u003d\u003d null)\r\n        user.email \u003d User.DEFAULT_EMAIL;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest.UserValidator",
      "methodName": "postDeserialize",
      "parameterTypes": [
        "User"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void postDeserialize(Address address) {\r\n    if (address.city \u003d\u003d null || address.state \u003d\u003d null || address.zip \u003d\u003d null) {\r\n        throw new JsonSyntaxException(\"Address city, state and zip are required fields.\");\r\n    }\r\n    if (address.firstLine \u003d\u003d null)\r\n        address.firstLine \u003d Address.DEFAULT_FIRST_LINE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.interceptors.InterceptorTest.AddressValidator",
      "methodName": "postDeserialize",
      "parameterTypes": [
        "Address"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void test() throws Exception {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(new PostConstructAdapterFactory()).create();\r\n    gson.fromJson(\"{\\\"bread\\\": \\\"white\\\", \\\"cheese\\\": \\\"cheddar\\\"}\", Sandwich.class);\r\n    try {\r\n        gson.fromJson(\"{\\\"bread\\\": \\\"cheesey bread\\\", \\\"cheese\\\": \\\"swiss\\\"}\", Sandwich.class);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertEquals(\"too cheesey\", expected.getMessage());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.PostConstructAdapterFactoryTest",
      "methodName": "test",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testList() {\r\n    MultipleSandwiches sandwiches \u003d new MultipleSandwiches(Arrays.asList(new Sandwich(\"white\", \"cheddar\"), new Sandwich(\"whole wheat\", \"swiss\")));\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(new PostConstructAdapterFactory()).create();\r\n    // Throws NullPointerException without the fix in https://github.com/google/gson/pull/1103\r\n    String json \u003d gson.toJson(sandwiches);\r\n    assertEquals(\"{\\\"sandwiches\\\":[{\\\"bread\\\":\\\"white\\\",\\\"cheese\\\":\\\"cheddar\\\"},{\\\"bread\\\":\\\"whole wheat\\\",\\\"cheese\\\":\\\"swiss\\\"}]}\", json);\r\n    MultipleSandwiches sandwichesFromJson \u003d gson.fromJson(json, MultipleSandwiches.class);\r\n    assertEquals(sandwiches, sandwichesFromJson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.PostConstructAdapterFactoryTest",
      "methodName": "testList",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@PostConstruct\r\nprivate void validate() {\r\n    if (bread.equals(\"cheesey bread\") \u0026\u0026 cheese !\u003d null) {\r\n        throw new IllegalArgumentException(\"too cheesey\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.PostConstructAdapterFactoryTest.Sandwich",
      "methodName": "validate",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    if (o \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof Sandwich)) {\r\n        return false;\r\n    }\r\n    final Sandwich other \u003d (Sandwich) o;\r\n    if (this.bread \u003d\u003d null ? other.bread !\u003d null : !this.bread.equals(other.bread)) {\r\n        return false;\r\n    }\r\n    if (this.cheese \u003d\u003d null ? other.cheese !\u003d null : !this.cheese.equals(other.cheese)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.PostConstructAdapterFactoryTest.Sandwich",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    if (o \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof MultipleSandwiches)) {\r\n        return false;\r\n    }\r\n    final MultipleSandwiches other \u003d (MultipleSandwiches) o;\r\n    if (this.sandwiches \u003d\u003d null ? other.sandwiches !\u003d null : !this.sandwiches.equals(other.sandwiches)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.PostConstructAdapterFactoryTest.MultipleSandwiches",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRuntimeTypeAdapter() {\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(CreditCard.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(rta).create();\r\n    CreditCard original \u003d new CreditCard(\"Jesse\", 234);\r\n    assertEquals(\"{\\\"type\\\":\\\"CreditCard\\\",\\\"cvv\\\":234,\\\"ownerName\\\":\\\"Jesse\\\"}\", gson.toJson(original, BillingInstrument.class));\r\n    BillingInstrument deserialized \u003d gson.fromJson(\"{type:\u0027CreditCard\u0027,cvv:234,ownerName:\u0027Jesse\u0027}\", BillingInstrument.class);\r\n    assertEquals(\"Jesse\", deserialized.ownerName);\r\n    assertTrue(deserialized instanceof CreditCard);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testRuntimeTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRuntimeTypeAdapterRecognizeSubtypes() {\r\n    // We don\u0027t have an explicit factory for CreditCard.class, but we do have one for\r\n    // BillingInstrument.class that has recognizeSubtypes(). So it should recognize CreditCard, and\r\n    // when we call gson.toJson(original) below, without an explicit type, it should be invoked.\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).recognizeSubtypes().registerSubtype(CreditCard.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(rta).create();\r\n    CreditCard original \u003d new CreditCard(\"Jesse\", 234);\r\n    assertEquals(\"{\\\"type\\\":\\\"CreditCard\\\",\\\"cvv\\\":234,\\\"ownerName\\\":\\\"Jesse\\\"}\", gson.toJson(original));\r\n    BillingInstrument deserialized \u003d gson.fromJson(\"{type:\u0027CreditCard\u0027,cvv:234,ownerName:\u0027Jesse\u0027}\", BillingInstrument.class);\r\n    assertEquals(\"Jesse\", deserialized.ownerName);\r\n    assertTrue(deserialized instanceof CreditCard);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testRuntimeTypeAdapterRecognizeSubtypes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRuntimeTypeIsBaseType() {\r\n    TypeAdapterFactory rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(BillingInstrument.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(rta).create();\r\n    BillingInstrument original \u003d new BillingInstrument(\"Jesse\");\r\n    assertEquals(\"{\\\"type\\\":\\\"BillingInstrument\\\",\\\"ownerName\\\":\\\"Jesse\\\"}\", gson.toJson(original, BillingInstrument.class));\r\n    BillingInstrument deserialized \u003d gson.fromJson(\"{type:\u0027BillingInstrument\u0027,ownerName:\u0027Jesse\u0027}\", BillingInstrument.class);\r\n    assertEquals(\"Jesse\", deserialized.ownerName);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testRuntimeTypeIsBaseType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullBaseType() {\r\n    try {\r\n        RuntimeTypeAdapterFactory.of(null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testNullBaseType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullTypeFieldName() {\r\n    try {\r\n        RuntimeTypeAdapterFactory.of(BillingInstrument.class, null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testNullTypeFieldName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullSubtype() {\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class);\r\n    try {\r\n        rta.registerSubtype(null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testNullSubtype",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullLabel() {\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class);\r\n    try {\r\n        rta.registerSubtype(CreditCard.class, null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testNullLabel",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDuplicateSubtype() {\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class);\r\n    rta.registerSubtype(CreditCard.class, \"CC\");\r\n    try {\r\n        rta.registerSubtype(CreditCard.class, \"Visa\");\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testDuplicateSubtype",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDuplicateLabel() {\r\n    RuntimeTypeAdapterFactory\u003cBillingInstrument\u003e rta \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class);\r\n    rta.registerSubtype(CreditCard.class, \"CC\");\r\n    try {\r\n        rta.registerSubtype(BankTransfer.class, \"CC\");\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testDuplicateLabel",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeMissingTypeField() {\r\n    TypeAdapterFactory billingAdapter \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(CreditCard.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(billingAdapter).create();\r\n    try {\r\n        gson.fromJson(\"{ownerName:\u0027Jesse\u0027}\", BillingInstrument.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testDeserializeMissingTypeField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeMissingSubtype() {\r\n    TypeAdapterFactory billingAdapter \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(BankTransfer.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(billingAdapter).create();\r\n    try {\r\n        gson.fromJson(\"{type:\u0027CreditCard\u0027,ownerName:\u0027Jesse\u0027}\", BillingInstrument.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testDeserializeMissingSubtype",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeMissingSubtype() {\r\n    TypeAdapterFactory billingAdapter \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(BankTransfer.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(billingAdapter).create();\r\n    try {\r\n        gson.toJson(new CreditCard(\"Jesse\", 456), BillingInstrument.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testSerializeMissingSubtype",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeCollidingTypeFieldName() {\r\n    TypeAdapterFactory billingAdapter \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class, \"cvv\").registerSubtype(CreditCard.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(billingAdapter).create();\r\n    try {\r\n        gson.toJson(new CreditCard(\"Jesse\", 456), BillingInstrument.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testSerializeCollidingTypeFieldName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeWrappedNullValue() {\r\n    TypeAdapterFactory billingAdapter \u003d RuntimeTypeAdapterFactory.of(BillingInstrument.class).registerSubtype(CreditCard.class).registerSubtype(BankTransfer.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(billingAdapter).create();\r\n    String serialized \u003d gson.toJson(new BillingInstrumentWrapper(null), BillingInstrumentWrapper.class);\r\n    BillingInstrumentWrapper deserialized \u003d gson.fromJson(serialized, BillingInstrumentWrapper.class);\r\n    assertNull(deserialized.instrument);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest",
      "methodName": "testSerializeWrappedNullValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLocalTimeZone() {\r\n    Date expected \u003d new Date();\r\n    String json \u003d gson.toJson(expected);\r\n    Date actual \u003d gson.fromJson(json, Date.class);\r\n    assertEquals(expected.getTime(), actual.getTime());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapterTest",
      "methodName": "testLocalTimeZone",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDifferentTimeZones() {\r\n    for (String timeZone : TimeZone.getAvailableIDs()) {\r\n        Calendar cal \u003d Calendar.getInstance(TimeZone.getTimeZone(timeZone));\r\n        Date expected \u003d cal.getTime();\r\n        String json \u003d gson.toJson(expected);\r\n        // System.out.println(json + \": \" + timeZone);\r\n        Date actual \u003d gson.fromJson(json, Date.class);\r\n        assertEquals(expected.getTime(), actual.getTime());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapterTest",
      "methodName": "testDifferentTimeZones",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * JDK 1.7 introduced support for XXX format to indicate UTC date. But Android is older JDK.\r\n * We want to make sure that this date is parseable in Android.\r\n */\r\n@Test\r\npublic void testUtcDatesOnJdkBefore1_7() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Date.class, new UtcDateTypeAdapter()).create();\r\n    Date unused \u003d gson.fromJson(\"\u00272014-12-05T04:00:00.000Z\u0027\", Date.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapterTest",
      "methodName": "testUtcDatesOnJdkBefore1_7",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUtcWithJdk7Default() {\r\n    Date expected \u003d new Date();\r\n    SimpleDateFormat iso8601Format \u003d new SimpleDateFormat(\"yyyy-MM-dd\u0027T\u0027HH:mm:ss.SSSXXX\", Locale.US);\r\n    iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n    String expectedJson \u003d \"\\\"\" + iso8601Format.format(expected) + \"\\\"\";\r\n    String actualJson \u003d gson.toJson(expected);\r\n    assertEquals(expectedJson, actualJson);\r\n    Date actual \u003d gson.fromJson(expectedJson, Date.class);\r\n    assertEquals(expected.getTime(), actual.getTime());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapterTest",
      "methodName": "testUtcWithJdk7Default",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullDateSerialization() {\r\n    String json \u003d gson.toJson(null, Date.class);\r\n    assertEquals(\"null\", json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapterTest",
      "methodName": "testNullDateSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWellFormedParseException() {\r\n    try {\r\n        gson.fromJson(\"2017-06-20T14:32:30\", Date.class);\r\n        fail(\"No exception\");\r\n    } catch (JsonParseException exe) {\r\n        assertEquals(\"java.text.ParseException: Failed to parse date [\u00272017-06-20T14\u0027]: 2017-06-20T14\", exe.getMessage());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.typeadapters.UtcDateTypeAdapterTest",
      "methodName": "testWellFormedParseException",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testPublicRecord() {\r\n    Gson gson \u003d new Gson();\r\n    PublicRecord r \u003d gson.fromJson(\"{\\\"i\\\":1}\", PublicRecord.class);\r\n    assertThat(r.i).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "testPublicRecord",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testPrivateRecord() {\r\n    Gson gson \u003d new Gson();\r\n    PrivateRecord r \u003d gson.fromJson(\"{\\\"i\\\":1}\", PrivateRecord.class);\r\n    assertThat(r.i).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "testPrivateRecord",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testLocalRecord() {\r\n    record LocalRecordDeserialization(int i) {\r\n    }\r\n    Gson gson \u003d new Gson();\r\n    LocalRecordDeserialization r \u003d gson.fromJson(\"{\\\"i\\\":1}\", LocalRecordDeserialization.class);\r\n    assertThat(r.i).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "testLocalRecord",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testLocalRecordSerialization() {\r\n    record LocalRecordSerialization(int i) {\r\n    }\r\n    Gson gson \u003d new Gson();\r\n    assertThat(gson.toJson(new LocalRecordSerialization(1))).isEqualTo(\"{\\\"i\\\":1}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "testLocalRecordSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testSerializedName() {\r\n    Gson gson \u003d new Gson();\r\n    RecordWithSerializedName r \u003d gson.fromJson(\"{\\\"custom-name\\\":1}\", RecordWithSerializedName.class);\r\n    assertThat(r.i).isEqualTo(1);\r\n    assertThat(gson.toJson(new RecordWithSerializedName(2))).isEqualTo(\"{\\\"custom-name\\\":2}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "testSerializedName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testCustomConstructor() {\r\n    Gson gson \u003d new Gson();\r\n    RecordWithCustomConstructor r \u003d gson.fromJson(\"{\\\"i\\\":1}\", RecordWithCustomConstructor.class);\r\n    assertThat(r.i).isEqualTo(6);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "testCustomConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"UnusedMethod\")\r\n@Override\r\npublic int i() {\r\n    return i + 5;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "i",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testCustomAccessor() {\r\n    Gson gson \u003d new Gson();\r\n    assertThat(gson.toJson(new RecordWithCustomAccessor(2))).isEqualTo(\"{\\\"i\\\":7}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "testCustomAccessor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic RecordWithCustomClassAdapter read(JsonReader in) throws IOException {\r\n    return new RecordWithCustomClassAdapter(in.nextInt() + 5);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest.RecordWithCustomClassAdapter.CustomAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "RecordWithCustomClassAdapter"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, RecordWithCustomClassAdapter value) throws IOException {\r\n    out.value(value.i + 6);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest.RecordWithCustomClassAdapter.CustomAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "RecordWithCustomClassAdapter"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testCustomClassAdapter() {\r\n    Gson gson \u003d new Gson();\r\n    RecordWithCustomClassAdapter r \u003d gson.fromJson(\"1\", RecordWithCustomClassAdapter.class);\r\n    assertThat(r.i).isEqualTo(6);\r\n    assertThat(gson.toJson(new RecordWithCustomClassAdapter(1))).isEqualTo(\"7\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "testCustomClassAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Integer read(JsonReader in) throws IOException {\r\n    return in.nextInt() + 5;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest.RecordWithCustomFieldAdapter.CustomAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Integer"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Integer value) throws IOException {\r\n    out.value(value + 6);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest.RecordWithCustomFieldAdapter.CustomAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Integer"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testCustomFieldAdapter() {\r\n    Gson gson \u003d new Gson();\r\n    RecordWithCustomFieldAdapter r \u003d gson.fromJson(\"{\\\"i\\\":1}\", RecordWithCustomFieldAdapter.class);\r\n    assertThat(r.i).isEqualTo(6);\r\n    assertThat(gson.toJson(new RecordWithCustomFieldAdapter(1))).isEqualTo(\"{\\\"i\\\":7}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "testCustomFieldAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic RecordWithRegisteredAdapter read(JsonReader in) throws IOException {\r\n    return new RecordWithRegisteredAdapter(in.nextInt() + 5);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "RecordWithRegisteredAdapter"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, RecordWithRegisteredAdapter value) throws IOException {\r\n    out.value(value.i + 6);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "RecordWithRegisteredAdapter"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testCustomAdapter() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(RecordWithRegisteredAdapter.class, new TypeAdapter\u003cRecordWithRegisteredAdapter\u003e() {\r\n\r\n        @Override\r\n        public RecordWithRegisteredAdapter read(JsonReader in) throws IOException {\r\n            return new RecordWithRegisteredAdapter(in.nextInt() + 5);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, RecordWithRegisteredAdapter value) throws IOException {\r\n            out.value(value.i + 6);\r\n        }\r\n    }).create();\r\n    RecordWithRegisteredAdapter r \u003d gson.fromJson(\"1\", RecordWithRegisteredAdapter.class);\r\n    assertThat(r.i).isEqualTo(6);\r\n    assertThat(gson.toJson(new RecordWithRegisteredAdapter(1))).isEqualTo(\"7\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.Java17RecordReflectionTest",
      "methodName": "testCustomAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testDefaultConstructor() {\r\n    Gson gson \u003d new Gson();\r\n    ClassWithDefaultConstructor c \u003d gson.fromJson(\"{\\\"i\\\":1}\", ClassWithDefaultConstructor.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "testDefaultConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testCustomDefaultConstructor() {\r\n    Gson gson \u003d new Gson();\r\n    ClassWithCustomDefaultConstructor c \u003d gson.fromJson(\"{\\\"i\\\":2}\", ClassWithCustomDefaultConstructor.class);\r\n    assertThat(c.i).isEqualTo(2);\r\n    c \u003d gson.fromJson(\"{}\", ClassWithCustomDefaultConstructor.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "testCustomDefaultConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests deserializing a class without default constructor.\r\n *\r\n * \u003cp\u003eThis should use JDK Unsafe, and would normally require specifying {@code \"unsafeAllocated\": true}\r\n * in the reflection metadata for GraalVM, though for some reason it also seems to work without it? Possibly\r\n * because GraalVM seems to have special support for Gson, see its class {@code com.oracle.svm.thirdparty.gson.GsonFeature}.\r\n */\r\n@Test\r\nvoid testClassWithoutDefaultConstructor() {\r\n    Gson gson \u003d new Gson();\r\n    ClassWithoutDefaultConstructor c \u003d gson.fromJson(\"{\\\"i\\\":1}\", ClassWithoutDefaultConstructor.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n    c \u003d gson.fromJson(\"{}\", ClassWithoutDefaultConstructor.class);\r\n    // Class is instantiated with JDK Unsafe, so field keeps its default value instead of assigned -1\r\n    assertThat(c.i).isEqualTo(0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "testClassWithoutDefaultConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic ClassWithoutDefaultConstructor createInstance(Type type) {\r\n    return new ClassWithoutDefaultConstructor(-2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "ClassWithoutDefaultConstructor"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testInstanceCreator() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ClassWithoutDefaultConstructor.class, new InstanceCreator\u003cClassWithoutDefaultConstructor\u003e() {\r\n\r\n        @Override\r\n        public ClassWithoutDefaultConstructor createInstance(Type type) {\r\n            return new ClassWithoutDefaultConstructor(-2);\r\n        }\r\n    }).create();\r\n    ClassWithoutDefaultConstructor c \u003d gson.fromJson(\"{\\\"i\\\":1}\", ClassWithoutDefaultConstructor.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n    c \u003d gson.fromJson(\"{}\", ClassWithoutDefaultConstructor.class);\r\n    // Uses default value specified by InstanceCreator\r\n    assertThat(c.i).isEqualTo(-2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "testInstanceCreator",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static int nonConstant() {\r\n    // \u003d 1\r\n    return \"a\".length();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest.ClassWithFinalField",
      "methodName": "nonConstant",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testFinalField() {\r\n    Gson gson \u003d new Gson();\r\n    ClassWithFinalField c \u003d gson.fromJson(\"{\\\"i\\\":2}\", ClassWithFinalField.class);\r\n    assertThat(c.i).isEqualTo(2);\r\n    c \u003d gson.fromJson(\"{}\", ClassWithFinalField.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "testFinalField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testSerializedName() {\r\n    Gson gson \u003d new Gson();\r\n    ClassWithSerializedName c \u003d gson.fromJson(\"{\\\"custom-name\\\":1}\", ClassWithSerializedName.class);\r\n    assertThat(c.i).isEqualTo(1);\r\n    c \u003d new ClassWithSerializedName();\r\n    c.i \u003d 2;\r\n    assertThat(gson.toJson(c)).isEqualTo(\"{\\\"custom-name\\\":2}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "testSerializedName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic ClassWithCustomClassAdapter read(JsonReader in) throws IOException {\r\n    return new ClassWithCustomClassAdapter(in.nextInt() + 5);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest.ClassWithCustomClassAdapter.CustomAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "ClassWithCustomClassAdapter"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, ClassWithCustomClassAdapter value) throws IOException {\r\n    out.value(value.i + 6);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest.ClassWithCustomClassAdapter.CustomAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "ClassWithCustomClassAdapter"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testCustomClassAdapter() {\r\n    Gson gson \u003d new Gson();\r\n    ClassWithCustomClassAdapter c \u003d gson.fromJson(\"1\", ClassWithCustomClassAdapter.class);\r\n    assertThat(c.i).isEqualTo(6);\r\n    assertThat(gson.toJson(new ClassWithCustomClassAdapter(1))).isEqualTo(\"7\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "testCustomClassAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Integer read(JsonReader in) throws IOException {\r\n    return in.nextInt() + 5;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest.ClassWithCustomFieldAdapter.CustomAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Integer"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Integer value) throws IOException {\r\n    out.value(value + 6);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest.ClassWithCustomFieldAdapter.CustomAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Integer"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testCustomFieldAdapter() {\r\n    Gson gson \u003d new Gson();\r\n    ClassWithCustomFieldAdapter c \u003d gson.fromJson(\"{\\\"i\\\":1}\", ClassWithCustomFieldAdapter.class);\r\n    assertThat(c.i).isEqualTo(6);\r\n    assertThat(gson.toJson(new ClassWithCustomFieldAdapter(1))).isEqualTo(\"{\\\"i\\\":7}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "testCustomFieldAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic ClassWithRegisteredAdapter read(JsonReader in) throws IOException {\r\n    return new ClassWithRegisteredAdapter(in.nextInt() + 5);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "ClassWithRegisteredAdapter"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, ClassWithRegisteredAdapter value) throws IOException {\r\n    out.value(value.i + 6);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "ClassWithRegisteredAdapter"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testCustomAdapter() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ClassWithRegisteredAdapter.class, new TypeAdapter\u003cClassWithRegisteredAdapter\u003e() {\r\n\r\n        @Override\r\n        public ClassWithRegisteredAdapter read(JsonReader in) throws IOException {\r\n            return new ClassWithRegisteredAdapter(in.nextInt() + 5);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, ClassWithRegisteredAdapter value) throws IOException {\r\n            out.value(value.i + 6);\r\n        }\r\n    }).create();\r\n    ClassWithRegisteredAdapter c \u003d gson.fromJson(\"1\", ClassWithRegisteredAdapter.class);\r\n    assertThat(c.i).isEqualTo(6);\r\n    assertThat(gson.toJson(new ClassWithRegisteredAdapter(1))).isEqualTo(\"7\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "testCustomAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\nvoid testGenerics() {\r\n    Gson gson \u003d new Gson();\r\n    List\u003cClassWithDefaultConstructor\u003e list \u003d gson.fromJson(\"[{\\\"i\\\":1}]\", new TypeToken\u003cList\u003cClassWithDefaultConstructor\u003e\u003e() {\r\n    });\r\n    assertThat(list).hasSize(1);\r\n    assertThat(list.get(0).i).isEqualTo(1);\r\n    @SuppressWarnings(\"unchecked\")\r\n    List\u003cClassWithDefaultConstructor\u003e list2 \u003d (List\u003cClassWithDefaultConstructor\u003e) gson.fromJson(\"[{\\\"i\\\":1}]\", TypeToken.getParameterized(List.class, ClassWithDefaultConstructor.class));\r\n    assertThat(list2).hasSize(1);\r\n    assertThat(list2.get(0).i).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.native_test.ReflectionTest",
      "methodName": "testGenerics",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Decides if a field should be skipped during serialization or deserialization.\r\n *\r\n * @param f the field object that is under test\r\n * @return true if the field should be ignored; otherwise false\r\n */\r\npublic boolean shouldSkipField(FieldAttributes f);",
    "methodIdentifier": {
      "className": "com.google.gson.ExclusionStrategy",
      "methodName": "shouldSkipField",
      "parameterTypes": [
        "FieldAttributes"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Decides if a class should be serialized or deserialized\r\n *\r\n * @param clazz the class object that is under test\r\n * @return true if the class should be ignored; otherwise false\r\n */\r\npublic boolean shouldSkipClass(Class\u003c?\u003e clazz);",
    "methodIdentifier": {
      "className": "com.google.gson.ExclusionStrategy",
      "methodName": "shouldSkipClass",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Gets the declaring Class that contains this field\r\n *\r\n * @return the declaring class that contains this field\r\n */\r\npublic Class\u003c?\u003e getDeclaringClass() {\r\n    return field.getDeclaringClass();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributes",
      "methodName": "getDeclaringClass",
      "parameterTypes": [],
      "returnType": "Class\u003c?\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Gets the name of the field\r\n *\r\n * @return the name of the field\r\n */\r\npublic String getName() {\r\n    return field.getName();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributes",
      "methodName": "getName",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the declared generic type of the field.\r\n *\r\n * \u003cp\u003eFor example, assume the following class definition:\r\n * \u003cpre class\u003d\"code\"\u003e\r\n * public class Foo {\r\n *   private String bar;\r\n *   private List\u0026lt;String\u0026gt; red;\r\n * }\r\n *\r\n * Type listParameterizedType \u003d new TypeToken\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}.getType();\r\n * \u003c/pre\u003e\r\n *\r\n * \u003cp\u003eThis method would return {@code String.class} for the {@code bar} field and\r\n * {@code listParameterizedType} for the {@code red} field.\r\n *\r\n * @return the specific type declared for this field\r\n */\r\npublic Type getDeclaredType() {\r\n    return field.getGenericType();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributes",
      "methodName": "getDeclaredType",
      "parameterTypes": [],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the {@code Class} object that was declared for this field.\r\n *\r\n * \u003cp\u003eFor example, assume the following class definition:\r\n * \u003cpre class\u003d\"code\"\u003e\r\n * public class Foo {\r\n *   private String bar;\r\n *   private List\u0026lt;String\u0026gt; red;\r\n * }\r\n * \u003c/pre\u003e\r\n *\r\n * \u003cp\u003eThis method would return {@code String.class} for the {@code bar} field and\r\n * {@code List.class} for the {@code red} field.\r\n *\r\n * @return the specific class object that was declared for the field\r\n */\r\npublic Class\u003c?\u003e getDeclaredClass() {\r\n    return field.getType();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributes",
      "methodName": "getDeclaredClass",
      "parameterTypes": [],
      "returnType": "Class\u003c?\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the {@code T} annotation object from this field if it exists; otherwise returns\r\n * {@code null}.\r\n *\r\n * @param annotation the class of the annotation that will be retrieved\r\n * @return the annotation instance if it is bound to the field; otherwise {@code null}\r\n */\r\npublic \u003cT extends Annotation\u003e T getAnnotation(Class\u003cT\u003e annotation) {\r\n    return field.getAnnotation(annotation);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributes",
      "methodName": "getAnnotation",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the annotations that are present on this field.\r\n *\r\n * @return an array of all the annotations set on the field\r\n * @since 1.4\r\n */\r\npublic Collection\u003cAnnotation\u003e getAnnotations() {\r\n    return Arrays.asList(field.getAnnotations());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributes",
      "methodName": "getAnnotations",
      "parameterTypes": [],
      "returnType": "Collection\u003cAnnotation\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns {@code true} if the field is defined with the {@code modifier}.\r\n *\r\n * \u003cp\u003eThis method is meant to be called as:\r\n * \u003cpre class\u003d\"code\"\u003e\r\n * boolean hasPublicModifier \u003d fieldAttribute.hasModifier(java.lang.reflect.Modifier.PUBLIC);\r\n * \u003c/pre\u003e\r\n *\r\n * @see java.lang.reflect.Modifier\r\n */\r\npublic boolean hasModifier(int modifier) {\r\n    return (field.getModifiers() \u0026 modifier) !\u003d 0;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributes",
      "methodName": "hasModifier",
      "parameterTypes": [
        "int"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return field.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributes",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return f.getName();\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return upperCaseFirstLetter(f.getName());\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return upperCaseFirstLetter(separateCamelCase(f.getName(), \u0027 \u0027));\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return separateCamelCase(f.getName(), \u0027_\u0027).toUpperCase(Locale.ENGLISH);\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return separateCamelCase(f.getName(), \u0027_\u0027).toLowerCase(Locale.ENGLISH);\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return separateCamelCase(f.getName(), \u0027-\u0027).toLowerCase(Locale.ENGLISH);\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return separateCamelCase(f.getName(), \u0027.\u0027).toLowerCase(Locale.ENGLISH);\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Converts the field name that uses camel-case define word separation into\r\n * separate words that are separated by the provided {@code separator}.\r\n */\r\nstatic String separateCamelCase(String name, char separator) {\r\n    StringBuilder translation \u003d new StringBuilder();\r\n    for (int i \u003d 0, length \u003d name.length(); i \u003c length; i++) {\r\n        char character \u003d name.charAt(i);\r\n        if (Character.isUpperCase(character) \u0026\u0026 translation.length() !\u003d 0) {\r\n            translation.append(separator);\r\n        }\r\n        translation.append(character);\r\n    }\r\n    return translation.toString();\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "separateCamelCase",
      "parameterTypes": [
        "String",
        "char"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Ensures the JSON field names begins with an upper case letter.\r\n */\r\nstatic String upperCaseFirstLetter(String s) {\r\n    int length \u003d s.length();\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        char c \u003d s.charAt(i);\r\n        if (Character.isLetter(c)) {\r\n            if (Character.isUpperCase(c)) {\r\n                return s;\r\n            }\r\n            char uppercased \u003d Character.toUpperCase(c);\r\n            // For leading letter only need one substring\r\n            if (i \u003d\u003d 0) {\r\n                return uppercased + s.substring(1);\r\n            } else {\r\n                return s.substring(0, i) + uppercased + s.substring(i + 1);\r\n            }\r\n        }\r\n    }\r\n    return s;\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "upperCaseFirstLetter",
      "parameterTypes": [
        "String"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Translates the field name into its JSON field name representation.\r\n *\r\n * @param f the field object that we are translating\r\n * @return the translated field name.\r\n * @since 1.3\r\n */\r\npublic String translateName(Field f);",
    "methodIdentifier": {
      "className": "com.google.gson.FieldNamingStrategy",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a {@link FormattingStyle} with the specified newline setting.\r\n *\r\n * \u003cp\u003eIt can be used to accommodate certain OS convention, for example\r\n * hardcode {@code \"\\n\"} for Linux and macOS, {@code \"\\r\\n\"} for Windows, or\r\n * call {@link java.lang.System#lineSeparator()} to match the current OS.\u003c/p\u003e\r\n *\r\n * \u003cp\u003eOnly combinations of {@code \\n} and {@code \\r} are allowed.\u003c/p\u003e\r\n *\r\n * @param newline the string value that will be used as newline.\r\n * @return a newly created {@link FormattingStyle}\r\n */\r\npublic FormattingStyle withNewline(String newline) {\r\n    return new FormattingStyle(newline, this.indent, this.spaceAfterSeparators);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FormattingStyle",
      "methodName": "withNewline",
      "parameterTypes": [
        "String"
      ],
      "returnType": "FormattingStyle"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a {@link FormattingStyle} with the specified indent string.\r\n *\r\n * \u003cp\u003eOnly combinations of spaces and tabs allowed in indent.\u003c/p\u003e\r\n *\r\n * @param indent the string value that will be used as indent.\r\n * @return a newly created {@link FormattingStyle}\r\n */\r\npublic FormattingStyle withIndent(String indent) {\r\n    return new FormattingStyle(this.newline, indent, this.spaceAfterSeparators);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FormattingStyle",
      "methodName": "withIndent",
      "parameterTypes": [
        "String"
      ],
      "returnType": "FormattingStyle"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a {@link FormattingStyle} which either uses a space after\r\n * the separators {@code \u0027,\u0027} and {@code \u0027:\u0027} in the JSON output, or not.\r\n *\r\n * \u003cp\u003eThis setting has no effect on the {@linkplain #withNewline(String) configured newline}.\r\n * If a non-empty newline is configured, it will always be added after\r\n * {@code \u0027,\u0027} and no space is added after the {@code \u0027,\u0027} in that case.\u003c/p\u003e\r\n *\r\n * @param spaceAfterSeparators whether to output a space after {@code \u0027,\u0027} and {@code \u0027:\u0027}.\r\n * @return a newly created {@link FormattingStyle}\r\n */\r\npublic FormattingStyle withSpaceAfterSeparators(boolean spaceAfterSeparators) {\r\n    return new FormattingStyle(this.newline, this.indent, spaceAfterSeparators);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FormattingStyle",
      "methodName": "withSpaceAfterSeparators",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "FormattingStyle"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the string value that will be used as a newline.\r\n *\r\n * @return the newline value.\r\n */\r\npublic String getNewline() {\r\n    return this.newline;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FormattingStyle",
      "methodName": "getNewline",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the string value that will be used as indent.\r\n *\r\n * @return the indent value.\r\n */\r\npublic String getIndent() {\r\n    return this.indent;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FormattingStyle",
      "methodName": "getIndent",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns whether a space will be used after {@code \u0027,\u0027} and {@code \u0027:\u0027}.\r\n */\r\npublic boolean usesSpaceAfterSeparators() {\r\n    return this.spaceAfterSeparators;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FormattingStyle",
      "methodName": "usesSpaceAfterSeparators",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a new GsonBuilder containing all custom factories and configuration used by the current\r\n * instance.\r\n *\r\n * @return a GsonBuilder instance.\r\n * @since 2.8.3\r\n */\r\npublic GsonBuilder newBuilder() {\r\n    return new GsonBuilder(this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "newBuilder",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * @deprecated This method by accident exposes an internal Gson class; it might be removed in a\r\n * future version.\r\n */\r\n@Deprecated\r\npublic Excluder excluder() {\r\n    return excluder;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "excluder",
      "parameterTypes": [],
      "returnType": "Excluder"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the field naming strategy used by this Gson instance.\r\n *\r\n * @see GsonBuilder#setFieldNamingStrategy(FieldNamingStrategy)\r\n */\r\npublic FieldNamingStrategy fieldNamingStrategy() {\r\n    return fieldNamingStrategy;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fieldNamingStrategy",
      "parameterTypes": [],
      "returnType": "FieldNamingStrategy"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns whether this Gson instance is serializing JSON object properties with\r\n * {@code null} values, or just omits them.\r\n *\r\n * @see GsonBuilder#serializeNulls()\r\n */\r\npublic boolean serializeNulls() {\r\n    return serializeNulls;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "serializeNulls",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns whether this Gson instance produces JSON output which is\r\n * HTML-safe, that means all HTML characters are escaped.\r\n *\r\n * @see GsonBuilder#disableHtmlEscaping()\r\n */\r\npublic boolean htmlSafe() {\r\n    return htmlSafe;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "htmlSafe",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Double read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return in.nextDouble();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Double"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    double doubleValue \u003d value.doubleValue();\r\n    checkValidFloatingPoint(doubleValue);\r\n    out.value(doubleValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private TypeAdapter\u003cNumber\u003e doubleAdapter(boolean serializeSpecialFloatingPointValues) {\r\n    if (serializeSpecialFloatingPointValues) {\r\n        return TypeAdapters.DOUBLE;\r\n    }\r\n    return new TypeAdapter\u003cNumber\u003e() {\r\n\r\n        @Override\r\n        public Double read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return in.nextDouble();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            double doubleValue \u003d value.doubleValue();\r\n            checkValidFloatingPoint(doubleValue);\r\n            out.value(doubleValue);\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "doubleAdapter",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "TypeAdapter\u003cNumber\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Float read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return (float) in.nextDouble();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Float"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    float floatValue \u003d value.floatValue();\r\n    checkValidFloatingPoint(floatValue);\r\n    // For backward compatibility don\u0027t call `JsonWriter.value(float)` because that method has\r\n    // been newly added and not all custom JsonWriter implementations might override it yet\r\n    Number floatNumber \u003d value instanceof Float ? value : floatValue;\r\n    out.value(floatNumber);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private TypeAdapter\u003cNumber\u003e floatAdapter(boolean serializeSpecialFloatingPointValues) {\r\n    if (serializeSpecialFloatingPointValues) {\r\n        return TypeAdapters.FLOAT;\r\n    }\r\n    return new TypeAdapter\u003cNumber\u003e() {\r\n\r\n        @Override\r\n        public Float read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return (float) in.nextDouble();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            float floatValue \u003d value.floatValue();\r\n            checkValidFloatingPoint(floatValue);\r\n            // For backward compatibility don\u0027t call `JsonWriter.value(float)` because that method has\r\n            // been newly added and not all custom JsonWriter implementations might override it yet\r\n            Number floatNumber \u003d value instanceof Float ? value : floatValue;\r\n            out.value(floatNumber);\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "floatAdapter",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "TypeAdapter\u003cNumber\u003e"
    }
  },
  {
    "sourceCode": "static void checkValidFloatingPoint(double value) {\r\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\r\n        throw new IllegalArgumentException(value + \" is not a valid double value as per JSON specification. To override this\" + \" behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "checkValidFloatingPoint",
      "parameterTypes": [
        "double"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return in.nextLong();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.value(value.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static TypeAdapter\u003cNumber\u003e longAdapter(LongSerializationPolicy longSerializationPolicy) {\r\n    if (longSerializationPolicy \u003d\u003d LongSerializationPolicy.DEFAULT) {\r\n        return TypeAdapters.LONG;\r\n    }\r\n    return new TypeAdapter\u003cNumber\u003e() {\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return in.nextLong();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            out.value(value.toString());\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "longAdapter",
      "parameterTypes": [
        "LongSerializationPolicy"
      ],
      "returnType": "TypeAdapter\u003cNumber\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, AtomicLong value) throws IOException {\r\n    longAdapter.write(out, value.get());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "AtomicLong"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic AtomicLong read(JsonReader in) throws IOException {\r\n    Number value \u003d longAdapter.read(in);\r\n    return new AtomicLong(value.longValue());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "AtomicLong"
    }
  },
  {
    "sourceCode": "private static TypeAdapter\u003cAtomicLong\u003e atomicLongAdapter(final TypeAdapter\u003cNumber\u003e longAdapter) {\r\n    return new TypeAdapter\u003cAtomicLong\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, AtomicLong value) throws IOException {\r\n            longAdapter.write(out, value.get());\r\n        }\r\n\r\n        @Override\r\n        public AtomicLong read(JsonReader in) throws IOException {\r\n            Number value \u003d longAdapter.read(in);\r\n            return new AtomicLong(value.longValue());\r\n        }\r\n    }.nullSafe();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "atomicLongAdapter",
      "parameterTypes": [
        "TypeAdapter\u003cNumber\u003e"
      ],
      "returnType": "TypeAdapter\u003cAtomicLong\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, AtomicLongArray value) throws IOException {\r\n    out.beginArray();\r\n    for (int i \u003d 0, length \u003d value.length(); i \u003c length; i++) {\r\n        longAdapter.write(out, value.get(i));\r\n    }\r\n    out.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "AtomicLongArray"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic AtomicLongArray read(JsonReader in) throws IOException {\r\n    List\u003cLong\u003e list \u003d new ArrayList\u003c\u003e();\r\n    in.beginArray();\r\n    while (in.hasNext()) {\r\n        long value \u003d longAdapter.read(in).longValue();\r\n        list.add(value);\r\n    }\r\n    in.endArray();\r\n    int length \u003d list.size();\r\n    AtomicLongArray array \u003d new AtomicLongArray(length);\r\n    for (int i \u003d 0; i \u003c length; ++i) {\r\n        array.set(i, list.get(i));\r\n    }\r\n    return array;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "AtomicLongArray"
    }
  },
  {
    "sourceCode": "private static TypeAdapter\u003cAtomicLongArray\u003e atomicLongArrayAdapter(final TypeAdapter\u003cNumber\u003e longAdapter) {\r\n    return new TypeAdapter\u003cAtomicLongArray\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, AtomicLongArray value) throws IOException {\r\n            out.beginArray();\r\n            for (int i \u003d 0, length \u003d value.length(); i \u003c length; i++) {\r\n                longAdapter.write(out, value.get(i));\r\n            }\r\n            out.endArray();\r\n        }\r\n\r\n        @Override\r\n        public AtomicLongArray read(JsonReader in) throws IOException {\r\n            List\u003cLong\u003e list \u003d new ArrayList\u003c\u003e();\r\n            in.beginArray();\r\n            while (in.hasNext()) {\r\n                long value \u003d longAdapter.read(in).longValue();\r\n                list.add(value);\r\n            }\r\n            in.endArray();\r\n            int length \u003d list.size();\r\n            AtomicLongArray array \u003d new AtomicLongArray(length);\r\n            for (int i \u003d 0; i \u003c length; ++i) {\r\n                array.set(i, list.get(i));\r\n            }\r\n            return array;\r\n        }\r\n    }.nullSafe();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "atomicLongArrayAdapter",
      "parameterTypes": [
        "TypeAdapter\u003cNumber\u003e"
      ],
      "returnType": "TypeAdapter\u003cAtomicLongArray\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the type adapter for {@code type}.\r\n *\r\n * \u003cp\u003eWhen calling this method concurrently from multiple threads and requesting\r\n * an adapter for the same type this method may return different {@code TypeAdapter}\r\n * instances. However, that should normally not be an issue because {@code TypeAdapter}\r\n * implementations are supposed to be stateless.\r\n *\r\n * @throws IllegalArgumentException if this Gson instance cannot serialize and\r\n *     deserialize {@code type}.\r\n */\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {\r\n    Objects.requireNonNull(type, \"type must not be null\");\r\n    TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\r\n    if (cached !\u003d null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e adapter \u003d (TypeAdapter\u003cT\u003e) cached;\r\n        return adapter;\r\n    }\r\n    Map\u003cTypeToken\u003c?\u003e, TypeAdapter\u003c?\u003e\u003e threadCalls \u003d threadLocalAdapterResults.get();\r\n    boolean isInitialAdapterRequest \u003d false;\r\n    if (threadCalls \u003d\u003d null) {\r\n        threadCalls \u003d new HashMap\u003c\u003e();\r\n        threadLocalAdapterResults.set(threadCalls);\r\n        isInitialAdapterRequest \u003d true;\r\n    } else {\r\n        // the key and value type parameters always agree\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e ongoingCall \u003d (TypeAdapter\u003cT\u003e) threadCalls.get(type);\r\n        if (ongoingCall !\u003d null) {\r\n            return ongoingCall;\r\n        }\r\n    }\r\n    TypeAdapter\u003cT\u003e candidate \u003d null;\r\n    try {\r\n        FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003c\u003e();\r\n        threadCalls.put(type, call);\r\n        for (TypeAdapterFactory factory : factories) {\r\n            candidate \u003d factory.create(this, type);\r\n            if (candidate !\u003d null) {\r\n                call.setDelegate(candidate);\r\n                // Replace future adapter with actual adapter\r\n                threadCalls.put(type, candidate);\r\n                break;\r\n            }\r\n        }\r\n    } finally {\r\n        if (isInitialAdapterRequest) {\r\n            threadLocalAdapterResults.remove();\r\n        }\r\n    }\r\n    if (candidate \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"GSON (\" + GsonBuildConfig.VERSION + \") cannot handle \" + type);\r\n    }\r\n    if (isInitialAdapterRequest) {\r\n        /*\r\n       * Publish resolved adapters to all threads\r\n       * Can only do this for the initial request because cyclic dependency TypeA -\u003e TypeB -\u003e TypeA\r\n       * would otherwise publish adapter for TypeB which uses not yet resolved adapter for TypeA\r\n       * See https://github.com/google/gson/issues/625\r\n       */\r\n        typeTokenCache.putAll(threadCalls);\r\n    }\r\n    return candidate;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "getAdapter",
      "parameterTypes": [
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * This method is used to get an alternate type adapter for the specified type. This is used\r\n * to access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\r\n * may have registered. This feature is typically used when you want to register a type\r\n * adapter that does a little bit of work but then delegates further processing to the Gson\r\n * default type adapter. Here is an example:\r\n * \u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read\r\n * from or written to JSON. We can achieve this by writing a type adapter factory that uses\r\n * the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method:\r\n * \u003cpre\u003e{@code\r\n * class StatsTypeAdapterFactory implements TypeAdapterFactory {\r\n *   public int numReads \u003d 0;\r\n *   public int numWrites \u003d 0;\r\n *   public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n *     final TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n *     return new TypeAdapter\u003cT\u003e() {\r\n *       public void write(JsonWriter out, T value) throws IOException {\r\n *         ++numWrites;\r\n *         delegate.write(out, value);\r\n *       }\r\n *       public T read(JsonReader in) throws IOException {\r\n *         ++numReads;\r\n *         return delegate.read(in);\r\n *       }\r\n *     };\r\n *   }\r\n * }\r\n * }\u003c/pre\u003e\r\n * This factory can now be used like this:\r\n * \u003cpre\u003e{@code\r\n * StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory();\r\n * Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\r\n * // Call gson.toJson() and fromJson methods on objects\r\n * System.out.println(\"Num JSON reads: \" + stats.numReads);\r\n * System.out.println(\"Num JSON writes: \" + stats.numWrites);\r\n * }\u003c/pre\u003e\r\n * Note that this call will skip all factories registered before {@code skipPast}. In case of\r\n * multiple TypeAdapterFactories registered it is up to the caller of this function to ensure\r\n * that the order of registration does not prevent this method from reaching a factory they\r\n * would expect to reply from this call.\r\n * Note that since you can not override the type adapter factories for some types, see\r\n * {@link GsonBuilder#registerTypeAdapter(Type, Object)}, our stats factory will not count\r\n * the number of instances of those types that will be read or written.\r\n *\r\n * \u003cp\u003eIf {@code skipPast} is a factory which has neither been registered on the {@link GsonBuilder}\r\n * nor specified with the {@link JsonAdapter @JsonAdapter} annotation on a class, then this\r\n * method behaves as if {@link #getAdapter(TypeToken)} had been called. This also means that\r\n * for fields with {@code @JsonAdapter} annotation this method behaves normally like {@code getAdapter}\r\n * (except for corner cases where a custom {@link InstanceCreator} is used to create an\r\n * instance of the factory).\r\n *\r\n * @param skipPast The type adapter factory that needs to be skipped while searching for\r\n *   a matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter\r\n *   factory from where {@code getDelegateAdapter} method is being invoked).\r\n * @param type Type for which the delegate adapter is being searched for.\r\n *\r\n * @since 2.2\r\n */\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken\u003cT\u003e type) {\r\n    Objects.requireNonNull(skipPast, \"skipPast must not be null\");\r\n    Objects.requireNonNull(type, \"type must not be null\");\r\n    if (jsonAdapterFactory.isClassJsonAdapterFactory(type, skipPast)) {\r\n        skipPast \u003d jsonAdapterFactory;\r\n    }\r\n    boolean skipPastFound \u003d false;\r\n    for (TypeAdapterFactory factory : factories) {\r\n        if (!skipPastFound) {\r\n            if (factory \u003d\u003d skipPast) {\r\n                skipPastFound \u003d true;\r\n            }\r\n            continue;\r\n        }\r\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\r\n        if (candidate !\u003d null) {\r\n            return candidate;\r\n        }\r\n    }\r\n    if (skipPastFound) {\r\n        throw new IllegalArgumentException(\"GSON cannot serialize or deserialize \" + type);\r\n    } else {\r\n        // Probably a factory from @JsonAdapter on a field\r\n        return getAdapter(type);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "getDelegateAdapter",
      "parameterTypes": [
        "TypeAdapterFactory",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the type adapter for {@code type}.\r\n *\r\n * @throws IllegalArgumentException if this Gson instance cannot serialize and\r\n *     deserialize {@code type}.\r\n */\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(Class\u003cT\u003e type) {\r\n    return getAdapter(TypeToken.get(type));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "getAdapter",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * This method serializes the specified object into its equivalent representation as a tree of\r\n * {@link JsonElement}s. This method should be used when the specified object is not a generic\r\n * type. This method uses {@link Class#getClass()} to get the type for the specified object, but\r\n * the {@code getClass()} loses the generic type information because of the Type Erasure feature\r\n * of Java. Note that this method works fine if any of the object fields are of generic type,\r\n * just the object itself should not be of a generic type. If the object is of generic type, use\r\n * {@link #toJsonTree(Object, Type)} instead.\r\n *\r\n * @param src the object for which JSON representation is to be created\r\n * @return JSON representation of {@code src}.\r\n * @since 1.4\r\n *\r\n * @see #toJsonTree(Object, Type)\r\n */\r\npublic JsonElement toJsonTree(Object src) {\r\n    if (src \u003d\u003d null) {\r\n        return JsonNull.INSTANCE;\r\n    }\r\n    return toJsonTree(src, src.getClass());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toJsonTree",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * This method serializes the specified object, including those of generic types, into its\r\n * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the\r\n * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}\r\n * instead.\r\n *\r\n * @param src the object for which JSON representation is to be created\r\n * @param typeOfSrc The specific genericized type of src. You can obtain\r\n * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\r\n * to get the type for {@code Collection\u003cFoo\u003e}, you should use:\r\n * \u003cpre\u003e\r\n * Type typeOfSrc \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\r\n * \u003c/pre\u003e\r\n * @return JSON representation of {@code src}.\r\n * @since 1.4\r\n *\r\n * @see #toJsonTree(Object)\r\n */\r\npublic JsonElement toJsonTree(Object src, Type typeOfSrc) {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    toJson(src, typeOfSrc, writer);\r\n    return writer.get();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toJsonTree",
      "parameterTypes": [
        "Object",
        "Type"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * This method serializes the specified object into its equivalent JSON representation.\r\n * This method should be used when the specified object is not a generic type. This method uses\r\n * {@link Class#getClass()} to get the type for the specified object, but the\r\n * {@code getClass()} loses the generic type information because of the Type Erasure feature\r\n * of Java. Note that this method works fine if any of the object fields are of generic type,\r\n * just the object itself should not be of a generic type. If the object is of generic type, use\r\n * {@link #toJson(Object, Type)} instead. If you want to write out the object to a\r\n * {@link Writer}, use {@link #toJson(Object, Appendable)} instead.\r\n *\r\n * @param src the object for which JSON representation is to be created\r\n * @return JSON representation of {@code src}.\r\n *\r\n * @see #toJson(Object, Appendable)\r\n * @see #toJson(Object, Type)\r\n */\r\npublic String toJson(Object src) {\r\n    if (src \u003d\u003d null) {\r\n        return toJson(JsonNull.INSTANCE);\r\n    }\r\n    return toJson(src, src.getClass());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toJson",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * This method serializes the specified object, including those of generic types, into its\r\n * equivalent JSON representation. This method must be used if the specified object is a generic\r\n * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out\r\n * the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.\r\n *\r\n * @param src the object for which JSON representation is to be created\r\n * @param typeOfSrc The specific genericized type of src. You can obtain\r\n * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\r\n * to get the type for {@code Collection\u003cFoo\u003e}, you should use:\r\n * \u003cpre\u003e\r\n * Type typeOfSrc \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\r\n * \u003c/pre\u003e\r\n * @return JSON representation of {@code src}.\r\n *\r\n * @see #toJson(Object, Type, Appendable)\r\n * @see #toJson(Object)\r\n */\r\npublic String toJson(Object src, Type typeOfSrc) {\r\n    StringWriter writer \u003d new StringWriter();\r\n    toJson(src, typeOfSrc, writer);\r\n    return writer.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toJson",
      "parameterTypes": [
        "Object",
        "Type"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * This method serializes the specified object into its equivalent JSON representation and\r\n * writes it to the writer.\r\n * This method should be used when the specified object is not a generic type. This method uses\r\n * {@link Class#getClass()} to get the type for the specified object, but the\r\n * {@code getClass()} loses the generic type information because of the Type Erasure feature\r\n * of Java. Note that this method works fine if any of the object fields are of generic type,\r\n * just the object itself should not be of a generic type. If the object is of generic type, use\r\n * {@link #toJson(Object, Type, Appendable)} instead.\r\n *\r\n * @param src the object for which JSON representation is to be created\r\n * @param writer Writer to which the JSON representation needs to be written\r\n * @throws JsonIOException if there was a problem writing to the writer\r\n * @since 1.2\r\n *\r\n * @see #toJson(Object)\r\n * @see #toJson(Object, Type, Appendable)\r\n */\r\npublic void toJson(Object src, Appendable writer) throws JsonIOException {\r\n    if (src !\u003d null) {\r\n        toJson(src, src.getClass(), writer);\r\n    } else {\r\n        toJson(JsonNull.INSTANCE, writer);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toJson",
      "parameterTypes": [
        "Object",
        "Appendable"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This method serializes the specified object, including those of generic types, into its\r\n * equivalent JSON representation and writes it to the writer.\r\n * This method must be used if the specified object is a generic type. For non-generic objects,\r\n * use {@link #toJson(Object, Appendable)} instead.\r\n *\r\n * @param src the object for which JSON representation is to be created\r\n * @param typeOfSrc The specific genericized type of src. You can obtain\r\n * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\r\n * to get the type for {@code Collection\u003cFoo\u003e}, you should use:\r\n * \u003cpre\u003e\r\n * Type typeOfSrc \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType();\r\n * \u003c/pre\u003e\r\n * @param writer Writer to which the JSON representation of src needs to be written\r\n * @throws JsonIOException if there was a problem writing to the writer\r\n * @since 1.2\r\n *\r\n * @see #toJson(Object, Type)\r\n * @see #toJson(Object, Appendable)\r\n */\r\npublic void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {\r\n    try {\r\n        JsonWriter jsonWriter \u003d newJsonWriter(Streams.writerForAppendable(writer));\r\n        toJson(src, typeOfSrc, jsonWriter);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toJson",
      "parameterTypes": [
        "Object",
        "Type",
        "Appendable"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Writes the JSON representation of {@code src} of type {@code typeOfSrc} to\r\n * {@code writer}.\r\n *\r\n * \u003cp\u003eIf the {@code Gson} instance has an {@linkplain GsonBuilder#setStrictness(Strictness) explicit strictness setting},\r\n * this setting will be used for writing the JSON regardless of the {@linkplain JsonWriter#getStrictness() strictness}\r\n * of the provided {@link JsonWriter}. For legacy reasons, if the {@code Gson} instance has no explicit strictness setting\r\n * and the writer does not have the strictness {@link Strictness#STRICT}, the JSON will be written in {@link Strictness#LENIENT}\r\n * mode.\u003cbr\u003e\r\n * Note that in all cases the old strictness setting of the writer will be restored when this method returns.\r\n *\r\n * \u003cp\u003eThe \u0027HTML-safe\u0027 and \u0027serialize {@code null}\u0027 settings of this {@code Gson} instance\r\n * (configured by the {@link GsonBuilder}) are applied, and the original settings of the\r\n * writer are restored once this method returns.\r\n *\r\n * @param src the object for which JSON representation is to be created\r\n * @param typeOfSrc the type of the object to be written\r\n * @param writer Writer to which the JSON representation of src needs to be written\r\n *\r\n * @throws JsonIOException if there was a problem writing to the writer\r\n */\r\npublic void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cObject\u003e adapter \u003d (TypeAdapter\u003cObject\u003e) getAdapter(TypeToken.get(typeOfSrc));\r\n    Strictness oldStrictness \u003d writer.getStrictness();\r\n    if (this.strictness !\u003d null) {\r\n        writer.setStrictness(this.strictness);\r\n    } else if (writer.getStrictness() !\u003d Strictness.STRICT) {\r\n        writer.setStrictness(Strictness.LENIENT);\r\n    }\r\n    boolean oldHtmlSafe \u003d writer.isHtmlSafe();\r\n    boolean oldSerializeNulls \u003d writer.getSerializeNulls();\r\n    writer.setHtmlSafe(htmlSafe);\r\n    writer.setSerializeNulls(serializeNulls);\r\n    try {\r\n        adapter.write(writer, src);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    } catch (AssertionError e) {\r\n        throw new AssertionError(\"AssertionError (GSON \" + GsonBuildConfig.VERSION + \"): \" + e.getMessage(), e);\r\n    } finally {\r\n        writer.setStrictness(oldStrictness);\r\n        writer.setHtmlSafe(oldHtmlSafe);\r\n        writer.setSerializeNulls(oldSerializeNulls);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toJson",
      "parameterTypes": [
        "Object",
        "Type",
        "JsonWriter"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.\r\n *\r\n * @param jsonElement root of a tree of {@link JsonElement}s\r\n * @return JSON String representation of the tree.\r\n * @since 1.4\r\n */\r\npublic String toJson(JsonElement jsonElement) {\r\n    StringWriter writer \u003d new StringWriter();\r\n    toJson(jsonElement, writer);\r\n    return writer.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toJson",
      "parameterTypes": [
        "JsonElement"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Writes out the equivalent JSON for a tree of {@link JsonElement}s.\r\n *\r\n * @param jsonElement root of a tree of {@link JsonElement}s\r\n * @param writer Writer to which the JSON representation needs to be written\r\n * @throws JsonIOException if there was a problem writing to the writer\r\n * @since 1.4\r\n */\r\npublic void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {\r\n    try {\r\n        JsonWriter jsonWriter \u003d newJsonWriter(Streams.writerForAppendable(writer));\r\n        toJson(jsonElement, jsonWriter);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toJson",
      "parameterTypes": [
        "JsonElement",
        "Appendable"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a new JSON writer configured for the settings on this Gson instance.\r\n *\r\n * \u003cp\u003eThe following settings are considered:\r\n * \u003cul\u003e\r\n *   \u003cli\u003e{@link GsonBuilder#disableHtmlEscaping()}\u003c/li\u003e\r\n *   \u003cli\u003e{@link GsonBuilder#generateNonExecutableJson()}\u003c/li\u003e\r\n *   \u003cli\u003e{@link GsonBuilder#serializeNulls()}\u003c/li\u003e\r\n *   \u003cli\u003e{@link GsonBuilder#setStrictness(Strictness)}. If no\r\n *   {@linkplain GsonBuilder#setStrictness(Strictness) explicit strictness has been set} the created\r\n *   writer will have a strictness of {@link Strictness#LEGACY_STRICT}. Otherwise, the strictness of\r\n *   the {@code Gson} instance will be used for the created writer.\u003c/li\u003e\r\n *   \u003cli\u003e{@link GsonBuilder#setPrettyPrinting()}\u003c/li\u003e\r\n *   \u003cli\u003e{@link GsonBuilder#setFormattingStyle(FormattingStyle)}\u003c/li\u003e\r\n * \u003c/ul\u003e\r\n */\r\npublic JsonWriter newJsonWriter(Writer writer) throws IOException {\r\n    if (generateNonExecutableJson) {\r\n        writer.write(JSON_NON_EXECUTABLE_PREFIX);\r\n    }\r\n    JsonWriter jsonWriter \u003d new JsonWriter(writer);\r\n    jsonWriter.setFormattingStyle(formattingStyle);\r\n    jsonWriter.setHtmlSafe(htmlSafe);\r\n    jsonWriter.setStrictness(strictness \u003d\u003d null ? Strictness.LEGACY_STRICT : strictness);\r\n    jsonWriter.setSerializeNulls(serializeNulls);\r\n    return jsonWriter;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "newJsonWriter",
      "parameterTypes": [
        "Writer"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a new JSON reader configured for the settings on this Gson instance.\r\n *\r\n * \u003cp\u003eThe following settings are considered:\r\n * \u003cul\u003e\r\n *   \u003cli\u003e{@link GsonBuilder#setStrictness(Strictness)}. If no\r\n *   {@linkplain GsonBuilder#setStrictness(Strictness) explicit strictness has been set} the created\r\n *   reader will have a strictness of {@link Strictness#LEGACY_STRICT}. Otherwise, the strictness of\r\n *   the {@code Gson} instance will be used for the created reader.\u003c/li\u003e\r\n * \u003c/ul\u003e\r\n */\r\npublic JsonReader newJsonReader(Reader reader) {\r\n    JsonReader jsonReader \u003d new JsonReader(reader);\r\n    jsonReader.setStrictness(strictness \u003d\u003d null ? Strictness.LEGACY_STRICT : strictness);\r\n    return jsonReader;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "newJsonReader",
      "parameterTypes": [
        "Reader"
      ],
      "returnType": "JsonReader"
    }
  },
  {
    "sourceCode": "/**\r\n * Writes the JSON for {@code jsonElement} to {@code writer}.\r\n *\r\n * \u003cp\u003eIf the {@code Gson} instance has an {@linkplain GsonBuilder#setStrictness(Strictness) explicit strictness setting},\r\n * this setting will be used for writing the JSON regardless of the {@linkplain JsonWriter#getStrictness() strictness}\r\n * of the provided {@link JsonWriter}. For legacy reasons, if the {@code Gson} instance has no explicit strictness setting\r\n * and the writer does not have the strictness {@link Strictness#STRICT}, the JSON will be written in {@link Strictness#LENIENT}\r\n * mode.\u003cbr\u003e\r\n * Note that in all cases the old strictness setting of the writer will be restored when this method returns.\r\n *\r\n * \u003cp\u003eThe \u0027HTML-safe\u0027 and \u0027serialize {@code null}\u0027 settings of this {@code Gson} instance\r\n * (configured by the {@link GsonBuilder}) are applied, and the original settings of the\r\n * writer are restored once this method returns.\r\n *\r\n * @param jsonElement the JSON element to be written\r\n * @param writer the JSON writer to which the provided element will be written\r\n * @throws JsonIOException if there was a problem writing to the writer\r\n */\r\npublic void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOException {\r\n    Strictness oldStrictness \u003d writer.getStrictness();\r\n    boolean oldHtmlSafe \u003d writer.isHtmlSafe();\r\n    boolean oldSerializeNulls \u003d writer.getSerializeNulls();\r\n    writer.setHtmlSafe(htmlSafe);\r\n    writer.setSerializeNulls(serializeNulls);\r\n    if (this.strictness !\u003d null) {\r\n        writer.setStrictness(this.strictness);\r\n    } else if (writer.getStrictness() !\u003d Strictness.STRICT) {\r\n        writer.setStrictness(Strictness.LENIENT);\r\n    }\r\n    try {\r\n        Streams.write(jsonElement, writer);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    } catch (AssertionError e) {\r\n        throw new AssertionError(\"AssertionError (GSON \" + GsonBuildConfig.VERSION + \"): \" + e.getMessage(), e);\r\n    } finally {\r\n        writer.setStrictness(oldStrictness);\r\n        writer.setHtmlSafe(oldHtmlSafe);\r\n        writer.setSerializeNulls(oldSerializeNulls);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toJson",
      "parameterTypes": [
        "JsonElement",
        "JsonWriter"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This method deserializes the specified JSON into an object of the specified class. It is not\r\n * suitable to use if the specified class is a generic type since it will not have the generic\r\n * type information because of the Type Erasure feature of Java. Therefore, this method should not\r\n * be used if the desired type is a generic type. Note that this method works fine if any of\r\n * the fields of the specified object are generics, just the object itself should not be a\r\n * generic type. For the cases when the object is of generic type, invoke\r\n * {@link #fromJson(String, TypeToken)}. If you have the JSON in a {@link Reader} instead of\r\n * a String, use {@link #fromJson(Reader, Class)} instead.\r\n *\r\n * \u003cp\u003eAn exception is thrown if the JSON string has multiple top-level JSON elements, or if there\r\n * is trailing data. Use {@link #fromJson(JsonReader, Type)} if this behavior is not desired.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param json the string from which the object is to be deserialized\r\n * @param classOfT the class of T\r\n * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}\r\n * or if {@code json} is empty.\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of type\r\n * classOfT\r\n *\r\n * @see #fromJson(Reader, Class)\r\n * @see #fromJson(String, TypeToken)\r\n */\r\npublic \u003cT\u003e T fromJson(String json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\r\n    T object \u003d fromJson(json, TypeToken.get(classOfT));\r\n    return Primitives.wrap(classOfT).cast(object);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "String",
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * This method deserializes the specified JSON into an object of the specified type. This method\r\n * is useful if the specified object is a generic type. For non-generic objects, use\r\n * {@link #fromJson(String, Class)} instead. If you have the JSON in a {@link Reader} instead of\r\n * a String, use {@link #fromJson(Reader, Type)} instead.\r\n *\r\n * \u003cp\u003eSince {@code Type} is not parameterized by T, this method is not type-safe and\r\n * should be used carefully. If you are creating the {@code Type} from a {@link TypeToken},\r\n * prefer using {@link #fromJson(String, TypeToken)} instead since its return type is based\r\n * on the {@code TypeToken} and is therefore more type-safe.\r\n *\r\n * \u003cp\u003eAn exception is thrown if the JSON string has multiple top-level JSON elements,\r\n * or if there is trailing data. Use {@link #fromJson(JsonReader, Type)} if this behavior is\r\n * not desired.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param json the string from which the object is to be deserialized\r\n * @param typeOfT The specific genericized type of src\r\n * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}\r\n * or if {@code json} is empty.\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\r\n *\r\n * @see #fromJson(Reader, Type)\r\n * @see #fromJson(String, Class)\r\n * @see #fromJson(String, TypeToken)\r\n */\r\n@SuppressWarnings({ \"unchecked\", \"TypeParameterUnusedInFormals\" })\r\npublic \u003cT\u003e T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\r\n    return (T) fromJson(json, TypeToken.get(typeOfT));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "String",
        "Type"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * This method deserializes the specified JSON into an object of the specified type. This method\r\n * is useful if the specified object is a generic type. For non-generic objects, use\r\n * {@link #fromJson(String, Class)} instead. If you have the JSON in a {@link Reader} instead of\r\n * a String, use {@link #fromJson(Reader, TypeToken)} instead.\r\n *\r\n * \u003cp\u003eAn exception is thrown if the JSON string has multiple top-level JSON elements, or if there\r\n * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param json the string from which the object is to be deserialized\r\n * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\r\n * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\r\n * {@code Collection\u003cFoo\u003e}, you should use:\r\n * \u003cpre\u003e\r\n * new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}\r\n * \u003c/pre\u003e\r\n * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}\r\n * or if {@code json} is empty.\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of the type typeOfT\r\n *\r\n * @see #fromJson(Reader, TypeToken)\r\n * @see #fromJson(String, Class)\r\n * @since 2.10\r\n */\r\npublic \u003cT\u003e T fromJson(String json, TypeToken\u003cT\u003e typeOfT) throws JsonSyntaxException {\r\n    if (json \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    StringReader reader \u003d new StringReader(json);\r\n    return fromJson(reader, typeOfT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "String",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * This method deserializes the JSON read from the specified reader into an object of the\r\n * specified class. It is not suitable to use if the specified class is a generic type since it\r\n * will not have the generic type information because of the Type Erasure feature of Java.\r\n * Therefore, this method should not be used if the desired type is a generic type. Note that\r\n * this method works fine if any of the fields of the specified object are generics, just the\r\n * object itself should not be a generic type. For the cases when the object is of generic type,\r\n * invoke {@link #fromJson(Reader, TypeToken)}. If you have the JSON in a String form instead of a\r\n * {@link Reader}, use {@link #fromJson(String, Class)} instead.\r\n *\r\n * \u003cp\u003eAn exception is thrown if the JSON data has multiple top-level JSON elements, or if there\r\n * is trailing data. Use {@link #fromJson(JsonReader, Type)} if this behavior is not desired.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param json the reader producing the JSON from which the object is to be deserialized.\r\n * @param classOfT the class of T\r\n * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\r\n * @throws JsonIOException if there was a problem reading from the Reader\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\r\n * @since 1.2\r\n *\r\n * @see #fromJson(String, Class)\r\n * @see #fromJson(Reader, TypeToken)\r\n */\r\npublic \u003cT\u003e T fromJson(Reader json, Class\u003cT\u003e classOfT) throws JsonSyntaxException, JsonIOException {\r\n    T object \u003d fromJson(json, TypeToken.get(classOfT));\r\n    return Primitives.wrap(classOfT).cast(object);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "Reader",
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * This method deserializes the JSON read from the specified reader into an object of the\r\n * specified type. This method is useful if the specified object is a generic type. For\r\n * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\r\n * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\r\n *\r\n * \u003cp\u003eSince {@code Type} is not parameterized by T, this method is not type-safe and\r\n * should be used carefully. If you are creating the {@code Type} from a {@link TypeToken},\r\n * prefer using {@link #fromJson(Reader, TypeToken)} instead since its return type is based\r\n * on the {@code TypeToken} and is therefore more type-safe.\r\n *\r\n * \u003cp\u003eAn exception is thrown if the JSON data has multiple top-level JSON elements, or if there\r\n * is trailing data. Use {@link #fromJson(JsonReader, Type)} if this behavior is not desired.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param json the reader producing JSON from which the object is to be deserialized\r\n * @param typeOfT The specific genericized type of src\r\n * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\r\n * @throws JsonIOException if there was a problem reading from the Reader\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\r\n * @since 1.2\r\n *\r\n * @see #fromJson(String, Type)\r\n * @see #fromJson(Reader, Class)\r\n * @see #fromJson(Reader, TypeToken)\r\n */\r\n@SuppressWarnings({ \"unchecked\", \"TypeParameterUnusedInFormals\" })\r\npublic \u003cT\u003e T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\r\n    return (T) fromJson(json, TypeToken.get(typeOfT));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "Reader",
        "Type"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * This method deserializes the JSON read from the specified reader into an object of the\r\n * specified type. This method is useful if the specified object is a generic type. For\r\n * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\r\n * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\r\n *\r\n * \u003cp\u003eAn exception is thrown if the JSON data has multiple top-level JSON elements, or if there\r\n * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param json the reader producing JSON from which the object is to be deserialized\r\n * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\r\n * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\r\n * {@code Collection\u003cFoo\u003e}, you should use:\r\n * \u003cpre\u003e\r\n * new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}\r\n * \u003c/pre\u003e\r\n * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\r\n * @throws JsonIOException if there was a problem reading from the Reader\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\r\n *\r\n * @see #fromJson(String, TypeToken)\r\n * @see #fromJson(Reader, Class)\r\n * @since 2.10\r\n */\r\npublic \u003cT\u003e T fromJson(Reader json, TypeToken\u003cT\u003e typeOfT) throws JsonIOException, JsonSyntaxException {\r\n    JsonReader jsonReader \u003d newJsonReader(json);\r\n    T object \u003d fromJson(jsonReader, typeOfT);\r\n    assertFullConsumption(object, jsonReader);\r\n    return object;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "Reader",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "private static void assertFullConsumption(Object obj, JsonReader reader) {\r\n    try {\r\n        if (obj !\u003d null \u0026\u0026 reader.peek() !\u003d JsonToken.END_DOCUMENT) {\r\n            throw new JsonSyntaxException(\"JSON document was not fully consumed.\");\r\n        }\r\n    } catch (MalformedJsonException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "assertFullConsumption",
      "parameterTypes": [
        "Object",
        "JsonReader"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// fromJson(JsonReader, Class) is unfortunately missing and cannot be added now without breaking\r\n// source compatibility in certain cases, see https://github.com/google/gson/pull/1700#discussion_r973764414\r\n/**\r\n * Reads the next JSON value from {@code reader} and converts it to an object\r\n * of type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.\r\n *\r\n * \u003cp\u003eSince {@code Type} is not parameterized by T, this method is not type-safe and\r\n * should be used carefully. If you are creating the {@code Type} from a {@link TypeToken},\r\n * prefer using {@link #fromJson(JsonReader, TypeToken)} instead since its return type is based\r\n * on the {@code TypeToken} and is therefore more type-safe. If the provided type is a\r\n * {@code Class} the {@code TypeToken} can be created with {@link TypeToken#get(Class)}.\r\n *\r\n * \u003cp\u003eUnlike the other {@code fromJson} methods, no exception is thrown if the JSON data has\r\n * multiple top-level JSON elements, or if there is trailing data.\r\n *\r\n * \u003cp\u003eIf the {@code Gson} instance has an {@linkplain GsonBuilder#setStrictness(Strictness) explicit strictness setting},\r\n * this setting will be used for reading the JSON regardless of the {@linkplain JsonReader#getStrictness() strictness}\r\n * of the provided {@link JsonReader}. For legacy reasons, if the {@code Gson} instance has no explicit strictness setting\r\n * and the reader does not have the strictness {@link Strictness#STRICT}, the JSON will be written in {@link Strictness#LENIENT}\r\n * mode.\u003cbr\u003e\r\n * Note that in all cases the old strictness setting of the reader will be restored when this method returns.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param reader the reader whose next JSON value should be deserialized\r\n * @param typeOfT The specific genericized type of src\r\n * @return an object of type T from the JsonReader. Returns {@code null} if {@code reader} is at EOF.\r\n * @throws JsonIOException if there was a problem reading from the JsonReader\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\r\n *\r\n * @see #fromJson(Reader, Type)\r\n * @see #fromJson(JsonReader, TypeToken)\r\n */\r\n@SuppressWarnings({ \"unchecked\", \"TypeParameterUnusedInFormals\" })\r\npublic \u003cT\u003e T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\r\n    return (T) fromJson(reader, TypeToken.get(typeOfT));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "JsonReader",
        "Type"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Reads the next JSON value from {@code reader} and converts it to an object\r\n * of type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.\r\n * This method is useful if the specified object is a generic type. For non-generic objects,\r\n * {@link #fromJson(JsonReader, Type)} can be called, or {@link TypeToken#get(Class)} can\r\n * be used to create the type token.\r\n *\r\n * \u003cp\u003eUnlike the other {@code fromJson} methods, no exception is thrown if the JSON data has\r\n * multiple top-level JSON elements, or if there is trailing data.\r\n *\r\n * \u003cp\u003eIf the {@code Gson} instance has an {@linkplain GsonBuilder#setStrictness(Strictness) explicit strictness setting},\r\n * this setting will be used for reading the JSON regardless of the {@linkplain JsonReader#getStrictness() strictness}\r\n * of the provided {@link JsonReader}. For legacy reasons, if the {@code Gson} instance has no explicit strictness setting\r\n * and the reader does not have the strictness {@link Strictness#STRICT}, the JSON will be written in {@link Strictness#LENIENT}\r\n * mode.\u003cbr\u003e\r\n * Note that in all cases the old strictness setting of the reader will be restored when this method returns.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param reader the reader whose next JSON value should be deserialized\r\n * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\r\n * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\r\n * {@code Collection\u003cFoo\u003e}, you should use:\r\n * \u003cpre\u003e\r\n * new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}\r\n * \u003c/pre\u003e\r\n * @return an object of type T from the JsonReader. Returns {@code null} if {@code reader} is at EOF.\r\n * @throws JsonIOException if there was a problem reading from the JsonReader\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of the type typeOfT\r\n *\r\n * @see #fromJson(Reader, TypeToken)\r\n * @see #fromJson(JsonReader, Type)\r\n * @since 2.10\r\n */\r\npublic \u003cT\u003e T fromJson(JsonReader reader, TypeToken\u003cT\u003e typeOfT) throws JsonIOException, JsonSyntaxException {\r\n    boolean isEmpty \u003d true;\r\n    Strictness oldStrictness \u003d reader.getStrictness();\r\n    if (this.strictness !\u003d null) {\r\n        reader.setStrictness(this.strictness);\r\n    } else if (reader.getStrictness() !\u003d Strictness.STRICT) {\r\n        reader.setStrictness(Strictness.LENIENT);\r\n    }\r\n    try {\r\n        JsonToken unused \u003d reader.peek();\r\n        isEmpty \u003d false;\r\n        TypeAdapter\u003cT\u003e typeAdapter \u003d getAdapter(typeOfT);\r\n        return typeAdapter.read(reader);\r\n    } catch (EOFException e) {\r\n        /*\r\n       * For compatibility with JSON 1.5 and earlier, we return null for empty\r\n       * documents instead of throwing.\r\n       */\r\n        if (isEmpty) {\r\n            return null;\r\n        }\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IllegalStateException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n        // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\r\n        throw new JsonSyntaxException(e);\r\n    } catch (AssertionError e) {\r\n        throw new AssertionError(\"AssertionError (GSON \" + GsonBuildConfig.VERSION + \"): \" + e.getMessage(), e);\r\n    } finally {\r\n        reader.setStrictness(oldStrictness);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "JsonReader",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * This method deserializes the JSON read from the specified parse tree into an object of the\r\n * specified type. It is not suitable to use if the specified class is a generic type since it\r\n * will not have the generic type information because of the Type Erasure feature of Java.\r\n * Therefore, this method should not be used if the desired type is a generic type. Note that\r\n * this method works fine if any of the fields of the specified object are generics, just the\r\n * object itself should not be a generic type. For the cases when the object is of generic type,\r\n * invoke {@link #fromJson(JsonElement, TypeToken)}.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\r\n * be deserialized\r\n * @param classOfT The class of T\r\n * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}\r\n * or if {@code json} is empty.\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of type classOfT\r\n * @since 1.3\r\n *\r\n * @see #fromJson(Reader, Class)\r\n * @see #fromJson(JsonElement, TypeToken)\r\n */\r\npublic \u003cT\u003e T fromJson(JsonElement json, Class\u003cT\u003e classOfT) throws JsonSyntaxException {\r\n    T object \u003d fromJson(json, TypeToken.get(classOfT));\r\n    return Primitives.wrap(classOfT).cast(object);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "JsonElement",
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * This method deserializes the JSON read from the specified parse tree into an object of the\r\n * specified type. This method is useful if the specified object is a generic type. For\r\n * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.\r\n *\r\n * \u003cp\u003eSince {@code Type} is not parameterized by T, this method is not type-safe and\r\n * should be used carefully. If you are creating the {@code Type} from a {@link TypeToken},\r\n * prefer using {@link #fromJson(JsonElement, TypeToken)} instead since its return type is based\r\n * on the {@code TypeToken} and is therefore more type-safe.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\r\n * be deserialized\r\n * @param typeOfT The specific genericized type of src\r\n * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}\r\n * or if {@code json} is empty.\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\r\n * @since 1.3\r\n *\r\n * @see #fromJson(Reader, Type)\r\n * @see #fromJson(JsonElement, Class)\r\n * @see #fromJson(JsonElement, TypeToken)\r\n */\r\n@SuppressWarnings({ \"unchecked\", \"TypeParameterUnusedInFormals\" })\r\npublic \u003cT\u003e T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {\r\n    return (T) fromJson(json, TypeToken.get(typeOfT));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "JsonElement",
        "Type"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * This method deserializes the JSON read from the specified parse tree into an object of the\r\n * specified type. This method is useful if the specified object is a generic type. For\r\n * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.\r\n *\r\n * @param \u003cT\u003e the type of the desired object\r\n * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\r\n * be deserialized\r\n * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\r\n * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\r\n * {@code Collection\u003cFoo\u003e}, you should use:\r\n * \u003cpre\u003e\r\n * new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}\r\n * \u003c/pre\u003e\r\n * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}\r\n * or if {@code json} is empty.\r\n * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\r\n *\r\n * @see #fromJson(Reader, TypeToken)\r\n * @see #fromJson(JsonElement, Class)\r\n * @since 2.10\r\n */\r\npublic \u003cT\u003e T fromJson(JsonElement json, TypeToken\u003cT\u003e typeOfT) throws JsonSyntaxException {\r\n    if (json \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    return fromJson(new JsonTreeReader(json), typeOfT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "fromJson",
      "parameterTypes": [
        "JsonElement",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "public void setDelegate(TypeAdapter\u003cT\u003e typeAdapter) {\r\n    if (delegate !\u003d null) {\r\n        throw new AssertionError(\"Delegate is already set\");\r\n    }\r\n    delegate \u003d typeAdapter;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson.FutureTypeAdapter",
      "methodName": "setDelegate",
      "parameterTypes": [
        "TypeAdapter\u003cT\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private TypeAdapter\u003cT\u003e delegate() {\r\n    TypeAdapter\u003cT\u003e delegate \u003d this.delegate;\r\n    if (delegate \u003d\u003d null) {\r\n        // Can occur when adapter is leaked to other thread or when adapter is used for (de-)serialization\r\n        // directly within the TypeAdapterFactory which requested it\r\n        throw new IllegalStateException(\"Adapter for type with cyclic dependency has been used\" + \" before dependency has been resolved\");\r\n    }\r\n    return delegate;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson.FutureTypeAdapter",
      "methodName": "delegate",
      "parameterTypes": [],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic TypeAdapter\u003cT\u003e getSerializationDelegate() {\r\n    return delegate();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson.FutureTypeAdapter",
      "methodName": "getSerializationDelegate",
      "parameterTypes": [],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    return delegate().read(in);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson.FutureTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    delegate().write(out, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson.FutureTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"{serializeNulls:\" + serializeNulls + \",factories:\" + factories + \",instanceCreators:\" + constructorConstructor + \"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.Gson",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to enable versioning support. Versioning support works based on the\r\n * annotation types {@link Since} and {@link Until}. It allows including or excluding fields\r\n * and classes based on the specified version. See the documentation of these annotation\r\n * types for more information.\r\n *\r\n * \u003cp\u003eBy default versioning support is disabled and usage of {@code @Since} and {@code @Until}\r\n * has no effect.\r\n *\r\n * @param version the version number to use.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @throws IllegalArgumentException if the version number is NaN or negative\r\n * @see Since\r\n * @see Until\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setVersion(double version) {\r\n    if (Double.isNaN(version) || version \u003c 0.0) {\r\n        throw new IllegalArgumentException(\"Invalid version: \" + version);\r\n    }\r\n    excluder \u003d excluder.withVersion(version);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setVersion",
      "parameterTypes": [
        "double"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to excludes all class fields that have the specified modifiers. By default,\r\n * Gson will exclude all fields marked {@code transient} or {@code static}. This method will\r\n * override that behavior.\r\n *\r\n * \u003cp\u003eThis is a convenience method which behaves as if an {@link ExclusionStrategy} which\r\n * excludes these fields was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this builder}.\r\n *\r\n * @param modifiers the field modifiers. You must use the modifiers specified in the\r\n * {@link java.lang.reflect.Modifier} class. For example,\r\n * {@link java.lang.reflect.Modifier#TRANSIENT},\r\n * {@link java.lang.reflect.Modifier#STATIC}.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder excludeFieldsWithModifiers(int... modifiers) {\r\n    Objects.requireNonNull(modifiers);\r\n    excluder \u003d excluder.withModifiers(modifiers);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "excludeFieldsWithModifiers",
      "parameterTypes": [
        "int"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some\r\n * special text. This prevents attacks from third-party sites through script sourcing. See\r\n * \u003ca href\u003d\"http://code.google.com/p/google-gson/issues/detail?id\u003d42\"\u003eGson Issue 42\u003c/a\u003e\r\n * for details.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder generateNonExecutableJson() {\r\n    this.generateNonExecutableJson \u003d true;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "generateNonExecutableJson",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to exclude all fields from consideration for serialization and deserialization\r\n * that do not have the {@link com.google.gson.annotations.Expose} annotation.\r\n *\r\n * \u003cp\u003eThis is a convenience method which behaves as if an {@link ExclusionStrategy} which excludes\r\n * these fields was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this builder}.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder excludeFieldsWithoutExposeAnnotation() {\r\n    excluder \u003d excluder.excludeFieldsWithoutExposeAnnotation();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "excludeFieldsWithoutExposeAnnotation",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configure Gson to serialize null fields. By default, Gson omits all fields that are null\r\n * during serialization.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.2\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder serializeNulls() {\r\n    this.serializeNulls \u003d true;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "serializeNulls",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Enabling this feature will only change the serialized form if the map key is\r\n * a complex type (i.e. non-primitive) in its \u003cstrong\u003eserialized\u003c/strong\u003e JSON\r\n * form. The default implementation of map serialization uses {@code toString()}\r\n * on the key; however, when this is called then one of the following cases\r\n * apply:\r\n *\r\n * \u003cp\u003e\u003cb\u003eMaps as JSON objects\u003c/b\u003e\r\n *\r\n * \u003cp\u003eFor this case, assume that a type adapter is registered to serialize and\r\n * deserialize some {@code Point} class, which contains an x and y coordinate,\r\n * to/from the JSON Primitive string value {@code \"(x,y)\"}. The Java map would\r\n * then be serialized as a {@link JsonObject}.\r\n *\r\n * \u003cp\u003eBelow is an example:\r\n * \u003cpre\u003e  {@code\r\n *   Gson gson \u003d new GsonBuilder()\r\n *       .register(Point.class, new MyPointTypeAdapter())\r\n *       .enableComplexMapKeySerialization()\r\n *       .create();\r\n *\r\n *   Map\u003cPoint, String\u003e original \u003d new LinkedHashMap\u003c\u003e();\r\n *   original.put(new Point(5, 6), \"a\");\r\n *   original.put(new Point(8, 8), \"b\");\r\n *   System.out.println(gson.toJson(original, type));\r\n * }\u003c/pre\u003e\r\n * The above code prints this JSON object:\u003cpre\u003e  {@code\r\n *   {\r\n *     \"(5,6)\": \"a\",\r\n *     \"(8,8)\": \"b\"\r\n *   }\r\n * }\u003c/pre\u003e\r\n *\r\n * \u003cp\u003e\u003cb\u003eMaps as JSON arrays\u003c/b\u003e\r\n *\r\n * \u003cp\u003eFor this case, assume that a type adapter was NOT registered for some\r\n * {@code Point} class, but rather the default Gson serialization is applied.\r\n * In this case, some {@code new Point(2,3)} would serialize as {@code\r\n * {\"x\":2,\"y\":3}}.\r\n *\r\n * \u003cp\u003eGiven the assumption above, a {@code Map\u003cPoint, String\u003e} will be\r\n * serialized as an array of arrays (can be viewed as an entry set of pairs).\r\n *\r\n * \u003cp\u003eBelow is an example of serializing complex types as JSON arrays:\r\n * \u003cpre\u003e {@code\r\n *   Gson gson \u003d new GsonBuilder()\r\n *       .enableComplexMapKeySerialization()\r\n *       .create();\r\n *\r\n *   Map\u003cPoint, String\u003e original \u003d new LinkedHashMap\u003c\u003e();\r\n *   original.put(new Point(5, 6), \"a\");\r\n *   original.put(new Point(8, 8), \"b\");\r\n *   System.out.println(gson.toJson(original, type));\r\n * }\r\n * \u003c/pre\u003e\r\n *\r\n * The JSON output would look as follows:\r\n * \u003cpre\u003e   {@code\r\n *   [\r\n *     [\r\n *       {\r\n *         \"x\": 5,\r\n *         \"y\": 6\r\n *       },\r\n *       \"a\"\r\n *     ],\r\n *     [\r\n *       {\r\n *         \"x\": 8,\r\n *         \"y\": 8\r\n *       },\r\n *       \"b\"\r\n *     ]\r\n *   ]\r\n * }\u003c/pre\u003e\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.7\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder enableComplexMapKeySerialization() {\r\n    complexMapKeySerialization \u003d true;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "enableComplexMapKeySerialization",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to exclude inner classes (\u003d non-{@code static} nested classes) during serialization\r\n * and deserialization. This is a convenience method which behaves as if an {@link ExclusionStrategy}\r\n * which excludes inner classes was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this builder}.\r\n * This means inner classes will be serialized as JSON {@code null}, and will be deserialized as\r\n * Java {@code null} with their JSON data being ignored. And fields with an inner class as type will\r\n * be ignored during serialization and deserialization.\r\n *\r\n * \u003cp\u003eBy default Gson serializes and deserializes inner classes, but ignores references to the\r\n * enclosing instance. Deserialization might not be possible at all when {@link #disableJdkUnsafe()}\r\n * is used (and no custom {@link InstanceCreator} is registered), or it can lead to unexpected\r\n * {@code NullPointerException}s when the deserialized instance is used afterwards.\r\n *\r\n * \u003cp\u003eIn general using inner classes with Gson should be avoided; they should be converted to {@code static}\r\n * nested classes if possible.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder disableInnerClassSerialization() {\r\n    excluder \u003d excluder.disableInnerClassSerialization();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "disableInnerClassSerialization",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to apply a specific serialization policy for {@code Long} and {@code long}\r\n * objects.\r\n *\r\n * @param serializationPolicy the particular policy to use for serializing longs.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) {\r\n    this.longSerializationPolicy \u003d Objects.requireNonNull(serializationPolicy);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setLongSerializationPolicy",
      "parameterTypes": [
        "LongSerializationPolicy"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to apply a specific naming policy to an object\u0027s fields during serialization\r\n * and deserialization.\r\n *\r\n * \u003cp\u003eThis method just delegates to {@link #setFieldNamingStrategy(FieldNamingStrategy)}.\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) {\r\n    return setFieldNamingStrategy(namingConvention);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setFieldNamingPolicy",
      "parameterTypes": [
        "FieldNamingPolicy"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to apply a specific naming strategy to an object\u0027s fields during\r\n * serialization and deserialization.\r\n *\r\n * \u003cp\u003eThe created Gson instance might only use the field naming strategy once for a\r\n * field and cache the result. It is not guaranteed that the strategy will be used\r\n * again every time the value of a field is serialized or deserialized.\r\n *\r\n * @param fieldNamingStrategy the naming strategy to apply to the fields\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {\r\n    this.fieldNamingPolicy \u003d Objects.requireNonNull(fieldNamingStrategy);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setFieldNamingStrategy",
      "parameterTypes": [
        "FieldNamingStrategy"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to apply a specific number strategy during deserialization of {@link Object}.\r\n *\r\n * @param objectToNumberStrategy the actual object-to-number strategy\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @see ToNumberPolicy#DOUBLE The default object-to-number strategy\r\n * @since 2.8.9\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setObjectToNumberStrategy(ToNumberStrategy objectToNumberStrategy) {\r\n    this.objectToNumberStrategy \u003d Objects.requireNonNull(objectToNumberStrategy);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setObjectToNumberStrategy",
      "parameterTypes": [
        "ToNumberStrategy"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to apply a specific number strategy during deserialization of {@link Number}.\r\n *\r\n * @param numberToNumberStrategy the actual number-to-number strategy\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @see ToNumberPolicy#LAZILY_PARSED_NUMBER The default number-to-number strategy\r\n * @since 2.8.9\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setNumberToNumberStrategy(ToNumberStrategy numberToNumberStrategy) {\r\n    this.numberToNumberStrategy \u003d Objects.requireNonNull(numberToNumberStrategy);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setNumberToNumberStrategy",
      "parameterTypes": [
        "ToNumberStrategy"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to apply a set of exclusion strategies during both serialization and\r\n * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.\r\n * This means that if one of the {@code strategies} suggests that a field (or class) should be\r\n * skipped then that field (or object) is skipped during serialization/deserialization.\r\n * The strategies are added to the existing strategies (if any); the existing strategies\r\n * are not replaced.\r\n *\r\n * \u003cp\u003eFields are excluded for serialization and deserialization when\r\n * {@link ExclusionStrategy#shouldSkipField(FieldAttributes) shouldSkipField} returns {@code true},\r\n * or when {@link ExclusionStrategy#shouldSkipClass(Class) shouldSkipClass} returns {@code true}\r\n * for the field type. Gson behaves as if the field did not exist; its value is not serialized\r\n * and on deserialization if a JSON member with this name exists it is skipped by default.\u003cbr\u003e\r\n * When objects of an excluded type (as determined by\r\n * {@link ExclusionStrategy#shouldSkipClass(Class) shouldSkipClass}) are serialized a\r\n * JSON null is written to output, and when deserialized the JSON value is skipped and\r\n * {@code null} is returned.\r\n *\r\n * \u003cp\u003eThe created Gson instance might only use an exclusion strategy once for a field or\r\n * class and cache the result. It is not guaranteed that the strategy will be used again\r\n * every time the value of a field or a class is serialized or deserialized.\r\n *\r\n * @param strategies the set of strategy object to apply during object (de)serialization.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.4\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {\r\n    Objects.requireNonNull(strategies);\r\n    for (ExclusionStrategy strategy : strategies) {\r\n        excluder \u003d excluder.withExclusionStrategy(strategy, true, true);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setExclusionStrategies",
      "parameterTypes": [
        "ExclusionStrategy"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to apply the passed in exclusion strategy during serialization.\r\n * If this method is invoked numerous times with different exclusion strategy objects\r\n * then the exclusion strategies that were added will be applied as a disjunction rule.\r\n * This means that if one of the added exclusion strategies suggests that a field (or\r\n * class) should be skipped then that field (or object) is skipped during its\r\n * serialization.\r\n *\r\n * \u003cp\u003eSee the documentation of {@link #setExclusionStrategies(ExclusionStrategy...)}\r\n * for a detailed description of the effect of exclusion strategies.\r\n *\r\n * @param strategy an exclusion strategy to apply during serialization.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.7\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy) {\r\n    Objects.requireNonNull(strategy);\r\n    excluder \u003d excluder.withExclusionStrategy(strategy, true, false);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "addSerializationExclusionStrategy",
      "parameterTypes": [
        "ExclusionStrategy"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to apply the passed in exclusion strategy during deserialization.\r\n * If this method is invoked numerous times with different exclusion strategy objects\r\n * then the exclusion strategies that were added will be applied as a disjunction rule.\r\n * This means that if one of the added exclusion strategies suggests that a field (or\r\n * class) should be skipped then that field (or object) is skipped during its\r\n * deserialization.\r\n *\r\n * \u003cp\u003eSee the documentation of {@link #setExclusionStrategies(ExclusionStrategy...)}\r\n * for a detailed description of the effect of exclusion strategies.\r\n *\r\n * @param strategy an exclusion strategy to apply during deserialization.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.7\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy) {\r\n    Objects.requireNonNull(strategy);\r\n    excluder \u003d excluder.withExclusionStrategy(strategy, false, true);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "addDeserializationExclusionStrategy",
      "parameterTypes": [
        "ExclusionStrategy"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to output JSON that fits in a page for pretty printing. This option only\r\n * affects JSON serialization.\r\n *\r\n * \u003cp\u003eThis is a convenience method which simply calls {@link #setFormattingStyle(FormattingStyle)}\r\n * with {@link FormattingStyle#PRETTY}.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setPrettyPrinting() {\r\n    return setFormattingStyle(FormattingStyle.PRETTY);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setPrettyPrinting",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to output JSON that uses a certain kind of formatting style (for example newline and indent).\r\n * This option only affects JSON serialization. By default Gson produces compact JSON output without any formatting.\r\n *\r\n * @param formattingStyle the formatting style to use.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since $next-version$\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setFormattingStyle(FormattingStyle formattingStyle) {\r\n    this.formattingStyle \u003d Objects.requireNonNull(formattingStyle);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setFormattingStyle",
      "parameterTypes": [
        "FormattingStyle"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Sets the strictness of this builder to {@link Strictness#LENIENT}.\r\n *\r\n * @deprecated This method is equivalent to calling {@link #setStrictness(Strictness)} with\r\n * {@link Strictness#LENIENT}: {@code setStrictness(Strictness.LENIENT)}\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern.\r\n * @see JsonReader#setStrictness(Strictness)\r\n * @see JsonWriter#setStrictness(Strictness)\r\n * @see #setStrictness(Strictness)\r\n */\r\n@Deprecated\r\n@InlineMe(replacement \u003d \"this.setStrictness(Strictness.LENIENT)\", imports \u003d \"com.google.gson.Strictness\")\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setLenient() {\r\n    return setStrictness(Strictness.LENIENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setLenient",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Sets the strictness of this builder to the provided parameter.\r\n *\r\n * \u003cp\u003eThis changes how strict the\r\n * \u003ca href\u003d\"https://www.ietf.org/rfc/rfc8259.txt\"\u003eRFC 8259 JSON specification\u003c/a\u003e is enforced when parsing or\r\n * writing JSON. For details on this, refer to {@link JsonReader#setStrictness(Strictness)} and\r\n * {@link JsonWriter#setStrictness(Strictness)}.\u003c/p\u003e\r\n *\r\n * @param strictness the new strictness mode. May not be {@code null}.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern.\r\n * @see JsonReader#setStrictness(Strictness)\r\n * @see JsonWriter#setStrictness(Strictness)\r\n * @since $next-version$\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setStrictness(Strictness strictness) {\r\n    this.strictness \u003d Objects.requireNonNull(strictness);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setStrictness",
      "parameterTypes": [
        "Strictness"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * By default, Gson escapes HTML characters such as \u0026lt; \u0026gt; etc. Use this option to configure\r\n * Gson to pass-through HTML characters as is.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder disableHtmlEscaping() {\r\n    this.escapeHtmlChars \u003d false;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "disableHtmlEscaping",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to serialize {@code Date} objects according to the pattern provided. You can\r\n * call this method or {@link #setDateFormat(int)} multiple times, but only the last invocation\r\n * will be used to decide the serialization format.\r\n *\r\n * \u003cp\u003eThe date format will be used to serialize and deserialize {@link java.util.Date} and in case\r\n * the {@code java.sql} module is present, also {@link java.sql.Timestamp} and {@link java.sql.Date}.\r\n *\r\n * \u003cp\u003eNote that this pattern must abide by the convention provided by {@code SimpleDateFormat}\r\n * class. See the documentation in {@link java.text.SimpleDateFormat} for more information on\r\n * valid date and time patterns.\u003c/p\u003e\r\n *\r\n * @param pattern the pattern that dates will be serialized/deserialized to/from\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.2\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setDateFormat(String pattern) {\r\n    // TODO(Joel): Make this fail fast if it is an invalid date format\r\n    this.datePattern \u003d pattern;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setDateFormat",
      "parameterTypes": [
        "String"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to serialize {@code Date} objects according to the style value provided.\r\n * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last\r\n * invocation will be used to decide the serialization format.\r\n *\r\n * \u003cp\u003eNote that this style value should be one of the predefined constants in the\r\n * {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more\r\n * information on the valid style constants.\u003c/p\u003e\r\n *\r\n * @param style the predefined date style that date objects will be serialized/deserialized\r\n * to/from\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.2\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setDateFormat(int style) {\r\n    this.dateStyle \u003d style;\r\n    this.datePattern \u003d null;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setDateFormat",
      "parameterTypes": [
        "int"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson to serialize {@code Date} objects according to the style value provided.\r\n * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last\r\n * invocation will be used to decide the serialization format.\r\n *\r\n * \u003cp\u003eNote that this style value should be one of the predefined constants in the\r\n * {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more\r\n * information on the valid style constants.\u003c/p\u003e\r\n *\r\n * @param dateStyle the predefined date style that date objects will be serialized/deserialized\r\n * to/from\r\n * @param timeStyle the predefined style for the time portion of the date objects\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.2\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setDateFormat(int dateStyle, int timeStyle) {\r\n    this.dateStyle \u003d dateStyle;\r\n    this.timeStyle \u003d timeStyle;\r\n    this.datePattern \u003d null;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "setDateFormat",
      "parameterTypes": [
        "int",
        "int"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson for custom serialization or deserialization. This method combines the\r\n * registration of an {@link TypeAdapter}, {@link InstanceCreator}, {@link JsonSerializer}, and a\r\n * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements\r\n * all the required interfaces for custom serialization with Gson. If a type adapter was\r\n * previously registered for the specified {@code type}, it is overwritten.\r\n *\r\n * \u003cp\u003eThis registers the type specified and no other types: you must manually register related\r\n * types! For example, applications registering {@code boolean.class} should also register {@code\r\n * Boolean.class}.\r\n *\r\n * \u003cp\u003e{@link JsonSerializer} and {@link JsonDeserializer} are made \"{@code null}-safe\". This\r\n * means when trying to serialize {@code null}, Gson will write a JSON {@code null} and the\r\n * serializer is not called. Similarly when deserializing a JSON {@code null}, Gson will emit\r\n * {@code null} without calling the deserializer. If it is desired to handle {@code null} values,\r\n * a {@link TypeAdapter} should be used instead.\r\n *\r\n * @param type the type definition for the type adapter being registered\r\n * @param typeAdapter This object must implement at least one of the {@link TypeAdapter},\r\n * {@link InstanceCreator}, {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @throws IllegalArgumentException if the type adapter being registered is for {@code Object} class or {@link JsonElement} or any of its subclasses\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\r\n    Objects.requireNonNull(type);\r\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e || typeAdapter instanceof InstanceCreator\u003c?\u003e || typeAdapter instanceof TypeAdapter\u003c?\u003e);\r\n    if (isTypeObjectOrJsonElement(type)) {\r\n        throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + type);\r\n    }\r\n    if (typeAdapter instanceof InstanceCreator\u003c?\u003e) {\r\n        instanceCreators.put(type, (InstanceCreator\u003c?\u003e) typeAdapter);\r\n    }\r\n    if (typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e) {\r\n        TypeToken\u003c?\u003e typeToken \u003d TypeToken.get(type);\r\n        factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));\r\n    }\r\n    if (typeAdapter instanceof TypeAdapter\u003c?\u003e) {\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapterFactory factory \u003d TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter) typeAdapter);\r\n        factories.add(factory);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "registerTypeAdapter",
      "parameterTypes": [
        "Type",
        "Object"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "private boolean isTypeObjectOrJsonElement(Type type) {\r\n    return type instanceof Class \u0026\u0026 (type \u003d\u003d Object.class || JsonElement.class.isAssignableFrom((Class\u003c?\u003e) type));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "isTypeObjectOrJsonElement",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Register a factory for type adapters. Registering a factory is useful when the type\r\n * adapter needs to be configured based on the type of the field being processed. Gson\r\n * is designed to handle a large number of factories, so you should consider registering\r\n * them to be at par with registering an individual type adapter.\r\n *\r\n * \u003cp\u003eThe created Gson instance might only use the factory once to create an adapter for\r\n * a specific type and cache the result. It is not guaranteed that the factory will be used\r\n * again every time the type is serialized or deserialized.\r\n *\r\n * @since 2.1\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {\r\n    Objects.requireNonNull(factory);\r\n    factories.add(factory);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "registerTypeAdapterFactory",
      "parameterTypes": [
        "TypeAdapterFactory"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.\r\n * This method combines the registration of a {@link TypeAdapter}, {@link JsonSerializer} and\r\n * a {@link JsonDeserializer}. If a type adapter was previously registered for the specified\r\n * type hierarchy, it is overridden. If a type adapter is registered for a specific type in\r\n * the type hierarchy, it will be invoked instead of the one registered for the type hierarchy.\r\n *\r\n * @param baseType the class definition for the type adapter being registered for the base class\r\n *        or interface\r\n * @param typeAdapter This object must implement at least one of {@link TypeAdapter},\r\n *        {@link JsonSerializer} or {@link JsonDeserializer} interfaces.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @throws IllegalArgumentException if the type adapter being registered is for {@link JsonElement} or any of its subclasses\r\n * @since 1.7\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder registerTypeHierarchyAdapter(Class\u003c?\u003e baseType, Object typeAdapter) {\r\n    Objects.requireNonNull(baseType);\r\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e || typeAdapter instanceof TypeAdapter\u003c?\u003e);\r\n    if (JsonElement.class.isAssignableFrom(baseType)) {\r\n        throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + baseType);\r\n    }\r\n    if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\r\n        hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\r\n    }\r\n    if (typeAdapter instanceof TypeAdapter\u003c?\u003e) {\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapterFactory factory \u003d TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter) typeAdapter);\r\n        factories.add(factory);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "registerTypeHierarchyAdapter",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "Object"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Section 6 of \u003ca href\u003d\"https://www.ietf.org/rfc/rfc8259.txt\"\u003eJSON specification\u003c/a\u003e disallows\r\n * special double values (NaN, Infinity, -Infinity). However,\r\n * \u003ca href\u003d\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\"\u003eJavascript\r\n * specification\u003c/a\u003e (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\r\n * values. Moreover, most JavaScript engines will accept these special values in JSON without\r\n * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\r\n * though JSON specification disallows them.\r\n *\r\n * \u003cp\u003eGson always accepts these special values during deserialization. However, it outputs\r\n * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\r\n * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\r\n * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\r\n * will throw an {@link IllegalArgumentException}. This method provides a way to override the\r\n * default behavior when you know that the JSON receiver will be able to handle these special\r\n * values.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder serializeSpecialFloatingPointValues() {\r\n    this.serializeSpecialFloatingPointValues \u003d true;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "serializeSpecialFloatingPointValues",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Disables usage of JDK\u0027s {@code sun.misc.Unsafe}.\r\n *\r\n * \u003cp\u003eBy default Gson uses {@code Unsafe} to create instances of classes which don\u0027t have\r\n * a no-args constructor. However, {@code Unsafe} might not be available for all Java\r\n * runtimes. For example Android does not provide {@code Unsafe}, or only with limited\r\n * functionality. Additionally {@code Unsafe} creates instances without executing any\r\n * constructor or initializer block, or performing initialization of field values. This can\r\n * lead to surprising and difficult to debug errors.\r\n * Therefore, to get reliable behavior regardless of which runtime is used, and to detect\r\n * classes which cannot be deserialized in an early stage of development, this method allows\r\n * disabling usage of {@code Unsafe}.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 2.9.0\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder disableJdkUnsafe() {\r\n    this.useJdkUnsafe \u003d false;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "disableJdkUnsafe",
      "parameterTypes": [],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Adds a reflection access filter. A reflection access filter prevents Gson from using\r\n * reflection for the serialization and deserialization of certain classes. The logic in\r\n * the filter specifies which classes those are.\r\n *\r\n * \u003cp\u003eFilters will be invoked in reverse registration order, that is, the most recently\r\n * added filter will be invoked first.\r\n *\r\n * \u003cp\u003eBy default Gson has no filters configured and will try to use reflection for\r\n * all classes for which no {@link TypeAdapter} has been registered, and for which no\r\n * built-in Gson {@code TypeAdapter} exists.\r\n *\r\n * \u003cp\u003eThe created Gson instance might only use an access filter once for a class or its\r\n * members and cache the result. It is not guaranteed that the filter will be used again\r\n * every time a class or its members are accessed during serialization or deserialization.\r\n *\r\n * @param filter filter to add\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 2.9.1\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder addReflectionAccessFilter(ReflectionAccessFilter filter) {\r\n    Objects.requireNonNull(filter);\r\n    reflectionFilters.addFirst(filter);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "addReflectionAccessFilter",
      "parameterTypes": [
        "ReflectionAccessFilter"
      ],
      "returnType": "GsonBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a {@link Gson} instance based on the current configuration. This method is free of\r\n * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.\r\n *\r\n * @return an instance of Gson configured with the options currently set in this builder\r\n */\r\npublic Gson create() {\r\n    List\u003cTypeAdapterFactory\u003e factories \u003d new ArrayList\u003c\u003e(this.factories.size() + this.hierarchyFactories.size() + 3);\r\n    factories.addAll(this.factories);\r\n    Collections.reverse(factories);\r\n    List\u003cTypeAdapterFactory\u003e hierarchyFactories \u003d new ArrayList\u003c\u003e(this.hierarchyFactories);\r\n    Collections.reverse(hierarchyFactories);\r\n    factories.addAll(hierarchyFactories);\r\n    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);\r\n    return new Gson(excluder, fieldNamingPolicy, new HashMap\u003c\u003e(instanceCreators), serializeNulls, complexMapKeySerialization, generateNonExecutableJson, escapeHtmlChars, formattingStyle, strictness, serializeSpecialFloatingPointValues, useJdkUnsafe, longSerializationPolicy, datePattern, dateStyle, timeStyle, new ArrayList\u003c\u003e(this.factories), new ArrayList\u003c\u003e(this.hierarchyFactories), factories, objectToNumberStrategy, numberToNumberStrategy, new ArrayList\u003c\u003e(reflectionFilters));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "create",
      "parameterTypes": [],
      "returnType": "Gson"
    }
  },
  {
    "sourceCode": "private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, List\u003cTypeAdapterFactory\u003e factories) {\r\n    TypeAdapterFactory dateAdapterFactory;\r\n    boolean sqlTypesSupported \u003d SqlTypesSupport.SUPPORTS_SQL_TYPES;\r\n    TypeAdapterFactory sqlTimestampAdapterFactory \u003d null;\r\n    TypeAdapterFactory sqlDateAdapterFactory \u003d null;\r\n    if (datePattern !\u003d null \u0026\u0026 !datePattern.trim().isEmpty()) {\r\n        dateAdapterFactory \u003d DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(datePattern);\r\n        if (sqlTypesSupported) {\r\n            sqlTimestampAdapterFactory \u003d SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(datePattern);\r\n            sqlDateAdapterFactory \u003d SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(datePattern);\r\n        }\r\n    } else if (dateStyle !\u003d DateFormat.DEFAULT \u0026\u0026 timeStyle !\u003d DateFormat.DEFAULT) {\r\n        dateAdapterFactory \u003d DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(dateStyle, timeStyle);\r\n        if (sqlTypesSupported) {\r\n            sqlTimestampAdapterFactory \u003d SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);\r\n            sqlDateAdapterFactory \u003d SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);\r\n        }\r\n    } else {\r\n        return;\r\n    }\r\n    factories.add(dateAdapterFactory);\r\n    if (sqlTypesSupported) {\r\n        factories.add(sqlTimestampAdapterFactory);\r\n        factories.add(sqlDateAdapterFactory);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilder",
      "methodName": "addTypeAdaptersForDate",
      "parameterTypes": [
        "String",
        "int",
        "int",
        "List\u003cTypeAdapterFactory\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Gson invokes this call-back method during deserialization to create an instance of the\r\n * specified type. The fields of the returned instance are overwritten with the data present\r\n * in the JSON. Since the prior contents of the object are destroyed and overwritten, do not\r\n * return an instance that is useful elsewhere. In particular, do not return a common instance,\r\n * always use {@code new} to create a new instance.\r\n *\r\n * @param type the parameterized T represented as a {@link Type}.\r\n * @return a default object instance of type T.\r\n */\r\npublic T createInstance(Type type);",
    "methodIdentifier": {
      "className": "com.google.gson.InstanceCreator",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * @deprecated\r\n * This is an internal Gson method. Use {@link Objects#requireNonNull(Object)} instead.\r\n */\r\n// Only deprecated for now because external projects might be using this by accident\r\n@Deprecated\r\npublic static \u003cT\u003e T checkNotNull(T obj) {\r\n    if (obj \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return obj;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Preconditions",
      "methodName": "checkNotNull",
      "parameterTypes": [
        "T"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "public static void checkArgument(boolean condition) {\r\n    if (!condition) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Preconditions",
      "methodName": "checkArgument",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a new parameterized type, applying {@code typeArguments} to\r\n * {@code rawType} and enclosed by {@code ownerType}.\r\n *\r\n * @return a {@link java.io.Serializable serializable} parameterized type.\r\n */\r\npublic static ParameterizedType newParameterizedTypeWithOwner(Type ownerType, Type rawType, Type... typeArguments) {\r\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "newParameterizedTypeWithOwner",
      "parameterTypes": [
        "Type",
        "Type",
        "Type"
      ],
      "returnType": "ParameterizedType"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns an array type whose elements are all instances of\r\n * {@code componentType}.\r\n *\r\n * @return a {@link java.io.Serializable serializable} generic array type.\r\n */\r\npublic static GenericArrayType arrayOf(Type componentType) {\r\n    return new GenericArrayTypeImpl(componentType);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "arrayOf",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "GenericArrayType"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a type that represents an unknown type that extends {@code bound}.\r\n * For example, if {@code bound} is {@code CharSequence.class}, this returns\r\n * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\r\n * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\r\n */\r\npublic static WildcardType subtypeOf(Type bound) {\r\n    Type[] upperBounds;\r\n    if (bound instanceof WildcardType) {\r\n        upperBounds \u003d ((WildcardType) bound).getUpperBounds();\r\n    } else {\r\n        upperBounds \u003d new Type[] { bound };\r\n    }\r\n    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "subtypeOf",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "WildcardType"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a type that represents an unknown supertype of {@code bound}. For\r\n * example, if {@code bound} is {@code String.class}, this returns {@code ?\r\n * super String}.\r\n */\r\npublic static WildcardType supertypeOf(Type bound) {\r\n    Type[] lowerBounds;\r\n    if (bound instanceof WildcardType) {\r\n        lowerBounds \u003d ((WildcardType) bound).getLowerBounds();\r\n    } else {\r\n        lowerBounds \u003d new Type[] { bound };\r\n    }\r\n    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "supertypeOf",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "WildcardType"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a type that is functionally equal but not necessarily equal\r\n * according to {@link Object#equals(Object) Object.equals()}. The returned\r\n * type is {@link java.io.Serializable}.\r\n */\r\npublic static Type canonicalize(Type type) {\r\n    if (type instanceof Class) {\r\n        Class\u003c?\u003e c \u003d (Class\u003c?\u003e) type;\r\n        return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType p \u003d (ParameterizedType) type;\r\n        return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments());\r\n    } else if (type instanceof GenericArrayType) {\r\n        GenericArrayType g \u003d (GenericArrayType) type;\r\n        return new GenericArrayTypeImpl(g.getGenericComponentType());\r\n    } else if (type instanceof WildcardType) {\r\n        WildcardType w \u003d (WildcardType) type;\r\n        return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\r\n    } else {\r\n        // type is either serializable as-is or unsupported\r\n        return type;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "canonicalize",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "public static Class\u003c?\u003e getRawType(Type type) {\r\n    if (type instanceof Class\u003c?\u003e) {\r\n        // type is a normal class.\r\n        return (Class\u003c?\u003e) type;\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType parameterizedType \u003d (ParameterizedType) type;\r\n        // getRawType() returns Type instead of Class; that seems to be an API mistake,\r\n        // see https://bugs.openjdk.org/browse/JDK-8250659\r\n        Type rawType \u003d parameterizedType.getRawType();\r\n        checkArgument(rawType instanceof Class);\r\n        return (Class\u003c?\u003e) rawType;\r\n    } else if (type instanceof GenericArrayType) {\r\n        Type componentType \u003d ((GenericArrayType) type).getGenericComponentType();\r\n        return Array.newInstance(getRawType(componentType), 0).getClass();\r\n    } else if (type instanceof TypeVariable) {\r\n        // we could use the variable\u0027s bounds, but that won\u0027t work if there are multiple.\r\n        // having a raw type that\u0027s more general than necessary is okay\r\n        return Object.class;\r\n    } else if (type instanceof WildcardType) {\r\n        Type[] bounds \u003d ((WildcardType) type).getUpperBounds();\r\n        // Currently the JLS only permits one bound for wildcards so using first bound is safe\r\n        assert bounds.length \u003d\u003d 1;\r\n        return getRawType(bounds[0]);\r\n    } else {\r\n        String className \u003d type \u003d\u003d null ? \"null\" : type.getClass().getName();\r\n        throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \" + \"GenericArrayType, but \u003c\" + type + \"\u003e is of type \" + className);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "getRawType",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "Class\u003c?\u003e"
    }
  },
  {
    "sourceCode": "private static boolean equal(Object a, Object b) {\r\n    return Objects.equals(a, b);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "equal",
      "parameterTypes": [
        "Object",
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if {@code a} and {@code b} are equal.\r\n */\r\npublic static boolean equals(Type a, Type b) {\r\n    if (a \u003d\u003d b) {\r\n        // also handles (a \u003d\u003d null \u0026\u0026 b \u003d\u003d null)\r\n        return true;\r\n    } else if (a instanceof Class) {\r\n        // Class already specifies equals().\r\n        return a.equals(b);\r\n    } else if (a instanceof ParameterizedType) {\r\n        if (!(b instanceof ParameterizedType)) {\r\n            return false;\r\n        }\r\n        // TODO: save a .clone() call\r\n        ParameterizedType pa \u003d (ParameterizedType) a;\r\n        ParameterizedType pb \u003d (ParameterizedType) b;\r\n        return equal(pa.getOwnerType(), pb.getOwnerType()) \u0026\u0026 pa.getRawType().equals(pb.getRawType()) \u0026\u0026 Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\r\n    } else if (a instanceof GenericArrayType) {\r\n        if (!(b instanceof GenericArrayType)) {\r\n            return false;\r\n        }\r\n        GenericArrayType ga \u003d (GenericArrayType) a;\r\n        GenericArrayType gb \u003d (GenericArrayType) b;\r\n        return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\r\n    } else if (a instanceof WildcardType) {\r\n        if (!(b instanceof WildcardType)) {\r\n            return false;\r\n        }\r\n        WildcardType wa \u003d (WildcardType) a;\r\n        WildcardType wb \u003d (WildcardType) b;\r\n        return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) \u0026\u0026 Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\r\n    } else if (a instanceof TypeVariable) {\r\n        if (!(b instanceof TypeVariable)) {\r\n            return false;\r\n        }\r\n        TypeVariable\u003c?\u003e va \u003d (TypeVariable\u003c?\u003e) a;\r\n        TypeVariable\u003c?\u003e vb \u003d (TypeVariable\u003c?\u003e) b;\r\n        return va.getGenericDeclaration() \u003d\u003d vb.getGenericDeclaration() \u0026\u0026 va.getName().equals(vb.getName());\r\n    } else {\r\n        // This isn\u0027t a type we support. Could be a generic array type, wildcard type, etc.\r\n        return false;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "equals",
      "parameterTypes": [
        "Type",
        "Type"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "public static String typeToString(Type type) {\r\n    return type instanceof Class ? ((Class\u003c?\u003e) type).getName() : type.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "typeToString",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the generic supertype for {@code supertype}. For example, given a class {@code\r\n * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set\u003cInteger\u003e} and the\r\n * result when the supertype is {@code Collection.class} is {@code Collection\u003cInteger\u003e}.\r\n */\r\nprivate static Type getGenericSupertype(Type context, Class\u003c?\u003e rawType, Class\u003c?\u003e supertype) {\r\n    if (supertype \u003d\u003d rawType) {\r\n        return context;\r\n    }\r\n    // we skip searching through interfaces if unknown is an interface\r\n    if (supertype.isInterface()) {\r\n        Class\u003c?\u003e[] interfaces \u003d rawType.getInterfaces();\r\n        for (int i \u003d 0, length \u003d interfaces.length; i \u003c length; i++) {\r\n            if (interfaces[i] \u003d\u003d supertype) {\r\n                return rawType.getGenericInterfaces()[i];\r\n            } else if (supertype.isAssignableFrom(interfaces[i])) {\r\n                return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], supertype);\r\n            }\r\n        }\r\n    }\r\n    // check our supertypes\r\n    if (!rawType.isInterface()) {\r\n        while (rawType !\u003d Object.class) {\r\n            Class\u003c?\u003e rawSupertype \u003d rawType.getSuperclass();\r\n            if (rawSupertype \u003d\u003d supertype) {\r\n                return rawType.getGenericSuperclass();\r\n            } else if (supertype.isAssignableFrom(rawSupertype)) {\r\n                return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, supertype);\r\n            }\r\n            rawType \u003d rawSupertype;\r\n        }\r\n    }\r\n    // we can\u0027t resolve this further\r\n    return supertype;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "getGenericSupertype",
      "parameterTypes": [
        "Type",
        "Class\u003c?\u003e",
        "Class\u003c?\u003e"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the generic form of {@code supertype}. For example, if this is {@code\r\n * ArrayList\u003cString\u003e}, this returns {@code Iterable\u003cString\u003e} given the input {@code\r\n * Iterable.class}.\r\n *\r\n * @param supertype a superclass of, or interface implemented by, this.\r\n */\r\nprivate static Type getSupertype(Type context, Class\u003c?\u003e contextRawType, Class\u003c?\u003e supertype) {\r\n    if (context instanceof WildcardType) {\r\n        // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\r\n        Type[] bounds \u003d ((WildcardType) context).getUpperBounds();\r\n        // Currently the JLS only permits one bound for wildcards so using first bound is safe\r\n        assert bounds.length \u003d\u003d 1;\r\n        context \u003d bounds[0];\r\n    }\r\n    checkArgument(supertype.isAssignableFrom(contextRawType));\r\n    return resolve(context, contextRawType, $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "getSupertype",
      "parameterTypes": [
        "Type",
        "Class\u003c?\u003e",
        "Class\u003c?\u003e"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the component type of this array type.\r\n * @throws ClassCastException if this type is not an array.\r\n */\r\npublic static Type getArrayComponentType(Type array) {\r\n    return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class\u003c?\u003e) array).getComponentType();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "getArrayComponentType",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the element type of this collection type.\r\n * @throws IllegalArgumentException if this type is not a collection.\r\n */\r\npublic static Type getCollectionElementType(Type context, Class\u003c?\u003e contextRawType) {\r\n    Type collectionType \u003d getSupertype(context, contextRawType, Collection.class);\r\n    if (collectionType instanceof ParameterizedType) {\r\n        return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\r\n    }\r\n    return Object.class;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "getCollectionElementType",
      "parameterTypes": [
        "Type",
        "Class\u003c?\u003e"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a two element array containing this map\u0027s key and value types in\r\n * positions 0 and 1 respectively.\r\n */\r\npublic static Type[] getMapKeyAndValueTypes(Type context, Class\u003c?\u003e contextRawType) {\r\n    /*\r\n     * Work around a problem with the declaration of java.util.Properties. That\r\n     * class should extend Hashtable\u003cString, String\u003e, but it\u0027s declared to\r\n     * extend Hashtable\u003cObject, Object\u003e.\r\n     */\r\n    if (context \u003d\u003d Properties.class) {\r\n        // TODO: test subclasses of Properties!\r\n        return new Type[] { String.class, String.class };\r\n    }\r\n    Type mapType \u003d getSupertype(context, contextRawType, Map.class);\r\n    // TODO: strip wildcards?\r\n    if (mapType instanceof ParameterizedType) {\r\n        ParameterizedType mapParameterizedType \u003d (ParameterizedType) mapType;\r\n        return mapParameterizedType.getActualTypeArguments();\r\n    }\r\n    return new Type[] { Object.class, Object.class };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "getMapKeyAndValueTypes",
      "parameterTypes": [
        "Type",
        "Class\u003c?\u003e"
      ],
      "returnType": "Type[]"
    }
  },
  {
    "sourceCode": "public static Type resolve(Type context, Class\u003c?\u003e contextRawType, Type toResolve) {\r\n    return resolve(context, contextRawType, toResolve, new HashMap\u003cTypeVariable\u003c?\u003e, Type\u003e());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "resolve",
      "parameterTypes": [
        "Type",
        "Class\u003c?\u003e",
        "Type"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "private static Type resolve(Type context, Class\u003c?\u003e contextRawType, Type toResolve, Map\u003cTypeVariable\u003c?\u003e, Type\u003e visitedTypeVariables) {\r\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\r\n    TypeVariable\u003c?\u003e resolving \u003d null;\r\n    while (true) {\r\n        if (toResolve instanceof TypeVariable) {\r\n            TypeVariable\u003c?\u003e typeVariable \u003d (TypeVariable\u003c?\u003e) toResolve;\r\n            Type previouslyResolved \u003d visitedTypeVariables.get(typeVariable);\r\n            if (previouslyResolved !\u003d null) {\r\n                // cannot reduce due to infinite recursion\r\n                return (previouslyResolved \u003d\u003d Void.TYPE) ? toResolve : previouslyResolved;\r\n            }\r\n            // Insert a placeholder to mark the fact that we are in the process of resolving this type\r\n            visitedTypeVariables.put(typeVariable, Void.TYPE);\r\n            if (resolving \u003d\u003d null) {\r\n                resolving \u003d typeVariable;\r\n            }\r\n            toResolve \u003d resolveTypeVariable(context, contextRawType, typeVariable);\r\n            if (toResolve \u003d\u003d typeVariable) {\r\n                break;\r\n            }\r\n        } else if (toResolve instanceof Class \u0026\u0026 ((Class\u003c?\u003e) toResolve).isArray()) {\r\n            Class\u003c?\u003e original \u003d (Class\u003c?\u003e) toResolve;\r\n            Type componentType \u003d original.getComponentType();\r\n            Type newComponentType \u003d resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n            toResolve \u003d equal(componentType, newComponentType) ? original : arrayOf(newComponentType);\r\n            break;\r\n        } else if (toResolve instanceof GenericArrayType) {\r\n            GenericArrayType original \u003d (GenericArrayType) toResolve;\r\n            Type componentType \u003d original.getGenericComponentType();\r\n            Type newComponentType \u003d resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n            toResolve \u003d equal(componentType, newComponentType) ? original : arrayOf(newComponentType);\r\n            break;\r\n        } else if (toResolve instanceof ParameterizedType) {\r\n            ParameterizedType original \u003d (ParameterizedType) toResolve;\r\n            Type ownerType \u003d original.getOwnerType();\r\n            Type newOwnerType \u003d resolve(context, contextRawType, ownerType, visitedTypeVariables);\r\n            boolean changed \u003d !equal(newOwnerType, ownerType);\r\n            Type[] args \u003d original.getActualTypeArguments();\r\n            for (int t \u003d 0, length \u003d args.length; t \u003c length; t++) {\r\n                Type resolvedTypeArgument \u003d resolve(context, contextRawType, args[t], visitedTypeVariables);\r\n                if (!equal(resolvedTypeArgument, args[t])) {\r\n                    if (!changed) {\r\n                        args \u003d args.clone();\r\n                        changed \u003d true;\r\n                    }\r\n                    args[t] \u003d resolvedTypeArgument;\r\n                }\r\n            }\r\n            toResolve \u003d changed ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args) : original;\r\n            break;\r\n        } else if (toResolve instanceof WildcardType) {\r\n            WildcardType original \u003d (WildcardType) toResolve;\r\n            Type[] originalLowerBound \u003d original.getLowerBounds();\r\n            Type[] originalUpperBound \u003d original.getUpperBounds();\r\n            if (originalLowerBound.length \u003d\u003d 1) {\r\n                Type lowerBound \u003d resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\r\n                if (lowerBound !\u003d originalLowerBound[0]) {\r\n                    toResolve \u003d supertypeOf(lowerBound);\r\n                    break;\r\n                }\r\n            } else if (originalUpperBound.length \u003d\u003d 1) {\r\n                Type upperBound \u003d resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\r\n                if (upperBound !\u003d originalUpperBound[0]) {\r\n                    toResolve \u003d subtypeOf(upperBound);\r\n                    break;\r\n                }\r\n            }\r\n            toResolve \u003d original;\r\n            break;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // ensure that any in-process resolution gets updated with the final result\r\n    if (resolving !\u003d null) {\r\n        visitedTypeVariables.put(resolving, toResolve);\r\n    }\r\n    return toResolve;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "resolve",
      "parameterTypes": [
        "Type",
        "Class\u003c?\u003e",
        "Type",
        "Map\u003cTypeVariable\u003c?\u003e, Type\u003e"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "private static Type resolveTypeVariable(Type context, Class\u003c?\u003e contextRawType, TypeVariable\u003c?\u003e unknown) {\r\n    Class\u003c?\u003e declaredByRaw \u003d declaringClassOf(unknown);\r\n    // we can\u0027t reduce this further\r\n    if (declaredByRaw \u003d\u003d null) {\r\n        return unknown;\r\n    }\r\n    Type declaredBy \u003d getGenericSupertype(context, contextRawType, declaredByRaw);\r\n    if (declaredBy instanceof ParameterizedType) {\r\n        int index \u003d indexOf(declaredByRaw.getTypeParameters(), unknown);\r\n        return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\r\n    }\r\n    return unknown;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "resolveTypeVariable",
      "parameterTypes": [
        "Type",
        "Class\u003c?\u003e",
        "TypeVariable\u003c?\u003e"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "private static int indexOf(Object[] array, Object toFind) {\r\n    for (int i \u003d 0, length \u003d array.length; i \u003c length; i++) {\r\n        if (toFind.equals(array[i])) {\r\n            return i;\r\n        }\r\n    }\r\n    throw new NoSuchElementException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "indexOf",
      "parameterTypes": [
        "Object[]",
        "Object"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\r\n * a class.\r\n */\r\nprivate static Class\u003c?\u003e declaringClassOf(TypeVariable\u003c?\u003e typeVariable) {\r\n    GenericDeclaration genericDeclaration \u003d typeVariable.getGenericDeclaration();\r\n    return genericDeclaration instanceof Class ? (Class\u003c?\u003e) genericDeclaration : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "declaringClassOf",
      "parameterTypes": [
        "TypeVariable\u003c?\u003e"
      ],
      "returnType": "Class\u003c?\u003e"
    }
  },
  {
    "sourceCode": "static void checkNotPrimitive(Type type) {\r\n    checkArgument(!(type instanceof Class\u003c?\u003e) || !((Class\u003c?\u003e) type).isPrimitive());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "checkNotPrimitive",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Whether an {@linkplain ParameterizedType#getOwnerType() owner type} must be specified when\r\n * constructing a {@link ParameterizedType} for {@code rawType}.\r\n *\r\n * \u003cp\u003eNote that this method might not require an owner type for all cases where Java reflection\r\n * would create parameterized types with owner type.\r\n */\r\npublic static boolean requiresOwnerType(Type rawType) {\r\n    if (rawType instanceof Class\u003c?\u003e) {\r\n        Class\u003c?\u003e rawTypeAsClass \u003d (Class\u003c?\u003e) rawType;\r\n        return !Modifier.isStatic(rawTypeAsClass.getModifiers()) \u0026\u0026 rawTypeAsClass.getDeclaringClass() !\u003d null;\r\n    }\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types",
      "methodName": "requiresOwnerType",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Type[] getActualTypeArguments() {\r\n    return typeArguments.clone();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.ParameterizedTypeImpl",
      "methodName": "getActualTypeArguments",
      "parameterTypes": [],
      "returnType": "Type[]"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Type getRawType() {\r\n    return rawType;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.ParameterizedTypeImpl",
      "methodName": "getRawType",
      "parameterTypes": [],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Type getOwnerType() {\r\n    return ownerType;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.ParameterizedTypeImpl",
      "methodName": "getOwnerType",
      "parameterTypes": [],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object other) {\r\n    return other instanceof ParameterizedType \u0026\u0026 $Gson$Types.equals(this, (ParameterizedType) other);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.ParameterizedTypeImpl",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private static int hashCodeOrZero(Object o) {\r\n    return o !\u003d null ? o.hashCode() : 0;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.ParameterizedTypeImpl",
      "methodName": "hashCodeOrZero",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.ParameterizedTypeImpl",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    int length \u003d typeArguments.length;\r\n    if (length \u003d\u003d 0) {\r\n        return typeToString(rawType);\r\n    }\r\n    StringBuilder stringBuilder \u003d new StringBuilder(30 * (length + 1));\r\n    stringBuilder.append(typeToString(rawType)).append(\"\u003c\").append(typeToString(typeArguments[0]));\r\n    for (int i \u003d 1; i \u003c length; i++) {\r\n        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\r\n    }\r\n    return stringBuilder.append(\"\u003e\").toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.ParameterizedTypeImpl",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Type getGenericComponentType() {\r\n    return componentType;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.GenericArrayTypeImpl",
      "methodName": "getGenericComponentType",
      "parameterTypes": [],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    return o instanceof GenericArrayType \u0026\u0026 $Gson$Types.equals(this, (GenericArrayType) o);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.GenericArrayTypeImpl",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return componentType.hashCode();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.GenericArrayTypeImpl",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return typeToString(componentType) + \"[]\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.GenericArrayTypeImpl",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Type[] getUpperBounds() {\r\n    return new Type[] { upperBound };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.WildcardTypeImpl",
      "methodName": "getUpperBounds",
      "parameterTypes": [],
      "returnType": "Type[]"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Type[] getLowerBounds() {\r\n    return lowerBound !\u003d null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.WildcardTypeImpl",
      "methodName": "getLowerBounds",
      "parameterTypes": [],
      "returnType": "Type[]"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object other) {\r\n    return other instanceof WildcardType \u0026\u0026 $Gson$Types.equals(this, (WildcardType) other);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.WildcardTypeImpl",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\r\n    return (lowerBound !\u003d null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.WildcardTypeImpl",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    if (lowerBound !\u003d null) {\r\n        return \"? super \" + typeToString(lowerBound);\r\n    } else if (upperBound \u003d\u003d Object.class) {\r\n        return \"?\";\r\n    } else {\r\n        return \"? extends \" + typeToString(upperBound);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.$Gson$Types.WildcardTypeImpl",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    Type type \u003d typeToken.getType();\r\n    if (!(type instanceof GenericArrayType || (type instanceof Class \u0026\u0026 ((Class\u003c?\u003e) type).isArray()))) {\r\n        return null;\r\n    }\r\n    Type componentType \u003d $Gson$Types.getArrayComponentType(type);\r\n    TypeAdapter\u003c?\u003e componentTypeAdapter \u003d gson.getAdapter(TypeToken.get(componentType));\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e arrayAdapter \u003d new ArrayTypeAdapter(gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\r\n    return arrayAdapter;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ArrayTypeAdapter",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Object read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    ArrayList\u003cE\u003e list \u003d new ArrayList\u003c\u003e();\r\n    in.beginArray();\r\n    while (in.hasNext()) {\r\n        E instance \u003d componentTypeAdapter.read(in);\r\n        list.add(instance);\r\n    }\r\n    in.endArray();\r\n    int size \u003d list.size();\r\n    // Have to copy primitives one by one to primitive array\r\n    if (componentType.isPrimitive()) {\r\n        Object array \u003d Array.newInstance(componentType, size);\r\n        for (int i \u003d 0; i \u003c size; i++) {\r\n            Array.set(array, i, list.get(i));\r\n        }\r\n        return array;\r\n    } else // But for Object[] can use ArrayList.toArray\r\n    {\r\n        @SuppressWarnings(\"unchecked\")\r\n        E[] array \u003d (E[]) Array.newInstance(componentType, size);\r\n        return list.toArray(array);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ArrayTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Object array) throws IOException {\r\n    if (array \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginArray();\r\n    for (int i \u003d 0, length \u003d Array.getLength(array); i \u003c length; i++) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        E value \u003d (E) Array.get(array, i);\r\n        componentTypeAdapter.write(out, value);\r\n    }\r\n    out.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ArrayTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    Type type \u003d typeToken.getType();\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    if (!Collection.class.isAssignableFrom(rawType)) {\r\n        return null;\r\n    }\r\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\r\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\r\n    // create() doesn\u0027t define a type parameter\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Collection\u003cE\u003e read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    Collection\u003cE\u003e collection \u003d constructor.construct();\r\n    in.beginArray();\r\n    while (in.hasNext()) {\r\n        E instance \u003d elementTypeAdapter.read(in);\r\n        collection.add(instance);\r\n    }\r\n    in.endArray();\r\n    return collection;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.Adapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Collection\u003cE\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Collection\u003cE\u003e collection) throws IOException {\r\n    if (collection \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginArray();\r\n    for (E element : collection) {\r\n        elementTypeAdapter.write(out, element);\r\n    }\r\n    out.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.Adapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Collection\u003cE\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// we use a runtime check to make sure the \u0027T\u0027s equal\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    return typeToken.getRawType() \u003d\u003d Date.class ? (TypeAdapter\u003cT\u003e) new DateTypeAdapter() : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DateTypeAdapter",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Date read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return deserializeToDate(in);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DateTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Date"
    }
  },
  {
    "sourceCode": "private Date deserializeToDate(JsonReader in) throws IOException {\r\n    String s \u003d in.nextString();\r\n    synchronized (dateFormats) {\r\n        for (DateFormat dateFormat : dateFormats) {\r\n            try {\r\n                return dateFormat.parse(s);\r\n            } catch (ParseException ignored) {\r\n                // OK: try the next format\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return ISO8601Utils.parse(s, new ParsePosition(0));\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DateTypeAdapter",
      "methodName": "deserializeToDate",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Date"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Date value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    DateFormat dateFormat \u003d dateFormats.get(0);\r\n    String dateFormatAsString;\r\n    synchronized (dateFormats) {\r\n        dateFormatAsString \u003d dateFormat.format(value);\r\n    }\r\n    out.value(dateFormatAsString);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DateTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Date"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\nprotected Date deserialize(Date date) {\r\n    return date;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter.DateType",
      "methodName": "deserialize",
      "parameterTypes": [
        "Date"
      ],
      "returnType": "Date"
    }
  },
  {
    "sourceCode": "protected abstract T deserialize(Date date);",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter.DateType",
      "methodName": "deserialize",
      "parameterTypes": [
        "Date"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "private TypeAdapterFactory createFactory(DefaultDateTypeAdapter\u003cT\u003e adapter) {\r\n    return TypeAdapters.newFactory(dateClass, adapter);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter.DateType",
      "methodName": "createFactory",
      "parameterTypes": [
        "DefaultDateTypeAdapter\u003cT\u003e"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "public final TypeAdapterFactory createAdapterFactory(String datePattern) {\r\n    return createFactory(new DefaultDateTypeAdapter\u003c\u003e(this, datePattern));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter.DateType",
      "methodName": "createAdapterFactory",
      "parameterTypes": [
        "String"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "public final TypeAdapterFactory createAdapterFactory(int style) {\r\n    return createFactory(new DefaultDateTypeAdapter\u003c\u003e(this, style));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter.DateType",
      "methodName": "createAdapterFactory",
      "parameterTypes": [
        "int"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "public final TypeAdapterFactory createAdapterFactory(int dateStyle, int timeStyle) {\r\n    return createFactory(new DefaultDateTypeAdapter\u003c\u003e(this, dateStyle, timeStyle));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter.DateType",
      "methodName": "createAdapterFactory",
      "parameterTypes": [
        "int",
        "int"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "public final TypeAdapterFactory createDefaultsAdapterFactory() {\r\n    return createFactory(new DefaultDateTypeAdapter\u003c\u003e(this, DateFormat.DEFAULT, DateFormat.DEFAULT));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter.DateType",
      "methodName": "createDefaultsAdapterFactory",
      "parameterTypes": [],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "// These methods need to be synchronized since JDK DateFormat classes are not thread-safe\r\n// See issue 162\r\n@Override\r\npublic void write(JsonWriter out, Date value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    DateFormat dateFormat \u003d dateFormats.get(0);\r\n    String dateFormatAsString;\r\n    synchronized (dateFormats) {\r\n        dateFormatAsString \u003d dateFormat.format(value);\r\n    }\r\n    out.value(dateFormatAsString);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Date"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    Date date \u003d deserializeToDate(in);\r\n    return dateType.deserialize(date);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "private Date deserializeToDate(JsonReader in) throws IOException {\r\n    String s \u003d in.nextString();\r\n    synchronized (dateFormats) {\r\n        for (DateFormat dateFormat : dateFormats) {\r\n            try {\r\n                return dateFormat.parse(s);\r\n            } catch (ParseException ignored) {\r\n                // OK: try the next format\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return ISO8601Utils.parse(s, new ParsePosition(0));\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter",
      "methodName": "deserializeToDate",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Date"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    DateFormat defaultFormat \u003d dateFormats.get(0);\r\n    if (defaultFormat instanceof SimpleDateFormat) {\r\n        return SIMPLE_NAME + \u0027(\u0027 + ((SimpleDateFormat) defaultFormat).toPattern() + \u0027)\u0027;\r\n    } else {\r\n        return SIMPLE_NAME + \u0027(\u0027 + defaultFormat.getClass().getSimpleName() + \u0027)\u0027;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapter",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    throw new AssertionError(\"Factory should not be used\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.DummyTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "// Separate helper method to make sure callers retrieve annotation in a consistent way\r\nprivate JsonAdapter getAnnotation(Class\u003c?\u003e rawType) {\r\n    return rawType.getAnnotation(JsonAdapter.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
      "methodName": "getAnnotation",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "JsonAdapter"
    }
  },
  {
    "sourceCode": "// this is not safe; requires that user has specified correct adapter class for @JsonAdapter\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e targetType) {\r\n    Class\u003c? super T\u003e rawType \u003d targetType.getRawType();\r\n    JsonAdapter annotation \u003d getAnnotation(rawType);\r\n    if (annotation \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    return (TypeAdapter\u003cT\u003e) getTypeAdapter(constructorConstructor, gson, targetType, annotation, true);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "// Separate helper method to make sure callers create adapter in a consistent way\r\nprivate static Object createAdapter(ConstructorConstructor constructorConstructor, Class\u003c?\u003e adapterClass) {\r\n    // TODO: The exception messages created by ConstructorConstructor are currently written in the context of\r\n    // deserialization and for example suggest usage of TypeAdapter, which would not work for @JsonAdapter usage\r\n    return constructorConstructor.get(TypeToken.get(adapterClass)).construct();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
      "methodName": "createAdapter",
      "parameterTypes": [
        "ConstructorConstructor",
        "Class\u003c?\u003e"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "private TypeAdapterFactory putFactoryAndGetCurrent(Class\u003c?\u003e rawType, TypeAdapterFactory factory) {\r\n    // Uses putIfAbsent in case multiple threads concurrently create factory\r\n    TypeAdapterFactory existingFactory \u003d adapterFactoryMap.putIfAbsent(rawType, factory);\r\n    return existingFactory !\u003d null ? existingFactory : factory;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
      "methodName": "putFactoryAndGetCurrent",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "TypeAdapterFactory"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "TypeAdapter\u003c?\u003e getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson, TypeToken\u003c?\u003e type, JsonAdapter annotation, boolean isClassAnnotation) {\r\n    Object instance \u003d createAdapter(constructorConstructor, annotation.value());\r\n    TypeAdapter\u003c?\u003e typeAdapter;\r\n    boolean nullSafe \u003d annotation.nullSafe();\r\n    if (instance instanceof TypeAdapter) {\r\n        typeAdapter \u003d (TypeAdapter\u003c?\u003e) instance;\r\n    } else if (instance instanceof TypeAdapterFactory) {\r\n        TypeAdapterFactory factory \u003d (TypeAdapterFactory) instance;\r\n        if (isClassAnnotation) {\r\n            factory \u003d putFactoryAndGetCurrent(type.getRawType(), factory);\r\n        }\r\n        typeAdapter \u003d factory.create(gson, type);\r\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\r\n        JsonSerializer\u003c?\u003e serializer \u003d instance instanceof JsonSerializer ? (JsonSerializer\u003c?\u003e) instance : null;\r\n        JsonDeserializer\u003c?\u003e deserializer \u003d instance instanceof JsonDeserializer ? (JsonDeserializer\u003c?\u003e) instance : null;\r\n        // Uses dummy factory instances because TreeTypeAdapter needs a \u0027skipPast\u0027 factory for `Gson.getDelegateAdapter`\r\n        // call and has to differentiate there whether TreeTypeAdapter was created for @JsonAdapter on class or field\r\n        TypeAdapterFactory skipPast;\r\n        if (isClassAnnotation) {\r\n            skipPast \u003d TREE_TYPE_CLASS_DUMMY_FACTORY;\r\n        } else {\r\n            skipPast \u003d TREE_TYPE_FIELD_DUMMY_FACTORY;\r\n        }\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapter\u003c?\u003e tempAdapter \u003d new TreeTypeAdapter(serializer, deserializer, gson, type, skipPast, nullSafe);\r\n        typeAdapter \u003d tempAdapter;\r\n        // TreeTypeAdapter handles nullSafe; don\u0027t additionally call `nullSafe()`\r\n        nullSafe \u003d false;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \" + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString() + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\" + \" JsonSerializer or JsonDeserializer.\");\r\n    }\r\n    if (typeAdapter !\u003d null \u0026\u0026 nullSafe) {\r\n        typeAdapter \u003d typeAdapter.nullSafe();\r\n    }\r\n    return typeAdapter;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
      "methodName": "getTypeAdapter",
      "parameterTypes": [
        "ConstructorConstructor",
        "Gson",
        "TypeToken\u003c?\u003e",
        "JsonAdapter",
        "boolean"
      ],
      "returnType": "TypeAdapter\u003c?\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns whether {@code factory} is a type adapter factory created for {@code @JsonAdapter}\r\n * placed on {@code type}.\r\n */\r\npublic boolean isClassJsonAdapterFactory(TypeToken\u003c?\u003e type, TypeAdapterFactory factory) {\r\n    Objects.requireNonNull(type);\r\n    Objects.requireNonNull(factory);\r\n    if (factory \u003d\u003d TREE_TYPE_CLASS_DUMMY_FACTORY) {\r\n        return true;\r\n    }\r\n    // Using raw type to match behavior of `create(Gson, TypeToken\u003cT\u003e)` above\r\n    Class\u003c?\u003e rawType \u003d type.getRawType();\r\n    TypeAdapterFactory existingFactory \u003d adapterFactoryMap.get(rawType);\r\n    if (existingFactory !\u003d null) {\r\n        // Checks for reference equality, like it is done by `Gson.getDelegateAdapter`\r\n        return existingFactory \u003d\u003d factory;\r\n    }\r\n    // If no factory has been created for the type yet check manually for a @JsonAdapter annotation\r\n    // which specifies a TypeAdapterFactory\r\n    // Otherwise behavior would not be consistent, depending on whether or not adapter had been requested\r\n    // before call to `isClassJsonAdapterFactory` was made\r\n    JsonAdapter annotation \u003d getAnnotation(rawType);\r\n    if (annotation \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    Class\u003c?\u003e adapterClass \u003d annotation.value();\r\n    if (!TypeAdapterFactory.class.isAssignableFrom(adapterClass)) {\r\n        return false;\r\n    }\r\n    Object adapter \u003d createAdapter(constructorConstructor, adapterClass);\r\n    TypeAdapterFactory newFactory \u003d (TypeAdapterFactory) adapter;\r\n    return putFactoryAndGetCurrent(rawType, newFactory) \u003d\u003d factory;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
      "methodName": "isClassJsonAdapterFactory",
      "parameterTypes": [
        "TypeToken\u003c?\u003e",
        "TypeAdapterFactory"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int read(char[] buffer, int offset, int count) {\r\n    throw new AssertionError();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "read",
      "parameterTypes": [
        "char[]",
        "int",
        "int"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void close() {\r\n    throw new AssertionError();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "close",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void beginArray() throws IOException {\r\n    expect(JsonToken.BEGIN_ARRAY);\r\n    JsonArray array \u003d (JsonArray) peekStack();\r\n    push(array.iterator());\r\n    pathIndices[stackSize - 1] \u003d 0;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "beginArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void endArray() throws IOException {\r\n    expect(JsonToken.END_ARRAY);\r\n    // empty iterator\r\n    popStack();\r\n    // array\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "endArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void beginObject() throws IOException {\r\n    expect(JsonToken.BEGIN_OBJECT);\r\n    JsonObject object \u003d (JsonObject) peekStack();\r\n    push(object.entrySet().iterator());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "beginObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void endObject() throws IOException {\r\n    expect(JsonToken.END_OBJECT);\r\n    // Free the last path name so that it can be garbage collected\r\n    pathNames[stackSize - 1] \u003d null;\r\n    // empty iterator\r\n    popStack();\r\n    // object\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "endObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean hasNext() throws IOException {\r\n    JsonToken token \u003d peek();\r\n    return token !\u003d JsonToken.END_OBJECT \u0026\u0026 token !\u003d JsonToken.END_ARRAY \u0026\u0026 token !\u003d JsonToken.END_DOCUMENT;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "hasNext",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonToken peek() throws IOException {\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "peek",
      "parameterTypes": [],
      "returnType": "JsonToken"
    }
  },
  {
    "sourceCode": "private Object peekStack() {\r\n    return stack[stackSize - 1];\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "peekStack",
      "parameterTypes": [],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\nprivate Object popStack() {\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "popStack",
      "parameterTypes": [],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "private void expect(JsonToken expected) throws IOException {\r\n    if (peek() !\u003d expected) {\r\n        throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "expect",
      "parameterTypes": [
        "JsonToken"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private String nextName(boolean skipName) throws IOException {\r\n    expect(JsonToken.NAME);\r\n    Iterator\u003c?\u003e i \u003d (Iterator\u003c?\u003e) peekStack();\r\n    Map.Entry\u003c?, ?\u003e entry \u003d (Map.Entry\u003c?, ?\u003e) i.next();\r\n    String result \u003d (String) entry.getKey();\r\n    pathNames[stackSize - 1] \u003d skipName ? \"\u003cskipped\u003e\" : result;\r\n    push(entry.getValue());\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "nextName",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String nextName() throws IOException {\r\n    return nextName(false);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "nextName",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String nextString() throws IOException {\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.STRING \u0026\u0026 token !\u003d JsonToken.NUMBER) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\r\n    }\r\n    String result \u003d ((JsonPrimitive) popStack()).getAsString();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "nextString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean nextBoolean() throws IOException {\r\n    expect(JsonToken.BOOLEAN);\r\n    boolean result \u003d ((JsonPrimitive) popStack()).getAsBoolean();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "nextBoolean",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void nextNull() throws IOException {\r\n    expect(JsonToken.NULL);\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "nextNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic double nextDouble() throws IOException {\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    double result \u003d ((JsonPrimitive) peekStack()).getAsDouble();\r\n    if (!isLenient() \u0026\u0026 (Double.isNaN(result) || Double.isInfinite(result))) {\r\n        throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result);\r\n    }\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "nextDouble",
      "parameterTypes": [],
      "returnType": "double"
    }
  },
  {
    "sourceCode": "@Override\r\npublic long nextLong() throws IOException {\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    long result \u003d ((JsonPrimitive) peekStack()).getAsLong();\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "nextLong",
      "parameterTypes": [],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int nextInt() throws IOException {\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    int result \u003d ((JsonPrimitive) peekStack()).getAsInt();\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "nextInt",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "JsonElement nextJsonElement() throws IOException {\r\n    final JsonToken peeked \u003d peek();\r\n    if (peeked \u003d\u003d JsonToken.NAME || peeked \u003d\u003d JsonToken.END_ARRAY || peeked \u003d\u003d JsonToken.END_OBJECT || peeked \u003d\u003d JsonToken.END_DOCUMENT) {\r\n        throw new IllegalStateException(\"Unexpected \" + peeked + \" when reading a JsonElement.\");\r\n    }\r\n    final JsonElement element \u003d (JsonElement) peekStack();\r\n    skipValue();\r\n    return element;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "nextJsonElement",
      "parameterTypes": [],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void close() throws IOException {\r\n    stack \u003d new Object[] { SENTINEL_CLOSED };\r\n    stackSize \u003d 1;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "close",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void skipValue() throws IOException {\r\n    JsonToken peeked \u003d peek();\r\n    switch(peeked) {\r\n        case NAME:\r\n            @SuppressWarnings(\"unused\")\r\n            String unused \u003d nextName(true);\r\n            break;\r\n        case END_ARRAY:\r\n            endArray();\r\n            break;\r\n        case END_OBJECT:\r\n            endObject();\r\n            break;\r\n        case END_DOCUMENT:\r\n            // Do nothing\r\n            break;\r\n        default:\r\n            popStack();\r\n            if (stackSize \u003e 0) {\r\n                pathIndices[stackSize - 1]++;\r\n            }\r\n            break;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "skipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return getClass().getSimpleName() + locationString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public void promoteNameToValue() throws IOException {\r\n    expect(JsonToken.NAME);\r\n    Iterator\u003c?\u003e i \u003d (Iterator\u003c?\u003e) peekStack();\r\n    Map.Entry\u003c?, ?\u003e entry \u003d (Map.Entry\u003c?, ?\u003e) i.next();\r\n    push(entry.getValue());\r\n    push(new JsonPrimitive((String) entry.getKey()));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "promoteNameToValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void push(Object newTop) {\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        int newLength \u003d stackSize * 2;\r\n        stack \u003d Arrays.copyOf(stack, newLength);\r\n        pathIndices \u003d Arrays.copyOf(pathIndices, newLength);\r\n        pathNames \u003d Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "push",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private String getPath(boolean usePreviousPath) {\r\n    StringBuilder result \u003d new StringBuilder().append(\u0027$\u0027);\r\n    for (int i \u003d 0; i \u003c stackSize; i++) {\r\n        if (stack[i] instanceof JsonArray) {\r\n            if (++i \u003c stackSize \u0026\u0026 stack[i] instanceof Iterator) {\r\n                int pathIndex \u003d pathIndices[i];\r\n                // If index is last path element it points to next array element; have to decrement\r\n                // `- 1` covers case where iterator for next element is on stack\r\n                // `- 2` covers case where peek() already pushed next element onto stack\r\n                if (usePreviousPath \u0026\u0026 pathIndex \u003e 0 \u0026\u0026 (i \u003d\u003d stackSize - 1 || i \u003d\u003d stackSize - 2)) {\r\n                    pathIndex--;\r\n                }\r\n                result.append(\u0027[\u0027).append(pathIndex).append(\u0027]\u0027);\r\n            }\r\n        } else if (stack[i] instanceof JsonObject) {\r\n            if (++i \u003c stackSize \u0026\u0026 stack[i] instanceof Iterator) {\r\n                result.append(\u0027.\u0027);\r\n                if (pathNames[i] !\u003d null) {\r\n                    result.append(pathNames[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "getPath",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String getPreviousPath() {\r\n    return getPath(true);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "getPreviousPath",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String getPath() {\r\n    return getPath(false);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "getPath",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "private String locationString() {\r\n    return \" at path \" + getPath();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReader",
      "methodName": "locationString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(char[] buffer, int offset, int counter) {\r\n    throw new AssertionError();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "write",
      "parameterTypes": [
        "char[]",
        "int",
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void flush() {\r\n    throw new AssertionError();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "flush",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void close() {\r\n    throw new AssertionError();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "close",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the top level object produced by this writer.\r\n */\r\npublic JsonElement get() {\r\n    if (!stack.isEmpty()) {\r\n        throw new IllegalStateException(\"Expected one JSON element but was \" + stack);\r\n    }\r\n    return product;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "get",
      "parameterTypes": [],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "private JsonElement peek() {\r\n    return stack.get(stack.size() - 1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "peek",
      "parameterTypes": [],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "private void put(JsonElement value) {\r\n    if (pendingName !\u003d null) {\r\n        if (!value.isJsonNull() || getSerializeNulls()) {\r\n            JsonObject object \u003d (JsonObject) peek();\r\n            object.add(pendingName, value);\r\n        }\r\n        pendingName \u003d null;\r\n    } else if (stack.isEmpty()) {\r\n        product \u003d value;\r\n    } else {\r\n        JsonElement element \u003d peek();\r\n        if (element instanceof JsonArray) {\r\n            ((JsonArray) element).add(value);\r\n        } else {\r\n            throw new IllegalStateException();\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "put",
      "parameterTypes": [
        "JsonElement"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter beginArray() throws IOException {\r\n    JsonArray array \u003d new JsonArray();\r\n    put(array);\r\n    stack.add(array);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "beginArray",
      "parameterTypes": [],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter endArray() throws IOException {\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonArray) {\r\n        stack.remove(stack.size() - 1);\r\n        return this;\r\n    }\r\n    throw new IllegalStateException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "endArray",
      "parameterTypes": [],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter beginObject() throws IOException {\r\n    JsonObject object \u003d new JsonObject();\r\n    put(object);\r\n    stack.add(object);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "beginObject",
      "parameterTypes": [],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter endObject() throws IOException {\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonObject) {\r\n        stack.remove(stack.size() - 1);\r\n        return this;\r\n    }\r\n    throw new IllegalStateException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "endObject",
      "parameterTypes": [],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter name(String name) throws IOException {\r\n    Objects.requireNonNull(name, \"name \u003d\u003d null\");\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException(\"Did not expect a name\");\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonObject) {\r\n        pendingName \u003d name;\r\n        return this;\r\n    }\r\n    throw new IllegalStateException(\"Please begin an object before writing a name.\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "name",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter value(String value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "value",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonWriter jsonValue(String value) throws IOException {\r\n    throw new UnsupportedOperationException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "jsonValue",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter nullValue() throws IOException {\r\n    put(JsonNull.INSTANCE);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "nullValue",
      "parameterTypes": [],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter value(boolean value) throws IOException {\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "value",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter value(Boolean value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "value",
      "parameterTypes": [
        "Boolean"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter value(float value) throws IOException {\r\n    if (!isLenient() \u0026\u0026 (Float.isNaN(value) || Float.isInfinite(value))) {\r\n        throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "value",
      "parameterTypes": [
        "float"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter value(double value) throws IOException {\r\n    if (!isLenient() \u0026\u0026 (Double.isNaN(value) || Double.isInfinite(value))) {\r\n        throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "value",
      "parameterTypes": [
        "double"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter value(long value) throws IOException {\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "value",
      "parameterTypes": [
        "long"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic JsonWriter value(Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    if (!isLenient()) {\r\n        double d \u003d value.doubleValue();\r\n        if (Double.isNaN(d) || Double.isInfinite(d)) {\r\n            throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\r\n        }\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "value",
      "parameterTypes": [
        "Number"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void flush() throws IOException {\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "flush",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void close() throws IOException {\r\n    if (!stack.isEmpty()) {\r\n        throw new IOException(\"Incomplete document\");\r\n    }\r\n    stack.add(SENTINEL_CLOSED);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriter",
      "methodName": "close",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    Type type \u003d typeToken.getType();\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    if (!Map.class.isAssignableFrom(rawType)) {\r\n        return null;\r\n    }\r\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawType);\r\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\r\n    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e // we don\u0027t define a type parameter for the key or value types\r\n    result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.MapTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a type adapter that writes the value as a string.\r\n */\r\nprivate TypeAdapter\u003c?\u003e getKeyAdapter(Gson context, Type keyType) {\r\n    return (keyType \u003d\u003d boolean.class || keyType \u003d\u003d Boolean.class) ? TypeAdapters.BOOLEAN_AS_STRING : context.getAdapter(TypeToken.get(keyType));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.MapTypeAdapterFactory",
      "methodName": "getKeyAdapter",
      "parameterTypes": [
        "Gson",
        "Type"
      ],
      "returnType": "TypeAdapter\u003c?\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Map\u003cK, V\u003e read(JsonReader in) throws IOException {\r\n    JsonToken peek \u003d in.peek();\r\n    if (peek \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    Map\u003cK, V\u003e map \u003d constructor.construct();\r\n    if (peek \u003d\u003d JsonToken.BEGIN_ARRAY) {\r\n        in.beginArray();\r\n        while (in.hasNext()) {\r\n            // entry array\r\n            in.beginArray();\r\n            K key \u003d keyTypeAdapter.read(in);\r\n            V value \u003d valueTypeAdapter.read(in);\r\n            V replaced \u003d map.put(key, value);\r\n            if (replaced !\u003d null) {\r\n                throw new JsonSyntaxException(\"duplicate key: \" + key);\r\n            }\r\n            in.endArray();\r\n        }\r\n        in.endArray();\r\n    } else {\r\n        in.beginObject();\r\n        while (in.hasNext()) {\r\n            JsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\r\n            K key \u003d keyTypeAdapter.read(in);\r\n            V value \u003d valueTypeAdapter.read(in);\r\n            V replaced \u003d map.put(key, value);\r\n            if (replaced !\u003d null) {\r\n                throw new JsonSyntaxException(\"duplicate key: \" + key);\r\n            }\r\n        }\r\n        in.endObject();\r\n    }\r\n    return map;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.MapTypeAdapterFactory.Adapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Map\u003cK, V\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Map\u003cK, V\u003e map) throws IOException {\r\n    if (map \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    if (!complexMapKeySerialization) {\r\n        out.beginObject();\r\n        for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) {\r\n            out.name(String.valueOf(entry.getKey()));\r\n            valueTypeAdapter.write(out, entry.getValue());\r\n        }\r\n        out.endObject();\r\n        return;\r\n    }\r\n    boolean hasComplexKeys \u003d false;\r\n    List\u003cJsonElement\u003e keys \u003d new ArrayList\u003c\u003e(map.size());\r\n    List\u003cV\u003e values \u003d new ArrayList\u003c\u003e(map.size());\r\n    for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) {\r\n        JsonElement keyElement \u003d keyTypeAdapter.toJsonTree(entry.getKey());\r\n        keys.add(keyElement);\r\n        values.add(entry.getValue());\r\n        hasComplexKeys |\u003d keyElement.isJsonArray() || keyElement.isJsonObject();\r\n    }\r\n    if (hasComplexKeys) {\r\n        out.beginArray();\r\n        for (int i \u003d 0, size \u003d keys.size(); i \u003c size; i++) {\r\n            // entry array\r\n            out.beginArray();\r\n            Streams.write(keys.get(i), out);\r\n            valueTypeAdapter.write(out, values.get(i));\r\n            out.endArray();\r\n        }\r\n        out.endArray();\r\n    } else {\r\n        out.beginObject();\r\n        for (int i \u003d 0, size \u003d keys.size(); i \u003c size; i++) {\r\n            JsonElement keyElement \u003d keys.get(i);\r\n            out.name(keyToString(keyElement));\r\n            valueTypeAdapter.write(out, values.get(i));\r\n        }\r\n        out.endObject();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.MapTypeAdapterFactory.Adapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Map\u003cK, V\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private String keyToString(JsonElement keyElement) {\r\n    if (keyElement.isJsonPrimitive()) {\r\n        JsonPrimitive primitive \u003d keyElement.getAsJsonPrimitive();\r\n        if (primitive.isNumber()) {\r\n            return String.valueOf(primitive.getAsNumber());\r\n        } else if (primitive.isBoolean()) {\r\n            return Boolean.toString(primitive.getAsBoolean());\r\n        } else if (primitive.isString()) {\r\n            return primitive.getAsString();\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (keyElement.isJsonNull()) {\r\n        return \"null\";\r\n    } else {\r\n        throw new AssertionError();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.MapTypeAdapterFactory.Adapter",
      "methodName": "keyToString",
      "parameterTypes": [
        "JsonElement"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    return type.getRawType() \u003d\u003d Number.class ? (TypeAdapter\u003cT\u003e) adapter : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.NumberTypeAdapter",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "private static TypeAdapterFactory newFactory(ToNumberStrategy toNumberStrategy) {\r\n    final NumberTypeAdapter adapter \u003d new NumberTypeAdapter(toNumberStrategy);\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            return type.getRawType() \u003d\u003d Number.class ? (TypeAdapter\u003cT\u003e) adapter : null;\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.NumberTypeAdapter",
      "methodName": "newFactory",
      "parameterTypes": [
        "ToNumberStrategy"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "public static TypeAdapterFactory getFactory(ToNumberStrategy toNumberStrategy) {\r\n    if (toNumberStrategy \u003d\u003d ToNumberPolicy.LAZILY_PARSED_NUMBER) {\r\n        return LAZILY_PARSED_NUMBER_FACTORY;\r\n    } else {\r\n        return newFactory(toNumberStrategy);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.NumberTypeAdapter",
      "methodName": "getFactory",
      "parameterTypes": [
        "ToNumberStrategy"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number read(JsonReader in) throws IOException {\r\n    JsonToken jsonToken \u003d in.peek();\r\n    switch(jsonToken) {\r\n        case NULL:\r\n            in.nextNull();\r\n            return null;\r\n        case NUMBER:\r\n        case STRING:\r\n            return toNumberStrategy.readNumber(in);\r\n        default:\r\n            throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken + \"; at path \" + in.getPath());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.NumberTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    out.value(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.NumberTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    if (type.getRawType() \u003d\u003d Object.class) {\r\n        return (TypeAdapter\u003cT\u003e) new ObjectTypeAdapter(gson, toNumberStrategy);\r\n    }\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ObjectTypeAdapter",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "private static TypeAdapterFactory newFactory(final ToNumberStrategy toNumberStrategy) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            if (type.getRawType() \u003d\u003d Object.class) {\r\n                return (TypeAdapter\u003cT\u003e) new ObjectTypeAdapter(gson, toNumberStrategy);\r\n            }\r\n            return null;\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ObjectTypeAdapter",
      "methodName": "newFactory",
      "parameterTypes": [
        "ToNumberStrategy"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "public static TypeAdapterFactory getFactory(ToNumberStrategy toNumberStrategy) {\r\n    if (toNumberStrategy \u003d\u003d ToNumberPolicy.DOUBLE) {\r\n        return DOUBLE_FACTORY;\r\n    } else {\r\n        return newFactory(toNumberStrategy);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ObjectTypeAdapter",
      "methodName": "getFactory",
      "parameterTypes": [
        "ToNumberStrategy"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "/**\r\n * Tries to begin reading a JSON array or JSON object, returning {@code null} if\r\n * the next element is neither of those.\r\n */\r\nprivate Object tryBeginNesting(JsonReader in, JsonToken peeked) throws IOException {\r\n    switch(peeked) {\r\n        case BEGIN_ARRAY:\r\n            in.beginArray();\r\n            return new ArrayList\u003c\u003e();\r\n        case BEGIN_OBJECT:\r\n            in.beginObject();\r\n            return new LinkedTreeMap\u003c\u003e();\r\n        default:\r\n            return null;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ObjectTypeAdapter",
      "methodName": "tryBeginNesting",
      "parameterTypes": [
        "JsonReader",
        "JsonToken"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "/**\r\n * Reads an {@code Object} which cannot have any nested elements\r\n */\r\nprivate Object readTerminal(JsonReader in, JsonToken peeked) throws IOException {\r\n    switch(peeked) {\r\n        case STRING:\r\n            return in.nextString();\r\n        case NUMBER:\r\n            return toNumberStrategy.readNumber(in);\r\n        case BOOLEAN:\r\n            return in.nextBoolean();\r\n        case NULL:\r\n            in.nextNull();\r\n            return null;\r\n        default:\r\n            // When read(JsonReader) is called with JsonReader in invalid state\r\n            throw new IllegalStateException(\"Unexpected token: \" + peeked);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ObjectTypeAdapter",
      "methodName": "readTerminal",
      "parameterTypes": [
        "JsonReader",
        "JsonToken"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Object read(JsonReader in) throws IOException {\r\n    // Either List or Map\r\n    Object current;\r\n    JsonToken peeked \u003d in.peek();\r\n    current \u003d tryBeginNesting(in, peeked);\r\n    if (current \u003d\u003d null) {\r\n        return readTerminal(in, peeked);\r\n    }\r\n    Deque\u003cObject\u003e stack \u003d new ArrayDeque\u003c\u003e();\r\n    while (true) {\r\n        while (in.hasNext()) {\r\n            String name \u003d null;\r\n            // Name is only used for JSON object members\r\n            if (current instanceof Map) {\r\n                name \u003d in.nextName();\r\n            }\r\n            peeked \u003d in.peek();\r\n            Object value \u003d tryBeginNesting(in, peeked);\r\n            boolean isNesting \u003d value !\u003d null;\r\n            if (value \u003d\u003d null) {\r\n                value \u003d readTerminal(in, peeked);\r\n            }\r\n            if (current instanceof List) {\r\n                @SuppressWarnings(\"unchecked\")\r\n                List\u003cObject\u003e list \u003d (List\u003cObject\u003e) current;\r\n                list.add(value);\r\n            } else {\r\n                @SuppressWarnings(\"unchecked\")\r\n                Map\u003cString, Object\u003e map \u003d (Map\u003cString, Object\u003e) current;\r\n                map.put(name, value);\r\n            }\r\n            if (isNesting) {\r\n                stack.addLast(current);\r\n                current \u003d value;\r\n            }\r\n        }\r\n        // End current element\r\n        if (current instanceof List) {\r\n            in.endArray();\r\n        } else {\r\n            in.endObject();\r\n        }\r\n        if (stack.isEmpty()) {\r\n            return current;\r\n        } else {\r\n            // Continue with enclosing element\r\n            current \u003d stack.removeLast();\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ObjectTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Object value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cObject\u003e typeAdapter \u003d (TypeAdapter\u003cObject\u003e) gson.getAdapter(value.getClass());\r\n    if (typeAdapter instanceof ObjectTypeAdapter) {\r\n        out.beginObject();\r\n        out.endObject();\r\n        return;\r\n    }\r\n    typeAdapter.write(out, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ObjectTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private boolean includeField(Field f, boolean serialize) {\r\n    return !excluder.excludeClass(f.getType(), serialize) \u0026\u0026 !excluder.excludeField(f, serialize);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
      "methodName": "includeField",
      "parameterTypes": [
        "Field",
        "boolean"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * first element holds the default name\r\n */\r\n@SuppressWarnings(\"MixedMutabilityReturnType\")\r\nprivate List\u003cString\u003e getFieldNames(Field f) {\r\n    SerializedName annotation \u003d f.getAnnotation(SerializedName.class);\r\n    if (annotation \u003d\u003d null) {\r\n        String name \u003d fieldNamingPolicy.translateName(f);\r\n        return Collections.singletonList(name);\r\n    }\r\n    String serializedName \u003d annotation.value();\r\n    String[] alternates \u003d annotation.alternate();\r\n    if (alternates.length \u003d\u003d 0) {\r\n        return Collections.singletonList(serializedName);\r\n    }\r\n    List\u003cString\u003e fieldNames \u003d new ArrayList\u003c\u003e(alternates.length + 1);\r\n    fieldNames.add(serializedName);\r\n    Collections.addAll(fieldNames, alternates);\r\n    return fieldNames;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
      "methodName": "getFieldNames",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "List\u003cString\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, final TypeToken\u003cT\u003e type) {\r\n    Class\u003c? super T\u003e raw \u003d type.getRawType();\r\n    if (!Object.class.isAssignableFrom(raw)) {\r\n        // it\u0027s a primitive!\r\n        return null;\r\n    }\r\n    FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n    if (filterResult \u003d\u003d FilterResult.BLOCK_ALL) {\r\n        throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \". Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n    boolean blockInaccessible \u003d filterResult \u003d\u003d FilterResult.BLOCK_INACCESSIBLE;\r\n    // If the type is actually a Java Record, we need to use the RecordAdapter instead. This will always be false\r\n    // on JVMs that do not support records.\r\n    if (ReflectionHelper.isRecord(raw)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e adapter \u003d (TypeAdapter\u003cT\u003e) new RecordAdapter\u003c\u003e(raw, getBoundFields(gson, type, raw, blockInaccessible, true), blockInaccessible);\r\n        return adapter;\r\n    }\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(type);\r\n    return new FieldReflectionAdapter\u003c\u003e(constructor, getBoundFields(gson, type, raw, blockInaccessible, false));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "private static \u003cM extends AccessibleObject \u0026 Member\u003e void checkAccessible(Object object, M member) {\r\n    if (!ReflectionAccessFilterHelper.canAccess(member, Modifier.isStatic(member.getModifiers()) ? null : object)) {\r\n        String memberDescription \u003d ReflectionHelper.getAccessibleObjectDescription(member, true);\r\n        throw new JsonIOException(memberDescription + \" is not accessible and ReflectionAccessFilter does not\" + \" permit making it accessible. Register a TypeAdapter for the declaring type, adjust the\" + \" access filter or increase the visibility of the element and its declaring type.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
      "methodName": "checkAccessible",
      "parameterTypes": [
        "Object",
        "M"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\nvoid write(JsonWriter writer, Object source) throws IOException, IllegalAccessException {\r\n    if (blockInaccessible) {\r\n        if (accessor \u003d\u003d null) {\r\n            checkAccessible(source, field);\r\n        } else {\r\n            // Note: This check might actually be redundant because access check for canonical\r\n            // constructor should have failed already\r\n            checkAccessible(source, accessor);\r\n        }\r\n    }\r\n    Object fieldValue;\r\n    if (accessor !\u003d null) {\r\n        try {\r\n            fieldValue \u003d accessor.invoke(source);\r\n        } catch (InvocationTargetException e) {\r\n            String accessorDescription \u003d ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n            throw new JsonIOException(\"Accessor \" + accessorDescription + \" threw exception\", e.getCause());\r\n        }\r\n    } else {\r\n        fieldValue \u003d field.get(source);\r\n    }\r\n    if (fieldValue \u003d\u003d source) {\r\n        // avoid direct recursion\r\n        return;\r\n    }\r\n    writer.name(serializedName);\r\n    writeTypeAdapter.write(writer, fieldValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\nvoid readIntoArray(JsonReader reader, int index, Object[] target) throws IOException, JsonParseException {\r\n    Object fieldValue \u003d typeAdapter.read(reader);\r\n    if (fieldValue \u003d\u003d null \u0026\u0026 isPrimitive) {\r\n        throw new JsonParseException(\"null is not allowed as value for record component \u0027\" + fieldName + \"\u0027\" + \" of primitive type; at path \" + reader.getPath());\r\n    }\r\n    target[index] \u003d fieldValue;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
      "methodName": "readIntoArray",
      "parameterTypes": [
        "JsonReader",
        "int",
        "Object[]"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\nvoid readIntoField(JsonReader reader, Object target) throws IOException, IllegalAccessException {\r\n    Object fieldValue \u003d typeAdapter.read(reader);\r\n    if (fieldValue !\u003d null || !isPrimitive) {\r\n        if (blockInaccessible) {\r\n            checkAccessible(target, field);\r\n        } else if (isStaticFinalField) {\r\n            // Reflection does not permit setting value of `static final` field, even after calling `setAccessible`\r\n            // Handle this here to avoid causing IllegalAccessException when calling `Field.set`\r\n            String fieldDescription \u003d ReflectionHelper.getAccessibleObjectDescription(field, false);\r\n            throw new JsonIOException(\"Cannot set value of \u0027static final\u0027 \" + fieldDescription);\r\n        }\r\n        field.set(target, fieldValue);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
      "methodName": "readIntoField",
      "parameterTypes": [
        "JsonReader",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private BoundField createBoundField(final Gson context, final Field field, final Method accessor, final String serializedName, final TypeToken\u003c?\u003e fieldType, final boolean serialize, final boolean blockInaccessible) {\r\n    final boolean isPrimitive \u003d Primitives.isPrimitive(fieldType.getRawType());\r\n    int modifiers \u003d field.getModifiers();\r\n    final boolean isStaticFinalField \u003d Modifier.isStatic(modifiers) \u0026\u0026 Modifier.isFinal(modifiers);\r\n    JsonAdapter annotation \u003d field.getAnnotation(JsonAdapter.class);\r\n    TypeAdapter\u003c?\u003e mapped \u003d null;\r\n    if (annotation !\u003d null) {\r\n        // This is not safe; requires that user has specified correct adapter class for @JsonAdapter\r\n        mapped \u003d jsonAdapterFactory.getTypeAdapter(constructorConstructor, context, fieldType, annotation, false);\r\n    }\r\n    final boolean jsonAdapterPresent \u003d mapped !\u003d null;\r\n    if (mapped \u003d\u003d null)\r\n        mapped \u003d context.getAdapter(fieldType);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final TypeAdapter\u003cObject\u003e typeAdapter \u003d (TypeAdapter\u003cObject\u003e) mapped;\r\n    final TypeAdapter\u003cObject\u003e writeTypeAdapter;\r\n    if (serialize) {\r\n        writeTypeAdapter \u003d jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper\u003c\u003e(context, typeAdapter, fieldType.getType());\r\n    } else {\r\n        // Will never actually be used, but we set it to avoid confusing nullness-analysis tools\r\n        writeTypeAdapter \u003d typeAdapter;\r\n    }\r\n    return new BoundField(serializedName, field) {\r\n\r\n        @Override\r\n        void write(JsonWriter writer, Object source) throws IOException, IllegalAccessException {\r\n            if (blockInaccessible) {\r\n                if (accessor \u003d\u003d null) {\r\n                    checkAccessible(source, field);\r\n                } else {\r\n                    // Note: This check might actually be redundant because access check for canonical\r\n                    // constructor should have failed already\r\n                    checkAccessible(source, accessor);\r\n                }\r\n            }\r\n            Object fieldValue;\r\n            if (accessor !\u003d null) {\r\n                try {\r\n                    fieldValue \u003d accessor.invoke(source);\r\n                } catch (InvocationTargetException e) {\r\n                    String accessorDescription \u003d ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                    throw new JsonIOException(\"Accessor \" + accessorDescription + \" threw exception\", e.getCause());\r\n                }\r\n            } else {\r\n                fieldValue \u003d field.get(source);\r\n            }\r\n            if (fieldValue \u003d\u003d source) {\r\n                // avoid direct recursion\r\n                return;\r\n            }\r\n            writer.name(serializedName);\r\n            writeTypeAdapter.write(writer, fieldValue);\r\n        }\r\n\r\n        @Override\r\n        void readIntoArray(JsonReader reader, int index, Object[] target) throws IOException, JsonParseException {\r\n            Object fieldValue \u003d typeAdapter.read(reader);\r\n            if (fieldValue \u003d\u003d null \u0026\u0026 isPrimitive) {\r\n                throw new JsonParseException(\"null is not allowed as value for record component \u0027\" + fieldName + \"\u0027\" + \" of primitive type; at path \" + reader.getPath());\r\n            }\r\n            target[index] \u003d fieldValue;\r\n        }\r\n\r\n        @Override\r\n        void readIntoField(JsonReader reader, Object target) throws IOException, IllegalAccessException {\r\n            Object fieldValue \u003d typeAdapter.read(reader);\r\n            if (fieldValue !\u003d null || !isPrimitive) {\r\n                if (blockInaccessible) {\r\n                    checkAccessible(target, field);\r\n                } else if (isStaticFinalField) {\r\n                    // Reflection does not permit setting value of `static final` field, even after calling `setAccessible`\r\n                    // Handle this here to avoid causing IllegalAccessException when calling `Field.set`\r\n                    String fieldDescription \u003d ReflectionHelper.getAccessibleObjectDescription(field, false);\r\n                    throw new JsonIOException(\"Cannot set value of \u0027static final\u0027 \" + fieldDescription);\r\n                }\r\n                field.set(target, fieldValue);\r\n            }\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
      "methodName": "createBoundField",
      "parameterTypes": [
        "Gson",
        "Field",
        "Method",
        "String",
        "TypeToken\u003c?\u003e",
        "boolean",
        "boolean"
      ],
      "returnType": "BoundField"
    }
  },
  {
    "sourceCode": "private static IllegalArgumentException createDuplicateFieldException(Class\u003c?\u003e declaringType, String duplicateName, Field field1, Field field2) {\r\n    throw new IllegalArgumentException(\"Class \" + declaringType.getName() + \" declares multiple JSON fields named \u0027\" + duplicateName + \"\u0027; conflict is caused\" + \" by fields \" + ReflectionHelper.fieldToString(field1) + \" and \" + ReflectionHelper.fieldToString(field2) + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
      "methodName": "createDuplicateFieldException",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "String",
        "Field",
        "Field"
      ],
      "returnType": "IllegalArgumentException"
    }
  },
  {
    "sourceCode": "private FieldsData getBoundFields(Gson context, TypeToken\u003c?\u003e type, Class\u003c?\u003e raw, boolean blockInaccessible, boolean isRecord) {\r\n    if (raw.isInterface()) {\r\n        return FieldsData.EMPTY;\r\n    }\r\n    Map\u003cString, BoundField\u003e deserializedFields \u003d new LinkedHashMap\u003c\u003e();\r\n    // For serialized fields use a Map to track duplicate field names; otherwise this could be a List\u003cBoundField\u003e instead\r\n    Map\u003cString, BoundField\u003e serializedFields \u003d new LinkedHashMap\u003c\u003e();\r\n    Class\u003c?\u003e originalRaw \u003d raw;\r\n    while (raw !\u003d Object.class) {\r\n        Field[] fields \u003d raw.getDeclaredFields();\r\n        // For inherited fields, check if access to their declaring class is allowed\r\n        if (raw !\u003d originalRaw \u0026\u0026 fields.length \u003e 0) {\r\n            FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n            if (filterResult \u003d\u003d FilterResult.BLOCK_ALL) {\r\n                throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\" + \" or adjust the access filter.\");\r\n            }\r\n            blockInaccessible \u003d filterResult \u003d\u003d FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n        for (Field field : fields) {\r\n            boolean serialize \u003d includeField(field, true);\r\n            boolean deserialize \u003d includeField(field, false);\r\n            if (!serialize \u0026\u0026 !deserialize) {\r\n                continue;\r\n            }\r\n            // The accessor method is only used for records. If the type is a record, we will read out values\r\n            // via its accessor method instead of via reflection. This way we will bypass the accessible restrictions\r\n            Method accessor \u003d null;\r\n            if (isRecord) {\r\n                // If there is a static field on a record, there will not be an accessor. Instead we will use the default\r\n                // field serialization logic, but for deserialization the field is excluded for simplicity. Note that Gson\r\n                // ignores static fields by default, but GsonBuilder.excludeFieldsWithModifiers can overwrite this.\r\n                if (Modifier.isStatic(field.getModifiers())) {\r\n                    deserialize \u003d false;\r\n                } else {\r\n                    accessor \u003d ReflectionHelper.getAccessor(raw, field);\r\n                    // If blockInaccessible, skip and perform access check later\r\n                    if (!blockInaccessible) {\r\n                        ReflectionHelper.makeAccessible(accessor);\r\n                    }\r\n                    // @SerializedName can be placed on accessor method, but it is not supported there\r\n                    // If field and method have annotation it is not easily possible to determine if accessor method\r\n                    // is implicit and has inherited annotation, or if it is explicitly declared with custom annotation\r\n                    if (accessor.getAnnotation(SerializedName.class) !\u003d null \u0026\u0026 field.getAnnotation(SerializedName.class) \u003d\u003d null) {\r\n                        String methodDescription \u003d ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                        throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\r\n                    }\r\n                }\r\n            }\r\n            // If blockInaccessible, skip and perform access check later\r\n            // For Records if the accessor method is used the field does not have to be made accessible\r\n            if (!blockInaccessible \u0026\u0026 accessor \u003d\u003d null) {\r\n                ReflectionHelper.makeAccessible(field);\r\n            }\r\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\r\n            List\u003cString\u003e fieldNames \u003d getFieldNames(field);\r\n            String serializedName \u003d fieldNames.get(0);\r\n            BoundField boundField \u003d createBoundField(context, field, accessor, serializedName, TypeToken.get(fieldType), serialize, blockInaccessible);\r\n            if (deserialize) {\r\n                for (String name : fieldNames) {\r\n                    BoundField replaced \u003d deserializedFields.put(name, boundField);\r\n                    if (replaced !\u003d null) {\r\n                        throw createDuplicateFieldException(originalRaw, name, replaced.field, field);\r\n                    }\r\n                }\r\n            }\r\n            if (serialize) {\r\n                BoundField replaced \u003d serializedFields.put(serializedName, boundField);\r\n                if (replaced !\u003d null) {\r\n                    throw createDuplicateFieldException(originalRaw, serializedName, replaced.field, field);\r\n                }\r\n            }\r\n        }\r\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\r\n        raw \u003d type.getRawType();\r\n    }\r\n    return new FieldsData(deserializedFields, new ArrayList\u003c\u003e(serializedFields.values()));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
      "methodName": "getBoundFields",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003c?\u003e",
        "Class\u003c?\u003e",
        "boolean",
        "boolean"
      ],
      "returnType": "FieldsData"
    }
  },
  {
    "sourceCode": "/**\r\n * Read this field value from the source, and append its JSON value to the writer\r\n */\r\nabstract void write(JsonWriter writer, Object source) throws IOException, IllegalAccessException;",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Read the value into the target array, used to provide constructor arguments for records\r\n */\r\nabstract void readIntoArray(JsonReader reader, int index, Object[] target) throws IOException, JsonParseException;",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField",
      "methodName": "readIntoArray",
      "parameterTypes": [
        "JsonReader",
        "int",
        "Object[]"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Read the value from the reader, and set it on the corresponding field on target via reflection\r\n */\r\nabstract void readIntoField(JsonReader reader, Object target) throws IOException, IllegalAccessException;",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField",
      "methodName": "readIntoField",
      "parameterTypes": [
        "JsonReader",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginObject();\r\n    try {\r\n        for (BoundField boundField : fieldsData.serializedFields) {\r\n            boundField.write(out, value);\r\n        }\r\n    } catch (IllegalAccessException e) {\r\n        throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n    }\r\n    out.endObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    A accumulator \u003d createAccumulator();\r\n    Map\u003cString, BoundField\u003e deserializedFields \u003d fieldsData.deserializedFields;\r\n    try {\r\n        in.beginObject();\r\n        while (in.hasNext()) {\r\n            String name \u003d in.nextName();\r\n            BoundField field \u003d deserializedFields.get(name);\r\n            if (field \u003d\u003d null) {\r\n                in.skipValue();\r\n            } else {\r\n                readField(accumulator, in, field);\r\n            }\r\n        }\r\n    } catch (IllegalStateException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IllegalAccessException e) {\r\n        throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n    }\r\n    in.endObject();\r\n    return finalize(accumulator);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Create the Object that will be used to collect each field value\r\n */\r\nabstract A createAccumulator();",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter",
      "methodName": "createAccumulator",
      "parameterTypes": [],
      "returnType": "A"
    }
  },
  {
    "sourceCode": "/**\r\n * Read a single BoundField into the accumulator. The JsonReader will be pointed at the\r\n * start of the value for the BoundField to read from.\r\n */\r\nabstract void readField(A accumulator, JsonReader in, BoundField field) throws IllegalAccessException, IOException;",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter",
      "methodName": "readField",
      "parameterTypes": [
        "A",
        "JsonReader",
        "BoundField"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Convert the accumulator to a final instance of T.\r\n */\r\nabstract T finalize(A accumulator);",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter",
      "methodName": "finalize",
      "parameterTypes": [
        "A"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\nT createAccumulator() {\r\n    return constructor.construct();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.FieldReflectionAdapter",
      "methodName": "createAccumulator",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\nvoid readField(T accumulator, JsonReader in, BoundField field) throws IllegalAccessException, IOException {\r\n    field.readIntoField(in, accumulator);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.FieldReflectionAdapter",
      "methodName": "readField",
      "parameterTypes": [
        "T",
        "JsonReader",
        "BoundField"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\nT finalize(T accumulator) {\r\n    return accumulator;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.FieldReflectionAdapter",
      "methodName": "finalize",
      "parameterTypes": [
        "T"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "private static Map\u003cClass\u003c?\u003e, Object\u003e primitiveDefaults() {\r\n    Map\u003cClass\u003c?\u003e, Object\u003e zeroes \u003d new HashMap\u003c\u003e();\r\n    zeroes.put(byte.class, (byte) 0);\r\n    zeroes.put(short.class, (short) 0);\r\n    zeroes.put(int.class, 0);\r\n    zeroes.put(long.class, 0L);\r\n    zeroes.put(float.class, 0F);\r\n    zeroes.put(double.class, 0D);\r\n    zeroes.put(char.class, \u0027\\0\u0027);\r\n    zeroes.put(boolean.class, false);\r\n    return zeroes;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.RecordAdapter",
      "methodName": "primitiveDefaults",
      "parameterTypes": [],
      "returnType": "Map\u003cClass\u003c?\u003e, Object\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\nObject[] createAccumulator() {\r\n    return constructorArgsDefaults.clone();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.RecordAdapter",
      "methodName": "createAccumulator",
      "parameterTypes": [],
      "returnType": "Object[]"
    }
  },
  {
    "sourceCode": "@Override\r\nvoid readField(Object[] accumulator, JsonReader in, BoundField field) throws IOException {\r\n    // Obtain the component index from the name of the field backing it\r\n    Integer componentIndex \u003d componentIndices.get(field.fieldName);\r\n    if (componentIndex \u003d\u003d null) {\r\n        throw new IllegalStateException(\"Could not find the index in the constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" for field with name \u0027\" + field.fieldName + \"\u0027,\" + \" unable to determine which argument in the constructor the field corresponds\" + \" to. This is unexpected behavior, as we expect the RecordComponents to have the\" + \" same names as the fields in the Java class, and that the order of the\" + \" RecordComponents is the same as the order of the canonical constructor parameters.\");\r\n    }\r\n    field.readIntoArray(in, componentIndex, accumulator);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.RecordAdapter",
      "methodName": "readField",
      "parameterTypes": [
        "Object[]",
        "JsonReader",
        "BoundField"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\nT finalize(Object[] accumulator) {\r\n    try {\r\n        return constructor.newInstance(accumulator);\r\n    } catch (IllegalAccessException e) {\r\n        throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n    }// Note: InstantiationException should be impossible because record class is not abstract;\r\n    // IllegalArgumentException should not be possible unless a bad adapter returns objects of the wrong type\r\n     catch (InstantiationException | IllegalArgumentException e) {\r\n        throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with args \" + Arrays.toString(accumulator), e);\r\n    } catch (InvocationTargetException e) {\r\n        // TODO: JsonParseException ?\r\n        throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with args \" + Arrays.toString(accumulator), e.getCause());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.RecordAdapter",
      "methodName": "finalize",
      "parameterTypes": [
        "Object[]"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the adapter used for serialization, might be {@code this} or another adapter.\r\n * That other adapter might itself also be a {@code SerializationDelegatingTypeAdapter}.\r\n */\r\npublic abstract TypeAdapter\u003cT\u003e getSerializationDelegate();",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.SerializationDelegatingTypeAdapter",
      "methodName": "getSerializationDelegate",
      "parameterTypes": [],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    if (deserializer \u003d\u003d null) {\r\n        return delegate().read(in);\r\n    }\r\n    JsonElement value \u003d Streams.parse(in);\r\n    if (nullSafe \u0026\u0026 value.isJsonNull()) {\r\n        return null;\r\n    }\r\n    return deserializer.deserialize(value, typeToken.getType(), context);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    if (serializer \u003d\u003d null) {\r\n        delegate().write(out, value);\r\n        return;\r\n    }\r\n    if (nullSafe \u0026\u0026 value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    JsonElement tree \u003d serializer.serialize(value, typeToken.getType(), context);\r\n    Streams.write(tree, out);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private TypeAdapter\u003cT\u003e delegate() {\r\n    // A race might lead to `delegate` being assigned by multiple threads but the last assignment will stick\r\n    TypeAdapter\u003cT\u003e d \u003d delegate;\r\n    return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(skipPastForGetDelegateAdapter, typeToken));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter",
      "methodName": "delegate",
      "parameterTypes": [],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the type adapter which is used for serialization. Returns {@code this}\r\n * if this {@code TreeTypeAdapter} has a {@link #serializer}; otherwise returns\r\n * the delegate.\r\n */\r\n@Override\r\npublic TypeAdapter\u003cT\u003e getSerializationDelegate() {\r\n    return serializer !\u003d null ? this : delegate();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter",
      "methodName": "getSerializationDelegate",
      "parameterTypes": [],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a new factory that will match each type against {@code exactType}.\r\n */\r\npublic static TypeAdapterFactory newFactory(TypeToken\u003c?\u003e exactType, Object typeAdapter) {\r\n    return new SingleTypeFactory(typeAdapter, exactType, false, null);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter",
      "methodName": "newFactory",
      "parameterTypes": [
        "TypeToken\u003c?\u003e",
        "Object"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a new factory that will match each type and its raw type against\r\n * {@code exactType}.\r\n */\r\npublic static TypeAdapterFactory newFactoryWithMatchRawType(TypeToken\u003c?\u003e exactType, Object typeAdapter) {\r\n    // only bother matching raw types if exact type is a raw type\r\n    boolean matchRawType \u003d exactType.getType() \u003d\u003d exactType.getRawType();\r\n    return new SingleTypeFactory(typeAdapter, exactType, matchRawType, null);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter",
      "methodName": "newFactoryWithMatchRawType",
      "parameterTypes": [
        "TypeToken\u003c?\u003e",
        "Object"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a new factory that will match each type\u0027s raw type for assignability\r\n * to {@code hierarchyType}.\r\n */\r\npublic static TypeAdapterFactory newTypeHierarchyFactory(Class\u003c?\u003e hierarchyType, Object typeAdapter) {\r\n    return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter",
      "methodName": "newTypeHierarchyFactory",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "Object"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "// guarded by typeToken.equals() call\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    boolean matches \u003d exactType !\u003d null ? exactType.equals(type) || (matchRawType \u0026\u0026 exactType.getType() \u003d\u003d type.getRawType()) : hierarchyType.isAssignableFrom(type.getRawType());\r\n    return matches ? new TreeTypeAdapter\u003c\u003e((JsonSerializer\u003cT\u003e) serializer, (JsonDeserializer\u003cT\u003e) deserializer, gson, type, this) : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter.SingleTypeFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Object src) {\r\n    return gson.toJsonTree(src);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter.GsonContextImpl",
      "methodName": "serialize",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Object src, Type typeOfSrc) {\r\n    return gson.toJsonTree(src, typeOfSrc);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter.GsonContextImpl",
      "methodName": "serialize",
      "parameterTypes": [
        "Object",
        "Type"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\n@SuppressWarnings({ \"unchecked\", \"TypeParameterUnusedInFormals\" })\r\npublic \u003cR\u003e R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\r\n    return gson.fromJson(json, typeOfT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TreeTypeAdapter.GsonContextImpl",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type"
      ],
      "returnType": "R"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    return delegate.read(in);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    // Order of preference for choosing type adapters\r\n    // First preference: a type adapter registered for the runtime type\r\n    // Second preference: a type adapter registered for the declared type\r\n    // Third preference: reflective type adapter for the runtime type (if it is a subclass of the declared type)\r\n    // Fourth preference: reflective type adapter for the declared type\r\n    TypeAdapter\u003cT\u003e chosen \u003d delegate;\r\n    Type runtimeType \u003d getRuntimeTypeIfMoreSpecific(type, value);\r\n    if (runtimeType !\u003d type) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e runtimeTypeAdapter \u003d (TypeAdapter\u003cT\u003e) context.getAdapter(TypeToken.get(runtimeType));\r\n        // For backward compatibility only check ReflectiveTypeAdapterFactory.Adapter here but not any other\r\n        // wrapping adapters, see https://github.com/google/gson/pull/1787#issuecomment-1222175189\r\n        if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {\r\n            // The user registered a type adapter for the runtime type, so we will use that\r\n            chosen \u003d runtimeTypeAdapter;\r\n        } else if (!isReflective(delegate)) {\r\n            // The user registered a type adapter for Base class, so we prefer it over the\r\n            // reflective type adapter for the runtime type\r\n            chosen \u003d delegate;\r\n        } else {\r\n            // Use the type adapter for runtime type\r\n            chosen \u003d runtimeTypeAdapter;\r\n        }\r\n    }\r\n    chosen.write(out, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns whether the type adapter uses reflection.\r\n *\r\n * @param typeAdapter the type adapter to check.\r\n */\r\nprivate static boolean isReflective(TypeAdapter\u003c?\u003e typeAdapter) {\r\n    // Run this in loop in case multiple delegating adapters are nested\r\n    while (typeAdapter instanceof SerializationDelegatingTypeAdapter) {\r\n        TypeAdapter\u003c?\u003e delegate \u003d ((SerializationDelegatingTypeAdapter\u003c?\u003e) typeAdapter).getSerializationDelegate();\r\n        // Break if adapter does not delegate serialization\r\n        if (delegate \u003d\u003d typeAdapter) {\r\n            break;\r\n        }\r\n        typeAdapter \u003d delegate;\r\n    }\r\n    return typeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper",
      "methodName": "isReflective",
      "parameterTypes": [
        "TypeAdapter\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Finds a compatible runtime type if it is more specific\r\n */\r\nprivate static Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\r\n    if (value !\u003d null \u0026\u0026 (type instanceof Class\u003c?\u003e || type instanceof TypeVariable\u003c?\u003e)) {\r\n        type \u003d value.getClass();\r\n    }\r\n    return type;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper",
      "methodName": "getRuntimeTypeIfMoreSpecific",
      "parameterTypes": [
        "Type",
        "Object"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Class value) throws IOException {\r\n    throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \" + value.getName() + \". Forgot to register a type adapter?\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"java-lang-class-unsupported\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Class"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Class read(JsonReader in) throws IOException {\r\n    throw new UnsupportedOperationException(\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"java-lang-class-unsupported\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Class"
    }
  },
  {
    "sourceCode": "@Override\r\npublic BitSet read(JsonReader in) throws IOException {\r\n    BitSet bitset \u003d new BitSet();\r\n    in.beginArray();\r\n    int i \u003d 0;\r\n    JsonToken tokenType \u003d in.peek();\r\n    while (tokenType !\u003d JsonToken.END_ARRAY) {\r\n        boolean set;\r\n        switch(tokenType) {\r\n            case NUMBER:\r\n            case STRING:\r\n                int intValue \u003d in.nextInt();\r\n                if (intValue \u003d\u003d 0) {\r\n                    set \u003d false;\r\n                } else if (intValue \u003d\u003d 1) {\r\n                    set \u003d true;\r\n                } else {\r\n                    throw new JsonSyntaxException(\"Invalid bitset value \" + intValue + \", expected 0 or 1; at path \" + in.getPreviousPath());\r\n                }\r\n                break;\r\n            case BOOLEAN:\r\n                set \u003d in.nextBoolean();\r\n                break;\r\n            default:\r\n                throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType + \"; at path \" + in.getPath());\r\n        }\r\n        if (set) {\r\n            bitset.set(i);\r\n        }\r\n        ++i;\r\n        tokenType \u003d in.peek();\r\n    }\r\n    in.endArray();\r\n    return bitset;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "BitSet"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, BitSet src) throws IOException {\r\n    out.beginArray();\r\n    for (int i \u003d 0, length \u003d src.length(); i \u003c length; i++) {\r\n        int value \u003d src.get(i) ? 1 : 0;\r\n        out.value(value);\r\n    }\r\n    out.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "BitSet"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Boolean read(JsonReader in) throws IOException {\r\n    JsonToken peek \u003d in.peek();\r\n    if (peek \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    } else if (peek \u003d\u003d JsonToken.STRING) {\r\n        // support strings for compatibility with GSON 1.7\r\n        return Boolean.parseBoolean(in.nextString());\r\n    }\r\n    return in.nextBoolean();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Boolean value) throws IOException {\r\n    out.value(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Boolean read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return Boolean.valueOf(in.nextString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Boolean value) throws IOException {\r\n    out.value(value \u003d\u003d null ? \"null\" : value.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    int intValue;\r\n    try {\r\n        intValue \u003d in.nextInt();\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(e);\r\n    }\r\n    // Allow up to 255 to support unsigned values\r\n    if (intValue \u003e 255 || intValue \u003c Byte.MIN_VALUE) {\r\n        throw new JsonSyntaxException(\"Lossy conversion from \" + intValue + \" to byte; at path \" + in.getPreviousPath());\r\n    }\r\n    return (byte) intValue;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        out.value(value.byteValue());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    int intValue;\r\n    try {\r\n        intValue \u003d in.nextInt();\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(e);\r\n    }\r\n    // Allow up to 65535 to support unsigned values\r\n    if (intValue \u003e 65535 || intValue \u003c Short.MIN_VALUE) {\r\n        throw new JsonSyntaxException(\"Lossy conversion from \" + intValue + \" to short; at path \" + in.getPreviousPath());\r\n    }\r\n    return (short) intValue;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        out.value(value.shortValue());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    try {\r\n        return in.nextInt();\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        out.value(value.intValue());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic AtomicInteger read(JsonReader in) throws IOException {\r\n    try {\r\n        return new AtomicInteger(in.nextInt());\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "AtomicInteger"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, AtomicInteger value) throws IOException {\r\n    out.value(value.get());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "AtomicInteger"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic AtomicBoolean read(JsonReader in) throws IOException {\r\n    return new AtomicBoolean(in.nextBoolean());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "AtomicBoolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, AtomicBoolean value) throws IOException {\r\n    out.value(value.get());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "AtomicBoolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic AtomicIntegerArray read(JsonReader in) throws IOException {\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    in.beginArray();\r\n    while (in.hasNext()) {\r\n        try {\r\n            int integer \u003d in.nextInt();\r\n            list.add(integer);\r\n        } catch (NumberFormatException e) {\r\n            throw new JsonSyntaxException(e);\r\n        }\r\n    }\r\n    in.endArray();\r\n    int length \u003d list.size();\r\n    AtomicIntegerArray array \u003d new AtomicIntegerArray(length);\r\n    for (int i \u003d 0; i \u003c length; ++i) {\r\n        array.set(i, list.get(i));\r\n    }\r\n    return array;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "AtomicIntegerArray"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\r\n    out.beginArray();\r\n    for (int i \u003d 0, length \u003d value.length(); i \u003c length; i++) {\r\n        out.value(value.get(i));\r\n    }\r\n    out.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "AtomicIntegerArray"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    try {\r\n        return in.nextLong();\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        out.value(value.longValue());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return (float) in.nextDouble();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        // For backward compatibility don\u0027t call `JsonWriter.value(float)` because that method has\r\n        // been newly added and not all custom JsonWriter implementations might override it yet\r\n        Number floatNumber \u003d value instanceof Float ? value : value.floatValue();\r\n        out.value(floatNumber);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return in.nextDouble();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        out.value(value.doubleValue());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Character read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String str \u003d in.nextString();\r\n    if (str.length() !\u003d 1) {\r\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str + \"; at \" + in.getPreviousPath());\r\n    }\r\n    return str.charAt(0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Character"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Character value) throws IOException {\r\n    out.value(value \u003d\u003d null ? null : String.valueOf(value));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Character"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String read(JsonReader in) throws IOException {\r\n    JsonToken peek \u003d in.peek();\r\n    if (peek \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    /* coerce booleans to strings for backwards compatibility */\r\n    if (peek \u003d\u003d JsonToken.BOOLEAN) {\r\n        return Boolean.toString(in.nextBoolean());\r\n    }\r\n    return in.nextString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, String value) throws IOException {\r\n    out.value(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic BigDecimal read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String s \u003d in.nextString();\r\n    try {\r\n        return NumberLimits.parseBigDecimal(s);\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as BigDecimal; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "BigDecimal"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, BigDecimal value) throws IOException {\r\n    out.value(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "BigDecimal"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic BigInteger read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String s \u003d in.nextString();\r\n    try {\r\n        return NumberLimits.parseBigInteger(s);\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as BigInteger; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "BigInteger"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, BigInteger value) throws IOException {\r\n    out.value(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "BigInteger"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Normally users should not be able to access and deserialize LazilyParsedNumber because\r\n// it is an internal type, but implement this nonetheless in case there are legit corner\r\n// cases where this is possible\r\n@Override\r\npublic LazilyParsedNumber read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return new LazilyParsedNumber(in.nextString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "LazilyParsedNumber"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, LazilyParsedNumber value) throws IOException {\r\n    out.value(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "LazilyParsedNumber"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic StringBuilder read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return new StringBuilder(in.nextString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "StringBuilder"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, StringBuilder value) throws IOException {\r\n    out.value(value \u003d\u003d null ? null : value.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "StringBuilder"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic StringBuffer read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return new StringBuffer(in.nextString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "StringBuffer"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, StringBuffer value) throws IOException {\r\n    out.value(value \u003d\u003d null ? null : value.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "StringBuffer"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic URL read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String nextString \u003d in.nextString();\r\n    return \"null\".equals(nextString) ? null : new URL(nextString);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "URL"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, URL value) throws IOException {\r\n    out.value(value \u003d\u003d null ? null : value.toExternalForm());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "URL"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic URI read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    try {\r\n        String nextString \u003d in.nextString();\r\n        return \"null\".equals(nextString) ? null : new URI(nextString);\r\n    } catch (URISyntaxException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "URI"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, URI value) throws IOException {\r\n    out.value(value \u003d\u003d null ? null : value.toASCIIString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "URI"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic InetAddress read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    // regrettably, this should have included both the host name and the host address\r\n    // For compatibility, we use InetAddress.getByName rather than the possibly-better\r\n    // .getAllByName\r\n    @SuppressWarnings(\"AddressSelection\")\r\n    InetAddress addr \u003d InetAddress.getByName(in.nextString());\r\n    return addr;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "InetAddress"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, InetAddress value) throws IOException {\r\n    out.value(value \u003d\u003d null ? null : value.getHostAddress());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "InetAddress"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic UUID read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String s \u003d in.nextString();\r\n    try {\r\n        return java.util.UUID.fromString(s);\r\n    } catch (IllegalArgumentException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as UUID; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "UUID"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, UUID value) throws IOException {\r\n    out.value(value \u003d\u003d null ? null : value.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "UUID"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Currency read(JsonReader in) throws IOException {\r\n    String s \u003d in.nextString();\r\n    try {\r\n        return Currency.getInstance(s);\r\n    } catch (IllegalArgumentException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as Currency; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Currency"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Currency value) throws IOException {\r\n    out.value(value.getCurrencyCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Currency"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Calendar read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    in.beginObject();\r\n    int year \u003d 0;\r\n    int month \u003d 0;\r\n    int dayOfMonth \u003d 0;\r\n    int hourOfDay \u003d 0;\r\n    int minute \u003d 0;\r\n    int second \u003d 0;\r\n    while (in.peek() !\u003d JsonToken.END_OBJECT) {\r\n        String name \u003d in.nextName();\r\n        int value \u003d in.nextInt();\r\n        if (YEAR.equals(name)) {\r\n            year \u003d value;\r\n        } else if (MONTH.equals(name)) {\r\n            month \u003d value;\r\n        } else if (DAY_OF_MONTH.equals(name)) {\r\n            dayOfMonth \u003d value;\r\n        } else if (HOUR_OF_DAY.equals(name)) {\r\n            hourOfDay \u003d value;\r\n        } else if (MINUTE.equals(name)) {\r\n            minute \u003d value;\r\n        } else if (SECOND.equals(name)) {\r\n            second \u003d value;\r\n        }\r\n    }\r\n    in.endObject();\r\n    return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Calendar"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Calendar value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginObject();\r\n    out.name(YEAR);\r\n    out.value(value.get(Calendar.YEAR));\r\n    out.name(MONTH);\r\n    out.value(value.get(Calendar.MONTH));\r\n    out.name(DAY_OF_MONTH);\r\n    out.value(value.get(Calendar.DAY_OF_MONTH));\r\n    out.name(HOUR_OF_DAY);\r\n    out.value(value.get(Calendar.HOUR_OF_DAY));\r\n    out.name(MINUTE);\r\n    out.value(value.get(Calendar.MINUTE));\r\n    out.name(SECOND);\r\n    out.value(value.get(Calendar.SECOND));\r\n    out.endObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Calendar"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Locale read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String locale \u003d in.nextString();\r\n    StringTokenizer tokenizer \u003d new StringTokenizer(locale, \"_\");\r\n    String language \u003d null;\r\n    String country \u003d null;\r\n    String variant \u003d null;\r\n    if (tokenizer.hasMoreElements()) {\r\n        language \u003d tokenizer.nextToken();\r\n    }\r\n    if (tokenizer.hasMoreElements()) {\r\n        country \u003d tokenizer.nextToken();\r\n    }\r\n    if (tokenizer.hasMoreElements()) {\r\n        variant \u003d tokenizer.nextToken();\r\n    }\r\n    if (country \u003d\u003d null \u0026\u0026 variant \u003d\u003d null) {\r\n        return new Locale(language);\r\n    } else if (variant \u003d\u003d null) {\r\n        return new Locale(language, country);\r\n    } else {\r\n        return new Locale(language, country, variant);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Locale"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Locale value) throws IOException {\r\n    out.value(value \u003d\u003d null ? null : value.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Locale"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tries to begin reading a JSON array or JSON object, returning {@code null} if\r\n * the next element is neither of those.\r\n */\r\nprivate JsonElement tryBeginNesting(JsonReader in, JsonToken peeked) throws IOException {\r\n    switch(peeked) {\r\n        case BEGIN_ARRAY:\r\n            in.beginArray();\r\n            return new JsonArray();\r\n        case BEGIN_OBJECT:\r\n            in.beginObject();\r\n            return new JsonObject();\r\n        default:\r\n            return null;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "tryBeginNesting",
      "parameterTypes": [
        "JsonReader",
        "JsonToken"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Reads a {@link JsonElement} which cannot have any nested elements\r\n */\r\nprivate JsonElement readTerminal(JsonReader in, JsonToken peeked) throws IOException {\r\n    switch(peeked) {\r\n        case STRING:\r\n            return new JsonPrimitive(in.nextString());\r\n        case NUMBER:\r\n            String number \u003d in.nextString();\r\n            return new JsonPrimitive(new LazilyParsedNumber(number));\r\n        case BOOLEAN:\r\n            return new JsonPrimitive(in.nextBoolean());\r\n        case NULL:\r\n            in.nextNull();\r\n            return JsonNull.INSTANCE;\r\n        default:\r\n            // When read(JsonReader) is called with JsonReader in invalid state\r\n            throw new IllegalStateException(\"Unexpected token: \" + peeked);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "readTerminal",
      "parameterTypes": [
        "JsonReader",
        "JsonToken"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement read(JsonReader in) throws IOException {\r\n    if (in instanceof JsonTreeReader) {\r\n        return ((JsonTreeReader) in).nextJsonElement();\r\n    }\r\n    // Either JsonArray or JsonObject\r\n    JsonElement current;\r\n    JsonToken peeked \u003d in.peek();\r\n    current \u003d tryBeginNesting(in, peeked);\r\n    if (current \u003d\u003d null) {\r\n        return readTerminal(in, peeked);\r\n    }\r\n    Deque\u003cJsonElement\u003e stack \u003d new ArrayDeque\u003c\u003e();\r\n    while (true) {\r\n        while (in.hasNext()) {\r\n            String name \u003d null;\r\n            // Name is only used for JSON object members\r\n            if (current instanceof JsonObject) {\r\n                name \u003d in.nextName();\r\n            }\r\n            peeked \u003d in.peek();\r\n            JsonElement value \u003d tryBeginNesting(in, peeked);\r\n            boolean isNesting \u003d value !\u003d null;\r\n            if (value \u003d\u003d null) {\r\n                value \u003d readTerminal(in, peeked);\r\n            }\r\n            if (current instanceof JsonArray) {\r\n                ((JsonArray) current).add(value);\r\n            } else {\r\n                ((JsonObject) current).add(name, value);\r\n            }\r\n            if (isNesting) {\r\n                stack.addLast(current);\r\n                current \u003d value;\r\n            }\r\n        }\r\n        // End current element\r\n        if (current instanceof JsonArray) {\r\n            in.endArray();\r\n        } else {\r\n            in.endObject();\r\n        }\r\n        if (stack.isEmpty()) {\r\n            return current;\r\n        } else {\r\n            // Continue with enclosing element\r\n            current \u003d stack.removeLast();\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, JsonElement value) throws IOException {\r\n    if (value \u003d\u003d null || value.isJsonNull()) {\r\n        out.nullValue();\r\n    } else if (value.isJsonPrimitive()) {\r\n        JsonPrimitive primitive \u003d value.getAsJsonPrimitive();\r\n        if (primitive.isNumber()) {\r\n            out.value(primitive.getAsNumber());\r\n        } else if (primitive.isBoolean()) {\r\n            out.value(primitive.getAsBoolean());\r\n        } else {\r\n            out.value(primitive.getAsString());\r\n        }\r\n    } else if (value.isJsonArray()) {\r\n        out.beginArray();\r\n        for (JsonElement e : value.getAsJsonArray()) {\r\n            write(out, e);\r\n        }\r\n        out.endArray();\r\n    } else if (value.isJsonObject()) {\r\n        out.beginObject();\r\n        for (Map.Entry\u003cString, JsonElement\u003e e : value.getAsJsonObject().entrySet()) {\r\n            out.name(e.getKey());\r\n            write(out, e.getValue());\r\n        }\r\n        out.endObject();\r\n    } else {\r\n        throw new IllegalArgumentException(\"Couldn\u0027t write \" + value.getClass());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "JsonElement"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Field[] run() {\r\n    Field[] fields \u003d classOfT.getDeclaredFields();\r\n    ArrayList\u003cField\u003e constantFieldsList \u003d new ArrayList\u003c\u003e(fields.length);\r\n    for (Field f : fields) {\r\n        if (f.isEnumConstant()) {\r\n            constantFieldsList.add(f);\r\n        }\r\n    }\r\n    Field[] constantFields \u003d constantFieldsList.toArray(new Field[0]);\r\n    AccessibleObject.setAccessible(constantFields, true);\r\n    return constantFields;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters.EnumTypeAdapter",
      "methodName": "run",
      "parameterTypes": [],
      "returnType": "Field[]"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String key \u003d in.nextString();\r\n    T constant \u003d nameToConstant.get(key);\r\n    return (constant \u003d\u003d null) ? stringToConstant.get(key) : constant;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters.EnumTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    out.value(value \u003d\u003d null ? null : constantToName.get(value));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters.EnumTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    if (!Enum.class.isAssignableFrom(rawType) || rawType \u003d\u003d Enum.class) {\r\n        return null;\r\n    }\r\n    if (!rawType.isEnum()) {\r\n        // handle anonymous subclasses\r\n        rawType \u003d rawType.getSuperclass();\r\n    }\r\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\n    TypeAdapter\u003cT\u003e adapter \u003d (TypeAdapter\u003cT\u003e) new EnumTypeAdapter(rawType);\r\n    return adapter;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "// we use a runtime check to make sure the \u0027T\u0027s equal\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    return typeToken.equals(type) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "public static \u003cTT\u003e TypeAdapterFactory newFactory(final TypeToken\u003cTT\u003e type, final TypeAdapter\u003cTT\u003e typeAdapter) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the \u0027T\u0027s equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n            return typeToken.equals(type) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "newFactory",
      "parameterTypes": [
        "TypeToken\u003cTT\u003e",
        "TypeAdapter\u003cTT\u003e"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "// we use a runtime check to make sure the \u0027T\u0027s equal\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    return typeToken.getRawType() \u003d\u003d type ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"Factory[type\u003d\" + type.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public static \u003cTT\u003e TypeAdapterFactory newFactory(final Class\u003cTT\u003e type, final TypeAdapter\u003cTT\u003e typeAdapter) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the \u0027T\u0027s equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n            return typeToken.getRawType() \u003d\u003d type ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[type\u003d\" + type.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "newFactory",
      "parameterTypes": [
        "Class\u003cTT\u003e",
        "TypeAdapter\u003cTT\u003e"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "// we use a runtime check to make sure the \u0027T\u0027s equal\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    return (rawType \u003d\u003d unboxed || rawType \u003d\u003d boxed) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"Factory[type\u003d\" + boxed.getName() + \"+\" + unboxed.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public static \u003cTT\u003e TypeAdapterFactory newFactory(final Class\u003cTT\u003e unboxed, final Class\u003cTT\u003e boxed, final TypeAdapter\u003c? super TT\u003e typeAdapter) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the \u0027T\u0027s equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n            Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n            return (rawType \u003d\u003d unboxed || rawType \u003d\u003d boxed) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[type\u003d\" + boxed.getName() + \"+\" + unboxed.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "newFactory",
      "parameterTypes": [
        "Class\u003cTT\u003e",
        "Class\u003cTT\u003e",
        "TypeAdapter\u003c? super TT\u003e"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "// we use a runtime check to make sure the \u0027T\u0027s equal\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    return (rawType \u003d\u003d base || rawType \u003d\u003d sub) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"Factory[type\u003d\" + base.getName() + \"+\" + sub.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public static \u003cTT\u003e TypeAdapterFactory newFactoryForMultipleTypes(final Class\u003cTT\u003e base, final Class\u003c? extends TT\u003e sub, final TypeAdapter\u003c? super TT\u003e typeAdapter) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the \u0027T\u0027s equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n            Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n            return (rawType \u003d\u003d base || rawType \u003d\u003d sub) ? (TypeAdapter\u003cT\u003e) typeAdapter : null;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[type\u003d\" + base.getName() + \"+\" + sub.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "newFactoryForMultipleTypes",
      "parameterTypes": [
        "Class\u003cTT\u003e",
        "Class\u003c? extends TT\u003e",
        "TypeAdapter\u003c? super TT\u003e"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T1 value) throws IOException {\r\n    typeAdapter.write(out, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T1"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T1 read(JsonReader in) throws IOException {\r\n    T1 result \u003d typeAdapter.read(in);\r\n    if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\r\n        throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T1"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT2\u003e TypeAdapter\u003cT2\u003e create(Gson gson, TypeToken\u003cT2\u003e typeToken) {\r\n    final Class\u003c? super T2\u003e requestedType \u003d typeToken.getRawType();\r\n    if (!clazz.isAssignableFrom(requestedType)) {\r\n        return null;\r\n    }\r\n    return (TypeAdapter\u003cT2\u003e) new TypeAdapter\u003cT1\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T1 value) throws IOException {\r\n            typeAdapter.write(out, value);\r\n        }\r\n\r\n        @Override\r\n        public T1 read(JsonReader in) throws IOException {\r\n            T1 result \u003d typeAdapter.read(in);\r\n            if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\r\n                throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT2\u003e"
      ],
      "returnType": "TypeAdapter\u003cT2\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"Factory[typeHierarchy\u003d\" + clazz.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\r\n * that the deserialized type matches the type requested.\r\n */\r\npublic static \u003cT1\u003e TypeAdapterFactory newTypeHierarchyFactory(final Class\u003cT1\u003e clazz, final TypeAdapter\u003cT1\u003e typeAdapter) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT2\u003e TypeAdapter\u003cT2\u003e create(Gson gson, TypeToken\u003cT2\u003e typeToken) {\r\n            final Class\u003c? super T2\u003e requestedType \u003d typeToken.getRawType();\r\n            if (!clazz.isAssignableFrom(requestedType)) {\r\n                return null;\r\n            }\r\n            return (TypeAdapter\u003cT2\u003e) new TypeAdapter\u003cT1\u003e() {\r\n\r\n                @Override\r\n                public void write(JsonWriter out, T1 value) throws IOException {\r\n                    typeAdapter.write(out, value);\r\n                }\r\n\r\n                @Override\r\n                public T1 read(JsonReader in) throws IOException {\r\n                    T1 result \u003d typeAdapter.read(in);\r\n                    if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\r\n                        throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[typeHierarchy\u003d\" + clazz.getName() + \",adapter\u003d\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.TypeAdapters",
      "methodName": "newTypeHierarchyFactory",
      "parameterTypes": [
        "Class\u003cT1\u003e",
        "TypeAdapter\u003cT1\u003e"
      ],
      "returnType": "TypeAdapterFactory"
    }
  },
  {
    "sourceCode": "/*\r\n    /**********************************************************\r\n    /* Formatting\r\n    /**********************************************************\r\n     */\r\n/**\r\n * Format a date into \u0027yyyy-MM-ddThh:mm:ssZ\u0027 (default timezone, no milliseconds precision)\r\n *\r\n * @param date the date to format\r\n * @return the date formatted as \u0027yyyy-MM-ddThh:mm:ssZ\u0027\r\n */\r\npublic static String format(Date date) {\r\n    return format(date, false, TIMEZONE_UTC);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601Utils",
      "methodName": "format",
      "parameterTypes": [
        "Date"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Format a date into \u0027yyyy-MM-ddThh:mm:ss[.sss]Z\u0027 (GMT timezone)\r\n *\r\n * @param date the date to format\r\n * @param millis true to include millis precision otherwise false\r\n * @return the date formatted as \u0027yyyy-MM-ddThh:mm:ss[.sss]Z\u0027\r\n */\r\npublic static String format(Date date, boolean millis) {\r\n    return format(date, millis, TIMEZONE_UTC);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601Utils",
      "methodName": "format",
      "parameterTypes": [
        "Date",
        "boolean"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\r\n *\r\n * @param date the date to format\r\n * @param millis true to include millis precision otherwise false\r\n * @param tz timezone to use for the formatting (UTC will produce \u0027Z\u0027)\r\n * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\r\n */\r\npublic static String format(Date date, boolean millis, TimeZone tz) {\r\n    Calendar calendar \u003d new GregorianCalendar(tz, Locale.US);\r\n    calendar.setTime(date);\r\n    // estimate capacity of buffer as close as we can (yeah, that\u0027s pedantic ;)\r\n    int capacity \u003d \"yyyy-MM-ddThh:mm:ss\".length();\r\n    capacity +\u003d millis ? \".sss\".length() : 0;\r\n    capacity +\u003d tz.getRawOffset() \u003d\u003d 0 ? \"Z\".length() : \"+hh:mm\".length();\r\n    StringBuilder formatted \u003d new StringBuilder(capacity);\r\n    padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\r\n    formatted.append(\u0027T\u0027);\r\n    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\r\n    if (millis) {\r\n        formatted.append(\u0027.\u0027);\r\n        padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\r\n    }\r\n    int offset \u003d tz.getOffset(calendar.getTimeInMillis());\r\n    if (offset !\u003d 0) {\r\n        int hours \u003d Math.abs((offset / (60 * 1000)) / 60);\r\n        int minutes \u003d Math.abs((offset / (60 * 1000)) % 60);\r\n        formatted.append(offset \u003c 0 ? \u0027-\u0027 : \u0027+\u0027);\r\n        padInt(formatted, hours, \"hh\".length());\r\n        formatted.append(\u0027:\u0027);\r\n        padInt(formatted, minutes, \"mm\".length());\r\n    } else {\r\n        formatted.append(\u0027Z\u0027);\r\n    }\r\n    return formatted.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601Utils",
      "methodName": "format",
      "parameterTypes": [
        "Date",
        "boolean",
        "TimeZone"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/*\r\n    /**********************************************************\r\n    /* Parsing\r\n    /**********************************************************\r\n     */\r\n/**\r\n * Parse a date from ISO-8601 formatted string. It expects a format\r\n * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\r\n *\r\n * @param date ISO string to parse in the appropriate format.\r\n * @param pos The position to start parsing from, updated to where parsing stopped.\r\n * @return the parsed date\r\n * @throws ParseException if the date is not in the appropriate format\r\n */\r\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\r\n    Exception fail \u003d null;\r\n    try {\r\n        int offset \u003d pos.getIndex();\r\n        // extract year\r\n        int year \u003d parseInt(date, offset, offset +\u003d 4);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract month\r\n        int month \u003d parseInt(date, offset, offset +\u003d 2);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract day\r\n        int day \u003d parseInt(date, offset, offset +\u003d 2);\r\n        // default time value\r\n        int hour \u003d 0;\r\n        int minutes \u003d 0;\r\n        int seconds \u003d 0;\r\n        // always use 0 otherwise returned date will include millis of current time\r\n        int milliseconds \u003d 0;\r\n        // if the value has no time component (and no time zone), we are done\r\n        boolean hasT \u003d checkOffset(date, offset, \u0027T\u0027);\r\n        if (!hasT \u0026\u0026 (date.length() \u003c\u003d offset)) {\r\n            Calendar calendar \u003d new GregorianCalendar(year, month - 1, day);\r\n            calendar.setLenient(false);\r\n            pos.setIndex(offset);\r\n            return calendar.getTime();\r\n        }\r\n        if (hasT) {\r\n            // extract hours, minutes, seconds and milliseconds\r\n            hour \u003d parseInt(date, offset +\u003d 1, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            minutes \u003d parseInt(date, offset, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            // second and milliseconds can be optional\r\n            if (date.length() \u003e offset) {\r\n                char c \u003d date.charAt(offset);\r\n                if (c !\u003d \u0027Z\u0027 \u0026\u0026 c !\u003d \u0027+\u0027 \u0026\u0026 c !\u003d \u0027-\u0027) {\r\n                    seconds \u003d parseInt(date, offset, offset +\u003d 2);\r\n                    // truncate up to 3 leap seconds\r\n                    if (seconds \u003e 59 \u0026\u0026 seconds \u003c 63)\r\n                        seconds \u003d 59;\r\n                    // milliseconds can be optional in the format\r\n                    if (checkOffset(date, offset, \u0027.\u0027)) {\r\n                        offset +\u003d 1;\r\n                        // assume at least one digit\r\n                        int endOffset \u003d indexOfNonDigit(date, offset + 1);\r\n                        // parse up to 3 digits\r\n                        int parseEndOffset \u003d Math.min(endOffset, offset + 3);\r\n                        int fraction \u003d parseInt(date, offset, parseEndOffset);\r\n                        // compensate for \"missing\" digits\r\n                        switch(// number of digits parsed\r\n                        parseEndOffset - offset) {\r\n                            case 2:\r\n                                milliseconds \u003d fraction * 10;\r\n                                break;\r\n                            case 1:\r\n                                milliseconds \u003d fraction * 100;\r\n                                break;\r\n                            default:\r\n                                milliseconds \u003d fraction;\r\n                        }\r\n                        offset \u003d endOffset;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // extract timezone\r\n        if (date.length() \u003c\u003d offset) {\r\n            throw new IllegalArgumentException(\"No time zone indicator\");\r\n        }\r\n        TimeZone timezone \u003d null;\r\n        char timezoneIndicator \u003d date.charAt(offset);\r\n        if (timezoneIndicator \u003d\u003d \u0027Z\u0027) {\r\n            timezone \u003d TIMEZONE_UTC;\r\n            offset +\u003d 1;\r\n        } else if (timezoneIndicator \u003d\u003d \u0027+\u0027 || timezoneIndicator \u003d\u003d \u0027-\u0027) {\r\n            String timezoneOffset \u003d date.substring(offset);\r\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\r\n            timezoneOffset \u003d timezoneOffset.length() \u003e\u003d 5 ? timezoneOffset : timezoneOffset + \"00\";\r\n            offset +\u003d timezoneOffset.length();\r\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\r\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\r\n                timezone \u003d TIMEZONE_UTC;\r\n            } else {\r\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\r\n                // not sure why, but that\u0027s the way it looks. Further, Javadocs for\r\n                // `java.util.TimeZone` specifically instruct use of GMT as base for\r\n                // custom timezones... odd.\r\n                String timezoneId \u003d \"GMT\" + timezoneOffset;\r\n                // String timezoneId \u003d \"UTC\" + timezoneOffset;\r\n                timezone \u003d TimeZone.getTimeZone(timezoneId);\r\n                String act \u003d timezone.getID();\r\n                if (!act.equals(timezoneId)) {\r\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\r\n                         *    one without. If so, don\u0027t sweat.\r\n                         *   Yes, very inefficient. Hopefully not hit often.\r\n                         *   If it becomes a perf problem, add \u0027loose\u0027 comparison instead.\r\n                         */\r\n                    String cleaned \u003d act.replace(\":\", \"\");\r\n                    if (!cleaned.equals(timezoneId)) {\r\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \u0027\" + timezoneIndicator + \"\u0027\");\r\n        }\r\n        Calendar calendar \u003d new GregorianCalendar(timezone);\r\n        calendar.setLenient(false);\r\n        calendar.set(Calendar.YEAR, year);\r\n        calendar.set(Calendar.MONTH, month - 1);\r\n        calendar.set(Calendar.DAY_OF_MONTH, day);\r\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\r\n        calendar.set(Calendar.MINUTE, minutes);\r\n        calendar.set(Calendar.SECOND, seconds);\r\n        calendar.set(Calendar.MILLISECOND, milliseconds);\r\n        pos.setIndex(offset);\r\n        return calendar.getTime();\r\n        // If we get a ParseException it\u0027ll already have the right message/offset.\r\n        // Other exception types can convert here.\r\n    } catch (IndexOutOfBoundsException e) {\r\n        fail \u003d e;\r\n    } catch (NumberFormatException e) {\r\n        fail \u003d e;\r\n    } catch (IllegalArgumentException e) {\r\n        fail \u003d e;\r\n    }\r\n    String input \u003d (date \u003d\u003d null) ? null : (\u0027\"\u0027 + date + \u0027\"\u0027);\r\n    String msg \u003d fail.getMessage();\r\n    if (msg \u003d\u003d null || msg.isEmpty()) {\r\n        msg \u003d \"(\" + fail.getClass().getName() + \")\";\r\n    }\r\n    ParseException ex \u003d new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\r\n    ex.initCause(fail);\r\n    throw ex;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601Utils",
      "methodName": "parse",
      "parameterTypes": [
        "String",
        "ParsePosition"
      ],
      "returnType": "Date"
    }
  },
  {
    "sourceCode": "/**\r\n * Check if the expected character exist at the given offset in the value.\r\n *\r\n * @param value the string to check at the specified offset\r\n * @param offset the offset to look for the expected character\r\n * @param expected the expected character\r\n * @return true if the expected character exist at the given offset\r\n */\r\nprivate static boolean checkOffset(String value, int offset, char expected) {\r\n    return (offset \u003c value.length()) \u0026\u0026 (value.charAt(offset) \u003d\u003d expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601Utils",
      "methodName": "checkOffset",
      "parameterTypes": [
        "String",
        "int",
        "char"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Parse an integer located between 2 given offsets in a string\r\n *\r\n * @param value the string to parse\r\n * @param beginIndex the start index for the integer in the string\r\n * @param endIndex the end index for the integer in the string\r\n * @return the int\r\n * @throws NumberFormatException if the value is not a number\r\n */\r\nprivate static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\r\n    if (beginIndex \u003c 0 || endIndex \u003e value.length() || beginIndex \u003e endIndex) {\r\n        throw new NumberFormatException(value);\r\n    }\r\n    // use same logic as in Integer.parseInt() but less generic we\u0027re not supporting negative values\r\n    int i \u003d beginIndex;\r\n    int result \u003d 0;\r\n    int digit;\r\n    if (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result \u003d -digit;\r\n    }\r\n    while (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result *\u003d 10;\r\n        result -\u003d digit;\r\n    }\r\n    return -result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601Utils",
      "methodName": "parseInt",
      "parameterTypes": [
        "String",
        "int",
        "int"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Zero pad a number to a specified length\r\n *\r\n * @param buffer buffer to use for padding\r\n * @param value the integer value to pad if necessary.\r\n * @param length the length of the string we should zero pad\r\n */\r\nprivate static void padInt(StringBuilder buffer, int value, int length) {\r\n    String strValue \u003d Integer.toString(value);\r\n    for (int i \u003d length - strValue.length(); i \u003e 0; i--) {\r\n        buffer.append(\u00270\u0027);\r\n    }\r\n    buffer.append(strValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601Utils",
      "methodName": "padInt",
      "parameterTypes": [
        "StringBuilder",
        "int",
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the index of the first character in the string that is not a digit, starting at offset.\r\n */\r\nprivate static int indexOfNonDigit(String string, int offset) {\r\n    for (int i \u003d offset; i \u003c string.length(); i++) {\r\n        char c \u003d string.charAt(i);\r\n        if (c \u003c \u00270\u0027 || c \u003e \u00279\u0027)\r\n            return i;\r\n    }\r\n    return string.length();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601Utils",
      "methodName": "indexOfNonDigit",
      "parameterTypes": [
        "String",
        "int"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Check if the class can be instantiated by Unsafe allocator. If the instance has interface or abstract modifiers\r\n * return an exception message.\r\n * @param c instance of the class to be checked\r\n * @return if instantiable {@code null}, else a non-{@code null} exception message\r\n */\r\nstatic String checkInstantiable(Class\u003c?\u003e c) {\r\n    int modifiers \u003d c.getModifiers();\r\n    if (Modifier.isInterface(modifiers)) {\r\n        return \"Interfaces can\u0027t be instantiated! Register an InstanceCreator\" + \" or a TypeAdapter for this type. Interface name: \" + c.getName();\r\n    }\r\n    if (Modifier.isAbstract(modifiers)) {\r\n        // R8 performs aggressive optimizations where it removes the default constructor of a class\r\n        // and makes the class `abstract`; check for that here explicitly\r\n        /*\r\n       * Note: Ideally should only show this R8-specific message when it is clear that R8 was\r\n       * used (e.g. when `c.getDeclaredConstructors().length \u003d\u003d 0`), but on Android where this\r\n       * issue with R8 occurs most, R8 seems to keep some constructors for some reason while\r\n       * still making the class abstract\r\n       */\r\n        return \"Abstract classes can\u0027t be instantiated! Adjust the R8 configuration or register\" + \" an InstanceCreator or a TypeAdapter for this type. Class name: \" + c.getName() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"r8-abstract-class\");\r\n    }\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "checkInstantiable",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return typeCreator.createInstance(type);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return rawTypeCreator.createInstance(type);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    throw new JsonIOException(exceptionMessage);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    throw new JsonIOException(message);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "public \u003cT\u003e ObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken) {\r\n    final Type type \u003d typeToken.getType();\r\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    // first try an instance creator\r\n    // types must agree\r\n    @SuppressWarnings(\"unchecked\")\r\n    final InstanceCreator\u003cT\u003e typeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\r\n    if (typeCreator !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                return typeCreator.createInstance(type);\r\n            }\r\n        };\r\n    }\r\n    // Next try raw type match for instance creators\r\n    // types must agree\r\n    @SuppressWarnings(\"unchecked\")\r\n    final InstanceCreator\u003cT\u003e rawTypeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(rawType);\r\n    if (rawTypeCreator !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                return rawTypeCreator.createInstance(type);\r\n            }\r\n        };\r\n    }\r\n    // First consider special constructors before checking for no-args constructors\r\n    // below to avoid matching internal no-args constructors which might be added in\r\n    // future JDK versions\r\n    ObjectConstructor\u003cT\u003e specialConstructor \u003d newSpecialCollectionConstructor(type, rawType);\r\n    if (specialConstructor !\u003d null) {\r\n        return specialConstructor;\r\n    }\r\n    FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, rawType);\r\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType, filterResult);\r\n    if (defaultConstructor !\u003d null) {\r\n        return defaultConstructor;\r\n    }\r\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\r\n    if (defaultImplementation !\u003d null) {\r\n        return defaultImplementation;\r\n    }\r\n    // Check whether type is instantiable; otherwise ReflectionAccessFilter recommendation\r\n    // of adjusting filter suggested below is irrelevant since it would not solve the problem\r\n    final String exceptionMessage \u003d checkInstantiable(rawType);\r\n    if (exceptionMessage !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(exceptionMessage);\r\n            }\r\n        };\r\n    }\r\n    // Consider usage of Unsafe as reflection, so don\u0027t use if BLOCK_ALL\r\n    // Additionally, since it is not calling any constructor at all, don\u0027t use if BLOCK_INACCESSIBLE\r\n    if (filterResult \u003d\u003d FilterResult.ALLOW) {\r\n        // finally try unsafe\r\n        return newUnsafeAllocator(rawType);\r\n    } else {\r\n        final String message \u003d \"Unable to create instance of \" + rawType + \"; ReflectionAccessFilter\" + \" does not permit using reflection or Unsafe. Register an InstanceCreator or a TypeAdapter\" + \" for this type or adjust the access filter to allow using reflection.\";\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(message);\r\n            }\r\n        };\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "get",
      "parameterTypes": [
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "ObjectConstructor\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    if (type instanceof ParameterizedType) {\r\n        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\r\n        if (elementType instanceof Class) {\r\n            @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n            T map \u003d (T) new EnumMap((Class) elementType);\r\n            return map;\r\n        } else {\r\n            throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\r\n        }\r\n    } else {\r\n        throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    if (type instanceof ParameterizedType) {\r\n        Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\r\n        if (elementType instanceof Class) {\r\n            @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n            T set \u003d (T) EnumSet.noneOf((Class) elementType);\r\n            return set;\r\n        } else {\r\n            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n        }\r\n    } else {\r\n        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates constructors for special JDK collection types which do not have a public no-args constructor.\r\n */\r\nprivate static \u003cT\u003e ObjectConstructor\u003cT\u003e newSpecialCollectionConstructor(final Type type, Class\u003c? super T\u003e rawType) {\r\n    if (EnumSet.class.isAssignableFrom(rawType)) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                if (type instanceof ParameterizedType) {\r\n                    Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                    if (elementType instanceof Class) {\r\n                        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n                        T set \u003d (T) EnumSet.noneOf((Class) elementType);\r\n                        return set;\r\n                    } else {\r\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n                    }\r\n                } else {\r\n                    throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n                }\r\n            }\r\n        };\r\n    } else // Only support creation of EnumMap, but not of custom subtypes; for them type parameters\r\n    // and constructor parameter might have completely different meaning\r\n    if (rawType \u003d\u003d EnumMap.class) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                if (type instanceof ParameterizedType) {\r\n                    Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                    if (elementType instanceof Class) {\r\n                        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n                        T map \u003d (T) new EnumMap((Class) elementType);\r\n                        return map;\r\n                    } else {\r\n                        throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\r\n                    }\r\n                } else {\r\n                    throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\r\n                }\r\n            }\r\n        };\r\n    }\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "newSpecialCollectionConstructor",
      "parameterTypes": [
        "Type",
        "Class\u003c? super T\u003e"
      ],
      "returnType": "ObjectConstructor\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    throw new JsonIOException(message);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    // New exception is created every time to avoid keeping reference\r\n    // to exception with potentially long stack trace, causing a\r\n    // memory leak\r\n    throw new JsonIOException(exceptionMessage);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    try {\r\n        // T is the same raw type as is requested\r\n        @SuppressWarnings(\"unchecked\")\r\n        T newInstance \u003d (T) constructor.newInstance();\r\n        return newInstance;\r\n    }// Note: InstantiationException should be impossible because check at start of method made sure\r\n    // that class is not abstract\r\n     catch (InstantiationException e) {\r\n        throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with no args\", e);\r\n    } catch (InvocationTargetException e) {\r\n        // TODO: don\u0027t wrap if cause is unchecked?\r\n        // TODO: JsonParseException ?\r\n        throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with no args\", e.getCause());\r\n    } catch (IllegalAccessException e) {\r\n        throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "private static \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultConstructor(Class\u003c? super T\u003e rawType, FilterResult filterResult) {\r\n    // Cannot invoke constructor of abstract class\r\n    if (Modifier.isAbstract(rawType.getModifiers())) {\r\n        return null;\r\n    }\r\n    final Constructor\u003c? super T\u003e constructor;\r\n    try {\r\n        constructor \u003d rawType.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException e) {\r\n        return null;\r\n    }\r\n    boolean canAccess \u003d filterResult \u003d\u003d FilterResult.ALLOW || (ReflectionAccessFilterHelper.canAccess(constructor, null) \u0026\u0026 // Be a bit more lenient here for BLOCK_ALL; if constructor is accessible and public then allow calling it\r\n    (filterResult !\u003d FilterResult.BLOCK_ALL || Modifier.isPublic(constructor.getModifiers())));\r\n    if (!canAccess) {\r\n        final String message \u003d \"Unable to invoke no-args constructor of \" + rawType + \";\" + \" constructor is not accessible and ReflectionAccessFilter does not permit making\" + \" it accessible. Register an InstanceCreator or a TypeAdapter for this type, change\" + \" the visibility of the constructor or adjust the access filter.\";\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(message);\r\n            }\r\n        };\r\n    }\r\n    // Only try to make accessible if allowed; in all other cases checks above should\r\n    // have verified that constructor is accessible\r\n    if (filterResult \u003d\u003d FilterResult.ALLOW) {\r\n        final String exceptionMessage \u003d ReflectionHelper.tryMakeAccessible(constructor);\r\n        if (exceptionMessage !\u003d null) {\r\n            /*\r\n         * Create ObjectConstructor which throws exception.\r\n         * This keeps backward compatibility (compared to returning `null` which\r\n         * would then choose another way of creating object).\r\n         * And it supports types which are only serialized but not deserialized\r\n         * (compared to directly throwing exception here), e.g. when runtime type\r\n         * of object is inaccessible, but compile-time type is accessible.\r\n         */\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    // New exception is created every time to avoid keeping reference\r\n                    // to exception with potentially long stack trace, causing a\r\n                    // memory leak\r\n                    throw new JsonIOException(exceptionMessage);\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return new ObjectConstructor\u003cT\u003e() {\r\n\r\n        @Override\r\n        public T construct() {\r\n            try {\r\n                // T is the same raw type as is requested\r\n                @SuppressWarnings(\"unchecked\")\r\n                T newInstance \u003d (T) constructor.newInstance();\r\n                return newInstance;\r\n            }// Note: InstantiationException should be impossible because check at start of method made sure\r\n            // that class is not abstract\r\n             catch (InstantiationException e) {\r\n                throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with no args\", e);\r\n            } catch (InvocationTargetException e) {\r\n                // TODO: don\u0027t wrap if cause is unchecked?\r\n                // TODO: JsonParseException ?\r\n                throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with no args\", e.getCause());\r\n            } catch (IllegalAccessException e) {\r\n                throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n            }\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "newDefaultConstructor",
      "parameterTypes": [
        "Class\u003c? super T\u003e",
        "FilterResult"
      ],
      "returnType": "ObjectConstructor\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return (T) new ArrayList\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return (T) new ArrayDeque\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return (T) new LinkedHashSet\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return (T) new TreeSet\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return (T) new LinkedTreeMap\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return (T) new LinkedHashMap\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return (T) new TreeMap\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return (T) new ConcurrentHashMap\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    return (T) new ConcurrentSkipListMap\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Constructors for common interface types like Map and List and their\r\n * subtypes.\r\n */\r\n// use runtime checks to guarantee that \u0027T\u0027 is what it is\r\n@SuppressWarnings(\"unchecked\")\r\nprivate static \u003cT\u003e ObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type, Class\u003c? super T\u003e rawType) {\r\n    /*\r\n     * IMPORTANT: Must only create instances for classes with public no-args constructor.\r\n     * For classes with special constructors / factory methods (e.g. EnumSet)\r\n     * `newSpecialCollectionConstructor` defined above must be used, to avoid no-args\r\n     * constructor check (which is called before this method) detecting internal no-args\r\n     * constructors which might be added in a future JDK version\r\n     */\r\n    if (Collection.class.isAssignableFrom(rawType)) {\r\n        if (SortedSet.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new TreeSet\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (Set.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedHashSet\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (Queue.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ArrayDeque\u003c\u003e();\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ArrayList\u003c\u003e();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    if (Map.class.isAssignableFrom(rawType)) {\r\n        if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ConcurrentSkipListMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ConcurrentHashMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (SortedMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new TreeMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (type instanceof ParameterizedType \u0026\u0026 !String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType())) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedHashMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedTreeMap\u003c\u003e();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "newDefaultImplementationConstructor",
      "parameterTypes": [
        "Type",
        "Class\u003c? super T\u003e"
      ],
      "returnType": "ObjectConstructor\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    throw new JsonIOException(exceptionMessageF);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T construct() {\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        T newInstance \u003d (T) UnsafeAllocator.INSTANCE.newInstance(rawType);\r\n        return newInstance;\r\n    } catch (Exception e) {\r\n        throw new RuntimeException((\"Unable to create instance of \" + rawType + \".\" + \" Registering an InstanceCreator or a TypeAdapter for this type, or adding a no-args\" + \" constructor may fix this problem.\"), e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "private \u003cT\u003e ObjectConstructor\u003cT\u003e newUnsafeAllocator(final Class\u003c? super T\u003e rawType) {\r\n    if (useJdkUnsafe) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                try {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    T newInstance \u003d (T) UnsafeAllocator.INSTANCE.newInstance(rawType);\r\n                    return newInstance;\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException((\"Unable to create instance of \" + rawType + \".\" + \" Registering an InstanceCreator or a TypeAdapter for this type, or adding a no-args\" + \" constructor may fix this problem.\"), e);\r\n                }\r\n            }\r\n        };\r\n    } else {\r\n        String exceptionMessage \u003d \"Unable to create instance of \" + rawType + \"; usage of JDK Unsafe\" + \" is disabled. Registering an InstanceCreator or a TypeAdapter for this type, adding a no-args\" + \" constructor, or enabling usage of JDK Unsafe may fix this problem.\";\r\n        // Check if R8 removed all constructors\r\n        if (rawType.getDeclaredConstructors().length \u003d\u003d 0) {\r\n            // R8 with Unsafe disabled might not be common enough to warrant a separate Troubleshooting Guide entry\r\n            exceptionMessage +\u003d \" Or adjust your R8 configuration to keep the no-args constructor of the class.\";\r\n        }\r\n        // Explicit final variable to allow usage in the anonymous class below\r\n        final String exceptionMessageF \u003d exceptionMessage;\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(exceptionMessageF);\r\n            }\r\n        };\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "newUnsafeAllocator",
      "parameterTypes": [
        "Class\u003c? super T\u003e"
      ],
      "returnType": "ObjectConstructor\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return instanceCreators.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructor",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\nprotected Excluder clone() {\r\n    try {\r\n        return (Excluder) super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "clone",
      "parameterTypes": [],
      "returnType": "Excluder"
    }
  },
  {
    "sourceCode": "public Excluder withVersion(double ignoreVersionsAfter) {\r\n    Excluder result \u003d clone();\r\n    result.version \u003d ignoreVersionsAfter;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "withVersion",
      "parameterTypes": [
        "double"
      ],
      "returnType": "Excluder"
    }
  },
  {
    "sourceCode": "public Excluder withModifiers(int... modifiers) {\r\n    Excluder result \u003d clone();\r\n    result.modifiers \u003d 0;\r\n    for (int modifier : modifiers) {\r\n        result.modifiers |\u003d modifier;\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "withModifiers",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Excluder"
    }
  },
  {
    "sourceCode": "public Excluder disableInnerClassSerialization() {\r\n    Excluder result \u003d clone();\r\n    result.serializeInnerClasses \u003d false;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "disableInnerClassSerialization",
      "parameterTypes": [],
      "returnType": "Excluder"
    }
  },
  {
    "sourceCode": "public Excluder excludeFieldsWithoutExposeAnnotation() {\r\n    Excluder result \u003d clone();\r\n    result.requireExpose \u003d true;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "excludeFieldsWithoutExposeAnnotation",
      "parameterTypes": [],
      "returnType": "Excluder"
    }
  },
  {
    "sourceCode": "public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy, boolean serialization, boolean deserialization) {\r\n    Excluder result \u003d clone();\r\n    if (serialization) {\r\n        result.serializationStrategies \u003d new ArrayList\u003c\u003e(serializationStrategies);\r\n        result.serializationStrategies.add(exclusionStrategy);\r\n    }\r\n    if (deserialization) {\r\n        result.deserializationStrategies \u003d new ArrayList\u003c\u003e(deserializationStrategies);\r\n        result.deserializationStrategies.add(exclusionStrategy);\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "withExclusionStrategy",
      "parameterTypes": [
        "ExclusionStrategy",
        "boolean",
        "boolean"
      ],
      "returnType": "Excluder"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    if (skipDeserialize) {\r\n        in.skipValue();\r\n        return null;\r\n    }\r\n    return delegate().read(in);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    if (skipSerialize) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    delegate().write(out, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private TypeAdapter\u003cT\u003e delegate() {\r\n    TypeAdapter\u003cT\u003e d \u003d delegate;\r\n    return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "delegate",
      "parameterTypes": [],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, final TypeToken\u003cT\u003e type) {\r\n    Class\u003c?\u003e rawType \u003d type.getRawType();\r\n    boolean excludeClass \u003d excludeClassChecks(rawType);\r\n    final boolean skipSerialize \u003d excludeClass || excludeClassInStrategy(rawType, true);\r\n    final boolean skipDeserialize \u003d excludeClass || excludeClassInStrategy(rawType, false);\r\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\r\n        return null;\r\n    }\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        /**\r\n         * The delegate is lazily created because it may not be needed, and creating it may fail.\r\n         */\r\n        private TypeAdapter\u003cT\u003e delegate;\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            if (skipDeserialize) {\r\n                in.skipValue();\r\n                return null;\r\n            }\r\n            return delegate().read(in);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (skipSerialize) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            delegate().write(out, value);\r\n        }\r\n\r\n        private TypeAdapter\u003cT\u003e delegate() {\r\n            TypeAdapter\u003cT\u003e d \u003d delegate;\r\n            return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "public boolean excludeField(Field field, boolean serialize) {\r\n    if ((modifiers \u0026 field.getModifiers()) !\u003d 0) {\r\n        return true;\r\n    }\r\n    if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\r\n        return true;\r\n    }\r\n    if (field.isSynthetic()) {\r\n        return true;\r\n    }\r\n    if (requireExpose) {\r\n        Expose annotation \u003d field.getAnnotation(Expose.class);\r\n        if (annotation \u003d\u003d null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(field.getType())) {\r\n        return true;\r\n    }\r\n    if (isAnonymousOrNonStaticLocal(field.getType())) {\r\n        return true;\r\n    }\r\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\r\n    if (!list.isEmpty()) {\r\n        FieldAttributes fieldAttributes \u003d new FieldAttributes(field);\r\n        for (ExclusionStrategy exclusionStrategy : list) {\r\n            if (exclusionStrategy.shouldSkipField(fieldAttributes)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "excludeField",
      "parameterTypes": [
        "Field",
        "boolean"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private boolean excludeClassChecks(Class\u003c?\u003e clazz) {\r\n    if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\r\n        return true;\r\n    }\r\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(clazz)) {\r\n        return true;\r\n    }\r\n    return isAnonymousOrNonStaticLocal(clazz);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "excludeClassChecks",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "public boolean excludeClass(Class\u003c?\u003e clazz, boolean serialize) {\r\n    return excludeClassChecks(clazz) || excludeClassInStrategy(clazz, serialize);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "excludeClass",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "boolean"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private boolean excludeClassInStrategy(Class\u003c?\u003e clazz, boolean serialize) {\r\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\r\n    for (ExclusionStrategy exclusionStrategy : list) {\r\n        if (exclusionStrategy.shouldSkipClass(clazz)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "excludeClassInStrategy",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "boolean"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private boolean isAnonymousOrNonStaticLocal(Class\u003c?\u003e clazz) {\r\n    return !Enum.class.isAssignableFrom(clazz) \u0026\u0026 !isStatic(clazz) \u0026\u0026 (clazz.isAnonymousClass() || clazz.isLocalClass());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "isAnonymousOrNonStaticLocal",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private boolean isInnerClass(Class\u003c?\u003e clazz) {\r\n    return clazz.isMemberClass() \u0026\u0026 !isStatic(clazz);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "isInnerClass",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private boolean isStatic(Class\u003c?\u003e clazz) {\r\n    return (clazz.getModifiers() \u0026 Modifier.STATIC) !\u003d 0;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "isStatic",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private boolean isValidVersion(Since since, Until until) {\r\n    return isValidSince(since) \u0026\u0026 isValidUntil(until);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "isValidVersion",
      "parameterTypes": [
        "Since",
        "Until"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private boolean isValidSince(Since annotation) {\r\n    if (annotation !\u003d null) {\r\n        double annotationVersion \u003d annotation.value();\r\n        return version \u003e\u003d annotationVersion;\r\n    }\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "isValidSince",
      "parameterTypes": [
        "Since"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private boolean isValidUntil(Until annotation) {\r\n    if (annotation !\u003d null) {\r\n        double annotationVersion \u003d annotation.value();\r\n        return version \u003c annotationVersion;\r\n    }\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Excluder",
      "methodName": "isValidUntil",
      "parameterTypes": [
        "Until"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private static int determineMajorJavaVersion() {\r\n    String javaVersion \u003d System.getProperty(\"java.version\");\r\n    return getMajorJavaVersion(javaVersion);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersion",
      "methodName": "determineMajorJavaVersion",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "// Visible for testing only\r\nstatic int getMajorJavaVersion(String javaVersion) {\r\n    int version \u003d parseDotted(javaVersion);\r\n    if (version \u003d\u003d -1) {\r\n        version \u003d extractBeginningInt(javaVersion);\r\n    }\r\n    if (version \u003d\u003d -1) {\r\n        // Choose minimum supported JDK version as default\r\n        return 6;\r\n    }\r\n    return version;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersion",
      "methodName": "getMajorJavaVersion",
      "parameterTypes": [
        "String"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "// Parses both legacy 1.8 style and newer 9.0.4 style\r\nprivate static int parseDotted(String javaVersion) {\r\n    try {\r\n        String[] parts \u003d javaVersion.split(\"[._]\", 3);\r\n        int firstVer \u003d Integer.parseInt(parts[0]);\r\n        if (firstVer \u003d\u003d 1 \u0026\u0026 parts.length \u003e 1) {\r\n            return Integer.parseInt(parts[1]);\r\n        } else {\r\n            return firstVer;\r\n        }\r\n    } catch (NumberFormatException e) {\r\n        return -1;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersion",
      "methodName": "parseDotted",
      "parameterTypes": [
        "String"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "private static int extractBeginningInt(String javaVersion) {\r\n    try {\r\n        StringBuilder num \u003d new StringBuilder();\r\n        for (int i \u003d 0; i \u003c javaVersion.length(); ++i) {\r\n            char c \u003d javaVersion.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                num.append(c);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return Integer.parseInt(num.toString());\r\n    } catch (NumberFormatException e) {\r\n        return -1;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersion",
      "methodName": "extractBeginningInt",
      "parameterTypes": [
        "String"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Gets the major Java version\r\n *\r\n * @return the major Java version, i.e. \u00278\u0027 for Java 1.8, \u00279\u0027 for Java 9 etc.\r\n */\r\npublic static int getMajorJavaVersion() {\r\n    return majorJavaVersion;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersion",
      "methodName": "getMajorJavaVersion",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Gets a boolean value depending if the application is running on Java 9 or later\r\n *\r\n * @return {@code true} if the application is running on Java 9 or later; and {@code false} otherwise.\r\n */\r\npublic static boolean isJava9OrLater() {\r\n    return majorJavaVersion \u003e\u003d 9;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersion",
      "methodName": "isJava9OrLater",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Changes the type of the current property name token to a string value.\r\n */\r\npublic abstract void promoteNameToValue(JsonReader reader) throws IOException;",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JsonReaderInternalAccess",
      "methodName": "promoteNameToValue",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private BigDecimal asBigDecimal() {\r\n    return NumberLimits.parseBigDecimal(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumber",
      "methodName": "asBigDecimal",
      "parameterTypes": [],
      "returnType": "BigDecimal"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int intValue() {\r\n    try {\r\n        return Integer.parseInt(value);\r\n    } catch (NumberFormatException e) {\r\n        try {\r\n            return (int) Long.parseLong(value);\r\n        } catch (NumberFormatException nfe) {\r\n            return asBigDecimal().intValue();\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumber",
      "methodName": "intValue",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic long longValue() {\r\n    try {\r\n        return Long.parseLong(value);\r\n    } catch (NumberFormatException e) {\r\n        return asBigDecimal().longValue();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumber",
      "methodName": "longValue",
      "parameterTypes": [],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "@Override\r\npublic float floatValue() {\r\n    return Float.parseFloat(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumber",
      "methodName": "floatValue",
      "parameterTypes": [],
      "returnType": "float"
    }
  },
  {
    "sourceCode": "@Override\r\npublic double doubleValue() {\r\n    return Double.parseDouble(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumber",
      "methodName": "doubleValue",
      "parameterTypes": [],
      "returnType": "double"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return value;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumber",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * If somebody is unlucky enough to have to serialize one of these, serialize\r\n * it as a BigDecimal so that they won\u0027t need Gson on the other side to\r\n * deserialize it.\r\n */\r\nprivate Object writeReplace() throws ObjectStreamException {\r\n    return asBigDecimal();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumber",
      "methodName": "writeReplace",
      "parameterTypes": [],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "private void readObject(ObjectInputStream in) throws IOException {\r\n    // Don\u0027t permit directly deserializing this class; writeReplace() should have written a replacement\r\n    throw new InvalidObjectException(\"Deserialization is unsupported\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumber",
      "methodName": "readObject",
      "parameterTypes": [
        "ObjectInputStream"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return value.hashCode();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumber",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object obj) {\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof LazilyParsedNumber) {\r\n        LazilyParsedNumber other \u003d (LazilyParsedNumber) obj;\r\n        return value.equals(other.value);\r\n    }\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumber",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int compare(Comparable a, Comparable b) {\r\n    return a.compareTo(b);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "compare",
      "parameterTypes": [
        "Comparable",
        "Comparable"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int size() {\r\n    return size;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "size",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic V get(Object key) {\r\n    Node\u003cK, V\u003e node \u003d findByObject(key);\r\n    return node !\u003d null ? node.value : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "get",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "V"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean containsKey(Object key) {\r\n    return findByObject(key) !\u003d null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "containsKey",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic V put(K key, V value) {\r\n    if (key \u003d\u003d null) {\r\n        throw new NullPointerException(\"key \u003d\u003d null\");\r\n    }\r\n    if (value \u003d\u003d null \u0026\u0026 !allowNullValues) {\r\n        throw new NullPointerException(\"value \u003d\u003d null\");\r\n    }\r\n    Node\u003cK, V\u003e created \u003d find(key, true);\r\n    V result \u003d created.value;\r\n    created.value \u003d value;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "put",
      "parameterTypes": [
        "K",
        "V"
      ],
      "returnType": "V"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void clear() {\r\n    root \u003d null;\r\n    size \u003d 0;\r\n    modCount++;\r\n    // Clear iteration order\r\n    Node\u003cK, V\u003e header \u003d this.header;\r\n    header.next \u003d header.prev \u003d header;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic V remove(Object key) {\r\n    Node\u003cK, V\u003e node \u003d removeInternalByKey(key);\r\n    return node !\u003d null ? node.value : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "remove",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "V"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the node at or adjacent to the given key, creating it if requested.\r\n *\r\n * @throws ClassCastException if {@code key} and the tree\u0027s keys aren\u0027t\r\n *     mutually comparable.\r\n */\r\nNode\u003cK, V\u003e find(K key, boolean create) {\r\n    Comparator\u003c? super K\u003e comparator \u003d this.comparator;\r\n    Node\u003cK, V\u003e nearest \u003d root;\r\n    int comparison \u003d 0;\r\n    if (nearest !\u003d null) {\r\n        // Micro-optimization: avoid polymorphic calls to Comparator.compare().\r\n        // Throws a ClassCastException below if there\u0027s trouble.\r\n        @SuppressWarnings(\"unchecked\")\r\n        Comparable\u003cObject\u003e comparableKey \u003d (comparator \u003d\u003d NATURAL_ORDER) ? (Comparable\u003cObject\u003e) key : null;\r\n        while (true) {\r\n            comparison \u003d (comparableKey !\u003d null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key, nearest.key);\r\n            // We found the requested key.\r\n            if (comparison \u003d\u003d 0) {\r\n                return nearest;\r\n            }\r\n            // If it exists, the key is in a subtree. Go deeper.\r\n            Node\u003cK, V\u003e child \u003d (comparison \u003c 0) ? nearest.left : nearest.right;\r\n            if (child \u003d\u003d null) {\r\n                break;\r\n            }\r\n            nearest \u003d child;\r\n        }\r\n    }\r\n    // The key doesn\u0027t exist in this tree.\r\n    if (!create) {\r\n        return null;\r\n    }\r\n    // Create the node and add it to the tree or the table.\r\n    Node\u003cK, V\u003e header \u003d this.header;\r\n    Node\u003cK, V\u003e created;\r\n    if (nearest \u003d\u003d null) {\r\n        // Check that the value is comparable if we didn\u0027t do any comparisons.\r\n        if (comparator \u003d\u003d NATURAL_ORDER \u0026\u0026 !(key instanceof Comparable)) {\r\n            throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\r\n        }\r\n        created \u003d new Node\u003c\u003e(allowNullValues, nearest, key, header, header.prev);\r\n        root \u003d created;\r\n    } else {\r\n        created \u003d new Node\u003c\u003e(allowNullValues, nearest, key, header, header.prev);\r\n        if (comparison \u003c 0) {\r\n            // nearest.key is higher\r\n            nearest.left \u003d created;\r\n        } else {\r\n            // comparison \u003e 0, nearest.key is lower\r\n            nearest.right \u003d created;\r\n        }\r\n        rebalance(nearest, true);\r\n    }\r\n    size++;\r\n    modCount++;\r\n    return created;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "find",
      "parameterTypes": [
        "K",
        "boolean"
      ],
      "returnType": "Node\u003cK, V\u003e"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\nNode\u003cK, V\u003e findByObject(Object key) {\r\n    try {\r\n        return key !\u003d null ? find((K) key, false) : null;\r\n    } catch (ClassCastException e) {\r\n        return null;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "findByObject",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "Node\u003cK, V\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns this map\u0027s entry that has the same key and value as {@code\r\n * entry}, or null if this map has no such entry.\r\n *\r\n * \u003cp\u003eThis method uses the comparator for key equality rather than {@code\r\n * equals}. If this map\u0027s comparator isn\u0027t consistent with equals (such as\r\n * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code\r\n * contains()} will violate the collections API.\r\n */\r\nNode\u003cK, V\u003e findByEntry(Entry\u003c?, ?\u003e entry) {\r\n    Node\u003cK, V\u003e mine \u003d findByObject(entry.getKey());\r\n    boolean valuesEqual \u003d mine !\u003d null \u0026\u0026 equal(mine.value, entry.getValue());\r\n    return valuesEqual ? mine : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "findByEntry",
      "parameterTypes": [
        "Entry\u003c?, ?\u003e"
      ],
      "returnType": "Node\u003cK, V\u003e"
    }
  },
  {
    "sourceCode": "private boolean equal(Object a, Object b) {\r\n    return Objects.equals(a, b);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "equal",
      "parameterTypes": [
        "Object",
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Removes {@code node} from this tree, rearranging the tree\u0027s structure as\r\n * necessary.\r\n *\r\n * @param unlink true to also unlink this node from the iteration linked list.\r\n */\r\nvoid removeInternal(Node\u003cK, V\u003e node, boolean unlink) {\r\n    if (unlink) {\r\n        node.prev.next \u003d node.next;\r\n        node.next.prev \u003d node.prev;\r\n    }\r\n    Node\u003cK, V\u003e left \u003d node.left;\r\n    Node\u003cK, V\u003e right \u003d node.right;\r\n    Node\u003cK, V\u003e originalParent \u003d node.parent;\r\n    if (left !\u003d null \u0026\u0026 right !\u003d null) {\r\n        /*\r\n       * To remove a node with both left and right subtrees, move an\r\n       * adjacent node from one of those subtrees into this node\u0027s place.\r\n       *\r\n       * Removing the adjacent node may change this node\u0027s subtrees. This\r\n       * node may no longer have two subtrees once the adjacent node is\r\n       * gone!\r\n       */\r\n        Node\u003cK, V\u003e adjacent \u003d (left.height \u003e right.height) ? left.last() : right.first();\r\n        // takes care of rebalance and size--\r\n        removeInternal(adjacent, false);\r\n        int leftHeight \u003d 0;\r\n        left \u003d node.left;\r\n        if (left !\u003d null) {\r\n            leftHeight \u003d left.height;\r\n            adjacent.left \u003d left;\r\n            left.parent \u003d adjacent;\r\n            node.left \u003d null;\r\n        }\r\n        int rightHeight \u003d 0;\r\n        right \u003d node.right;\r\n        if (right !\u003d null) {\r\n            rightHeight \u003d right.height;\r\n            adjacent.right \u003d right;\r\n            right.parent \u003d adjacent;\r\n            node.right \u003d null;\r\n        }\r\n        adjacent.height \u003d Math.max(leftHeight, rightHeight) + 1;\r\n        replaceInParent(node, adjacent);\r\n        return;\r\n    } else if (left !\u003d null) {\r\n        replaceInParent(node, left);\r\n        node.left \u003d null;\r\n    } else if (right !\u003d null) {\r\n        replaceInParent(node, right);\r\n        node.right \u003d null;\r\n    } else {\r\n        replaceInParent(node, null);\r\n    }\r\n    rebalance(originalParent, false);\r\n    size--;\r\n    modCount++;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "removeInternal",
      "parameterTypes": [
        "Node\u003cK, V\u003e",
        "boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "Node\u003cK, V\u003e removeInternalByKey(Object key) {\r\n    Node\u003cK, V\u003e node \u003d findByObject(key);\r\n    if (node !\u003d null) {\r\n        removeInternal(node, true);\r\n    }\r\n    return node;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "removeInternalByKey",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "Node\u003cK, V\u003e"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"ReferenceEquality\")\r\nprivate void replaceInParent(Node\u003cK, V\u003e node, Node\u003cK, V\u003e replacement) {\r\n    Node\u003cK, V\u003e parent \u003d node.parent;\r\n    node.parent \u003d null;\r\n    if (replacement !\u003d null) {\r\n        replacement.parent \u003d parent;\r\n    }\r\n    if (parent !\u003d null) {\r\n        if (parent.left \u003d\u003d node) {\r\n            parent.left \u003d replacement;\r\n        } else {\r\n            assert parent.right \u003d\u003d node;\r\n            parent.right \u003d replacement;\r\n        }\r\n    } else {\r\n        root \u003d replacement;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "replaceInParent",
      "parameterTypes": [
        "Node\u003cK, V\u003e",
        "Node\u003cK, V\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Rebalances the tree by making any AVL rotations necessary between the\r\n * newly-unbalanced node and the tree\u0027s root.\r\n *\r\n * @param insert true if the node was unbalanced by an insert; false if it\r\n *     was by a removal.\r\n */\r\nprivate void rebalance(Node\u003cK, V\u003e unbalanced, boolean insert) {\r\n    for (Node\u003cK, V\u003e node \u003d unbalanced; node !\u003d null; node \u003d node.parent) {\r\n        Node\u003cK, V\u003e left \u003d node.left;\r\n        Node\u003cK, V\u003e right \u003d node.right;\r\n        int leftHeight \u003d left !\u003d null ? left.height : 0;\r\n        int rightHeight \u003d right !\u003d null ? right.height : 0;\r\n        int delta \u003d leftHeight - rightHeight;\r\n        if (delta \u003d\u003d -2) {\r\n            Node\u003cK, V\u003e rightLeft \u003d right.left;\r\n            Node\u003cK, V\u003e rightRight \u003d right.right;\r\n            int rightRightHeight \u003d rightRight !\u003d null ? rightRight.height : 0;\r\n            int rightLeftHeight \u003d rightLeft !\u003d null ? rightLeft.height : 0;\r\n            int rightDelta \u003d rightLeftHeight - rightRightHeight;\r\n            if (rightDelta \u003d\u003d -1 || (rightDelta \u003d\u003d 0 \u0026\u0026 !insert)) {\r\n                // AVL right right\r\n                rotateLeft(node);\r\n            } else {\r\n                assert (rightDelta \u003d\u003d 1);\r\n                // AVL right left\r\n                rotateRight(right);\r\n                rotateLeft(node);\r\n            }\r\n            if (insert) {\r\n                // no further rotations will be necessary\r\n                break;\r\n            }\r\n        } else if (delta \u003d\u003d 2) {\r\n            Node\u003cK, V\u003e leftLeft \u003d left.left;\r\n            Node\u003cK, V\u003e leftRight \u003d left.right;\r\n            int leftRightHeight \u003d leftRight !\u003d null ? leftRight.height : 0;\r\n            int leftLeftHeight \u003d leftLeft !\u003d null ? leftLeft.height : 0;\r\n            int leftDelta \u003d leftLeftHeight - leftRightHeight;\r\n            if (leftDelta \u003d\u003d 1 || (leftDelta \u003d\u003d 0 \u0026\u0026 !insert)) {\r\n                // AVL left left\r\n                rotateRight(node);\r\n            } else {\r\n                assert (leftDelta \u003d\u003d -1);\r\n                // AVL left right\r\n                rotateLeft(left);\r\n                rotateRight(node);\r\n            }\r\n            if (insert) {\r\n                // no further rotations will be necessary\r\n                break;\r\n            }\r\n        } else if (delta \u003d\u003d 0) {\r\n            // leftHeight \u003d\u003d rightHeight\r\n            node.height \u003d leftHeight + 1;\r\n            if (insert) {\r\n                // the insert caused balance, so rebalancing is done!\r\n                break;\r\n            }\r\n        } else {\r\n            assert (delta \u003d\u003d -1 || delta \u003d\u003d 1);\r\n            node.height \u003d Math.max(leftHeight, rightHeight) + 1;\r\n            if (!insert) {\r\n                // the height hasn\u0027t changed, so rebalancing is done!\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "rebalance",
      "parameterTypes": [
        "Node\u003cK, V\u003e",
        "boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Rotates the subtree so that its root\u0027s right child is the new root.\r\n */\r\nprivate void rotateLeft(Node\u003cK, V\u003e root) {\r\n    Node\u003cK, V\u003e left \u003d root.left;\r\n    Node\u003cK, V\u003e pivot \u003d root.right;\r\n    Node\u003cK, V\u003e pivotLeft \u003d pivot.left;\r\n    Node\u003cK, V\u003e pivotRight \u003d pivot.right;\r\n    // move the pivot\u0027s left child to the root\u0027s right\r\n    root.right \u003d pivotLeft;\r\n    if (pivotLeft !\u003d null) {\r\n        pivotLeft.parent \u003d root;\r\n    }\r\n    replaceInParent(root, pivot);\r\n    // move the root to the pivot\u0027s left\r\n    pivot.left \u003d root;\r\n    root.parent \u003d pivot;\r\n    // fix heights\r\n    root.height \u003d Math.max(left !\u003d null ? left.height : 0, pivotLeft !\u003d null ? pivotLeft.height : 0) + 1;\r\n    pivot.height \u003d Math.max(root.height, pivotRight !\u003d null ? pivotRight.height : 0) + 1;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "rotateLeft",
      "parameterTypes": [
        "Node\u003cK, V\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Rotates the subtree so that its root\u0027s left child is the new root.\r\n */\r\nprivate void rotateRight(Node\u003cK, V\u003e root) {\r\n    Node\u003cK, V\u003e pivot \u003d root.left;\r\n    Node\u003cK, V\u003e right \u003d root.right;\r\n    Node\u003cK, V\u003e pivotLeft \u003d pivot.left;\r\n    Node\u003cK, V\u003e pivotRight \u003d pivot.right;\r\n    // move the pivot\u0027s right child to the root\u0027s left\r\n    root.left \u003d pivotRight;\r\n    if (pivotRight !\u003d null) {\r\n        pivotRight.parent \u003d root;\r\n    }\r\n    replaceInParent(root, pivot);\r\n    // move the root to the pivot\u0027s right\r\n    pivot.right \u003d root;\r\n    root.parent \u003d pivot;\r\n    // fixup heights\r\n    root.height \u003d Math.max(right !\u003d null ? right.height : 0, pivotRight !\u003d null ? pivotRight.height : 0) + 1;\r\n    pivot.height \u003d Math.max(root.height, pivotLeft !\u003d null ? pivotLeft.height : 0) + 1;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "rotateRight",
      "parameterTypes": [
        "Node\u003cK, V\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Set\u003cEntry\u003cK, V\u003e\u003e entrySet() {\r\n    EntrySet result \u003d entrySet;\r\n    return result !\u003d null ? result : (entrySet \u003d new EntrySet());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "entrySet",
      "parameterTypes": [],
      "returnType": "Set\u003cEntry\u003cK, V\u003e\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Set\u003cK\u003e keySet() {\r\n    KeySet result \u003d keySet;\r\n    return result !\u003d null ? result : (keySet \u003d new KeySet());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "keySet",
      "parameterTypes": [],
      "returnType": "Set\u003cK\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic K getKey() {\r\n    return key;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.Node",
      "methodName": "getKey",
      "parameterTypes": [],
      "returnType": "K"
    }
  },
  {
    "sourceCode": "@Override\r\npublic V getValue() {\r\n    return value;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.Node",
      "methodName": "getValue",
      "parameterTypes": [],
      "returnType": "V"
    }
  },
  {
    "sourceCode": "@Override\r\npublic V setValue(V value) {\r\n    if (value \u003d\u003d null \u0026\u0026 !allowNullValue) {\r\n        throw new NullPointerException(\"value \u003d\u003d null\");\r\n    }\r\n    V oldValue \u003d this.value;\r\n    this.value \u003d value;\r\n    return oldValue;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.Node",
      "methodName": "setValue",
      "parameterTypes": [
        "V"
      ],
      "returnType": "V"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    if (o instanceof Entry) {\r\n        Entry\u003c?, ?\u003e other \u003d (Entry\u003c?, ?\u003e) o;\r\n        return (key \u003d\u003d null ? other.getKey() \u003d\u003d null : key.equals(other.getKey())) \u0026\u0026 (value \u003d\u003d null ? other.getValue() \u003d\u003d null : value.equals(other.getValue()));\r\n    }\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.Node",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return (key \u003d\u003d null ? 0 : key.hashCode()) ^ (value \u003d\u003d null ? 0 : value.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.Node",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return key + \"\u003d\" + value;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.Node",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the first node in this subtree.\r\n */\r\npublic Node\u003cK, V\u003e first() {\r\n    Node\u003cK, V\u003e node \u003d this;\r\n    Node\u003cK, V\u003e child \u003d node.left;\r\n    while (child !\u003d null) {\r\n        node \u003d child;\r\n        child \u003d node.left;\r\n    }\r\n    return node;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.Node",
      "methodName": "first",
      "parameterTypes": [],
      "returnType": "Node\u003cK, V\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the last node in this subtree.\r\n */\r\npublic Node\u003cK, V\u003e last() {\r\n    Node\u003cK, V\u003e node \u003d this;\r\n    Node\u003cK, V\u003e child \u003d node.right;\r\n    while (child !\u003d null) {\r\n        node \u003d child;\r\n        child \u003d node.right;\r\n    }\r\n    return node;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.Node",
      "methodName": "last",
      "parameterTypes": [],
      "returnType": "Node\u003cK, V\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\n@SuppressWarnings(\"ReferenceEquality\")\r\npublic final boolean hasNext() {\r\n    return next !\u003d header;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.LinkedTreeMapIterator",
      "methodName": "hasNext",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"ReferenceEquality\")\r\nfinal Node\u003cK, V\u003e nextNode() {\r\n    Node\u003cK, V\u003e e \u003d next;\r\n    if (e \u003d\u003d header) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    if (modCount !\u003d expectedModCount) {\r\n        throw new ConcurrentModificationException();\r\n    }\r\n    next \u003d e.next;\r\n    return lastReturned \u003d e;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.LinkedTreeMapIterator",
      "methodName": "nextNode",
      "parameterTypes": [],
      "returnType": "Node\u003cK, V\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic final void remove() {\r\n    if (lastReturned \u003d\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    removeInternal(lastReturned, true);\r\n    lastReturned \u003d null;\r\n    expectedModCount \u003d modCount;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.LinkedTreeMapIterator",
      "methodName": "remove",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int size() {\r\n    return size;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.EntrySet",
      "methodName": "size",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Entry\u003cK, V\u003e next() {\r\n    return nextNode();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.EntrySet",
      "methodName": "next",
      "parameterTypes": [],
      "returnType": "Entry\u003cK, V\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Iterator\u003cEntry\u003cK, V\u003e\u003e iterator() {\r\n    return new LinkedTreeMapIterator\u003cEntry\u003cK, V\u003e\u003e() {\r\n\r\n        @Override\r\n        public Entry\u003cK, V\u003e next() {\r\n            return nextNode();\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.EntrySet",
      "methodName": "iterator",
      "parameterTypes": [],
      "returnType": "Iterator\u003cEntry\u003cK, V\u003e\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean contains(Object o) {\r\n    return o instanceof Entry \u0026\u0026 findByEntry((Entry\u003c?, ?\u003e) o) !\u003d null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.EntrySet",
      "methodName": "contains",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean remove(Object o) {\r\n    if (!(o instanceof Entry)) {\r\n        return false;\r\n    }\r\n    Node\u003cK, V\u003e node \u003d findByEntry((Entry\u003c?, ?\u003e) o);\r\n    if (node \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    removeInternal(node, true);\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.EntrySet",
      "methodName": "remove",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void clear() {\r\n    LinkedTreeMap.this.clear();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.EntrySet",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int size() {\r\n    return size;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.KeySet",
      "methodName": "size",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic K next() {\r\n    return nextNode().key;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.KeySet",
      "methodName": "next",
      "parameterTypes": [],
      "returnType": "K"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Iterator\u003cK\u003e iterator() {\r\n    return new LinkedTreeMapIterator\u003cK\u003e() {\r\n\r\n        @Override\r\n        public K next() {\r\n            return nextNode().key;\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.KeySet",
      "methodName": "iterator",
      "parameterTypes": [],
      "returnType": "Iterator\u003cK\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean contains(Object o) {\r\n    return containsKey(o);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.KeySet",
      "methodName": "contains",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean remove(Object key) {\r\n    return removeInternalByKey(key) !\u003d null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.KeySet",
      "methodName": "remove",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void clear() {\r\n    LinkedTreeMap.this.clear();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap.KeySet",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * If somebody is unlucky enough to have to serialize one of these, serialize\r\n * it as a LinkedHashMap so that they won\u0027t need Gson on the other side to\r\n * deserialize it. Using serialization defeats our DoS defence, so most apps\r\n * shouldn\u0027t use it.\r\n */\r\nprivate Object writeReplace() throws ObjectStreamException {\r\n    return new LinkedHashMap\u003c\u003e(this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "writeReplace",
      "parameterTypes": [],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "private void readObject(ObjectInputStream in) throws IOException {\r\n    // Don\u0027t permit directly deserializing this class; writeReplace() should have written a replacement\r\n    throw new InvalidObjectException(\"Deserialization is unsupported\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMap",
      "methodName": "readObject",
      "parameterTypes": [
        "ObjectInputStream"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic E get(int index) {\r\n    return delegate.get(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "get",
      "parameterTypes": [
        "int"
      ],
      "returnType": "E"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int size() {\r\n    return delegate.size();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "size",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "private E nonNull(E element) {\r\n    if (element \u003d\u003d null) {\r\n        throw new NullPointerException(\"Element must be non-null\");\r\n    }\r\n    return element;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "nonNull",
      "parameterTypes": [
        "E"
      ],
      "returnType": "E"
    }
  },
  {
    "sourceCode": "@Override\r\npublic E set(int index, E element) {\r\n    return delegate.set(index, nonNull(element));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "set",
      "parameterTypes": [
        "int",
        "E"
      ],
      "returnType": "E"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void add(int index, E element) {\r\n    delegate.add(index, nonNull(element));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "add",
      "parameterTypes": [
        "int",
        "E"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic E remove(int index) {\r\n    return delegate.remove(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "remove",
      "parameterTypes": [
        "int"
      ],
      "returnType": "E"
    }
  },
  {
    "sourceCode": "/* The following methods are overridden because their default implementation is inefficient */\r\n@Override\r\npublic void clear() {\r\n    delegate.clear();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean remove(Object o) {\r\n    return delegate.remove(o);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "remove",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean removeAll(Collection\u003c?\u003e c) {\r\n    return delegate.removeAll(c);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "removeAll",
      "parameterTypes": [
        "Collection\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean retainAll(Collection\u003c?\u003e c) {\r\n    return delegate.retainAll(c);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "retainAll",
      "parameterTypes": [
        "Collection\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean contains(Object o) {\r\n    return delegate.contains(o);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "contains",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int indexOf(Object o) {\r\n    return delegate.indexOf(o);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "indexOf",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int lastIndexOf(Object o) {\r\n    return delegate.lastIndexOf(o);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "lastIndexOf",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Object[] toArray() {\r\n    return delegate.toArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "toArray",
      "parameterTypes": [],
      "returnType": "Object[]"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e T[] toArray(T[] a) {\r\n    return delegate.toArray(a);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "toArray",
      "parameterTypes": [
        "T[]"
      ],
      "returnType": "T[]"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    return delegate.equals(o);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return delegate.hashCode();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NonNullElementWrapperList",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "private static void checkNumberStringLength(String s) {\r\n    if (s.length() \u003e MAX_NUMBER_STRING_LENGTH) {\r\n        throw new NumberFormatException(\"Number string too large: \" + s.substring(0, 30) + \"...\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NumberLimits",
      "methodName": "checkNumberStringLength",
      "parameterTypes": [
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public static BigDecimal parseBigDecimal(String s) throws NumberFormatException {\r\n    checkNumberStringLength(s);\r\n    BigDecimal decimal \u003d new BigDecimal(s);\r\n    // Cast to long to avoid issues with abs when value is Integer.MIN_VALUE\r\n    if (Math.abs((long) decimal.scale()) \u003e\u003d 10_000) {\r\n        throw new NumberFormatException(\"Number has unsupported scale: \" + s);\r\n    }\r\n    return decimal;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NumberLimits",
      "methodName": "parseBigDecimal",
      "parameterTypes": [
        "String"
      ],
      "returnType": "BigDecimal"
    }
  },
  {
    "sourceCode": "public static BigInteger parseBigInteger(String s) throws NumberFormatException {\r\n    checkNumberStringLength(s);\r\n    return new BigInteger(s);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.NumberLimits",
      "methodName": "parseBigInteger",
      "parameterTypes": [
        "String"
      ],
      "returnType": "BigInteger"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a new instance.\r\n */\r\npublic T construct();",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ObjectConstructor",
      "methodName": "construct",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the same DateFormat as {@code DateFormat.getDateInstance(style, Locale.US)} in Java 8 or below.\r\n */\r\npublic static DateFormat getUSDateFormat(int style) {\r\n    return new SimpleDateFormat(getDateFormatPattern(style), Locale.US);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.PreJava9DateFormatProvider",
      "methodName": "getUSDateFormat",
      "parameterTypes": [
        "int"
      ],
      "returnType": "DateFormat"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the same DateFormat as {@code DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US)}\r\n * in Java 8 or below.\r\n */\r\npublic static DateFormat getUSDateTimeFormat(int dateStyle, int timeStyle) {\r\n    String pattern \u003d getDatePartOfDateTimePattern(dateStyle) + \" \" + getTimePartOfDateTimePattern(timeStyle);\r\n    return new SimpleDateFormat(pattern, Locale.US);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.PreJava9DateFormatProvider",
      "methodName": "getUSDateTimeFormat",
      "parameterTypes": [
        "int",
        "int"
      ],
      "returnType": "DateFormat"
    }
  },
  {
    "sourceCode": "private static String getDateFormatPattern(int style) {\r\n    switch(style) {\r\n        case DateFormat.SHORT:\r\n            return \"M/d/yy\";\r\n        case DateFormat.MEDIUM:\r\n            return \"MMM d, y\";\r\n        case DateFormat.LONG:\r\n            return \"MMMM d, y\";\r\n        case DateFormat.FULL:\r\n            return \"EEEE, MMMM d, y\";\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown DateFormat style: \" + style);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.PreJava9DateFormatProvider",
      "methodName": "getDateFormatPattern",
      "parameterTypes": [
        "int"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "private static String getDatePartOfDateTimePattern(int dateStyle) {\r\n    switch(dateStyle) {\r\n        case DateFormat.SHORT:\r\n            return \"M/d/yy\";\r\n        case DateFormat.MEDIUM:\r\n            return \"MMM d, yyyy\";\r\n        case DateFormat.LONG:\r\n            return \"MMMM d, yyyy\";\r\n        case DateFormat.FULL:\r\n            return \"EEEE, MMMM d, yyyy\";\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown DateFormat style: \" + dateStyle);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.PreJava9DateFormatProvider",
      "methodName": "getDatePartOfDateTimePattern",
      "parameterTypes": [
        "int"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "private static String getTimePartOfDateTimePattern(int timeStyle) {\r\n    switch(timeStyle) {\r\n        case DateFormat.SHORT:\r\n            return \"h:mm a\";\r\n        case DateFormat.MEDIUM:\r\n            return \"h:mm:ss a\";\r\n        case DateFormat.FULL:\r\n        case DateFormat.LONG:\r\n            return \"h:mm:ss a z\";\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown DateFormat style: \" + timeStyle);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.PreJava9DateFormatProvider",
      "methodName": "getTimePartOfDateTimePattern",
      "parameterTypes": [
        "int"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if this type is a primitive.\r\n */\r\npublic static boolean isPrimitive(Type type) {\r\n    return type instanceof Class\u003c?\u003e \u0026\u0026 ((Class\u003c?\u003e) type).isPrimitive();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Primitives",
      "methodName": "isPrimitive",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns {@code true} if {@code type} is one of the nine\r\n * primitive-wrapper types, such as {@link Integer}.\r\n *\r\n * @see Class#isPrimitive\r\n */\r\npublic static boolean isWrapperType(Type type) {\r\n    return type \u003d\u003d Integer.class || type \u003d\u003d Float.class || type \u003d\u003d Byte.class || type \u003d\u003d Double.class || type \u003d\u003d Long.class || type \u003d\u003d Character.class || type \u003d\u003d Boolean.class || type \u003d\u003d Short.class || type \u003d\u003d Void.class;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Primitives",
      "methodName": "isWrapperType",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the corresponding wrapper type of {@code type} if it is a primitive\r\n * type; otherwise returns {@code type} itself. Idempotent.\r\n * \u003cpre\u003e\r\n *     wrap(int.class) \u003d\u003d Integer.class\r\n *     wrap(Integer.class) \u003d\u003d Integer.class\r\n *     wrap(String.class) \u003d\u003d String.class\r\n * \u003c/pre\u003e\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static \u003cT\u003e Class\u003cT\u003e wrap(Class\u003cT\u003e type) {\r\n    if (type \u003d\u003d int.class)\r\n        return (Class\u003cT\u003e) Integer.class;\r\n    if (type \u003d\u003d float.class)\r\n        return (Class\u003cT\u003e) Float.class;\r\n    if (type \u003d\u003d byte.class)\r\n        return (Class\u003cT\u003e) Byte.class;\r\n    if (type \u003d\u003d double.class)\r\n        return (Class\u003cT\u003e) Double.class;\r\n    if (type \u003d\u003d long.class)\r\n        return (Class\u003cT\u003e) Long.class;\r\n    if (type \u003d\u003d char.class)\r\n        return (Class\u003cT\u003e) Character.class;\r\n    if (type \u003d\u003d boolean.class)\r\n        return (Class\u003cT\u003e) Boolean.class;\r\n    if (type \u003d\u003d short.class)\r\n        return (Class\u003cT\u003e) Short.class;\r\n    if (type \u003d\u003d void.class)\r\n        return (Class\u003cT\u003e) Void.class;\r\n    return type;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Primitives",
      "methodName": "wrap",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "Class\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the corresponding primitive type of {@code type} if it is a\r\n * wrapper type; otherwise returns {@code type} itself. Idempotent.\r\n * \u003cpre\u003e\r\n *     unwrap(Integer.class) \u003d\u003d int.class\r\n *     unwrap(int.class) \u003d\u003d int.class\r\n *     unwrap(String.class) \u003d\u003d String.class\r\n * \u003c/pre\u003e\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static \u003cT\u003e Class\u003cT\u003e unwrap(Class\u003cT\u003e type) {\r\n    if (type \u003d\u003d Integer.class)\r\n        return (Class\u003cT\u003e) int.class;\r\n    if (type \u003d\u003d Float.class)\r\n        return (Class\u003cT\u003e) float.class;\r\n    if (type \u003d\u003d Byte.class)\r\n        return (Class\u003cT\u003e) byte.class;\r\n    if (type \u003d\u003d Double.class)\r\n        return (Class\u003cT\u003e) double.class;\r\n    if (type \u003d\u003d Long.class)\r\n        return (Class\u003cT\u003e) long.class;\r\n    if (type \u003d\u003d Character.class)\r\n        return (Class\u003cT\u003e) char.class;\r\n    if (type \u003d\u003d Boolean.class)\r\n        return (Class\u003cT\u003e) boolean.class;\r\n    if (type \u003d\u003d Short.class)\r\n        return (Class\u003cT\u003e) short.class;\r\n    if (type \u003d\u003d Void.class)\r\n        return (Class\u003cT\u003e) void.class;\r\n    return type;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Primitives",
      "methodName": "unwrap",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "Class\u003cT\u003e"
    }
  },
  {
    "sourceCode": "private static String getInaccessibleTroubleshootingSuffix(Exception e) {\r\n    // Class was added in Java 9, therefore cannot use instanceof\r\n    if (e.getClass().getName().equals(\"java.lang.reflect.InaccessibleObjectException\")) {\r\n        String message \u003d e.getMessage();\r\n        String troubleshootingId \u003d message !\u003d null \u0026\u0026 message.contains(\"to module com.google.gson\") ? \"reflection-inaccessible-to-module-gson\" : \"reflection-inaccessible\";\r\n        return \"\\nSee \" + TroubleshootingGuide.createUrl(troubleshootingId);\r\n    }\r\n    return \"\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "getInaccessibleTroubleshootingSuffix",
      "parameterTypes": [
        "Exception"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Internal implementation of making an {@link AccessibleObject} accessible.\r\n *\r\n * @param object the object that {@link AccessibleObject#setAccessible(boolean)} should be called on.\r\n * @throws JsonIOException if making the object accessible fails\r\n */\r\npublic static void makeAccessible(AccessibleObject object) throws JsonIOException {\r\n    try {\r\n        object.setAccessible(true);\r\n    } catch (Exception exception) {\r\n        String description \u003d getAccessibleObjectDescription(object, false);\r\n        throw new JsonIOException(\"Failed making \" + description + \" accessible; either increase its visibility\" + \" or write a custom TypeAdapter for its declaring type.\" + getInaccessibleTroubleshootingSuffix(exception), exception);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "makeAccessible",
      "parameterTypes": [
        "AccessibleObject"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a short string describing the {@link AccessibleObject} in a human-readable way.\r\n * The result is normally shorter than {@link AccessibleObject#toString()} because it omits\r\n * modifiers (e.g. {@code final}) and uses simple names for constructor and method parameter\r\n * types.\r\n *\r\n * @param object object to describe\r\n * @param uppercaseFirstLetter whether the first letter of the description should be uppercased\r\n */\r\npublic static String getAccessibleObjectDescription(AccessibleObject object, boolean uppercaseFirstLetter) {\r\n    String description;\r\n    if (object instanceof Field) {\r\n        description \u003d \"field \u0027\" + fieldToString((Field) object) + \"\u0027\";\r\n    } else if (object instanceof Method) {\r\n        Method method \u003d (Method) object;\r\n        StringBuilder methodSignatureBuilder \u003d new StringBuilder(method.getName());\r\n        appendExecutableParameters(method, methodSignatureBuilder);\r\n        String methodSignature \u003d methodSignatureBuilder.toString();\r\n        description \u003d \"method \u0027\" + method.getDeclaringClass().getName() + \"#\" + methodSignature + \"\u0027\";\r\n    } else if (object instanceof Constructor) {\r\n        description \u003d \"constructor \u0027\" + constructorToString((Constructor\u003c?\u003e) object) + \"\u0027\";\r\n    } else {\r\n        description \u003d \"\u003cunknown AccessibleObject\u003e \" + object.toString();\r\n    }\r\n    if (uppercaseFirstLetter \u0026\u0026 Character.isLowerCase(description.charAt(0))) {\r\n        description \u003d Character.toUpperCase(description.charAt(0)) + description.substring(1);\r\n    }\r\n    return description;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "getAccessibleObjectDescription",
      "parameterTypes": [
        "AccessibleObject",
        "boolean"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a string representation for a field, omitting modifiers and\r\n * the field type.\r\n */\r\npublic static String fieldToString(Field field) {\r\n    return field.getDeclaringClass().getName() + \"#\" + field.getName();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "fieldToString",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a string representation for a constructor.\r\n * E.g.: {@code java.lang.String(char[], int, int)}\r\n */\r\npublic static String constructorToString(Constructor\u003c?\u003e constructor) {\r\n    StringBuilder stringBuilder \u003d new StringBuilder(constructor.getDeclaringClass().getName());\r\n    appendExecutableParameters(constructor, stringBuilder);\r\n    return stringBuilder.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "constructorToString",
      "parameterTypes": [
        "Constructor\u003c?\u003e"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "// Note: Ideally parameter type would be java.lang.reflect.Executable, but that was added in Java 8\r\nprivate static void appendExecutableParameters(AccessibleObject executable, StringBuilder stringBuilder) {\r\n    stringBuilder.append(\u0027(\u0027);\r\n    Class\u003c?\u003e[] parameters \u003d (executable instanceof Method) ? ((Method) executable).getParameterTypes() : ((Constructor\u003c?\u003e) executable).getParameterTypes();\r\n    for (int i \u003d 0; i \u003c parameters.length; i++) {\r\n        if (i \u003e 0) {\r\n            stringBuilder.append(\", \");\r\n        }\r\n        stringBuilder.append(parameters[i].getSimpleName());\r\n    }\r\n    stringBuilder.append(\u0027)\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "appendExecutableParameters",
      "parameterTypes": [
        "AccessibleObject",
        "StringBuilder"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tries making the constructor accessible, returning an exception message\r\n * if this fails.\r\n *\r\n * @param constructor constructor to make accessible\r\n * @return exception message; {@code null} if successful, non-{@code null} if\r\n *    unsuccessful\r\n */\r\npublic static String tryMakeAccessible(Constructor\u003c?\u003e constructor) {\r\n    try {\r\n        constructor.setAccessible(true);\r\n        return null;\r\n    } catch (Exception exception) {\r\n        return \"Failed making constructor \u0027\" + constructorToString(constructor) + \"\u0027 accessible;\" + \" either increase its visibility or write a custom InstanceCreator or TypeAdapter for\" + // Include the message since it might contain more detailed information\r\n        \" its declaring type: \" + exception.getMessage() + getInaccessibleTroubleshootingSuffix(exception);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "tryMakeAccessible",
      "parameterTypes": [
        "Constructor\u003c?\u003e"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * If records are supported on the JVM, this is equivalent to a call to Class.isRecord()\r\n */\r\npublic static boolean isRecord(Class\u003c?\u003e raw) {\r\n    return RECORD_HELPER.isRecord(raw);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "isRecord",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "public static String[] getRecordComponentNames(Class\u003c?\u003e raw) {\r\n    return RECORD_HELPER.getRecordComponentNames(raw);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "getRecordComponentNames",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "String[]"
    }
  },
  {
    "sourceCode": "/**\r\n * Looks up the record accessor method that corresponds to the given record field\r\n */\r\npublic static Method getAccessor(Class\u003c?\u003e raw, Field field) {\r\n    return RECORD_HELPER.getAccessor(raw, field);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "getAccessor",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "Field"
      ],
      "returnType": "Method"
    }
  },
  {
    "sourceCode": "public static \u003cT\u003e Constructor\u003cT\u003e getCanonicalRecordConstructor(Class\u003cT\u003e raw) {\r\n    return RECORD_HELPER.getCanonicalRecordConstructor(raw);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "getCanonicalRecordConstructor",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "Constructor\u003cT\u003e"
    }
  },
  {
    "sourceCode": "public static RuntimeException createExceptionForUnexpectedIllegalAccess(IllegalAccessException exception) {\r\n    throw new RuntimeException(\"Unexpected IllegalAccessException occurred (Gson \" + GsonBuildConfig.VERSION + \").\" + \" Certain ReflectionAccessFilter features require Java \u003e\u003d 9 to work correctly. If you are not using\" + \" ReflectionAccessFilter, report this to the Gson maintainers.\", exception);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "createExceptionForUnexpectedIllegalAccess",
      "parameterTypes": [
        "IllegalAccessException"
      ],
      "returnType": "RuntimeException"
    }
  },
  {
    "sourceCode": "private static RuntimeException createExceptionForRecordReflectionException(ReflectiveOperationException exception) {\r\n    throw new RuntimeException(\"Unexpected ReflectiveOperationException occurred\" + \" (Gson \" + GsonBuildConfig.VERSION + \").\" + \" To support Java records, reflection is utilized to read out information\" + \" about records. All these invocations happens after it is established\" + \" that records exist in the JVM. This exception is unexpected behavior.\", exception);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper",
      "methodName": "createExceptionForRecordReflectionException",
      "parameterTypes": [
        "ReflectiveOperationException"
      ],
      "returnType": "RuntimeException"
    }
  },
  {
    "sourceCode": "abstract boolean isRecord(Class\u003c?\u003e clazz);",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordHelper",
      "methodName": "isRecord",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "abstract String[] getRecordComponentNames(Class\u003c?\u003e clazz);",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordHelper",
      "methodName": "getRecordComponentNames",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "String[]"
    }
  },
  {
    "sourceCode": "abstract \u003cT\u003e Constructor\u003cT\u003e getCanonicalRecordConstructor(Class\u003cT\u003e raw);",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordHelper",
      "methodName": "getCanonicalRecordConstructor",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "Constructor\u003cT\u003e"
    }
  },
  {
    "sourceCode": "public abstract Method getAccessor(Class\u003c?\u003e raw, Field field);",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordHelper",
      "methodName": "getAccessor",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "Field"
      ],
      "returnType": "Method"
    }
  },
  {
    "sourceCode": "@Override\r\nboolean isRecord(Class\u003c?\u003e raw) {\r\n    try {\r\n        return (boolean) isRecord.invoke(raw);\r\n    } catch (ReflectiveOperationException e) {\r\n        throw createExceptionForRecordReflectionException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordSupportedHelper",
      "methodName": "isRecord",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\nString[] getRecordComponentNames(Class\u003c?\u003e raw) {\r\n    try {\r\n        Object[] recordComponents \u003d (Object[]) getRecordComponents.invoke(raw);\r\n        String[] componentNames \u003d new String[recordComponents.length];\r\n        for (int i \u003d 0; i \u003c recordComponents.length; i++) {\r\n            componentNames[i] \u003d (String) getName.invoke(recordComponents[i]);\r\n        }\r\n        return componentNames;\r\n    } catch (ReflectiveOperationException e) {\r\n        throw createExceptionForRecordReflectionException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordSupportedHelper",
      "methodName": "getRecordComponentNames",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "String[]"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e Constructor\u003cT\u003e getCanonicalRecordConstructor(Class\u003cT\u003e raw) {\r\n    try {\r\n        Object[] recordComponents \u003d (Object[]) getRecordComponents.invoke(raw);\r\n        Class\u003c?\u003e[] recordComponentTypes \u003d new Class\u003c?\u003e[recordComponents.length];\r\n        for (int i \u003d 0; i \u003c recordComponents.length; i++) {\r\n            recordComponentTypes[i] \u003d (Class\u003c?\u003e) getType.invoke(recordComponents[i]);\r\n        }\r\n        // Uses getDeclaredConstructor because implicit constructor has same visibility as record and might\r\n        // therefore not be public\r\n        return raw.getDeclaredConstructor(recordComponentTypes);\r\n    } catch (ReflectiveOperationException e) {\r\n        throw createExceptionForRecordReflectionException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordSupportedHelper",
      "methodName": "getCanonicalRecordConstructor",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "Constructor\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Method getAccessor(Class\u003c?\u003e raw, Field field) {\r\n    try {\r\n        // Records consists of record components, each with a unique name, a corresponding field and accessor method\r\n        // with the same name. Ref.: https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.10.3\r\n        return raw.getMethod(field.getName());\r\n    } catch (ReflectiveOperationException e) {\r\n        throw createExceptionForRecordReflectionException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordSupportedHelper",
      "methodName": "getAccessor",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "Field"
      ],
      "returnType": "Method"
    }
  },
  {
    "sourceCode": "@Override\r\nboolean isRecord(Class\u003c?\u003e clazz) {\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordNotSupportedHelper",
      "methodName": "isRecord",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\nString[] getRecordComponentNames(Class\u003c?\u003e clazz) {\r\n    throw new UnsupportedOperationException(\"Records are not supported on this JVM, this method should not be called\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordNotSupportedHelper",
      "methodName": "getRecordComponentNames",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "String[]"
    }
  },
  {
    "sourceCode": "@Override\r\n\u003cT\u003e Constructor\u003cT\u003e getCanonicalRecordConstructor(Class\u003cT\u003e raw) {\r\n    throw new UnsupportedOperationException(\"Records are not supported on this JVM, this method should not be called\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordNotSupportedHelper",
      "methodName": "getCanonicalRecordConstructor",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "Constructor\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Method getAccessor(Class\u003c?\u003e raw, Field field) {\r\n    throw new UnsupportedOperationException(\"Records are not supported on this JVM, this method should not be called\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.ReflectionHelper.RecordNotSupportedHelper",
      "methodName": "getAccessor",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "Field"
      ],
      "returnType": "Method"
    }
  },
  {
    "sourceCode": "// Platform type detection is based on Moshi\u0027s Util.isPlatformType(Class)\r\n// See https://github.com/square/moshi/blob/3c108919ee1cce88a433ffda04eeeddc0341eae7/moshi/src/main/java/com/squareup/moshi/internal/Util.java#L141\r\npublic static boolean isJavaType(Class\u003c?\u003e c) {\r\n    return isJavaType(c.getName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ReflectionAccessFilterHelper",
      "methodName": "isJavaType",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private static boolean isJavaType(String className) {\r\n    return className.startsWith(\"java.\") || className.startsWith(\"javax.\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ReflectionAccessFilterHelper",
      "methodName": "isJavaType",
      "parameterTypes": [
        "String"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "public static boolean isAndroidType(Class\u003c?\u003e c) {\r\n    return isAndroidType(c.getName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ReflectionAccessFilterHelper",
      "methodName": "isAndroidType",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private static boolean isAndroidType(String className) {\r\n    return className.startsWith(\"android.\") || className.startsWith(\"androidx.\") || isJavaType(className);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ReflectionAccessFilterHelper",
      "methodName": "isAndroidType",
      "parameterTypes": [
        "String"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "public static boolean isAnyPlatformType(Class\u003c?\u003e c) {\r\n    String className \u003d c.getName();\r\n    return // Covers Android and Java\r\n    isAndroidType(className) || className.startsWith(\"kotlin.\") || className.startsWith(\"kotlinx.\") || className.startsWith(\"scala.\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ReflectionAccessFilterHelper",
      "methodName": "isAnyPlatformType",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Gets the result of applying all filters until the first one returns a result\r\n * other than {@link FilterResult#INDECISIVE}, or {@link FilterResult#ALLOW} if\r\n * the list of filters is empty or all returned {@code INDECISIVE}.\r\n */\r\npublic static FilterResult getFilterResult(List\u003cReflectionAccessFilter\u003e reflectionFilters, Class\u003c?\u003e c) {\r\n    for (ReflectionAccessFilter filter : reflectionFilters) {\r\n        FilterResult result \u003d filter.check(c);\r\n        if (result !\u003d FilterResult.INDECISIVE) {\r\n            return result;\r\n        }\r\n    }\r\n    return FilterResult.ALLOW;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ReflectionAccessFilterHelper",
      "methodName": "getFilterResult",
      "parameterTypes": [
        "List\u003cReflectionAccessFilter\u003e",
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "/**\r\n * See {@link AccessibleObject#canAccess(Object)} (Java \u003e\u003d 9)\r\n */\r\npublic static boolean canAccess(AccessibleObject accessibleObject, Object object) {\r\n    return AccessChecker.INSTANCE.canAccess(accessibleObject, object);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ReflectionAccessFilterHelper",
      "methodName": "canAccess",
      "parameterTypes": [
        "AccessibleObject",
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean canAccess(AccessibleObject accessibleObject, Object object) {\r\n    try {\r\n        return (Boolean) canAccessMethod.invoke(accessibleObject, object);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Failed invoking canAccess\", e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ReflectionAccessFilterHelper.AccessChecker",
      "methodName": "canAccess",
      "parameterTypes": [
        "AccessibleObject",
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean canAccess(AccessibleObject accessibleObject, Object object) {\r\n    // Cannot determine whether object can be accessed, so assume it can be accessed\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ReflectionAccessFilterHelper.AccessChecker",
      "methodName": "canAccess",
      "parameterTypes": [
        "AccessibleObject",
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "public abstract boolean canAccess(AccessibleObject accessibleObject, Object object);",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ReflectionAccessFilterHelper.AccessChecker",
      "methodName": "canAccess",
      "parameterTypes": [
        "AccessibleObject",
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "// we use a runtime check to make sure the \u0027T\u0027s equal\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    return typeToken.getRawType() \u003d\u003d java.sql.Date.class ? (TypeAdapter\u003cT\u003e) new SqlDateTypeAdapter() : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlDateTypeAdapter",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic java.sql.Date read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String s \u003d in.nextString();\r\n    try {\r\n        Date utilDate;\r\n        synchronized (this) {\r\n            utilDate \u003d format.parse(s);\r\n        }\r\n        return new java.sql.Date(utilDate.getTime());\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as SQL Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlDateTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "java.sql.Date"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, java.sql.Date value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    String dateString;\r\n    synchronized (this) {\r\n        dateString \u003d format.format(value);\r\n    }\r\n    out.value(dateString);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlDateTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "java.sql.Date"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// we use a runtime check to make sure the \u0027T\u0027s equal\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    if (typeToken.getRawType() \u003d\u003d Timestamp.class) {\r\n        final TypeAdapter\u003cDate\u003e dateTypeAdapter \u003d gson.getAdapter(Date.class);\r\n        return (TypeAdapter\u003cT\u003e) new SqlTimestampTypeAdapter(dateTypeAdapter);\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTimestampTypeAdapter",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Timestamp read(JsonReader in) throws IOException {\r\n    Date date \u003d dateTypeAdapter.read(in);\r\n    return date !\u003d null ? new Timestamp(date.getTime()) : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTimestampTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Timestamp"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Timestamp value) throws IOException {\r\n    dateTypeAdapter.write(out, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTimestampTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Timestamp"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// we use a runtime check to make sure the \u0027T\u0027s equal\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\r\n    return typeToken.getRawType() \u003d\u003d Time.class ? (TypeAdapter\u003cT\u003e) new SqlTimeTypeAdapter() : null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTimeTypeAdapter",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Time read(JsonReader in) throws IOException {\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    String s \u003d in.nextString();\r\n    try {\r\n        synchronized (this) {\r\n            Date date \u003d format.parse(s);\r\n            return new Time(date.getTime());\r\n        }\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as SQL Time; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTimeTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Time"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Time value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    String timeString;\r\n    synchronized (this) {\r\n        timeString \u003d format.format(value);\r\n    }\r\n    out.value(timeString);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTimeTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Time"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\nprotected java.sql.Date deserialize(Date date) {\r\n    return new java.sql.Date(date.getTime());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesSupport",
      "methodName": "deserialize",
      "parameterTypes": [
        "Date"
      ],
      "returnType": "java.sql.Date"
    }
  },
  {
    "sourceCode": "@Override\r\nprotected Timestamp deserialize(Date date) {\r\n    return new Timestamp(date.getTime());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesSupport",
      "methodName": "deserialize",
      "parameterTypes": [
        "Date"
      ],
      "returnType": "Timestamp"
    }
  },
  {
    "sourceCode": "/**\r\n * Takes a reader in any state and returns the next value as a JsonElement.\r\n */\r\npublic static JsonElement parse(JsonReader reader) throws JsonParseException {\r\n    boolean isEmpty \u003d true;\r\n    try {\r\n        JsonToken unused \u003d reader.peek();\r\n        isEmpty \u003d false;\r\n        return TypeAdapters.JSON_ELEMENT.read(reader);\r\n    } catch (EOFException e) {\r\n        /*\r\n       * For compatibility with JSON 1.5 and earlier, we return a JsonNull for\r\n       * empty documents instead of throwing.\r\n       */\r\n        if (isEmpty) {\r\n            return JsonNull.INSTANCE;\r\n        }\r\n        // The stream ended prematurely so it is likely a syntax error.\r\n        throw new JsonSyntaxException(e);\r\n    } catch (MalformedJsonException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams",
      "methodName": "parse",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Writes the JSON element to the writer, recursively.\r\n */\r\npublic static void write(JsonElement element, JsonWriter writer) throws IOException {\r\n    TypeAdapters.JSON_ELEMENT.write(writer, element);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams",
      "methodName": "write",
      "parameterTypes": [
        "JsonElement",
        "JsonWriter"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public static Writer writerForAppendable(Appendable appendable) {\r\n    return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams",
      "methodName": "writerForAppendable",
      "parameterTypes": [
        "Appendable"
      ],
      "returnType": "Writer"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(char[] chars, int offset, int length) throws IOException {\r\n    currentWrite.setChars(chars);\r\n    appendable.append(currentWrite, offset, offset + length);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter",
      "methodName": "write",
      "parameterTypes": [
        "char[]",
        "int",
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void flush() {\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter",
      "methodName": "flush",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void close() {\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter",
      "methodName": "close",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Override these methods for better performance\r\n// They would otherwise unnecessarily create Strings or char arrays\r\n@Override\r\npublic void write(int i) throws IOException {\r\n    appendable.append((char) i);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter",
      "methodName": "write",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(String str, int off, int len) throws IOException {\r\n    // Appendable.append turns null -\u003e \"null\", which is not desired here\r\n    Objects.requireNonNull(str);\r\n    appendable.append(str, off, off + len);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter",
      "methodName": "write",
      "parameterTypes": [
        "String",
        "int",
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Writer append(CharSequence csq) throws IOException {\r\n    appendable.append(csq);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter",
      "methodName": "append",
      "parameterTypes": [
        "CharSequence"
      ],
      "returnType": "Writer"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Writer append(CharSequence csq, int start, int end) throws IOException {\r\n    appendable.append(csq, start, end);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter",
      "methodName": "append",
      "parameterTypes": [
        "CharSequence",
        "int",
        "int"
      ],
      "returnType": "Writer"
    }
  },
  {
    "sourceCode": "void setChars(char[] chars) {\r\n    this.chars \u003d chars;\r\n    this.cachedString \u003d null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter.CurrentWrite",
      "methodName": "setChars",
      "parameterTypes": [
        "char[]"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int length() {\r\n    return chars.length;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter.CurrentWrite",
      "methodName": "length",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic char charAt(int i) {\r\n    return chars[i];\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter.CurrentWrite",
      "methodName": "charAt",
      "parameterTypes": [
        "int"
      ],
      "returnType": "char"
    }
  },
  {
    "sourceCode": "@Override\r\npublic CharSequence subSequence(int start, int end) {\r\n    return new String(chars, start, end - start);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter.CurrentWrite",
      "methodName": "subSequence",
      "parameterTypes": [
        "int",
        "int"
      ],
      "returnType": "CharSequence"
    }
  },
  {
    "sourceCode": "// Must return string representation to satisfy toString() contract\r\n@Override\r\npublic String toString() {\r\n    if (cachedString \u003d\u003d null) {\r\n        cachedString \u003d new String(chars);\r\n    }\r\n    return cachedString;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.Streams.AppendableWriter.CurrentWrite",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a URL referring to the specified troubleshooting section.\r\n */\r\npublic static String createUrl(String id) {\r\n    return \"https://github.com/google/gson/blob/main/Troubleshooting.md#\" + id;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.TroubleshootingGuide",
      "methodName": "createUrl",
      "parameterTypes": [
        "String"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public abstract \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception;",
    "methodIdentifier": {
      "className": "com.google.gson.internal.UnsafeAllocator",
      "methodName": "newInstance",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Asserts that the class is instantiable. This check should have already occurred\r\n * in {@link ConstructorConstructor}; this check here acts as safeguard since trying\r\n * to use Unsafe for non-instantiable classes might crash the JVM on some devices.\r\n */\r\nprivate static void assertInstantiable(Class\u003c?\u003e c) {\r\n    String exceptionMessage \u003d ConstructorConstructor.checkInstantiable(c);\r\n    if (exceptionMessage !\u003d null) {\r\n        throw new AssertionError(\"UnsafeAllocator is used for non-instantiable type: \" + exceptionMessage);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.UnsafeAllocator",
      "methodName": "assertInstantiable",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n    assertInstantiable(c);\r\n    return (T) allocateInstance.invoke(unsafe, c);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.UnsafeAllocator",
      "methodName": "newInstance",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n    assertInstantiable(c);\r\n    return (T) newInstance.invoke(null, c, constructorId);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.UnsafeAllocator",
      "methodName": "newInstance",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n    assertInstantiable(c);\r\n    return (T) newInstance.invoke(null, c, Object.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.UnsafeAllocator",
      "methodName": "newInstance",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\r\n    throw new UnsupportedOperationException(\"Cannot allocate \" + c + \". Usage of JDK sun.misc.Unsafe is enabled, \" + \"but it could not be used. Make sure your runtime is configured correctly.\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.UnsafeAllocator",
      "methodName": "newInstance",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "private static UnsafeAllocator create() {\r\n    // try JVM\r\n    // public class Unsafe {\r\n    // public Object allocateInstance(Class\u003c?\u003e type);\r\n    // }\r\n    try {\r\n        Class\u003c?\u003e unsafeClass \u003d Class.forName(\"sun.misc.Unsafe\");\r\n        Field f \u003d unsafeClass.getDeclaredField(\"theUnsafe\");\r\n        f.setAccessible(true);\r\n        final Object unsafe \u003d f.get(null);\r\n        final Method allocateInstance \u003d unsafeClass.getMethod(\"allocateInstance\", Class.class);\r\n        return new UnsafeAllocator() {\r\n\r\n            @Override\r\n            @SuppressWarnings(\"unchecked\")\r\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n                assertInstantiable(c);\r\n                return (T) allocateInstance.invoke(unsafe, c);\r\n            }\r\n        };\r\n    } catch (Exception ignored) {\r\n        // OK: try the next way\r\n    }\r\n    // try dalvikvm, post-gingerbread\r\n    // public class ObjectStreamClass {\r\n    // private static native int getConstructorId(Class\u003c?\u003e c);\r\n    // private static native Object newInstance(Class\u003c?\u003e instantiationClass, int methodId);\r\n    // }\r\n    try {\r\n        Method getConstructorId \u003d ObjectStreamClass.class.getDeclaredMethod(\"getConstructorId\", Class.class);\r\n        getConstructorId.setAccessible(true);\r\n        final int constructorId \u003d (Integer) getConstructorId.invoke(null, Object.class);\r\n        final Method newInstance \u003d ObjectStreamClass.class.getDeclaredMethod(\"newInstance\", Class.class, int.class);\r\n        newInstance.setAccessible(true);\r\n        return new UnsafeAllocator() {\r\n\r\n            @Override\r\n            @SuppressWarnings(\"unchecked\")\r\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n                assertInstantiable(c);\r\n                return (T) newInstance.invoke(null, c, constructorId);\r\n            }\r\n        };\r\n    } catch (Exception ignored) {\r\n        // OK: try the next way\r\n    }\r\n    // try dalvikvm, pre-gingerbread\r\n    // public class ObjectInputStream {\r\n    // private static native Object newInstance(\r\n    // Class\u003c?\u003e instantiationClass, Class\u003c?\u003e constructorClass);\r\n    // }\r\n    try {\r\n        final Method newInstance \u003d ObjectInputStream.class.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\r\n        newInstance.setAccessible(true);\r\n        return new UnsafeAllocator() {\r\n\r\n            @Override\r\n            @SuppressWarnings(\"unchecked\")\r\n            public \u003cT\u003e T newInstance(Class\u003cT\u003e c) throws Exception {\r\n                assertInstantiable(c);\r\n                return (T) newInstance.invoke(null, c, Object.class);\r\n            }\r\n        };\r\n    } catch (Exception ignored) {\r\n        // OK: try the next way\r\n    }\r\n    // give up\r\n    return new UnsafeAllocator() {\r\n\r\n        @Override\r\n        public \u003cT\u003e T newInstance(Class\u003cT\u003e c) {\r\n            throw new UnsupportedOperationException(\"Cannot allocate \" + c + \". Usage of JDK sun.misc.Unsafe is enabled, \" + \"but it could not be used. Make sure your runtime is configured correctly.\");\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.UnsafeAllocator",
      "methodName": "create",
      "parameterTypes": [],
      "returnType": "UnsafeAllocator"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a deep copy of this element and all its children.\r\n *\r\n * @since 2.8.2\r\n */\r\n@Override\r\npublic JsonArray deepCopy() {\r\n    if (!elements.isEmpty()) {\r\n        JsonArray result \u003d new JsonArray(elements.size());\r\n        for (JsonElement element : elements) {\r\n            result.add(element.deepCopy());\r\n        }\r\n        return result;\r\n    }\r\n    return new JsonArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "deepCopy",
      "parameterTypes": [],
      "returnType": "JsonArray"
    }
  },
  {
    "sourceCode": "/**\r\n * Adds the specified boolean to self.\r\n *\r\n * @param bool the boolean that needs to be added to the array.\r\n * @since 2.4\r\n */\r\npublic void add(Boolean bool) {\r\n    elements.add(bool \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(bool));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "add",
      "parameterTypes": [
        "Boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Adds the specified character to self.\r\n *\r\n * @param character the character that needs to be added to the array.\r\n * @since 2.4\r\n */\r\npublic void add(Character character) {\r\n    elements.add(character \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(character));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "add",
      "parameterTypes": [
        "Character"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Adds the specified number to self.\r\n *\r\n * @param number the number that needs to be added to the array.\r\n * @since 2.4\r\n */\r\npublic void add(Number number) {\r\n    elements.add(number \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(number));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "add",
      "parameterTypes": [
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Adds the specified string to self.\r\n *\r\n * @param string the string that needs to be added to the array.\r\n * @since 2.4\r\n */\r\npublic void add(String string) {\r\n    elements.add(string \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(string));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "add",
      "parameterTypes": [
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Adds the specified element to self.\r\n *\r\n * @param element the element that needs to be added to the array.\r\n */\r\npublic void add(JsonElement element) {\r\n    if (element \u003d\u003d null) {\r\n        element \u003d JsonNull.INSTANCE;\r\n    }\r\n    elements.add(element);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "add",
      "parameterTypes": [
        "JsonElement"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Adds all the elements of the specified array to self.\r\n *\r\n * @param array the array whose elements need to be added to the array.\r\n */\r\npublic void addAll(JsonArray array) {\r\n    elements.addAll(array.elements);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "addAll",
      "parameterTypes": [
        "JsonArray"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Replaces the element at the specified position in this array with the specified element.\r\n *\r\n * @param index index of the element to replace\r\n * @param element element to be stored at the specified position\r\n * @return the element previously at the specified position\r\n * @throws IndexOutOfBoundsException if the specified index is outside the array bounds\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonElement set(int index, JsonElement element) {\r\n    return elements.set(index, element \u003d\u003d null ? JsonNull.INSTANCE : element);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "set",
      "parameterTypes": [
        "int",
        "JsonElement"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Removes the first occurrence of the specified element from this array, if it is present.\r\n * If the array does not contain the element, it is unchanged.\r\n *\r\n * @param element element to be removed from this array, if present\r\n * @return true if this array contained the specified element, false otherwise\r\n * @since 2.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic boolean remove(JsonElement element) {\r\n    return elements.remove(element);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "remove",
      "parameterTypes": [
        "JsonElement"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Removes the element at the specified position in this array. Shifts any subsequent elements\r\n * to the left (subtracts one from their indices). Returns the element that was removed from\r\n * the array.\r\n *\r\n * @param index index the index of the element to be removed\r\n * @return the element previously at the specified position\r\n * @throws IndexOutOfBoundsException if the specified index is outside the array bounds\r\n * @since 2.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonElement remove(int index) {\r\n    return elements.remove(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "remove",
      "parameterTypes": [
        "int"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if this array contains the specified element.\r\n *\r\n * @return true if this array contains the specified element.\r\n * @param element whose presence in this array is to be tested\r\n * @since 2.3\r\n */\r\npublic boolean contains(JsonElement element) {\r\n    return elements.contains(element);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "contains",
      "parameterTypes": [
        "JsonElement"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the number of elements in the array.\r\n *\r\n * @return the number of elements in the array.\r\n */\r\npublic int size() {\r\n    return elements.size();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "size",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if the array is empty.\r\n *\r\n * @return true if the array is empty.\r\n * @since 2.8.7\r\n */\r\npublic boolean isEmpty() {\r\n    return elements.isEmpty();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "isEmpty",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns an iterator to navigate the elements of the array. Since the array is an ordered list,\r\n * the iterator navigates the elements in the order they were inserted.\r\n *\r\n * @return an iterator to navigate the elements of the array.\r\n */\r\n@Override\r\npublic Iterator\u003cJsonElement\u003e iterator() {\r\n    return elements.iterator();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "iterator",
      "parameterTypes": [],
      "returnType": "Iterator\u003cJsonElement\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the i-th element of the array.\r\n *\r\n * @param i the index of the element that is being sought.\r\n * @return the element present at the i-th index.\r\n * @throws IndexOutOfBoundsException if {@code i} is negative or greater than or equal to the\r\n * {@link #size()} of the array.\r\n */\r\npublic JsonElement get(int i) {\r\n    return elements.get(i);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "get",
      "parameterTypes": [
        "int"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "private JsonElement getAsSingleElement() {\r\n    int size \u003d elements.size();\r\n    if (size \u003d\u003d 1) {\r\n        return elements.get(0);\r\n    }\r\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsSingleElement",
      "parameterTypes": [],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a {@link Number} if it contains a single element.\r\n * This method calls {@link JsonElement#getAsNumber()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a number if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n */\r\n@Override\r\npublic Number getAsNumber() {\r\n    return getAsSingleElement().getAsNumber();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsNumber",
      "parameterTypes": [],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a {@link String} if it contains a single element.\r\n * This method calls {@link JsonElement#getAsString()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a String if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n */\r\n@Override\r\npublic String getAsString() {\r\n    return getAsSingleElement().getAsString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a double if it contains a single element.\r\n * This method calls {@link JsonElement#getAsDouble()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a double if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n */\r\n@Override\r\npublic double getAsDouble() {\r\n    return getAsSingleElement().getAsDouble();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsDouble",
      "parameterTypes": [],
      "returnType": "double"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a {@link BigDecimal} if it contains a single element.\r\n * This method calls {@link JsonElement#getAsBigDecimal()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a {@link BigDecimal} if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n * @since 1.2\r\n */\r\n@Override\r\npublic BigDecimal getAsBigDecimal() {\r\n    return getAsSingleElement().getAsBigDecimal();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsBigDecimal",
      "parameterTypes": [],
      "returnType": "BigDecimal"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a {@link BigInteger} if it contains a single element.\r\n * This method calls {@link JsonElement#getAsBigInteger()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a {@link BigInteger} if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n * @since 1.2\r\n */\r\n@Override\r\npublic BigInteger getAsBigInteger() {\r\n    return getAsSingleElement().getAsBigInteger();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsBigInteger",
      "parameterTypes": [],
      "returnType": "BigInteger"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a float if it contains a single element.\r\n * This method calls {@link JsonElement#getAsFloat()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a float if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n */\r\n@Override\r\npublic float getAsFloat() {\r\n    return getAsSingleElement().getAsFloat();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsFloat",
      "parameterTypes": [],
      "returnType": "float"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a long if it contains a single element.\r\n * This method calls {@link JsonElement#getAsLong()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a long if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n */\r\n@Override\r\npublic long getAsLong() {\r\n    return getAsSingleElement().getAsLong();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsLong",
      "parameterTypes": [],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as an integer if it contains a single element.\r\n * This method calls {@link JsonElement#getAsInt()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as an integer if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n */\r\n@Override\r\npublic int getAsInt() {\r\n    return getAsSingleElement().getAsInt();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsInt",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a primitive byte if it contains a single element.\r\n * This method calls {@link JsonElement#getAsByte()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a primitive byte if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n */\r\n@Override\r\npublic byte getAsByte() {\r\n    return getAsSingleElement().getAsByte();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsByte",
      "parameterTypes": [],
      "returnType": "byte"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a character if it contains a single element.\r\n * This method calls {@link JsonElement#getAsCharacter()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a primitive short if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n * @deprecated This method is misleading, as it does not get this element as a char but rather as\r\n * a string\u0027s first character.\r\n */\r\n@Deprecated\r\n@Override\r\npublic char getAsCharacter() {\r\n    return getAsSingleElement().getAsCharacter();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsCharacter",
      "parameterTypes": [],
      "returnType": "char"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a primitive short if it contains a single element.\r\n * This method calls {@link JsonElement#getAsShort()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a primitive short if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n */\r\n@Override\r\npublic short getAsShort() {\r\n    return getAsSingleElement().getAsShort();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsShort",
      "parameterTypes": [],
      "returnType": "short"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this array as a boolean if it contains a single element.\r\n * This method calls {@link JsonElement#getAsBoolean()} on the element, therefore any\r\n * of the exceptions declared by that method can occur.\r\n *\r\n * @return this element as a boolean if it is single element array.\r\n * @throws IllegalStateException if the array is empty or has more than one element.\r\n */\r\n@Override\r\npublic boolean getAsBoolean() {\r\n    return getAsSingleElement().getAsBoolean();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "getAsBoolean",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a mutable {@link List} view of this {@code JsonArray}. Changes to the {@code List}\r\n * are visible in this {@code JsonArray} and the other way around.\r\n *\r\n * \u003cp\u003eThe {@code List} does not permit {@code null} elements. Unlike {@code JsonArray}\u0027s\r\n * {@code null} handling, a {@link NullPointerException} is thrown when trying to add {@code null}.\r\n * Use {@link JsonNull} for JSON null values.\r\n *\r\n * @return mutable {@code List} view\r\n * @since 2.10\r\n */\r\npublic List\u003cJsonElement\u003e asList() {\r\n    return new NonNullElementWrapperList\u003c\u003e(elements);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "asList",
      "parameterTypes": [],
      "returnType": "List\u003cJsonElement\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns whether the other object is equal to this. This method only considers\r\n * the other object to be equal if it is an instance of {@code JsonArray} and has\r\n * equal elements in the same order.\r\n */\r\n@Override\r\npublic boolean equals(Object o) {\r\n    return (o \u003d\u003d this) || (o instanceof JsonArray \u0026\u0026 ((JsonArray) o).elements.equals(elements));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the hash code of this array. This method calculates the hash code based\r\n * on the elements of this array.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return elements.hashCode();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArray",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Invokes default deserialization on the specified object. It should never be invoked on\r\n * the element received as a parameter of the\r\n * {@link JsonDeserializer#deserialize(JsonElement, Type, JsonDeserializationContext)} method. Doing\r\n * so will result in an infinite loop since Gson will in-turn call the custom deserializer again.\r\n *\r\n * @param json the parse tree.\r\n * @param typeOfT type of the expected return value.\r\n * @param \u003cT\u003e The type of the deserialized object.\r\n * @return An object of type typeOfT.\r\n * @throws JsonParseException if the parse tree does not contain expected data.\r\n */\r\n@SuppressWarnings(\"TypeParameterUnusedInFormals\")\r\npublic \u003cT\u003e T deserialize(JsonElement json, Type typeOfT) throws JsonParseException;",
    "methodIdentifier": {
      "className": "com.google.gson.JsonDeserializationContext",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Gson invokes this call-back method during deserialization when it encounters a field of the\r\n * specified type.\r\n * \u003cp\u003eIn the implementation of this call-back method, you should consider invoking\r\n * {@link JsonDeserializationContext#deserialize(JsonElement, Type)} method to create objects\r\n * for any non-trivial field of the returned object. However, you should never invoke it on the\r\n * same type passing {@code json} since that will cause an infinite loop (Gson will call your\r\n * call-back method again).\r\n *\r\n * @param json The Json data being deserialized\r\n * @param typeOfT The type of the Object to deserialize to\r\n * @return a deserialized object of the specified type typeOfT which is a subclass of {@code T}\r\n * @throws JsonParseException if json is not in the expected format of {@code typeOfT}\r\n */\r\npublic T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException;",
    "methodIdentifier": {
      "className": "com.google.gson.JsonDeserializer",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a deep copy of this element. Immutable elements like primitives\r\n * and nulls are not copied.\r\n *\r\n * @since 2.8.2\r\n */\r\npublic abstract JsonElement deepCopy();",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "deepCopy",
      "parameterTypes": [],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Provides a check for verifying if this element is a JSON array or not.\r\n *\r\n * @return true if this element is of type {@link JsonArray}, false otherwise.\r\n */\r\npublic boolean isJsonArray() {\r\n    return this instanceof JsonArray;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "isJsonArray",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Provides a check for verifying if this element is a JSON object or not.\r\n *\r\n * @return true if this element is of type {@link JsonObject}, false otherwise.\r\n */\r\npublic boolean isJsonObject() {\r\n    return this instanceof JsonObject;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "isJsonObject",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Provides a check for verifying if this element is a primitive or not.\r\n *\r\n * @return true if this element is of type {@link JsonPrimitive}, false otherwise.\r\n */\r\npublic boolean isJsonPrimitive() {\r\n    return this instanceof JsonPrimitive;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "isJsonPrimitive",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Provides a check for verifying if this element represents a null value or not.\r\n *\r\n * @return true if this element is of type {@link JsonNull}, false otherwise.\r\n * @since 1.2\r\n */\r\npublic boolean isJsonNull() {\r\n    return this instanceof JsonNull;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "isJsonNull",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a {@link JsonObject}. If this element is of some\r\n * other type, an {@link IllegalStateException} will result. Hence it is best to use this method\r\n * after ensuring that this element is of the desired type by calling {@link #isJsonObject()}\r\n * first.\r\n *\r\n * @return this element as a {@link JsonObject}.\r\n * @throws IllegalStateException if this element is of another type.\r\n */\r\npublic JsonObject getAsJsonObject() {\r\n    if (isJsonObject()) {\r\n        return (JsonObject) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Object: \" + this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsJsonObject",
      "parameterTypes": [],
      "returnType": "JsonObject"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a {@link JsonArray}. If this element is of some\r\n * other type, an {@link IllegalStateException} will result. Hence it is best to use this method\r\n * after ensuring that this element is of the desired type by calling {@link #isJsonArray()}\r\n * first.\r\n *\r\n * @return this element as a {@link JsonArray}.\r\n * @throws IllegalStateException if this element is of another type.\r\n */\r\npublic JsonArray getAsJsonArray() {\r\n    if (isJsonArray()) {\r\n        return (JsonArray) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Array: \" + this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsJsonArray",
      "parameterTypes": [],
      "returnType": "JsonArray"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a {@link JsonPrimitive}. If this element is of some\r\n * other type, an {@link IllegalStateException} will result. Hence it is best to use this method\r\n * after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}\r\n * first.\r\n *\r\n * @return this element as a {@link JsonPrimitive}.\r\n * @throws IllegalStateException if this element is of another type.\r\n */\r\npublic JsonPrimitive getAsJsonPrimitive() {\r\n    if (isJsonPrimitive()) {\r\n        return (JsonPrimitive) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Primitive: \" + this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsJsonPrimitive",
      "parameterTypes": [],
      "returnType": "JsonPrimitive"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a {@link JsonNull}. If this element is of some\r\n * other type, an {@link IllegalStateException} will result. Hence it is best to use this method\r\n * after ensuring that this element is of the desired type by calling {@link #isJsonNull()}\r\n * first.\r\n *\r\n * @return this element as a {@link JsonNull}.\r\n * @throws IllegalStateException if this element is of another type.\r\n * @since 1.2\r\n */\r\n// When this method is used only to verify that the value is JsonNull\r\n@CanIgnoreReturnValue\r\npublic JsonNull getAsJsonNull() {\r\n    if (isJsonNull()) {\r\n        return (JsonNull) this;\r\n    }\r\n    throw new IllegalStateException(\"Not a JSON Null: \" + this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsJsonNull",
      "parameterTypes": [],
      "returnType": "JsonNull"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a boolean value.\r\n *\r\n * @return this element as a primitive boolean value.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n */\r\npublic boolean getAsBoolean() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsBoolean",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a {@link Number}.\r\n *\r\n * @return this element as a {@link Number}.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray},\r\n * or cannot be converted to a number.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n */\r\npublic Number getAsNumber() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsNumber",
      "parameterTypes": [],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a string value.\r\n *\r\n * @return this element as a string value.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n */\r\npublic String getAsString() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a primitive double value.\r\n *\r\n * @return this element as a primitive double value.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\r\n * @throws NumberFormatException if the value contained is not a valid double.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n */\r\npublic double getAsDouble() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsDouble",
      "parameterTypes": [],
      "returnType": "double"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a primitive float value.\r\n *\r\n * @return this element as a primitive float value.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\r\n * @throws NumberFormatException if the value contained is not a valid float.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n */\r\npublic float getAsFloat() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsFloat",
      "parameterTypes": [],
      "returnType": "float"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a primitive long value.\r\n *\r\n * @return this element as a primitive long value.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\r\n * @throws NumberFormatException if the value contained is not a valid long.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n */\r\npublic long getAsLong() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsLong",
      "parameterTypes": [],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a primitive integer value.\r\n *\r\n * @return this element as a primitive integer value.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\r\n * @throws NumberFormatException if the value contained is not a valid integer.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n */\r\npublic int getAsInt() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsInt",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a primitive byte value.\r\n *\r\n * @return this element as a primitive byte value.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\r\n * @throws NumberFormatException if the value contained is not a valid byte.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n * @since 1.3\r\n */\r\npublic byte getAsByte() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsByte",
      "parameterTypes": [],
      "returnType": "byte"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get the first character of the string value of this element.\r\n *\r\n * @return the first character of the string value.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray},\r\n * or if its string value is empty.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n * @since 1.3\r\n * @deprecated This method is misleading, as it does not get this element as a char but rather as\r\n * a string\u0027s first character.\r\n */\r\n@Deprecated\r\npublic char getAsCharacter() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsCharacter",
      "parameterTypes": [],
      "returnType": "char"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a {@link BigDecimal}.\r\n *\r\n * @return this element as a {@link BigDecimal}.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\r\n * @throws NumberFormatException if this element is not a valid {@link BigDecimal}.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n * @since 1.2\r\n */\r\npublic BigDecimal getAsBigDecimal() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsBigDecimal",
      "parameterTypes": [],
      "returnType": "BigDecimal"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a {@link BigInteger}.\r\n *\r\n * @return this element as a {@link BigInteger}.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\r\n * @throws NumberFormatException if this element is not a valid {@link BigInteger}.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n * @since 1.2\r\n */\r\npublic BigInteger getAsBigInteger() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsBigInteger",
      "parameterTypes": [],
      "returnType": "BigInteger"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a primitive short value.\r\n *\r\n * @return this element as a primitive short value.\r\n * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\r\n * @throws NumberFormatException if the value contained is not a valid short.\r\n * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\r\n * more than a single element.\r\n */\r\npublic short getAsShort() {\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "getAsShort",
      "parameterTypes": [],
      "returnType": "short"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a String representation of this element.\r\n */\r\n@Override\r\npublic String toString() {\r\n    try {\r\n        StringWriter stringWriter \u003d new StringWriter();\r\n        JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n        // Make writer lenient because toString() must not fail, even if for example JsonPrimitive contains NaN\r\n        jsonWriter.setStrictness(Strictness.LENIENT);\r\n        Streams.write(this, jsonWriter);\r\n        return stringWriter.toString();\r\n    } catch (IOException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonElement",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the same instance since it is an immutable value.\r\n *\r\n * @since 2.8.2\r\n */\r\n@Override\r\npublic JsonNull deepCopy() {\r\n    return INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonNull",
      "methodName": "deepCopy",
      "parameterTypes": [],
      "returnType": "JsonNull"
    }
  },
  {
    "sourceCode": "/**\r\n * All instances of {@code JsonNull} have the same hash code since they are indistinguishable.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return JsonNull.class.hashCode();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonNull",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * All instances of {@code JsonNull} are considered equal.\r\n */\r\n@Override\r\npublic boolean equals(Object other) {\r\n    return other instanceof JsonNull;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonNull",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a deep copy of this element and all its children.\r\n *\r\n * @since 2.8.2\r\n */\r\n@Override\r\npublic JsonObject deepCopy() {\r\n    JsonObject result \u003d new JsonObject();\r\n    for (Map.Entry\u003cString, JsonElement\u003e entry : members.entrySet()) {\r\n        result.add(entry.getKey(), entry.getValue().deepCopy());\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "deepCopy",
      "parameterTypes": [],
      "returnType": "JsonObject"
    }
  },
  {
    "sourceCode": "/**\r\n * Adds a member, which is a name-value pair, to self. The name must be a String, but the value\r\n * can be an arbitrary {@link JsonElement}, thereby allowing you to build a full tree of JsonElements\r\n * rooted at this node.\r\n *\r\n * @param property name of the member.\r\n * @param value the member object.\r\n */\r\npublic void add(String property, JsonElement value) {\r\n    members.put(property, value \u003d\u003d null ? JsonNull.INSTANCE : value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "add",
      "parameterTypes": [
        "String",
        "JsonElement"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Removes the {@code property} from this object.\r\n *\r\n * @param property name of the member that should be removed.\r\n * @return the {@link JsonElement} object that is being removed, or {@code null} if no\r\n *   member with this name exists.\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonElement remove(String property) {\r\n    return members.remove(property);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "remove",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to add a string member. The specified value is converted to a\r\n * {@link JsonPrimitive} of String.\r\n *\r\n * @param property name of the member.\r\n * @param value the string value associated with the member.\r\n */\r\npublic void addProperty(String property, String value) {\r\n    add(property, value \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(value));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "addProperty",
      "parameterTypes": [
        "String",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to add a number member. The specified value is converted to a\r\n * {@link JsonPrimitive} of Number.\r\n *\r\n * @param property name of the member.\r\n * @param value the number value associated with the member.\r\n */\r\npublic void addProperty(String property, Number value) {\r\n    add(property, value \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(value));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "addProperty",
      "parameterTypes": [
        "String",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to add a boolean member. The specified value is converted to a\r\n * {@link JsonPrimitive} of Boolean.\r\n *\r\n * @param property name of the member.\r\n * @param value the boolean value associated with the member.\r\n */\r\npublic void addProperty(String property, Boolean value) {\r\n    add(property, value \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(value));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "addProperty",
      "parameterTypes": [
        "String",
        "Boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to add a char member. The specified value is converted to a\r\n * {@link JsonPrimitive} of Character.\r\n *\r\n * @param property name of the member.\r\n * @param value the char value associated with the member.\r\n */\r\npublic void addProperty(String property, Character value) {\r\n    add(property, value \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(value));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "addProperty",
      "parameterTypes": [
        "String",
        "Character"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a set of members of this object. The set is ordered, and the order is in which the\r\n * elements were added.\r\n *\r\n * @return a set of members of this object.\r\n */\r\npublic Set\u003cMap.Entry\u003cString, JsonElement\u003e\u003e entrySet() {\r\n    return members.entrySet();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "entrySet",
      "parameterTypes": [],
      "returnType": "Set\u003cMap.Entry\u003cString, JsonElement\u003e\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a set of members key values.\r\n *\r\n * @return a set of member keys as Strings\r\n * @since 2.8.1\r\n */\r\npublic Set\u003cString\u003e keySet() {\r\n    return members.keySet();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "keySet",
      "parameterTypes": [],
      "returnType": "Set\u003cString\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the number of key/value pairs in the object.\r\n *\r\n * @return the number of key/value pairs in the object.\r\n * @since 2.7\r\n */\r\npublic int size() {\r\n    return members.size();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "size",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if the number of key/value pairs in the object is zero.\r\n *\r\n * @return true if the number of key/value pairs in the object is zero.\r\n * @since 2.10.1\r\n */\r\npublic boolean isEmpty() {\r\n    return members.size() \u003d\u003d 0;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "isEmpty",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to check if a member with the specified name is present in this object.\r\n *\r\n * @param memberName name of the member that is being checked for presence.\r\n * @return true if there is a member with the specified name, false otherwise.\r\n */\r\npublic boolean has(String memberName) {\r\n    return members.containsKey(memberName);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "has",
      "parameterTypes": [
        "String"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the member with the specified name.\r\n *\r\n * @param memberName name of the member that is being requested.\r\n * @return the member matching the name, or {@code null} if no such member exists.\r\n */\r\npublic JsonElement get(String memberName) {\r\n    return members.get(memberName);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "get",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get the specified member as a {@link JsonPrimitive}.\r\n *\r\n * @param memberName name of the member being requested.\r\n * @return the {@code JsonPrimitive} corresponding to the specified member, or {@code null} if no\r\n *   member with this name exists.\r\n * @throws ClassCastException if the member is not of type {@code JsonPrimitive}.\r\n */\r\npublic JsonPrimitive getAsJsonPrimitive(String memberName) {\r\n    return (JsonPrimitive) members.get(memberName);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "getAsJsonPrimitive",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonPrimitive"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get the specified member as a {@link JsonArray}.\r\n *\r\n * @param memberName name of the member being requested.\r\n * @return the {@code JsonArray} corresponding to the specified member, or {@code null} if no\r\n *   member with this name exists.\r\n * @throws ClassCastException if the member is not of type {@code JsonArray}.\r\n */\r\npublic JsonArray getAsJsonArray(String memberName) {\r\n    return (JsonArray) members.get(memberName);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "getAsJsonArray",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonArray"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get the specified member as a {@link JsonObject}.\r\n *\r\n * @param memberName name of the member being requested.\r\n * @return the {@code JsonObject} corresponding to the specified member, or {@code null} if no\r\n *   member with this name exists.\r\n * @throws ClassCastException if the member is not of type {@code JsonObject}.\r\n */\r\npublic JsonObject getAsJsonObject(String memberName) {\r\n    return (JsonObject) members.get(memberName);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "getAsJsonObject",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonObject"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a mutable {@link Map} view of this {@code JsonObject}. Changes to the {@code Map}\r\n * are visible in this {@code JsonObject} and the other way around.\r\n *\r\n * \u003cp\u003eThe {@code Map} does not permit {@code null} keys or values. Unlike {@code JsonObject}\u0027s\r\n * {@code null} handling, a {@link NullPointerException} is thrown when trying to add {@code null}.\r\n * Use {@link JsonNull} for JSON null values.\r\n *\r\n * @return mutable {@code Map} view\r\n * @since 2.10\r\n */\r\npublic Map\u003cString, JsonElement\u003e asMap() {\r\n    // It is safe to expose the underlying map because it disallows null keys and values\r\n    return members;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "asMap",
      "parameterTypes": [],
      "returnType": "Map\u003cString, JsonElement\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns whether the other object is equal to this. This method only considers\r\n * the other object to be equal if it is an instance of {@code JsonObject} and has\r\n * equal members, ignoring order.\r\n */\r\n@Override\r\npublic boolean equals(Object o) {\r\n    return (o \u003d\u003d this) || (o instanceof JsonObject \u0026\u0026 ((JsonObject) o).members.equals(members));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the hash code of this object. This method calculates the hash code based\r\n * on the members of this object, ignoring order.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return members.hashCode();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObject",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Parses the specified JSON string into a parse tree.\r\n * An exception is thrown if the JSON string has multiple top-level JSON elements,\r\n * or if there is trailing data.\r\n *\r\n * \u003cp\u003eThe JSON string is parsed in {@linkplain JsonReader#setStrictness(Strictness) lenient mode}.\r\n *\r\n * @param json JSON text\r\n * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\r\n * @throws JsonParseException if the specified text is not valid JSON\r\n * @since 2.8.6\r\n */\r\npublic static JsonElement parseString(String json) throws JsonSyntaxException {\r\n    return parseReader(new StringReader(json));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParser",
      "methodName": "parseString",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Parses the complete JSON string provided by the reader into a parse tree.\r\n * An exception is thrown if the JSON string has multiple top-level JSON elements,\r\n * or if there is trailing data.\r\n *\r\n * \u003cp\u003eThe JSON data is parsed in {@linkplain JsonReader#setStrictness(Strictness) lenient mode}.\r\n *\r\n * @param reader JSON text\r\n * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\r\n * @throws JsonParseException if there is an IOException or if the specified\r\n *     text is not valid JSON\r\n * @since 2.8.6\r\n */\r\npublic static JsonElement parseReader(Reader reader) throws JsonIOException, JsonSyntaxException {\r\n    try {\r\n        JsonReader jsonReader \u003d new JsonReader(reader);\r\n        JsonElement element \u003d parseReader(jsonReader);\r\n        if (!element.isJsonNull() \u0026\u0026 jsonReader.peek() !\u003d JsonToken.END_DOCUMENT) {\r\n            throw new JsonSyntaxException(\"Did not consume the entire document.\");\r\n        }\r\n        return element;\r\n    } catch (MalformedJsonException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParser",
      "methodName": "parseReader",
      "parameterTypes": [
        "Reader"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the next value from the JSON stream as a parse tree.\r\n * Unlike the other {@code parse} methods, no exception is thrown if the JSON data has\r\n * multiple top-level JSON elements, or if there is trailing data.\r\n *\r\n * \u003cp\u003eThe JSON data is parsed in {@linkplain JsonReader#setStrictness(Strictness) lenient mode},\r\n * regardless of the strictness setting of the provided reader. The strictness setting\r\n * of the reader is restored once this method returns.\r\n *\r\n * @throws JsonParseException if there is an IOException or if the specified\r\n *     text is not valid JSON\r\n * @since 2.8.6\r\n */\r\npublic static JsonElement parseReader(JsonReader reader) throws JsonIOException, JsonSyntaxException {\r\n    Strictness strictness \u003d reader.getStrictness();\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    try {\r\n        return Streams.parse(reader);\r\n    } catch (StackOverflowError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source: \" + reader + \" to Json\", e);\r\n    } catch (OutOfMemoryError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source: \" + reader + \" to Json\", e);\r\n    } finally {\r\n        reader.setStrictness(strictness);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParser",
      "methodName": "parseReader",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * @deprecated Use {@link JsonParser#parseString}\r\n */\r\n@Deprecated\r\n@InlineMe(replacement \u003d \"JsonParser.parseString(json)\", imports \u003d \"com.google.gson.JsonParser\")\r\npublic JsonElement parse(String json) throws JsonSyntaxException {\r\n    return parseString(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParser",
      "methodName": "parse",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * @deprecated Use {@link JsonParser#parseReader(Reader)}\r\n */\r\n@Deprecated\r\n@InlineMe(replacement \u003d \"JsonParser.parseReader(json)\", imports \u003d \"com.google.gson.JsonParser\")\r\npublic JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {\r\n    return parseReader(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParser",
      "methodName": "parse",
      "parameterTypes": [
        "Reader"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * @deprecated Use {@link JsonParser#parseReader(JsonReader)}\r\n */\r\n@Deprecated\r\n@InlineMe(replacement \u003d \"JsonParser.parseReader(json)\", imports \u003d \"com.google.gson.JsonParser\")\r\npublic JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {\r\n    return parseReader(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParser",
      "methodName": "parse",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the same value as primitives are immutable.\r\n *\r\n * @since 2.8.2\r\n */\r\n@Override\r\npublic JsonPrimitive deepCopy() {\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "deepCopy",
      "parameterTypes": [],
      "returnType": "JsonPrimitive"
    }
  },
  {
    "sourceCode": "/**\r\n * Check whether this primitive contains a boolean value.\r\n *\r\n * @return true if this primitive contains a boolean value, false otherwise.\r\n */\r\npublic boolean isBoolean() {\r\n    return value instanceof Boolean;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "isBoolean",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a boolean value.\r\n * If this primitive {@linkplain #isBoolean() is not a boolean}, the string value\r\n * is parsed using {@link Boolean#parseBoolean(String)}. This means {@code \"true\"} (ignoring\r\n * case) is considered {@code true} and any other value is considered {@code false}.\r\n */\r\n@Override\r\npublic boolean getAsBoolean() {\r\n    if (isBoolean()) {\r\n        return (Boolean) value;\r\n    }\r\n    // Check to see if the value as a String is \"true\" in any case.\r\n    return Boolean.parseBoolean(getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsBoolean",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Check whether this primitive contains a Number.\r\n *\r\n * @return true if this primitive contains a Number, false otherwise.\r\n */\r\npublic boolean isNumber() {\r\n    return value instanceof Number;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "isNumber",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a {@link Number}.\r\n * If this primitive {@linkplain #isString() is a string}, a lazily parsed {@code Number}\r\n * is constructed which parses the string when any of its methods are called (which can\r\n * lead to a {@link NumberFormatException}).\r\n *\r\n * @throws UnsupportedOperationException if this primitive is neither a number nor a string.\r\n */\r\n@Override\r\npublic Number getAsNumber() {\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsNumber",
      "parameterTypes": [],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "/**\r\n * Check whether this primitive contains a String value.\r\n *\r\n * @return true if this primitive contains a String value, false otherwise.\r\n */\r\npublic boolean isString() {\r\n    return value instanceof String;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "isString",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "// Don\u0027t add Javadoc, inherit it from super implementation; no exceptions are thrown here\r\n@Override\r\npublic String getAsString() {\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * @throws NumberFormatException {@inheritDoc}\r\n */\r\n@Override\r\npublic double getAsDouble() {\r\n    return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsDouble",
      "parameterTypes": [],
      "returnType": "double"
    }
  },
  {
    "sourceCode": "/**\r\n * @throws NumberFormatException {@inheritDoc}\r\n */\r\n@Override\r\npublic BigDecimal getAsBigDecimal() {\r\n    return value instanceof BigDecimal ? (BigDecimal) value : NumberLimits.parseBigDecimal(getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsBigDecimal",
      "parameterTypes": [],
      "returnType": "BigDecimal"
    }
  },
  {
    "sourceCode": "/**\r\n * @throws NumberFormatException {@inheritDoc}\r\n */\r\n@Override\r\npublic BigInteger getAsBigInteger() {\r\n    return value instanceof BigInteger ? (BigInteger) value : isIntegral(this) ? BigInteger.valueOf(this.getAsNumber().longValue()) : NumberLimits.parseBigInteger(this.getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsBigInteger",
      "parameterTypes": [],
      "returnType": "BigInteger"
    }
  },
  {
    "sourceCode": "/**\r\n * @throws NumberFormatException {@inheritDoc}\r\n */\r\n@Override\r\npublic float getAsFloat() {\r\n    return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsFloat",
      "parameterTypes": [],
      "returnType": "float"
    }
  },
  {
    "sourceCode": "/**\r\n * Convenience method to get this element as a primitive long.\r\n *\r\n * @return this element as a primitive long.\r\n * @throws NumberFormatException {@inheritDoc}\r\n */\r\n@Override\r\npublic long getAsLong() {\r\n    return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsLong",
      "parameterTypes": [],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "/**\r\n * @throws NumberFormatException {@inheritDoc}\r\n */\r\n@Override\r\npublic short getAsShort() {\r\n    return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsShort",
      "parameterTypes": [],
      "returnType": "short"
    }
  },
  {
    "sourceCode": "/**\r\n * @throws NumberFormatException {@inheritDoc}\r\n */\r\n@Override\r\npublic int getAsInt() {\r\n    return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsInt",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * @throws NumberFormatException {@inheritDoc}\r\n */\r\n@Override\r\npublic byte getAsByte() {\r\n    return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsByte",
      "parameterTypes": [],
      "returnType": "byte"
    }
  },
  {
    "sourceCode": "/**\r\n * @throws UnsupportedOperationException if the string value of this\r\n * primitive is empty.\r\n * @deprecated This method is misleading, as it does not get this element as a char but rather as\r\n * a string\u0027s first character.\r\n */\r\n@Deprecated\r\n@Override\r\npublic char getAsCharacter() {\r\n    String s \u003d getAsString();\r\n    if (s.isEmpty()) {\r\n        throw new UnsupportedOperationException(\"String value is empty\");\r\n    } else {\r\n        return s.charAt(0);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "getAsCharacter",
      "parameterTypes": [],
      "returnType": "char"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the hash code of this object.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    if (value \u003d\u003d null) {\r\n        return 31;\r\n    }\r\n    // Using recommended hashing algorithm from Effective Java for longs and doubles\r\n    if (isIntegral(this)) {\r\n        long value \u003d getAsNumber().longValue();\r\n        return (int) (value ^ (value \u003e\u003e\u003e 32));\r\n    }\r\n    if (value instanceof Number) {\r\n        long value \u003d Double.doubleToLongBits(getAsNumber().doubleValue());\r\n        return (int) (value ^ (value \u003e\u003e\u003e 32));\r\n    }\r\n    return value.hashCode();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns whether the other object is equal to this. This method only considers\r\n * the other object to be equal if it is an instance of {@code JsonPrimitive} and\r\n * has an equal value.\r\n */\r\n@Override\r\npublic boolean equals(Object obj) {\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    JsonPrimitive other \u003d (JsonPrimitive) obj;\r\n    if (value \u003d\u003d null) {\r\n        return other.value \u003d\u003d null;\r\n    }\r\n    if (isIntegral(this) \u0026\u0026 isIntegral(other)) {\r\n        return (this.value instanceof BigInteger || other.value instanceof BigInteger) ? this.getAsBigInteger().equals(other.getAsBigInteger()) : this.getAsNumber().longValue() \u003d\u003d other.getAsNumber().longValue();\r\n    }\r\n    if (value instanceof Number \u0026\u0026 other.value instanceof Number) {\r\n        double a \u003d getAsNumber().doubleValue();\r\n        // Java standard types other than double return true for two NaN. So, need\r\n        // special handling for double.\r\n        double b \u003d other.getAsNumber().doubleValue();\r\n        return a \u003d\u003d b || (Double.isNaN(a) \u0026\u0026 Double.isNaN(b));\r\n    }\r\n    return value.equals(other.value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if the specified number is an integral type\r\n * (Long, Integer, Short, Byte, BigInteger)\r\n */\r\nprivate static boolean isIntegral(JsonPrimitive primitive) {\r\n    if (primitive.value instanceof Number) {\r\n        Number number \u003d (Number) primitive.value;\r\n        return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte;\r\n    }\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitive",
      "methodName": "isIntegral",
      "parameterTypes": [
        "JsonPrimitive"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Invokes default serialization on the specified object.\r\n *\r\n * @param src the object that needs to be serialized.\r\n * @return a tree of {@link JsonElement}s corresponding to the serialized form of {@code src}.\r\n */\r\npublic JsonElement serialize(Object src);",
    "methodIdentifier": {
      "className": "com.google.gson.JsonSerializationContext",
      "methodName": "serialize",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Invokes default serialization on the specified object passing the specific type information.\r\n * It should never be invoked on the element received as a parameter of the\r\n * {@link JsonSerializer#serialize(Object, Type, JsonSerializationContext)} method. Doing\r\n * so will result in an infinite loop since Gson will in-turn call the custom serializer again.\r\n *\r\n * @param src the object that needs to be serialized.\r\n * @param typeOfSrc the actual genericized type of src object.\r\n * @return a tree of {@link JsonElement}s corresponding to the serialized form of {@code src}.\r\n */\r\npublic JsonElement serialize(Object src, Type typeOfSrc);",
    "methodIdentifier": {
      "className": "com.google.gson.JsonSerializationContext",
      "methodName": "serialize",
      "parameterTypes": [
        "Object",
        "Type"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Gson invokes this call-back method during serialization when it encounters a field of the\r\n * specified type.\r\n *\r\n * \u003cp\u003eIn the implementation of this call-back method, you should consider invoking\r\n * {@link JsonSerializationContext#serialize(Object, Type)} method to create JsonElements for any\r\n * non-trivial field of the {@code src} object. However, you should never invoke it on the\r\n * {@code src} object itself since that will cause an infinite loop (Gson will call your\r\n * call-back method again).\u003c/p\u003e\r\n *\r\n * @param src the object that needs to be converted to Json.\r\n * @param typeOfSrc the actual type (fully genericized version) of the source object.\r\n * @return a JsonElement corresponding to the specified object.\r\n */\r\npublic JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context);",
    "methodIdentifier": {
      "className": "com.google.gson.JsonSerializer",
      "methodName": "serialize",
      "parameterTypes": [
        "T",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the next available {@link JsonElement} on the reader. Throws a\r\n * {@link NoSuchElementException} if no element is available.\r\n *\r\n * @return the next available {@code JsonElement} on the reader.\r\n * @throws JsonParseException if the incoming stream is malformed JSON.\r\n * @throws NoSuchElementException if no {@code JsonElement} is available.\r\n * @since 1.4\r\n */\r\n@Override\r\npublic JsonElement next() throws JsonParseException {\r\n    if (!hasNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    try {\r\n        return Streams.parse(parser);\r\n    } catch (StackOverflowError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\r\n    } catch (OutOfMemoryError e) {\r\n        throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParser",
      "methodName": "next",
      "parameterTypes": [],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if a {@link JsonElement} is available on the input for consumption\r\n * @return true if a {@link JsonElement} is available on the input, false otherwise\r\n * @throws JsonParseException if the incoming stream is malformed JSON.\r\n * @since 1.4\r\n */\r\n@Override\r\npublic boolean hasNext() {\r\n    synchronized (lock) {\r\n        try {\r\n            return parser.peek() !\u003d JsonToken.END_DOCUMENT;\r\n        } catch (MalformedJsonException e) {\r\n            throw new JsonSyntaxException(e);\r\n        } catch (IOException e) {\r\n            throw new JsonIOException(e);\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParser",
      "methodName": "hasNext",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * This optional {@link Iterator} method is not relevant for stream parsing and hence is not\r\n * implemented.\r\n * @since 1.4\r\n */\r\n@Override\r\npublic void remove() {\r\n    throw new UnsupportedOperationException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParser",
      "methodName": "remove",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Long value) {\r\n    if (value \u003d\u003d null) {\r\n        return JsonNull.INSTANCE;\r\n    }\r\n    return new JsonPrimitive(value);\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "serialize",
      "parameterTypes": [
        "Long"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Long value) {\r\n    if (value \u003d\u003d null) {\r\n        return JsonNull.INSTANCE;\r\n    }\r\n    return new JsonPrimitive(value.toString());\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "serialize",
      "parameterTypes": [
        "Long"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Serialize this {@code value} using this serialization policy.\r\n *\r\n * @param value the long value to be serialized into a {@link JsonElement}\r\n * @return the serialized version of {@code value}\r\n */\r\npublic abstract JsonElement serialize(Long value);",
    "methodIdentifier": {
      "className": "",
      "methodName": "serialize",
      "parameterTypes": [
        "Long"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "private static boolean isCapturingTypeVariablesForbidden() {\r\n    return !Objects.equals(System.getProperty(\"gson.allowCapturingTypeVariables\"), \"true\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "isCapturingTypeVariablesForbidden",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Verifies that {@code this} is an instance of a direct subclass of TypeToken and\r\n * returns the type argument for {@code T} in {@link $Gson$Types#canonicalize\r\n * canonical form}.\r\n */\r\nprivate Type getTypeTokenTypeArgument() {\r\n    Type superclass \u003d getClass().getGenericSuperclass();\r\n    if (superclass instanceof ParameterizedType) {\r\n        ParameterizedType parameterized \u003d (ParameterizedType) superclass;\r\n        if (parameterized.getRawType() \u003d\u003d TypeToken.class) {\r\n            Type typeArgument \u003d $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\r\n            if (isCapturingTypeVariablesForbidden()) {\r\n                verifyNoTypeVariable(typeArgument);\r\n            }\r\n            return typeArgument;\r\n        }\r\n    } else // Check for raw TypeToken as superclass\r\n    if (superclass \u003d\u003d TypeToken.class) {\r\n        throw new IllegalStateException(\"TypeToken must be created with a type argument: new TypeToken\u003c...\u003e() {};\" + \" When using code shrinkers (ProGuard, R8, ...) make sure that generic signatures are preserved.\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"type-token-raw\"));\r\n    }\r\n    // User created subclass of subclass of TypeToken\r\n    throw new IllegalStateException(\"Must only create direct subclasses of TypeToken\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "getTypeTokenTypeArgument",
      "parameterTypes": [],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "private static void verifyNoTypeVariable(Type type) {\r\n    if (type instanceof TypeVariable) {\r\n        TypeVariable\u003c?\u003e typeVariable \u003d (TypeVariable\u003c?\u003e) type;\r\n        throw new IllegalArgumentException(\"TypeToken type argument must not contain a type variable; captured type variable \" + typeVariable.getName() + \" declared by \" + typeVariable.getGenericDeclaration() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"typetoken-type-variable\"));\r\n    } else if (type instanceof GenericArrayType) {\r\n        verifyNoTypeVariable(((GenericArrayType) type).getGenericComponentType());\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType parameterizedType \u003d (ParameterizedType) type;\r\n        Type ownerType \u003d parameterizedType.getOwnerType();\r\n        if (ownerType !\u003d null) {\r\n            verifyNoTypeVariable(ownerType);\r\n        }\r\n        for (Type typeArgument : parameterizedType.getActualTypeArguments()) {\r\n            verifyNoTypeVariable(typeArgument);\r\n        }\r\n    } else if (type instanceof WildcardType) {\r\n        WildcardType wildcardType \u003d (WildcardType) type;\r\n        for (Type bound : wildcardType.getLowerBounds()) {\r\n            verifyNoTypeVariable(bound);\r\n        }\r\n        for (Type bound : wildcardType.getUpperBounds()) {\r\n            verifyNoTypeVariable(bound);\r\n        }\r\n    } else if (type \u003d\u003d null) {\r\n        // Occurs in Eclipse IDE and certain Java versions (e.g. Java 11.0.18) when capturing type variable\r\n        // declared by method of local class, see https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n        throw new IllegalArgumentException(\"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "verifyNoTypeVariable",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the raw (non-generic) type for this type.\r\n */\r\npublic final Class\u003c? super T\u003e getRawType() {\r\n    return rawType;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "getRawType",
      "parameterTypes": [],
      "returnType": "Class\u003c? super T\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Gets underlying {@code Type} instance.\r\n */\r\npublic final Type getType() {\r\n    return type;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "getType",
      "parameterTypes": [],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "/**\r\n * Check if this type is assignable from the given class object.\r\n *\r\n * @deprecated this implementation may be inconsistent with javac for types\r\n *     with wildcards.\r\n */\r\n@Deprecated\r\npublic boolean isAssignableFrom(Class\u003c?\u003e cls) {\r\n    return isAssignableFrom((Type) cls);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "isAssignableFrom",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Check if this type is assignable from the given Type.\r\n *\r\n * @deprecated this implementation may be inconsistent with javac for types\r\n *     with wildcards.\r\n */\r\n@Deprecated\r\npublic boolean isAssignableFrom(Type from) {\r\n    if (from \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (type.equals(from)) {\r\n        return true;\r\n    }\r\n    if (type instanceof Class\u003c?\u003e) {\r\n        return rawType.isAssignableFrom($Gson$Types.getRawType(from));\r\n    } else if (type instanceof ParameterizedType) {\r\n        return isAssignableFrom(from, (ParameterizedType) type, new HashMap\u003cString, Type\u003e());\r\n    } else if (type instanceof GenericArrayType) {\r\n        return rawType.isAssignableFrom($Gson$Types.getRawType(from)) \u0026\u0026 isAssignableFrom(from, (GenericArrayType) type);\r\n    } else {\r\n        throw buildUnexpectedTypeError(type, Class.class, ParameterizedType.class, GenericArrayType.class);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "isAssignableFrom",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Check if this type is assignable from the given type token.\r\n *\r\n * @deprecated this implementation may be inconsistent with javac for types\r\n *     with wildcards.\r\n */\r\n@Deprecated\r\npublic boolean isAssignableFrom(TypeToken\u003c?\u003e token) {\r\n    return isAssignableFrom(token.getType());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "isAssignableFrom",
      "parameterTypes": [
        "TypeToken\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Private helper function that performs some assignability checks for\r\n * the provided GenericArrayType.\r\n */\r\nprivate static boolean isAssignableFrom(Type from, GenericArrayType to) {\r\n    Type toGenericComponentType \u003d to.getGenericComponentType();\r\n    if (toGenericComponentType instanceof ParameterizedType) {\r\n        Type t \u003d from;\r\n        if (from instanceof GenericArrayType) {\r\n            t \u003d ((GenericArrayType) from).getGenericComponentType();\r\n        } else if (from instanceof Class\u003c?\u003e) {\r\n            Class\u003c?\u003e classType \u003d (Class\u003c?\u003e) from;\r\n            while (classType.isArray()) {\r\n                classType \u003d classType.getComponentType();\r\n            }\r\n            t \u003d classType;\r\n        }\r\n        return isAssignableFrom(t, (ParameterizedType) toGenericComponentType, new HashMap\u003cString, Type\u003e());\r\n    }\r\n    // No generic defined on \"to\"; therefore, return true and let other\r\n    // checks determine assignability\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "isAssignableFrom",
      "parameterTypes": [
        "Type",
        "GenericArrayType"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Private recursive helper function to actually do the type-safe checking\r\n * of assignability.\r\n */\r\nprivate static boolean isAssignableFrom(Type from, ParameterizedType to, Map\u003cString, Type\u003e typeVarMap) {\r\n    if (from \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (to.equals(from)) {\r\n        return true;\r\n    }\r\n    // First figure out the class and any type information.\r\n    Class\u003c?\u003e clazz \u003d $Gson$Types.getRawType(from);\r\n    ParameterizedType ptype \u003d null;\r\n    if (from instanceof ParameterizedType) {\r\n        ptype \u003d (ParameterizedType) from;\r\n    }\r\n    // Load up parameterized variable info if it was parameterized.\r\n    if (ptype !\u003d null) {\r\n        Type[] tArgs \u003d ptype.getActualTypeArguments();\r\n        TypeVariable\u003c?\u003e[] tParams \u003d clazz.getTypeParameters();\r\n        for (int i \u003d 0; i \u003c tArgs.length; i++) {\r\n            Type arg \u003d tArgs[i];\r\n            TypeVariable\u003c?\u003e var \u003d tParams[i];\r\n            while (arg instanceof TypeVariable\u003c?\u003e) {\r\n                TypeVariable\u003c?\u003e v \u003d (TypeVariable\u003c?\u003e) arg;\r\n                arg \u003d typeVarMap.get(v.getName());\r\n            }\r\n            typeVarMap.put(var.getName(), arg);\r\n        }\r\n        // check if they are equivalent under our current mapping.\r\n        if (typeEquals(ptype, to, typeVarMap)) {\r\n            return true;\r\n        }\r\n    }\r\n    for (Type itype : clazz.getGenericInterfaces()) {\r\n        if (isAssignableFrom(itype, to, new HashMap\u003c\u003e(typeVarMap))) {\r\n            return true;\r\n        }\r\n    }\r\n    // Interfaces didn\u0027t work, try the superclass.\r\n    Type sType \u003d clazz.getGenericSuperclass();\r\n    return isAssignableFrom(sType, to, new HashMap\u003c\u003e(typeVarMap));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "isAssignableFrom",
      "parameterTypes": [
        "Type",
        "ParameterizedType",
        "Map\u003cString, Type\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Checks if two parameterized types are exactly equal, under the variable\r\n * replacement described in the typeVarMap.\r\n */\r\nprivate static boolean typeEquals(ParameterizedType from, ParameterizedType to, Map\u003cString, Type\u003e typeVarMap) {\r\n    if (from.getRawType().equals(to.getRawType())) {\r\n        Type[] fromArgs \u003d from.getActualTypeArguments();\r\n        Type[] toArgs \u003d to.getActualTypeArguments();\r\n        for (int i \u003d 0; i \u003c fromArgs.length; i++) {\r\n            if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "typeEquals",
      "parameterTypes": [
        "ParameterizedType",
        "ParameterizedType",
        "Map\u003cString, Type\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private static AssertionError buildUnexpectedTypeError(Type token, Class\u003c?\u003e... expected) {\r\n    // Build exception message\r\n    StringBuilder exceptionMessage \u003d new StringBuilder(\"Unexpected type. Expected one of: \");\r\n    for (Class\u003c?\u003e clazz : expected) {\r\n        exceptionMessage.append(clazz.getName()).append(\", \");\r\n    }\r\n    exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append(\u0027.\u0027);\r\n    return new AssertionError(exceptionMessage.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "buildUnexpectedTypeError",
      "parameterTypes": [
        "Type",
        "Class\u003c?\u003e"
      ],
      "returnType": "AssertionError"
    }
  },
  {
    "sourceCode": "/**\r\n * Checks if two types are the same or are equivalent under a variable mapping\r\n * given in the type map that was provided.\r\n */\r\nprivate static boolean matches(Type from, Type to, Map\u003cString, Type\u003e typeMap) {\r\n    return to.equals(from) || (from instanceof TypeVariable \u0026\u0026 to.equals(typeMap.get(((TypeVariable\u003c?\u003e) from).getName())));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "matches",
      "parameterTypes": [
        "Type",
        "Type",
        "Map\u003cString, Type\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic final int hashCode() {\r\n    return this.hashCode;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic final boolean equals(Object o) {\r\n    return o instanceof TypeToken\u003c?\u003e \u0026\u0026 $Gson$Types.equals(type, ((TypeToken\u003c?\u003e) o).type);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic final String toString() {\r\n    return $Gson$Types.typeToString(type);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Gets type literal for the given {@code Type} instance.\r\n */\r\npublic static TypeToken\u003c?\u003e get(Type type) {\r\n    return new TypeToken\u003c\u003e(type);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "get",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "TypeToken\u003c?\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Gets type literal for the given {@code Class} instance.\r\n */\r\npublic static \u003cT\u003e TypeToken\u003cT\u003e get(Class\u003cT\u003e type) {\r\n    return new TypeToken\u003c\u003e(type);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "get",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "TypeToken\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Gets a type literal for the parameterized type represented by applying {@code typeArguments} to\r\n * {@code rawType}. This is mainly intended for situations where the type arguments are not\r\n * available at compile time. The following example shows how a type token for {@code Map\u003cK, V\u003e}\r\n * can be created:\r\n * \u003cpre\u003e{@code\r\n * Class\u003cK\u003e keyClass \u003d ...;\r\n * Class\u003cV\u003e valueClass \u003d ...;\r\n * TypeToken\u003c?\u003e mapTypeToken \u003d TypeToken.getParameterized(Map.class, keyClass, valueClass);\r\n * }\u003c/pre\u003e\r\n * As seen here the result is a {@code TypeToken\u003c?\u003e}; this method cannot provide any type-safety,\r\n * and care must be taken to pass in the correct number of type arguments.\r\n *\r\n * \u003cp\u003eIf {@code rawType} is a non-generic class and no type arguments are provided, this method\r\n * simply delegates to {@link #get(Class)} and creates a {@code TypeToken(Class)}.\r\n *\r\n * @throws IllegalArgumentException\r\n *   If {@code rawType} is not of type {@code Class}, or if the type arguments are invalid for\r\n *   the raw type\r\n */\r\npublic static TypeToken\u003c?\u003e getParameterized(Type rawType, Type... typeArguments) {\r\n    Objects.requireNonNull(rawType);\r\n    Objects.requireNonNull(typeArguments);\r\n    // Perform basic validation here because this is the only public API where users\r\n    // can create malformed parameterized types\r\n    if (!(rawType instanceof Class)) {\r\n        // See also https://bugs.openjdk.org/browse/JDK-8250659\r\n        throw new IllegalArgumentException(\"rawType must be of type Class, but was \" + rawType);\r\n    }\r\n    Class\u003c?\u003e rawClass \u003d (Class\u003c?\u003e) rawType;\r\n    TypeVariable\u003c?\u003e[] typeVariables \u003d rawClass.getTypeParameters();\r\n    int expectedArgsCount \u003d typeVariables.length;\r\n    int actualArgsCount \u003d typeArguments.length;\r\n    if (actualArgsCount !\u003d expectedArgsCount) {\r\n        throw new IllegalArgumentException(rawClass.getName() + \" requires \" + expectedArgsCount + \" type arguments, but got \" + actualArgsCount);\r\n    }\r\n    // For legacy reasons create a TypeToken(Class) if the type is not generic\r\n    if (typeArguments.length \u003d\u003d 0) {\r\n        return get(rawClass);\r\n    }\r\n    // Check for this here to avoid misleading exception thrown by ParameterizedTypeImpl\r\n    if ($Gson$Types.requiresOwnerType(rawType)) {\r\n        throw new IllegalArgumentException(\"Raw type \" + rawClass.getName() + \" is not supported because\" + \" it requires specifying an owner type\");\r\n    }\r\n    for (int i \u003d 0; i \u003c expectedArgsCount; i++) {\r\n        Type typeArgument \u003d Objects.requireNonNull(typeArguments[i], \"Type argument must not be null\");\r\n        Class\u003c?\u003e rawTypeArgument \u003d $Gson$Types.getRawType(typeArgument);\r\n        TypeVariable\u003c?\u003e typeVariable \u003d typeVariables[i];\r\n        for (Type bound : typeVariable.getBounds()) {\r\n            Class\u003c?\u003e rawBound \u003d $Gson$Types.getRawType(bound);\r\n            if (!rawBound.isAssignableFrom(rawTypeArgument)) {\r\n                throw new IllegalArgumentException(\"Type argument \" + typeArgument + \" does not satisfy bounds\" + \" for type variable \" + typeVariable + \" declared by \" + rawType);\r\n            }\r\n        }\r\n    }\r\n    return new TypeToken\u003c\u003e($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "getParameterized",
      "parameterTypes": [
        "Type",
        "Type"
      ],
      "returnType": "TypeToken\u003c?\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Gets type literal for the array type whose elements are all instances of {@code componentType}.\r\n */\r\npublic static TypeToken\u003c?\u003e getArray(Type componentType) {\r\n    return new TypeToken\u003c\u003e($Gson$Types.arrayOf(componentType));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeToken",
      "methodName": "getArray",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "TypeToken\u003c?\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return ReflectionAccessFilterHelper.isJavaType(rawClass) ? FilterResult.BLOCK_INACCESSIBLE : FilterResult.INDECISIVE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ReflectionAccessFilter",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return ReflectionAccessFilterHelper.isJavaType(rawClass) ? FilterResult.BLOCK_ALL : FilterResult.INDECISIVE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ReflectionAccessFilter",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return ReflectionAccessFilterHelper.isAndroidType(rawClass) ? FilterResult.BLOCK_ALL : FilterResult.INDECISIVE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ReflectionAccessFilter",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return ReflectionAccessFilterHelper.isAnyPlatformType(rawClass) ? FilterResult.BLOCK_ALL : FilterResult.INDECISIVE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ReflectionAccessFilter",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "/**\r\n * Checks if reflection access should be allowed for a class.\r\n *\r\n * @param rawClass\r\n *    Class to check\r\n * @return\r\n *    Result indicating whether reflection access is allowed\r\n */\r\nFilterResult check(Class\u003c?\u003e rawClass);",
    "methodIdentifier": {
      "className": "com.google.gson.ReflectionAccessFilter",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "/**\r\n * Sets the strictness of this reader.\r\n *\r\n * @deprecated Please use {@link #setStrictness(Strictness)} instead.\r\n * {@code JsonReader.setLenient(true)} should be replaced by {@code JsonReader.setStrictness(Strictness.LENIENT)}\r\n * and {@code JsonReader.setLenient(false)} should be replaced by {@code JsonReader.setStrictness(Strictness.LEGACY_STRICT)}.\u003cbr\u003e\r\n * However, if you used {@code setLenient(false)} before, you might prefer {@link Strictness#STRICT} now instead.\r\n *\r\n * @param lenient whether this reader should be lenient. If true, the strictness is set to {@link Strictness#LENIENT}.\r\n *                If false, the strictness is set to {@link Strictness#LEGACY_STRICT}.\r\n * @see #setStrictness(Strictness)\r\n */\r\n@Deprecated\r\n// Don\u0027t specify @InlineMe, so caller with `setLenient(false)` becomes aware of new Strictness.STRICT\r\n@SuppressWarnings(\"InlineMeSuggester\")\r\npublic final void setLenient(boolean lenient) {\r\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "setLenient",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if the {@link Strictness} of this reader is equal to {@link Strictness#LENIENT}.\r\n *\r\n * @see #setStrictness(Strictness)\r\n */\r\npublic final boolean isLenient() {\r\n    return strictness \u003d\u003d Strictness.LENIENT;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "isLenient",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures how liberal this parser is in what it accepts.\r\n *\r\n * \u003cp\u003eIn {@linkplain Strictness#STRICT strict} mode, the\r\n * parser only accepts JSON in accordance with \u003ca href\u003d\"https://www.ietf.org/rfc/rfc8259.txt\"\u003eRFC 8259\u003c/a\u003e.\r\n * In {@linkplain Strictness#LEGACY_STRICT legacy strict} mode (the default), only JSON in accordance with the\r\n * RFC 8259 is accepted, with a few exceptions denoted below for backwards compatibility reasons.\r\n * In {@linkplain Strictness#LENIENT lenient} mode, all sort of non-spec compliant JSON is accepted (see below).\u003c/p\u003e\r\n *\r\n * \u003cdl\u003e\r\n *     \u003cdt\u003e{@link Strictness#STRICT}\u003c/dt\u003e\r\n *     \u003cdd\u003e\r\n *         In strict mode, only input compliant with RFC 8259 is accepted.\r\n *     \u003c/dd\u003e\r\n *     \u003cdt\u003e{@link Strictness#LEGACY_STRICT}\u003c/dt\u003e\r\n *     \u003cdd\u003e\r\n *         In legacy strict mode, the following departures from RFC 8259 are accepted:\r\n *         \u003cul\u003e\r\n *             \u003cli\u003eJsonReader allows the literals {@code true}, {@code false} and {@code null}\r\n *                 to have any capitalization, for example {@code fAlSe} or {@code NULL}\r\n *             \u003cli\u003eJsonReader supports the escape sequence {@code \\\u0027}, representing a {@code \u0027} (single-quote)\r\n *             \u003cli\u003eJsonReader supports the escape sequence \u003ccode\u003e\\\u003ci\u003eLF\u003c/i\u003e\u003c/code\u003e (with {@code LF}\r\n *                 being the Unicode character {@code U+000A}), resulting in a {@code LF} within the\r\n *                 read JSON string\r\n *             \u003cli\u003eJsonReader allows unescaped control characters ({@code U+0000} through {@code U+001F})\r\n *         \u003c/ul\u003e\r\n *     \u003c/dd\u003e\r\n *     \u003cdt\u003e{@link Strictness#LENIENT}\u003c/dt\u003e\r\n *     \u003cdd\u003e\r\n *         In lenient mode, all input that is accepted in legacy strict mode is accepted in addition to the following\r\n *         departures from RFC 8259:\r\n *         \u003cul\u003e\r\n *             \u003cli\u003eStreams that start with the \u003ca href\u003d\"#nonexecuteprefix\"\u003enon-execute prefix\u003c/a\u003e, {@code \")]}\u0027\\n\"}\r\n *             \u003cli\u003eStreams that include multiple top-level values. With legacy strict or strict parsing,\r\n *                 each stream must contain exactly one top-level value.\r\n *             \u003cli\u003eNumbers may be {@link Double#isNaN() NaNs} or {@link Double#isInfinite() infinities} represented by\r\n *                 {@code NaN} and {@code (-)Infinity} respectively.\r\n *             \u003cli\u003eEnd of line comments starting with {@code //} or {@code #} and ending with a newline character.\r\n *             \u003cli\u003eC-style comments starting with {@code /*} and ending with\r\n *                 {@code *}{@code /}. Such comments may not be nested.\r\n *             \u003cli\u003eNames that are unquoted or {@code \u0027single quoted\u0027}.\r\n *             \u003cli\u003eStrings that are unquoted or {@code \u0027single quoted\u0027}.\r\n *             \u003cli\u003eArray elements separated by {@code ;} instead of {@code ,}.\r\n *             \u003cli\u003eUnnecessary array separators. These are interpreted as if null\r\n *                 was the omitted value.\r\n *             \u003cli\u003eNames and values separated by {@code \u003d} or {@code \u003d\u003e} instead of\r\n *                 {@code :}.\r\n *             \u003cli\u003eName/value pairs separated by {@code ;} instead of {@code ,}.\r\n *         \u003c/ul\u003e\r\n *     \u003c/dd\u003e\r\n * \u003c/dl\u003e\r\n *\r\n * @param strictness the new strictness value of this reader. May not be {@code null}.\r\n * @since $next-version$\r\n */\r\npublic final void setStrictness(Strictness strictness) {\r\n    Objects.requireNonNull(strictness);\r\n    this.strictness \u003d strictness;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "setStrictness",
      "parameterTypes": [
        "Strictness"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the {@linkplain Strictness strictness} of this reader.\r\n *\r\n * @see #setStrictness(Strictness)\r\n * @since $next-version$\r\n */\r\npublic final Strictness getStrictness() {\r\n    return strictness;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "getStrictness",
      "parameterTypes": [],
      "returnType": "Strictness"
    }
  },
  {
    "sourceCode": "/**\r\n * Consumes the next token from the JSON stream and asserts that it is the\r\n * beginning of a new array.\r\n */\r\npublic void beginArray() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_BEGIN_ARRAY) {\r\n        push(JsonScope.EMPTY_ARRAY);\r\n        pathIndices[stackSize - 1] \u003d 0;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"BEGIN_ARRAY\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "beginArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Consumes the next token from the JSON stream and asserts that it is the\r\n * end of the current array.\r\n */\r\npublic void endArray() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_END_ARRAY) {\r\n        stackSize--;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"END_ARRAY\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "endArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Consumes the next token from the JSON stream and asserts that it is the\r\n * beginning of a new object.\r\n */\r\npublic void beginObject() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_BEGIN_OBJECT) {\r\n        push(JsonScope.EMPTY_OBJECT);\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"BEGIN_OBJECT\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "beginObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Consumes the next token from the JSON stream and asserts that it is the\r\n * end of the current object.\r\n */\r\npublic void endObject() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_END_OBJECT) {\r\n        stackSize--;\r\n        // Free the last path name so that it can be garbage collected!\r\n        pathNames[stackSize] \u003d null;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"END_OBJECT\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "endObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if the current array or object has another element.\r\n */\r\npublic boolean hasNext() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    return p !\u003d PEEKED_END_OBJECT \u0026\u0026 p !\u003d PEEKED_END_ARRAY \u0026\u0026 p !\u003d PEEKED_EOF;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "hasNext",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the type of the next token without consuming it.\r\n */\r\npublic JsonToken peek() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "peek",
      "parameterTypes": [],
      "returnType": "JsonToken"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"fallthrough\")\r\nint doPeek() throws IOException {\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (strictness \u003d\u003d Strictness.LENIENT) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "doPeek",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "private int peekKeyword() throws IOException {\r\n    // Figure out which keyword we\u0027re matching against by its first character.\r\n    char c \u003d buffer[pos];\r\n    String keyword;\r\n    String keywordUpper;\r\n    int peeking;\r\n    // Look at the first letter to determine what keyword we are trying to match.\r\n    if (c \u003d\u003d \u0027t\u0027 || c \u003d\u003d \u0027T\u0027) {\r\n        keyword \u003d \"true\";\r\n        keywordUpper \u003d \"TRUE\";\r\n        peeking \u003d PEEKED_TRUE;\r\n    } else if (c \u003d\u003d \u0027f\u0027 || c \u003d\u003d \u0027F\u0027) {\r\n        keyword \u003d \"false\";\r\n        keywordUpper \u003d \"FALSE\";\r\n        peeking \u003d PEEKED_FALSE;\r\n    } else if (c \u003d\u003d \u0027n\u0027 || c \u003d\u003d \u0027N\u0027) {\r\n        keyword \u003d \"null\";\r\n        keywordUpper \u003d \"NULL\";\r\n        peeking \u003d PEEKED_NULL;\r\n    } else {\r\n        return PEEKED_NONE;\r\n    }\r\n    // Uppercased keywords are not allowed in STRICT mode\r\n    boolean allowsUpperCased \u003d strictness !\u003d Strictness.STRICT;\r\n    // Confirm that chars [0..length) match the keyword.\r\n    int length \u003d keyword.length();\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        if (pos + i \u003e\u003d limit \u0026\u0026 !fillBuffer(i + 1)) {\r\n            return PEEKED_NONE;\r\n        }\r\n        c \u003d buffer[pos + i];\r\n        boolean matched \u003d c \u003d\u003d keyword.charAt(i) || (allowsUpperCased \u0026\u0026 c \u003d\u003d keywordUpper.charAt(i));\r\n        if (!matched) {\r\n            return PEEKED_NONE;\r\n        }\r\n    }\r\n    if ((pos + length \u003c limit || fillBuffer(length + 1)) \u0026\u0026 isLiteral(buffer[pos + length])) {\r\n        // Don\u0027t match trues, falsey or nullsoft!\r\n        return PEEKED_NONE;\r\n    }\r\n    // We\u0027ve found the keyword followed either by EOF or by a non-literal character.\r\n    pos +\u003d length;\r\n    return peeked \u003d peeking;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "peekKeyword",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "private int peekNumber() throws IOException {\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    int p \u003d pos;\r\n    int l \u003d limit;\r\n    // Negative to accommodate Long.MIN_VALUE more easily.\r\n    long value \u003d 0;\r\n    boolean negative \u003d false;\r\n    boolean fitsInLong \u003d true;\r\n    int last \u003d NUMBER_CHAR_NONE;\r\n    int i \u003d 0;\r\n    charactersOfNumber: for (; true; i++) {\r\n        if (p + i \u003d\u003d l) {\r\n            if (i \u003d\u003d buffer.length) {\r\n                // Though this looks like a well-formed number, it\u0027s too long to continue reading. Give up\r\n                // and let the application handle this as an unquoted literal.\r\n                return PEEKED_NONE;\r\n            }\r\n            if (!fillBuffer(i + 1)) {\r\n                break;\r\n            }\r\n            p \u003d pos;\r\n            l \u003d limit;\r\n        }\r\n        char c \u003d buffer[p + i];\r\n        switch(c) {\r\n            case \u0027-\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_NONE) {\r\n                    negative \u003d true;\r\n                    last \u003d NUMBER_CHAR_SIGN;\r\n                    continue;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_EXP_E) {\r\n                    last \u003d NUMBER_CHAR_EXP_SIGN;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case \u0027+\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_EXP_E) {\r\n                    last \u003d NUMBER_CHAR_EXP_SIGN;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case \u0027e\u0027:\r\n            case \u0027E\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_DIGIT || last \u003d\u003d NUMBER_CHAR_FRACTION_DIGIT) {\r\n                    last \u003d NUMBER_CHAR_EXP_E;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case \u0027.\u0027:\r\n                if (last \u003d\u003d NUMBER_CHAR_DIGIT) {\r\n                    last \u003d NUMBER_CHAR_DECIMAL;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            default:\r\n                if (c \u003c \u00270\u0027 || c \u003e \u00279\u0027) {\r\n                    if (!isLiteral(c)) {\r\n                        break charactersOfNumber;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                }\r\n                if (last \u003d\u003d NUMBER_CHAR_SIGN || last \u003d\u003d NUMBER_CHAR_NONE) {\r\n                    value \u003d -(c - \u00270\u0027);\r\n                    last \u003d NUMBER_CHAR_DIGIT;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_DIGIT) {\r\n                    if (value \u003d\u003d 0) {\r\n                        // Leading \u00270\u0027 prefix is not allowed (since it could be octal).\r\n                        return PEEKED_NONE;\r\n                    }\r\n                    long newValue \u003d value * 10 - (c - \u00270\u0027);\r\n                    fitsInLong \u0026\u003d value \u003e MIN_INCOMPLETE_INTEGER || (value \u003d\u003d MIN_INCOMPLETE_INTEGER \u0026\u0026 newValue \u003c value);\r\n                    value \u003d newValue;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_DECIMAL) {\r\n                    last \u003d NUMBER_CHAR_FRACTION_DIGIT;\r\n                } else if (last \u003d\u003d NUMBER_CHAR_EXP_E || last \u003d\u003d NUMBER_CHAR_EXP_SIGN) {\r\n                    last \u003d NUMBER_CHAR_EXP_DIGIT;\r\n                }\r\n        }\r\n    }\r\n    // We\u0027ve read a complete number. Decide if it\u0027s a PEEKED_LONG or a PEEKED_NUMBER.\r\n    // Don\u0027t store -0 as long; user might want to read it as double -0.0\r\n    // Don\u0027t try to convert Long.MIN_VALUE to positive long; it would overflow MAX_VALUE\r\n    if (last \u003d\u003d NUMBER_CHAR_DIGIT \u0026\u0026 fitsInLong \u0026\u0026 (value !\u003d Long.MIN_VALUE || negative) \u0026\u0026 (value !\u003d 0 || !negative)) {\r\n        peekedLong \u003d negative ? value : -value;\r\n        pos +\u003d i;\r\n        return peeked \u003d PEEKED_LONG;\r\n    } else if (last \u003d\u003d NUMBER_CHAR_DIGIT || last \u003d\u003d NUMBER_CHAR_FRACTION_DIGIT || last \u003d\u003d NUMBER_CHAR_EXP_DIGIT) {\r\n        peekedNumberLength \u003d i;\r\n        return peeked \u003d PEEKED_NUMBER;\r\n    } else {\r\n        return PEEKED_NONE;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "peekNumber",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"fallthrough\")\r\nprivate boolean isLiteral(char c) throws IOException {\r\n    switch(c) {\r\n        case \u0027/\u0027:\r\n        case \u0027\\\\\u0027:\r\n        case \u0027;\u0027:\r\n        case \u0027#\u0027:\r\n        case \u0027\u003d\u0027:\r\n            // fall-through\r\n            checkLenient();\r\n        case \u0027{\u0027:\r\n        case \u0027}\u0027:\r\n        case \u0027[\u0027:\r\n        case \u0027]\u0027:\r\n        case \u0027:\u0027:\r\n        case \u0027,\u0027:\r\n        case \u0027 \u0027:\r\n        case \u0027\\t\u0027:\r\n        case \u0027\\f\u0027:\r\n        case \u0027\\r\u0027:\r\n        case \u0027\\n\u0027:\r\n            return false;\r\n        default:\r\n            return true;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "isLiteral",
      "parameterTypes": [
        "char"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the next token, a {@link JsonToken#NAME property name}, and consumes it.\r\n *\r\n * @throws IOException if the next token in the stream is not a property\r\n *     name.\r\n */\r\npublic String nextName() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    String result;\r\n    if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\r\n        result \u003d nextUnquotedValue();\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\r\n        result \u003d nextQuotedValue(\u0027\\\u0027\u0027);\r\n    } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\r\n        result \u003d nextQuotedValue(\u0027\"\u0027);\r\n    } else {\r\n        throw unexpectedTokenError(\"a name\");\r\n    }\r\n    peeked \u003d PEEKED_NONE;\r\n    pathNames[stackSize - 1] \u003d result;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "nextName",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the {@link JsonToken#STRING string} value of the next token,\r\n * consuming it. If the next token is a number, this method will return its\r\n * string form.\r\n *\r\n * @throws IllegalStateException if the next token is not a string or if\r\n *     this reader is closed.\r\n */\r\npublic String nextString() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    String result;\r\n    if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n        result \u003d nextUnquotedValue();\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED) {\r\n        result \u003d nextQuotedValue(\u0027\\\u0027\u0027);\r\n    } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\r\n        result \u003d nextQuotedValue(\u0027\"\u0027);\r\n    } else if (p \u003d\u003d PEEKED_BUFFERED) {\r\n        result \u003d peekedString;\r\n        peekedString \u003d null;\r\n    } else if (p \u003d\u003d PEEKED_LONG) {\r\n        result \u003d Long.toString(peekedLong);\r\n    } else if (p \u003d\u003d PEEKED_NUMBER) {\r\n        result \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else {\r\n        throw unexpectedTokenError(\"a string\");\r\n    }\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "nextString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\r\n * consuming it.\r\n *\r\n * @throws IllegalStateException if the next token is not a boolean or if\r\n *     this reader is closed.\r\n */\r\npublic boolean nextBoolean() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_TRUE) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return true;\r\n    } else if (p \u003d\u003d PEEKED_FALSE) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return false;\r\n    }\r\n    throw unexpectedTokenError(\"a boolean\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "nextBoolean",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Consumes the next token from the JSON stream and asserts that it is a\r\n * literal null.\r\n *\r\n * @throws IllegalStateException if the next token is not null or if this\r\n *     reader is closed.\r\n */\r\npublic void nextNull() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_NULL) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n    } else {\r\n        throw unexpectedTokenError(\"null\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "nextNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the {@link JsonToken#NUMBER double} value of the next token,\r\n * consuming it. If the next token is a string, this method will attempt to\r\n * parse it as a double using {@link Double#parseDouble(String)}.\r\n *\r\n * @throws IllegalStateException if the next token is not a literal value.\r\n * @throws NumberFormatException if the next literal value cannot be parsed\r\n *     as a double.\r\n * @throws MalformedJsonException if the next literal value is NaN or Infinity\r\n *     and this reader is not {@link #setStrictness(Strictness) lenient}.\r\n */\r\npublic double nextDouble() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return (double) peekedLong;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\r\n        peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n    } else if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n        peekedString \u003d nextUnquotedValue();\r\n    } else if (p !\u003d PEEKED_BUFFERED) {\r\n        throw unexpectedTokenError(\"a double\");\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double result \u003d Double.parseDouble(peekedString);\r\n    if (strictness !\u003d Strictness.LENIENT \u0026\u0026 (Double.isNaN(result) || Double.isInfinite(result))) {\r\n        throw syntaxError(\"JSON forbids NaN and infinities: \" + result);\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "nextDouble",
      "parameterTypes": [],
      "returnType": "double"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the {@link JsonToken#NUMBER long} value of the next token,\r\n * consuming it. If the next token is a string, this method will attempt to\r\n * parse it as a long. If the next token\u0027s numeric value cannot be exactly\r\n * represented by a Java {@code long}, this method throws.\r\n *\r\n * @throws IllegalStateException if the next token is not a literal value.\r\n * @throws NumberFormatException if the next literal value cannot be parsed\r\n *     as a number, or exactly represented as a long.\r\n */\r\npublic long nextLong() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return peekedLong;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED || p \u003d\u003d PEEKED_UNQUOTED) {\r\n        if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n            peekedString \u003d nextUnquotedValue();\r\n        } else {\r\n            peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n        }\r\n        try {\r\n            long result \u003d Long.parseLong(peekedString);\r\n            peeked \u003d PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        } catch (NumberFormatException ignored) {\r\n            // Fall back to parse as a double below.\r\n        }\r\n    } else {\r\n        throw unexpectedTokenError(\"a long\");\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double asDouble \u003d Double.parseDouble(peekedString);\r\n    long result \u003d (long) asDouble;\r\n    if (result !\u003d asDouble) {\r\n        // Make sure no precision was lost casting to \u0027long\u0027.\r\n        throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "nextLong",
      "parameterTypes": [],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the string up to but not including {@code quote}, unescaping any\r\n * character escape sequences encountered along the way. The opening quote\r\n * should have already been read. This consumes the closing quote, but does\r\n * not include it in the returned string.\r\n *\r\n * @param quote either \u0027 or \".\r\n * @throws NumberFormatException if any unicode escape sequences are\r\n *     malformed.\r\n */\r\nprivate String nextQuotedValue(char quote) throws IOException {\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    StringBuilder builder \u003d null;\r\n    while (true) {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        int start \u003d p;\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            // In strict mode, throw an exception when meeting unescaped control characters (U+0000 through U+001F)\r\n            if (strictness \u003d\u003d Strictness.STRICT \u0026\u0026 c \u003c 0x20) {\r\n                throw syntaxError(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n            } else if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    return new String(buffer, start, len);\r\n                } else {\r\n                    builder.append(buffer, start, len);\r\n                    return builder.toString();\r\n                }\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    int estimatedLength \u003d (len + 1) * 2;\r\n                    builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n                }\r\n                builder.append(buffer, start, len);\r\n                builder.append(readEscapeCharacter());\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n                start \u003d p;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        if (builder \u003d\u003d null) {\r\n            int estimatedLength \u003d (p - start) * 2;\r\n            builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n        }\r\n        builder.append(buffer, start, p - start);\r\n        pos \u003d p;\r\n        if (!fillBuffer(1)) {\r\n            throw syntaxError(\"Unterminated string\");\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "nextQuotedValue",
      "parameterTypes": [
        "char"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns an unquoted value as a string.\r\n */\r\n@SuppressWarnings(\"fallthrough\")\r\nprivate String nextUnquotedValue() throws IOException {\r\n    StringBuilder builder \u003d null;\r\n    int i \u003d 0;\r\n    findNonLiteralCharacter: while (true) {\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    break findNonLiteralCharacter;\r\n            }\r\n        }\r\n        // Attempt to load the entire literal into the buffer at once.\r\n        if (i \u003c buffer.length) {\r\n            if (fillBuffer(i + 1)) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // use a StringBuilder when the value is too long. This is too long to be a number!\r\n        if (builder \u003d\u003d null) {\r\n            builder \u003d new StringBuilder(Math.max(i, 16));\r\n        }\r\n        builder.append(buffer, pos, i);\r\n        pos +\u003d i;\r\n        i \u003d 0;\r\n        if (!fillBuffer(1)) {\r\n            break;\r\n        }\r\n    }\r\n    String result \u003d (null \u003d\u003d builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n    pos +\u003d i;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "nextUnquotedValue",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "private void skipQuotedValue(char quote) throws IOException {\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    do {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                return;\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                char unused \u003d readEscapeCharacter();\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        pos \u003d p;\r\n    } while (fillBuffer(1));\r\n    throw syntaxError(\"Unterminated string\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "skipQuotedValue",
      "parameterTypes": [
        "char"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"fallthrough\")\r\nprivate void skipUnquotedValue() throws IOException {\r\n    do {\r\n        int i \u003d 0;\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    pos +\u003d i;\r\n                    return;\r\n            }\r\n        }\r\n        pos +\u003d i;\r\n    } while (fillBuffer(1));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "skipUnquotedValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the {@link JsonToken#NUMBER int} value of the next token,\r\n * consuming it. If the next token is a string, this method will attempt to\r\n * parse it as an int. If the next token\u0027s numeric value cannot be exactly\r\n * represented by a Java {@code int}, this method throws.\r\n *\r\n * @throws IllegalStateException if the next token is not a literal value.\r\n * @throws NumberFormatException if the next literal value cannot be parsed\r\n *     as a number, or exactly represented as an int.\r\n */\r\npublic int nextInt() throws IOException {\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    int result;\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        result \u003d (int) peekedLong;\r\n        if (peekedLong !\u003d result) {\r\n            // Make sure no precision was lost casting to \u0027int\u0027.\r\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\r\n        }\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return result;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED || p \u003d\u003d PEEKED_UNQUOTED) {\r\n        if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n            peekedString \u003d nextUnquotedValue();\r\n        } else {\r\n            peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n        }\r\n        try {\r\n            result \u003d Integer.parseInt(peekedString);\r\n            peeked \u003d PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        } catch (NumberFormatException ignored) {\r\n            // Fall back to parse as a double below.\r\n        }\r\n    } else {\r\n        throw unexpectedTokenError(\"an int\");\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double asDouble \u003d Double.parseDouble(peekedString);\r\n    result \u003d (int) asDouble;\r\n    if (result !\u003d asDouble) {\r\n        // Make sure no precision was lost casting to \u0027int\u0027.\r\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "nextInt",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Closes this JSON reader and the underlying {@link Reader}.\r\n */\r\n@Override\r\npublic void close() throws IOException {\r\n    peeked \u003d PEEKED_NONE;\r\n    stack[0] \u003d JsonScope.CLOSED;\r\n    stackSize \u003d 1;\r\n    in.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "close",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Skips the next value recursively. This method is intended for use when\r\n * the JSON token stream contains unrecognized or unhandled values.\r\n *\r\n * \u003cp\u003eThe behavior depends on the type of the next JSON token:\r\n * \u003cul\u003e\r\n *   \u003cli\u003eStart of a JSON array or object: It and all of its nested values are skipped.\u003c/li\u003e\r\n *   \u003cli\u003ePrimitive value (for example a JSON number): The primitive value is skipped.\u003c/li\u003e\r\n *   \u003cli\u003eProperty name: Only the name but not the value of the property is skipped.\r\n *   {@code skipValue()} has to be called again to skip the property value as well.\u003c/li\u003e\r\n *   \u003cli\u003eEnd of a JSON array or object: Only this end token is skipped.\u003c/li\u003e\r\n *   \u003cli\u003eEnd of JSON document: Skipping has no effect, the next token continues to be the\r\n *   end of the document.\u003c/li\u003e\r\n * \u003c/ul\u003e\r\n */\r\npublic void skipValue() throws IOException {\r\n    int count \u003d 0;\r\n    do {\r\n        int p \u003d peeked;\r\n        if (p \u003d\u003d PEEKED_NONE) {\r\n            p \u003d doPeek();\r\n        }\r\n        switch(p) {\r\n            case PEEKED_BEGIN_ARRAY:\r\n                push(JsonScope.EMPTY_ARRAY);\r\n                count++;\r\n                break;\r\n            case PEEKED_BEGIN_OBJECT:\r\n                push(JsonScope.EMPTY_OBJECT);\r\n                count++;\r\n                break;\r\n            case PEEKED_END_ARRAY:\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_END_OBJECT:\r\n                // Only update when object end is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    // Free the last path name so that it can be garbage collected\r\n                    pathNames[stackSize - 1] \u003d null;\r\n                }\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_UNQUOTED:\r\n                skipUnquotedValue();\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED:\r\n                skipQuotedValue(\u0027\\\u0027\u0027);\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED:\r\n                skipQuotedValue(\u0027\"\u0027);\r\n                break;\r\n            case PEEKED_UNQUOTED_NAME:\r\n                skipUnquotedValue();\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED_NAME:\r\n                skipQuotedValue(\u0027\\\u0027\u0027);\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED_NAME:\r\n                skipQuotedValue(\u0027\"\u0027);\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_NUMBER:\r\n                pos +\u003d peekedNumberLength;\r\n                break;\r\n            case PEEKED_EOF:\r\n                // Do nothing\r\n                return;\r\n        }\r\n        peeked \u003d PEEKED_NONE;\r\n    } while (count \u003e 0);\r\n    pathIndices[stackSize - 1]++;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "skipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void push(int newTop) {\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        int newLength \u003d stackSize * 2;\r\n        stack \u003d Arrays.copyOf(stack, newLength);\r\n        pathIndices \u003d Arrays.copyOf(pathIndices, newLength);\r\n        pathNames \u003d Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "push",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true once {@code limit - pos \u003e\u003d minimum}. If the data is\r\n * exhausted before that many characters are available, this returns\r\n * false.\r\n */\r\nprivate boolean fillBuffer(int minimum) throws IOException {\r\n    char[] buffer \u003d this.buffer;\r\n    lineStart -\u003d pos;\r\n    if (limit !\u003d pos) {\r\n        limit -\u003d pos;\r\n        System.arraycopy(buffer, pos, buffer, 0, limit);\r\n    } else {\r\n        limit \u003d 0;\r\n    }\r\n    pos \u003d 0;\r\n    int total;\r\n    while ((total \u003d in.read(buffer, limit, buffer.length - limit)) !\u003d -1) {\r\n        limit +\u003d total;\r\n        // if this is the first read, consume an optional byte order mark (BOM) if it exists\r\n        if (lineNumber \u003d\u003d 0 \u0026\u0026 lineStart \u003d\u003d 0 \u0026\u0026 limit \u003e 0 \u0026\u0026 buffer[0] \u003d\u003d \u0027\\ufeff\u0027) {\r\n            pos++;\r\n            lineStart++;\r\n            minimum++;\r\n        }\r\n        if (limit \u003e\u003d minimum) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "fillBuffer",
      "parameterTypes": [
        "int"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the next character in the stream that is neither whitespace nor a\r\n * part of a comment. When this returns, the returned character is always at\r\n * {@code buffer[pos-1]}; this means the caller can always push back the\r\n * returned character by decrementing {@code pos}.\r\n */\r\nprivate int nextNonWhitespace(boolean throwOnEof) throws IOException {\r\n    /*\r\n     * This code uses ugly local variables \u0027p\u0027 and \u0027l\u0027 representing the \u0027pos\u0027\r\n     * and \u0027limit\u0027 fields respectively. Using locals rather than fields saves\r\n     * a few field reads for each whitespace character in a pretty-printed\r\n     * document, resulting in a 5% speedup. We need to flush \u0027p\u0027 to its field\r\n     * before any (potentially indirect) call to fillBuffer() and reread both\r\n     * \u0027p\u0027 and \u0027l\u0027 after any (potentially indirect) call to the same method.\r\n     */\r\n    char[] buffer \u003d this.buffer;\r\n    int p \u003d pos;\r\n    int l \u003d limit;\r\n    while (true) {\r\n        if (p \u003d\u003d l) {\r\n            pos \u003d p;\r\n            if (!fillBuffer(1)) {\r\n                break;\r\n            }\r\n            p \u003d pos;\r\n            l \u003d limit;\r\n        }\r\n        int c \u003d buffer[p++];\r\n        if (c \u003d\u003d \u0027\\n\u0027) {\r\n            lineNumber++;\r\n            lineStart \u003d p;\r\n            continue;\r\n        } else if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\t\u0027) {\r\n            continue;\r\n        }\r\n        if (c \u003d\u003d \u0027/\u0027) {\r\n            pos \u003d p;\r\n            if (p \u003d\u003d l) {\r\n                // push back \u0027/\u0027 so it\u0027s still in the buffer when this method returns\r\n                pos--;\r\n                boolean charsLoaded \u003d fillBuffer(2);\r\n                // consume the \u0027/\u0027 again\r\n                pos++;\r\n                if (!charsLoaded) {\r\n                    return c;\r\n                }\r\n            }\r\n            checkLenient();\r\n            char peek \u003d buffer[pos];\r\n            switch(peek) {\r\n                case \u0027*\u0027:\r\n                    // skip a /* c-style comment */\r\n                    pos++;\r\n                    if (!skipTo(\"*/\")) {\r\n                        throw syntaxError(\"Unterminated comment\");\r\n                    }\r\n                    p \u003d pos + 2;\r\n                    l \u003d limit;\r\n                    continue;\r\n                case \u0027/\u0027:\r\n                    // skip a // end-of-line comment\r\n                    pos++;\r\n                    skipToEndOfLine();\r\n                    p \u003d pos;\r\n                    l \u003d limit;\r\n                    continue;\r\n                default:\r\n                    return c;\r\n            }\r\n        } else if (c \u003d\u003d \u0027#\u0027) {\r\n            pos \u003d p;\r\n            /*\r\n         * Skip a # hash end-of-line comment. The JSON RFC doesn\u0027t\r\n         * specify this behaviour, but it\u0027s required to parse\r\n         * existing documents. See http://b/2571423.\r\n         */\r\n            checkLenient();\r\n            skipToEndOfLine();\r\n            p \u003d pos;\r\n            l \u003d limit;\r\n        } else {\r\n            pos \u003d p;\r\n            return c;\r\n        }\r\n    }\r\n    if (throwOnEof) {\r\n        throw new EOFException(\"End of input\" + locationString());\r\n    } else {\r\n        return -1;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "nextNonWhitespace",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "private void checkLenient() throws IOException {\r\n    if (strictness !\u003d Strictness.LENIENT) {\r\n        throw syntaxError(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "checkLenient",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Advances the position until after the next newline character. If the line\r\n * is terminated by \"\\r\\n\", the \u0027\\n\u0027 must be consumed as whitespace by the\r\n * caller.\r\n */\r\nprivate void skipToEndOfLine() throws IOException {\r\n    while (pos \u003c limit || fillBuffer(1)) {\r\n        char c \u003d buffer[pos++];\r\n        if (c \u003d\u003d \u0027\\n\u0027) {\r\n            lineNumber++;\r\n            lineStart \u003d pos;\r\n            break;\r\n        } else if (c \u003d\u003d \u0027\\r\u0027) {\r\n            break;\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "skipToEndOfLine",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * @param toFind a string to search for. Must not contain a newline.\r\n */\r\nprivate boolean skipTo(String toFind) throws IOException {\r\n    int length \u003d toFind.length();\r\n    outer: for (; pos + length \u003c\u003d limit || fillBuffer(length); pos++) {\r\n        if (buffer[pos] \u003d\u003d \u0027\\n\u0027) {\r\n            lineNumber++;\r\n            lineStart \u003d pos + 1;\r\n            continue;\r\n        }\r\n        for (int c \u003d 0; c \u003c length; c++) {\r\n            if (buffer[pos + c] !\u003d toFind.charAt(c)) {\r\n                continue outer;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "skipTo",
      "parameterTypes": [
        "String"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return getClass().getSimpleName() + locationString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "String locationString() {\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "locationString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "private String getPath(boolean usePreviousPath) {\r\n    StringBuilder result \u003d new StringBuilder().append(\u0027$\u0027);\r\n    for (int i \u003d 0; i \u003c stackSize; i++) {\r\n        switch(stack[i]) {\r\n            case JsonScope.EMPTY_ARRAY:\r\n            case JsonScope.NONEMPTY_ARRAY:\r\n                int pathIndex \u003d pathIndices[i];\r\n                // If index is last path element it points to next array element; have to decrement\r\n                if (usePreviousPath \u0026\u0026 pathIndex \u003e 0 \u0026\u0026 i \u003d\u003d stackSize - 1) {\r\n                    pathIndex--;\r\n                }\r\n                result.append(\u0027[\u0027).append(pathIndex).append(\u0027]\u0027);\r\n                break;\r\n            case JsonScope.EMPTY_OBJECT:\r\n            case JsonScope.DANGLING_NAME:\r\n            case JsonScope.NONEMPTY_OBJECT:\r\n                result.append(\u0027.\u0027);\r\n                if (pathNames[i] !\u003d null) {\r\n                    result.append(pathNames[i]);\r\n                }\r\n                break;\r\n            case JsonScope.NONEMPTY_DOCUMENT:\r\n            case JsonScope.EMPTY_DOCUMENT:\r\n            case JsonScope.CLOSED:\r\n                break;\r\n        }\r\n    }\r\n    return result.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "getPath",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a \u003ca href\u003d\"https://goessner.net/articles/JsonPath/\"\u003eJSONPath\u003c/a\u003e\r\n * in \u003ci\u003edot-notation\u003c/i\u003e to the previous (or current) location in the JSON document:\r\n * \u003cul\u003e\r\n *   \u003cli\u003eFor JSON arrays the path points to the index of the previous element.\u003cbr\u003e\r\n *   If no element has been consumed yet it uses the index 0 (even if there are no elements).\u003c/li\u003e\r\n *   \u003cli\u003eFor JSON objects the path points to the last property, or to the current\r\n *   property if its name has already been consumed.\u003c/li\u003e\r\n * \u003c/ul\u003e\r\n *\r\n * \u003cp\u003eThis method can be useful to add additional context to exception messages\r\n * \u003ci\u003eafter\u003c/i\u003e a value has been consumed.\r\n */\r\npublic String getPreviousPath() {\r\n    return getPath(true);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "getPreviousPath",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a \u003ca href\u003d\"https://goessner.net/articles/JsonPath/\"\u003eJSONPath\u003c/a\u003e\r\n * in \u003ci\u003edot-notation\u003c/i\u003e to the next (or current) location in the JSON document:\r\n * \u003cul\u003e\r\n *   \u003cli\u003eFor JSON arrays the path points to the index of the next element (even\r\n *   if there are no further elements).\u003c/li\u003e\r\n *   \u003cli\u003eFor JSON objects the path points to the last property, or to the current\r\n *   property if its name has already been consumed.\u003c/li\u003e\r\n * \u003c/ul\u003e\r\n *\r\n * \u003cp\u003eThis method can be useful to add additional context to exception messages\r\n * \u003ci\u003ebefore\u003c/i\u003e a value is consumed, for example when the {@linkplain #peek() peeked}\r\n * token is unexpected.\r\n */\r\npublic String getPath() {\r\n    return getPath(false);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "getPath",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Unescapes the character identified by the character or characters that\r\n * immediately follow a backslash. The backslash \u0027\\\u0027 should have already\r\n * been read. This supports both Unicode escapes \"u000A\" and two-character\r\n * escapes \"\\n\".\r\n *\r\n * @throws MalformedJsonException if any Unicode escape sequences are\r\n *     malformed.\r\n */\r\n@SuppressWarnings(\"fallthrough\")\r\nprivate char readEscapeCharacter() throws IOException {\r\n    if (pos \u003d\u003d limit \u0026\u0026 !fillBuffer(1)) {\r\n        throw syntaxError(\"Unterminated escape sequence\");\r\n    }\r\n    char escaped \u003d buffer[pos++];\r\n    switch(escaped) {\r\n        case \u0027u\u0027:\r\n            if (pos + 4 \u003e limit \u0026\u0026 !fillBuffer(4)) {\r\n                throw syntaxError(\"Unterminated escape sequence\");\r\n            }\r\n            // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\r\n            int result \u003d 0;\r\n            for (int i \u003d pos, end \u003d i + 4; i \u003c end; i++) {\r\n                char c \u003d buffer[i];\r\n                result \u003c\u003c\u003d 4;\r\n                if (c \u003e\u003d \u00270\u0027 \u0026\u0026 c \u003c\u003d \u00279\u0027) {\r\n                    result +\u003d (c - \u00270\u0027);\r\n                } else if (c \u003e\u003d \u0027a\u0027 \u0026\u0026 c \u003c\u003d \u0027f\u0027) {\r\n                    result +\u003d (c - \u0027a\u0027 + 10);\r\n                } else if (c \u003e\u003d \u0027A\u0027 \u0026\u0026 c \u003c\u003d \u0027F\u0027) {\r\n                    result +\u003d (c - \u0027A\u0027 + 10);\r\n                } else {\r\n                    throw syntaxError(\"Malformed Unicode escape \\\\u\" + new String(buffer, pos, 4));\r\n                }\r\n            }\r\n            pos +\u003d 4;\r\n            return (char) result;\r\n        case \u0027t\u0027:\r\n            return \u0027\\t\u0027;\r\n        case \u0027b\u0027:\r\n            return \u0027\\b\u0027;\r\n        case \u0027n\u0027:\r\n            return \u0027\\n\u0027;\r\n        case \u0027r\u0027:\r\n            return \u0027\\r\u0027;\r\n        case \u0027f\u0027:\r\n            return \u0027\\f\u0027;\r\n        case \u0027\\n\u0027:\r\n            if (strictness \u003d\u003d Strictness.STRICT) {\r\n                throw syntaxError(\"Cannot escape a newline character in strict mode\");\r\n            }\r\n            lineNumber++;\r\n            lineStart \u003d pos;\r\n        // fall-through\r\n        case \u0027\\\u0027\u0027:\r\n            if (strictness \u003d\u003d Strictness.STRICT) {\r\n                throw syntaxError(\"Invalid escaped character \\\"\u0027\\\" in strict mode\");\r\n            }\r\n        case \u0027\"\u0027:\r\n        case \u0027\\\\\u0027:\r\n        case \u0027/\u0027:\r\n            return escaped;\r\n        default:\r\n            // throw error when none of the above cases are matched\r\n            throw syntaxError(\"Invalid escape sequence\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "readEscapeCharacter",
      "parameterTypes": [],
      "returnType": "char"
    }
  },
  {
    "sourceCode": "/**\r\n * Throws a new IO exception with the given message and a context snippet\r\n * with this reader\u0027s content.\r\n */\r\nprivate IOException syntaxError(String message) throws IOException {\r\n    throw new MalformedJsonException(message + locationString() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"malformed-json\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "syntaxError",
      "parameterTypes": [
        "String"
      ],
      "returnType": "IOException"
    }
  },
  {
    "sourceCode": "private IllegalStateException unexpectedTokenError(String expected) throws IOException {\r\n    JsonToken peeked \u003d peek();\r\n    String troubleshootingId \u003d peeked \u003d\u003d JsonToken.NULL ? \"adapter-not-null-safe\" : \"unexpected-json-structure\";\r\n    return new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString() + \"\\nSee \" + TroubleshootingGuide.createUrl(troubleshootingId));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "unexpectedTokenError",
      "parameterTypes": [
        "String"
      ],
      "returnType": "IllegalStateException"
    }
  },
  {
    "sourceCode": "/**\r\n * Consumes the non-execute prefix if it exists.\r\n */\r\nprivate void consumeNonExecutePrefix() throws IOException {\r\n    // fast-forward through the leading whitespace\r\n    int unused \u003d nextNonWhitespace(true);\r\n    pos--;\r\n    if (pos + 5 \u003e limit \u0026\u0026 !fillBuffer(5)) {\r\n        return;\r\n    }\r\n    int p \u003d pos;\r\n    char[] buf \u003d buffer;\r\n    if (buf[p] !\u003d \u0027)\u0027 || buf[p + 1] !\u003d \u0027]\u0027 || buf[p + 2] !\u003d \u0027}\u0027 || buf[p + 3] !\u003d \u0027\\\u0027\u0027 || buf[p + 4] !\u003d \u0027\\n\u0027) {\r\n        // not a security token!\r\n        return;\r\n    }\r\n    // we consumed a security token!\r\n    pos +\u003d 5;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "consumeNonExecutePrefix",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void promoteNameToValue(JsonReader reader) throws IOException {\r\n    if (reader instanceof JsonTreeReader) {\r\n        ((JsonTreeReader) reader).promoteNameToValue();\r\n        return;\r\n    }\r\n    int p \u003d reader.peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d reader.doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\r\n        reader.peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\r\n        reader.peeked \u003d PEEKED_SINGLE_QUOTED;\r\n    } else if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\r\n        reader.peeked \u003d PEEKED_UNQUOTED;\r\n    } else {\r\n        throw reader.unexpectedTokenError(\"a name\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReader",
      "methodName": "promoteNameToValue",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Sets the indentation string to be repeated for each level of indentation\r\n * in the encoded document. If {@code indent.isEmpty()} the encoded document\r\n * will be compact. Otherwise the encoded document will be more\r\n * human-readable.\r\n *\r\n * \u003cp\u003eThis is a convenience method which overwrites any previously\r\n * {@linkplain #setFormattingStyle(FormattingStyle) set formatting style} with\r\n * either {@link FormattingStyle#COMPACT} if the given indent string is\r\n * empty, or {@link FormattingStyle#PRETTY} with the given indent if\r\n * not empty.\r\n *\r\n * @param indent a string containing only whitespace.\r\n */\r\npublic final void setIndent(String indent) {\r\n    if (indent.isEmpty()) {\r\n        setFormattingStyle(FormattingStyle.COMPACT);\r\n    } else {\r\n        setFormattingStyle(FormattingStyle.PRETTY.withIndent(indent));\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "setIndent",
      "parameterTypes": [
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Sets the formatting style to be used in the encoded document.\r\n *\r\n * \u003cp\u003eThe formatting style specifies for example the indentation string to be\r\n * repeated for each level of indentation, or the newline style, to accommodate\r\n * various OS styles.\u003c/p\u003e\r\n *\r\n * @param formattingStyle the formatting style to use, must not be {@code null}.\r\n * @since $next-version$\r\n */\r\npublic final void setFormattingStyle(FormattingStyle formattingStyle) {\r\n    this.formattingStyle \u003d Objects.requireNonNull(formattingStyle);\r\n    this.formattedComma \u003d \",\";\r\n    if (this.formattingStyle.usesSpaceAfterSeparators()) {\r\n        this.formattedColon \u003d \": \";\r\n        // Only add space if no newline is written\r\n        if (this.formattingStyle.getNewline().isEmpty()) {\r\n            this.formattedComma \u003d \", \";\r\n        }\r\n    } else {\r\n        this.formattedColon \u003d \":\";\r\n    }\r\n    this.usesEmptyNewlineAndIndent \u003d this.formattingStyle.getNewline().isEmpty() \u0026\u0026 this.formattingStyle.getIndent().isEmpty();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "setFormattingStyle",
      "parameterTypes": [
        "FormattingStyle"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the pretty printing style used by this writer.\r\n *\r\n * @return the {@code FormattingStyle} that will be used.\r\n * @since $next-version$\r\n */\r\npublic final FormattingStyle getFormattingStyle() {\r\n    return formattingStyle;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "getFormattingStyle",
      "parameterTypes": [],
      "returnType": "FormattingStyle"
    }
  },
  {
    "sourceCode": "/**\r\n * Sets the strictness of this writer.\r\n *\r\n * @deprecated Please use {@link #setStrictness(Strictness)} instead.\r\n * {@code JsonWriter.setLenient(true)} should be replaced by {@code JsonWriter.setStrictness(Strictness.LENIENT)}\r\n * and {@code JsonWriter.setLenient(false)} should be replaced by {@code JsonWriter.setStrictness(Strictness.LEGACY_STRICT)}.\u003cbr\u003e\r\n * However, if you used {@code setLenient(false)} before, you might prefer {@link Strictness#STRICT} now instead.\r\n *\r\n * @param lenient whether this writer should be lenient. If true, the strictness is set to {@link Strictness#LENIENT}.\r\n *                If false, the strictness is set to {@link Strictness#LEGACY_STRICT}.\r\n * @see #setStrictness(Strictness)\r\n */\r\n@Deprecated\r\n// Don\u0027t specify @InlineMe, so caller with `setLenient(false)` becomes aware of new Strictness.STRICT\r\n@SuppressWarnings(\"InlineMeSuggester\")\r\npublic final void setLenient(boolean lenient) {\r\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "setLenient",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if the {@link Strictness} of this writer is equal to {@link Strictness#LENIENT}.\r\n *\r\n * @see JsonWriter#setStrictness(Strictness)\r\n */\r\npublic boolean isLenient() {\r\n    return strictness \u003d\u003d Strictness.LENIENT;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "isLenient",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures how strict this writer is with regard to the syntax rules specified in \u003ca\r\n * href\u003d\"https://www.ietf.org/rfc/rfc8259.txt\"\u003eRFC 8259\u003c/a\u003e. By default, {@link Strictness#LEGACY_STRICT} is used.\r\n *\r\n * \u003cdl\u003e\r\n *     \u003cdt\u003e{@link Strictness#STRICT} \u0026amp; {@link Strictness#LEGACY_STRICT}\u003c/dt\u003e\r\n *     \u003cdd\u003e\r\n *         The behavior of these is currently identical. In these strictness modes, the writer only writes JSON\r\n *         in accordance with RFC 8259.\r\n *     \u003c/dd\u003e\r\n *     \u003cdt\u003e{@link Strictness#LENIENT}\u003c/dt\u003e\r\n *     \u003cdd\u003e\r\n *         This mode relaxes the behavior of the writer to allow the writing of {@link Double#isNaN() NaNs}\r\n *         and {@link Double#isInfinite() infinities}. It also allows writing multiple top level values.\r\n *     \u003c/dd\u003e\r\n * \u003c/dl\u003e\r\n *\r\n * @param strictness the new strictness of this writer. May not be {@code null}.\r\n * @since $next-version$\r\n */\r\npublic final void setStrictness(Strictness strictness) {\r\n    this.strictness \u003d Objects.requireNonNull(strictness);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "setStrictness",
      "parameterTypes": [
        "Strictness"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the {@linkplain Strictness strictness} of this writer.\r\n *\r\n * @see #setStrictness(Strictness)\r\n * @since $next-version$\r\n */\r\npublic final Strictness getStrictness() {\r\n    return strictness;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "getStrictness",
      "parameterTypes": [],
      "returnType": "Strictness"
    }
  },
  {
    "sourceCode": "/**\r\n * Configures this writer to emit JSON that\u0027s safe for direct inclusion in HTML\r\n * and XML documents. This escapes the HTML characters {@code \u003c}, {@code \u003e},\r\n * {@code \u0026} and {@code \u003d} before writing them to the stream. Without this\r\n * setting, your XML/HTML encoder should replace these characters with the\r\n * corresponding escape sequences.\r\n */\r\npublic final void setHtmlSafe(boolean htmlSafe) {\r\n    this.htmlSafe \u003d htmlSafe;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "setHtmlSafe",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if this writer writes JSON that\u0027s safe for inclusion in HTML\r\n * and XML documents.\r\n */\r\npublic final boolean isHtmlSafe() {\r\n    return htmlSafe;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "isHtmlSafe",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Sets whether object members are serialized when their value is null.\r\n * This has no impact on array elements. The default is true.\r\n */\r\npublic final void setSerializeNulls(boolean serializeNulls) {\r\n    this.serializeNulls \u003d serializeNulls;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "setSerializeNulls",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns true if object members are serialized when their value is null.\r\n * This has no impact on array elements. The default is true.\r\n */\r\npublic final boolean getSerializeNulls() {\r\n    return serializeNulls;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "getSerializeNulls",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Begins encoding a new array. Each call to this method must be paired with\r\n * a call to {@link #endArray}.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter beginArray() throws IOException {\r\n    writeDeferredName();\r\n    return open(EMPTY_ARRAY, \u0027[\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "beginArray",
      "parameterTypes": [],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Ends encoding the current array.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter endArray() throws IOException {\r\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \u0027]\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "endArray",
      "parameterTypes": [],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Begins encoding a new object. Each call to this method must be paired\r\n * with a call to {@link #endObject}.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter beginObject() throws IOException {\r\n    writeDeferredName();\r\n    return open(EMPTY_OBJECT, \u0027{\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "beginObject",
      "parameterTypes": [],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Ends encoding the current object.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter endObject() throws IOException {\r\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \u0027}\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "endObject",
      "parameterTypes": [],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Enters a new scope by appending any necessary whitespace and the given\r\n * bracket.\r\n */\r\n@CanIgnoreReturnValue\r\nprivate JsonWriter open(int empty, char openBracket) throws IOException {\r\n    beforeValue();\r\n    push(empty);\r\n    out.write(openBracket);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "open",
      "parameterTypes": [
        "int",
        "char"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Closes the current scope by appending any necessary whitespace and the\r\n * given bracket.\r\n */\r\n@CanIgnoreReturnValue\r\nprivate JsonWriter close(int empty, int nonempty, char closeBracket) throws IOException {\r\n    int context \u003d peek();\r\n    if (context !\u003d nonempty \u0026\u0026 context !\u003d empty) {\r\n        throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n    if (deferredName !\u003d null) {\r\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\r\n    }\r\n    stackSize--;\r\n    if (context \u003d\u003d nonempty) {\r\n        newline();\r\n    }\r\n    out.write(closeBracket);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "close",
      "parameterTypes": [
        "int",
        "int",
        "char"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "private void push(int newTop) {\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        stack \u003d Arrays.copyOf(stack, stackSize * 2);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "push",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the value on the top of the stack.\r\n */\r\nprivate int peek() {\r\n    if (stackSize \u003d\u003d 0) {\r\n        throw new IllegalStateException(\"JsonWriter is closed.\");\r\n    }\r\n    return stack[stackSize - 1];\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "peek",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * Replace the value on the top of the stack with the given value.\r\n */\r\nprivate void replaceTop(int topOfStack) {\r\n    stack[stackSize - 1] \u003d topOfStack;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "replaceTop",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Encodes the property name.\r\n *\r\n * @param name the name of the forthcoming value. May not be {@code null}.\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter name(String name) throws IOException {\r\n    Objects.requireNonNull(name, \"name \u003d\u003d null\");\r\n    if (deferredName !\u003d null) {\r\n        throw new IllegalStateException(\"Already wrote a name, expecting a value.\");\r\n    }\r\n    int context \u003d peek();\r\n    if (context !\u003d EMPTY_OBJECT \u0026\u0026 context !\u003d NONEMPTY_OBJECT) {\r\n        throw new IllegalStateException(\"Please begin an object before writing a name.\");\r\n    }\r\n    deferredName \u003d name;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "name",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "private void writeDeferredName() throws IOException {\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "writeDeferredName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @param value the literal string value, or null to encode a null literal.\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(String value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    beforeValue();\r\n    string(value);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "value",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Writes {@code value} directly to the writer without quoting or\r\n * escaping. This might not be supported by all implementations, if\r\n * not supported an {@code UnsupportedOperationException} is thrown.\r\n *\r\n * @param value the literal string value, or null to encode a null literal.\r\n * @return this writer.\r\n * @throws UnsupportedOperationException if this writer does not support\r\n *    writing raw JSON values.\r\n * @since 2.4\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter jsonValue(String value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.append(value);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "jsonValue",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Encodes {@code null}.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter nullValue() throws IOException {\r\n    if (deferredName !\u003d null) {\r\n        if (serializeNulls) {\r\n            writeDeferredName();\r\n        } else {\r\n            deferredName \u003d null;\r\n            // skip the name and the value\r\n            return this;\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.write(\"null\");\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "nullValue",
      "parameterTypes": [],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(boolean value) throws IOException {\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.write(value ? \"true\" : \"false\");\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "value",
      "parameterTypes": [
        "boolean"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @return this writer.\r\n * @since 2.7\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(Boolean value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.write(value ? \"true\" : \"false\");\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "value",
      "parameterTypes": [
        "Boolean"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @param value a finite value, or if {@link #setStrictness(Strictness) lenient},\r\n *     also {@link Float#isNaN() NaN} or {@link Float#isInfinite()\r\n *     infinity}.\r\n * @return this writer.\r\n * @throws IllegalArgumentException if the value is NaN or Infinity and this writer is not {@link\r\n *     #setStrictness(Strictness) lenient}.\r\n * @since 2.9.1\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(float value) throws IOException {\r\n    writeDeferredName();\r\n    if (strictness !\u003d Strictness.LENIENT \u0026\u0026 (Float.isNaN(value) || Float.isInfinite(value))) {\r\n        throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\r\n    }\r\n    beforeValue();\r\n    out.append(Float.toString(value));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "value",
      "parameterTypes": [
        "float"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @param value a finite value, or if {@link #setStrictness(Strictness) lenient},\r\n *     also {@link Double#isNaN() NaN} or {@link Double#isInfinite() infinity}.\r\n * @return this writer.\r\n * @throws IllegalArgumentException if the value is NaN or Infinity and this writer is\r\n *     not {@link #setStrictness(Strictness) lenient}.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(double value) throws IOException {\r\n    writeDeferredName();\r\n    if (strictness !\u003d Strictness.LENIENT \u0026\u0026 (Double.isNaN(value) || Double.isInfinite(value))) {\r\n        throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\r\n    }\r\n    beforeValue();\r\n    out.append(Double.toString(value));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "value",
      "parameterTypes": [
        "double"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(long value) throws IOException {\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.write(Long.toString(value));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "value",
      "parameterTypes": [
        "long"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns whether the {@code toString()} of {@code c} can be trusted to return\r\n * a valid JSON number.\r\n */\r\nprivate static boolean isTrustedNumberType(Class\u003c? extends Number\u003e c) {\r\n    // Note: Don\u0027t consider LazilyParsedNumber trusted because it could contain\r\n    // an arbitrary malformed string\r\n    return c \u003d\u003d Integer.class || c \u003d\u003d Long.class || c \u003d\u003d Double.class || c \u003d\u003d Float.class || c \u003d\u003d Byte.class || c \u003d\u003d Short.class || c \u003d\u003d BigDecimal.class || c \u003d\u003d BigInteger.class || c \u003d\u003d AtomicInteger.class || c \u003d\u003d AtomicLong.class;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "isTrustedNumberType",
      "parameterTypes": [
        "Class\u003c? extends Number\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Encodes {@code value}. The value is written by directly writing the {@link Number#toString()}\r\n * result to JSON. Implementations must make sure that the result represents a valid JSON number.\r\n *\r\n * @param value a finite value, or if {@link #setStrictness(Strictness) lenient},\r\n *     also {@link Double#isNaN() NaN} or {@link Double#isInfinite() infinity}.\r\n * @return this writer.\r\n * @throws IllegalArgumentException if the value is NaN or Infinity and this writer is\r\n *     not {@link #setStrictness(Strictness) lenient}; or if the {@code toString()} result is not a\r\n *     valid JSON number.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(Number value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    String string \u003d value.toString();\r\n    if (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\")) {\r\n        if (strictness !\u003d Strictness.LENIENT) {\r\n            throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + string);\r\n        }\r\n    } else {\r\n        Class\u003c? extends Number\u003e numberClass \u003d value.getClass();\r\n        // Validate that string is valid before writing it directly to JSON output\r\n        if (!isTrustedNumberType(numberClass) \u0026\u0026 !VALID_JSON_NUMBER_PATTERN.matcher(string).matches()) {\r\n            throw new IllegalArgumentException(\"String created by \" + numberClass + \" is not a valid JSON number: \" + string);\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.append(string);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "value",
      "parameterTypes": [
        "Number"
      ],
      "returnType": "JsonWriter"
    }
  },
  {
    "sourceCode": "/**\r\n * Ensures all buffered data is written to the underlying {@link Writer}\r\n * and flushes that writer.\r\n */\r\n@Override\r\npublic void flush() throws IOException {\r\n    if (stackSize \u003d\u003d 0) {\r\n        throw new IllegalStateException(\"JsonWriter is closed.\");\r\n    }\r\n    out.flush();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "flush",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Flushes and closes this writer and the underlying {@link Writer}.\r\n *\r\n * @throws IOException if the JSON document is incomplete.\r\n */\r\n@Override\r\npublic void close() throws IOException {\r\n    out.close();\r\n    int size \u003d stackSize;\r\n    if (size \u003e 1 || (size \u003d\u003d 1 \u0026\u0026 stack[size - 1] !\u003d NONEMPTY_DOCUMENT)) {\r\n        throw new IOException(\"Incomplete document\");\r\n    }\r\n    stackSize \u003d 0;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "close",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void string(String value) throws IOException {\r\n    String[] replacements \u003d htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\r\n    out.write(\u0027\\\"\u0027);\r\n    int last \u003d 0;\r\n    int length \u003d value.length();\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        char c \u003d value.charAt(i);\r\n        String replacement;\r\n        if (c \u003c 128) {\r\n            replacement \u003d replacements[c];\r\n            if (replacement \u003d\u003d null) {\r\n                continue;\r\n            }\r\n        } else if (c \u003d\u003d \u0027\\u2028\u0027) {\r\n            replacement \u003d \"\\\\u2028\";\r\n        } else if (c \u003d\u003d \u0027\\u2029\u0027) {\r\n            replacement \u003d \"\\\\u2029\";\r\n        } else {\r\n            continue;\r\n        }\r\n        if (last \u003c i) {\r\n            out.write(value, last, i - last);\r\n        }\r\n        out.write(replacement);\r\n        last \u003d i + 1;\r\n    }\r\n    if (last \u003c length) {\r\n        out.write(value, last, length - last);\r\n    }\r\n    out.write(\u0027\\\"\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "string",
      "parameterTypes": [
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void newline() throws IOException {\r\n    if (usesEmptyNewlineAndIndent) {\r\n        return;\r\n    }\r\n    out.write(formattingStyle.getNewline());\r\n    for (int i \u003d 1, size \u003d stackSize; i \u003c size; i++) {\r\n        out.write(formattingStyle.getIndent());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "newline",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Inserts any necessary separators and whitespace before a name. Also\r\n * adjusts the stack to expect the name\u0027s value.\r\n */\r\nprivate void beforeName() throws IOException {\r\n    int context \u003d peek();\r\n    if (context \u003d\u003d NONEMPTY_OBJECT) {\r\n        // first in object\r\n        out.write(formattedComma);\r\n    } else if (context !\u003d EMPTY_OBJECT) {\r\n        // not in an object!\r\n        throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n    newline();\r\n    replaceTop(DANGLING_NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "beforeName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Inserts any necessary separators and whitespace before a literal value,\r\n * inline array, or inline object. Also adjusts the stack to expect either a\r\n * closing bracket or another element.\r\n */\r\n@SuppressWarnings(\"fallthrough\")\r\nprivate void beforeValue() throws IOException {\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (strictness !\u003d Strictness.LENIENT) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(formattedComma);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(formattedColon);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriter",
      "methodName": "beforeValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Double readNumber(JsonReader in) throws IOException {\r\n    return in.nextDouble();\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "readNumber",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Double"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number readNumber(JsonReader in) throws IOException {\r\n    return new LazilyParsedNumber(in.nextString());\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "readNumber",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number readNumber(JsonReader in) throws IOException, JsonParseException {\r\n    String value \u003d in.nextString();\r\n    try {\r\n        return Long.parseLong(value);\r\n    } catch (NumberFormatException longE) {\r\n        try {\r\n            Double d \u003d Double.valueOf(value);\r\n            if ((d.isInfinite() || d.isNaN()) \u0026\u0026 !in.isLenient()) {\r\n                throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + d + \"; at path \" + in.getPreviousPath());\r\n            }\r\n            return d;\r\n        } catch (NumberFormatException doubleE) {\r\n            throw new JsonParseException(\"Cannot parse \" + value + \"; at path \" + in.getPreviousPath(), doubleE);\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "readNumber",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic BigDecimal readNumber(JsonReader in) throws IOException {\r\n    String value \u003d in.nextString();\r\n    try {\r\n        return NumberLimits.parseBigDecimal(value);\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonParseException(\"Cannot parse \" + value + \"; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "readNumber",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "BigDecimal"
    }
  },
  {
    "sourceCode": "/**\r\n * Reads a number from the given JSON reader. A strategy is supposed to read a single value from the\r\n * reader, and the read value is guaranteed never to be {@code null}.\r\n *\r\n * @param in JSON reader to read a number from\r\n * @return number read from the JSON reader.\r\n */\r\npublic Number readNumber(JsonReader in) throws IOException;",
    "methodIdentifier": {
      "className": "com.google.gson.ToNumberStrategy",
      "methodName": "readNumber",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "/**\r\n * Writes one JSON value (an array, object, string, number, boolean or null)\r\n * for {@code value}.\r\n *\r\n * @param value the Java object to write. May be null.\r\n */\r\npublic abstract void write(JsonWriter out, T value) throws IOException;",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Converts {@code value} to a JSON document and writes it to {@code out}.\r\n *\r\n * \u003cp\u003eA {@link JsonWriter} with default configuration is used for writing the\r\n * JSON data. To customize this behavior, create a {@link JsonWriter}, configure\r\n * it and then use {@link #write(JsonWriter, Object)} instead.\r\n *\r\n * @param value the Java object to convert. May be {@code null}.\r\n * @since 2.2\r\n */\r\npublic final void toJson(Writer out, T value) throws IOException {\r\n    JsonWriter writer \u003d new JsonWriter(out);\r\n    write(writer, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "toJson",
      "parameterTypes": [
        "Writer",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n    } else {\r\n        TypeAdapter.this.write(out, value);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader reader) throws IOException {\r\n    if (reader.peek() \u003d\u003d JsonToken.NULL) {\r\n        reader.nextNull();\r\n        return null;\r\n    }\r\n    return TypeAdapter.this.read(reader);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * This wrapper method is used to make a type adapter null tolerant. In general, a\r\n * type adapter is required to handle nulls in write and read methods. Here is how this\r\n * is typically done:\u003cbr\u003e\r\n * \u003cpre\u003e{@code\r\n * Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\r\n *   new TypeAdapter\u003cFoo\u003e() {\r\n *     public Foo read(JsonReader in) throws IOException {\r\n *       if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n *         in.nextNull();\r\n *         return null;\r\n *       }\r\n *       // read a Foo from in and return it\r\n *     }\r\n *     public void write(JsonWriter out, Foo src) throws IOException {\r\n *       if (src \u003d\u003d null) {\r\n *         out.nullValue();\r\n *         return;\r\n *       }\r\n *       // write src as JSON to out\r\n *     }\r\n *   }).create();\r\n * }\u003c/pre\u003e\r\n * You can avoid this boilerplate handling of nulls by wrapping your type adapter with\r\n * this method. Here is how we will rewrite the above example:\r\n * \u003cpre\u003e{@code\r\n * Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class,\r\n *   new TypeAdapter\u003cFoo\u003e() {\r\n *     public Foo read(JsonReader in) throws IOException {\r\n *       // read a Foo from in and return it\r\n *     }\r\n *     public void write(JsonWriter out, Foo src) throws IOException {\r\n *       // write src as JSON to out\r\n *     }\r\n *   }.nullSafe()).create();\r\n * }\u003c/pre\u003e\r\n * Note that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\r\n */\r\npublic final TypeAdapter\u003cT\u003e nullSafe() {\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (value \u003d\u003d null) {\r\n                out.nullValue();\r\n            } else {\r\n                TypeAdapter.this.write(out, value);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader reader) throws IOException {\r\n            if (reader.peek() \u003d\u003d JsonToken.NULL) {\r\n                reader.nextNull();\r\n                return null;\r\n            }\r\n            return TypeAdapter.this.read(reader);\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "nullSafe",
      "parameterTypes": [],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Converts {@code value} to a JSON document.\r\n *\r\n * \u003cp\u003eA {@link JsonWriter} with default configuration is used for writing the\r\n * JSON data. To customize this behavior, create a {@link JsonWriter}, configure\r\n * it and then use {@link #write(JsonWriter, Object)} instead.\r\n *\r\n * @throws JsonIOException wrapping {@code IOException}s thrown by {@link #write(JsonWriter, Object)}\r\n * @param value the Java object to convert. May be {@code null}.\r\n * @since 2.2\r\n */\r\npublic final String toJson(T value) {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    try {\r\n        toJson(stringWriter, value);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n    return stringWriter.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "toJson",
      "parameterTypes": [
        "T"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Converts {@code value} to a JSON tree.\r\n *\r\n * @param value the Java object to convert. May be {@code null}.\r\n * @return the converted JSON tree. May be {@link JsonNull}.\r\n * @throws JsonIOException wrapping {@code IOException}s thrown by {@link #write(JsonWriter, Object)}\r\n * @since 2.2\r\n */\r\npublic final JsonElement toJsonTree(T value) {\r\n    try {\r\n        JsonTreeWriter jsonWriter \u003d new JsonTreeWriter();\r\n        write(jsonWriter, value);\r\n        return jsonWriter.get();\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "toJsonTree",
      "parameterTypes": [
        "T"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Reads one JSON value (an array, object, string, number, boolean or null)\r\n * and converts it to a Java object. Returns the converted object.\r\n *\r\n * @return the converted Java object. May be {@code null}.\r\n */\r\npublic abstract T read(JsonReader in) throws IOException;",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Converts the JSON document in {@code in} to a Java object.\r\n *\r\n * \u003cp\u003eA {@link JsonReader} with default configuration (that is with\r\n * {@link Strictness#LEGACY_STRICT} as strictness) is used for reading the JSON data.\r\n * To customize this behavior, create a {@link JsonReader}, configure it and then\r\n * use {@link #read(JsonReader)} instead.\r\n *\r\n * \u003cp\u003eNo exception is thrown if the JSON data has multiple top-level JSON elements,\r\n * or if there is trailing data.\r\n *\r\n * @return the converted Java object. May be {@code null}.\r\n * @since 2.2\r\n */\r\npublic final T fromJson(Reader in) throws IOException {\r\n    JsonReader reader \u003d new JsonReader(in);\r\n    return read(reader);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "fromJson",
      "parameterTypes": [
        "Reader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Converts the JSON document in {@code json} to a Java object.\r\n *\r\n * \u003cp\u003eA {@link JsonReader} with default configuration (that is with\r\n * {@link Strictness#LEGACY_STRICT} as strictness) is used for reading the JSON data.\r\n * To customize this behavior, create a {@link JsonReader}, configure it and then\r\n * use {@link #read(JsonReader)} instead.\r\n *\r\n * \u003cp\u003eNo exception is thrown if the JSON data has multiple top-level JSON elements,\r\n * or if there is trailing data.\r\n *\r\n * @return the converted Java object. May be {@code null}.\r\n * @since 2.2\r\n */\r\npublic final T fromJson(String json) throws IOException {\r\n    return fromJson(new StringReader(json));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "fromJson",
      "parameterTypes": [
        "String"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Converts {@code jsonTree} to a Java object.\r\n *\r\n * @param jsonTree the JSON element to convert. May be {@link JsonNull}.\r\n * @return the converted Java object. May be {@code null}.\r\n * @throws JsonIOException wrapping {@code IOException}s thrown by {@link #read(JsonReader)}\r\n * @since 2.2\r\n */\r\npublic final T fromJsonTree(JsonElement jsonTree) {\r\n    try {\r\n        JsonReader jsonReader \u003d new JsonTreeReader(jsonTree);\r\n        return read(jsonReader);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapter",
      "methodName": "fromJsonTree",
      "parameterTypes": [
        "JsonElement"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a type adapter for {@code type}, or null if this factory doesn\u0027t\r\n * support {@code type}.\r\n */\r\n\u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type);",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Test for issue 212.\r\n */\r\n@Test\r\npublic void testParseComments() {\r\n    String json \u003d \"[\\n\" + \"  // this is a comment\\n\" + \"  \\\"a\\\",\\n\" + \"  /* this is another comment */\\n\" + \"  \\\"b\\\",\\n\" + \"  # this is yet another comment\\n\" + \"  \\\"c\\\"\\n\" + \"]\";\r\n    List\u003cString\u003e abc \u003d new Gson().fromJson(json, new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(abc).containsExactly(\"a\", \"b\", \"c\").inOrder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.CommentsTest",
      "methodName": "testParseComments",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Asserts that the specified {@code value} is not present in {@code collection}\r\n * @param collection the collection to look into\r\n * @param value the value that needs to be checked for presence\r\n */\r\npublic static \u003cT\u003e void assertContains(Collection\u003cT\u003e collection, T value) {\r\n    for (T entry : collection) {\r\n        if (entry.equals(value)) {\r\n            return;\r\n        }\r\n    }\r\n    Assert.fail(value + \" not present in \" + collection);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.MoreAsserts",
      "methodName": "assertContains",
      "parameterTypes": [
        "Collection\u003cT\u003e",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public static void assertEqualsAndHashCode(Object a, Object b) {\r\n    Assert.assertTrue(a.equals(b));\r\n    Assert.assertTrue(b.equals(a));\r\n    Assert.assertEquals(a.hashCode(), b.hashCode());\r\n    Assert.assertFalse(a.equals(null));\r\n    Assert.assertFalse(a.equals(new Object()));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.MoreAsserts",
      "methodName": "assertEqualsAndHashCode",
      "parameterTypes": [
        "Object",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static boolean isProtectedOrPublic(Method method) {\r\n    int modifiers \u003d method.getModifiers();\r\n    return Modifier.isProtected(modifiers) || Modifier.isPublic(modifiers);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.MoreAsserts",
      "methodName": "isProtectedOrPublic",
      "parameterTypes": [
        "Method"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "private static String getMethodSignature(Method method) {\r\n    StringBuilder builder \u003d new StringBuilder(method.getName());\r\n    builder.append(\u0027(\u0027);\r\n    String sep \u003d \"\";\r\n    for (Class\u003c?\u003e paramType : method.getParameterTypes()) {\r\n        builder.append(sep).append(paramType.getName());\r\n        sep \u003d \",\";\r\n    }\r\n    builder.append(\u0027)\u0027);\r\n    return builder.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.MoreAsserts",
      "methodName": "getMethodSignature",
      "parameterTypes": [
        "Method"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Asserts that {@code subClass} overrides all protected and public methods declared by\r\n * {@code baseClass} except for the ones whose signatures are in {@code ignoredMethods}.\r\n */\r\npublic static void assertOverridesMethods(Class\u003c?\u003e baseClass, Class\u003c?\u003e subClass, List\u003cString\u003e ignoredMethods) {\r\n    Set\u003cString\u003e requiredOverriddenMethods \u003d new LinkedHashSet\u003c\u003e();\r\n    for (Method method : baseClass.getDeclaredMethods()) {\r\n        // Note: Do not filter out `final` methods; maybe they should not be `final` and subclass needs\r\n        // to override them\r\n        if (isProtectedOrPublic(method)) {\r\n            requiredOverriddenMethods.add(getMethodSignature(method));\r\n        }\r\n    }\r\n    for (Method method : subClass.getDeclaredMethods()) {\r\n        requiredOverriddenMethods.remove(getMethodSignature(method));\r\n    }\r\n    for (String ignoredMethod : ignoredMethods) {\r\n        boolean foundIgnored \u003d requiredOverriddenMethods.remove(ignoredMethod);\r\n        if (!foundIgnored) {\r\n            throw new IllegalArgumentException(\"Method \u0027\" + ignoredMethod + \"\u0027 does not exist or is already overridden\");\r\n        }\r\n    }\r\n    if (!requiredOverriddenMethods.isEmpty()) {\r\n        Assert.fail(subClass.getSimpleName() + \" must override these methods: \" + requiredOverriddenMethods);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.MoreAsserts",
      "methodName": "assertOverridesMethods",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "Class\u003c?\u003e",
        "List\u003cString\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(Base.SERIALIZER_KEY, NAME);\r\n    return obj;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.BaseSerializer",
      "methodName": "serialize",
      "parameterTypes": [
        "Base",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Sub src, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(Base.SERIALIZER_KEY, NAME);\r\n    return obj;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.SubSerializer",
      "methodName": "serialize",
      "parameterTypes": [
        "Sub",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "public int getIntValue() {\r\n    return intValue;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.BagOfPrimitives",
      "methodName": "getIntValue",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\"{\");\r\n    sb.append(\"\\\"longValue\\\":\").append(longValue).append(\",\");\r\n    sb.append(\"\\\"intValue\\\":\").append(intValue).append(\",\");\r\n    sb.append(\"\\\"booleanValue\\\":\").append(booleanValue).append(\",\");\r\n    sb.append(\"\\\"stringValue\\\":\\\"\").append(stringValue).append(\"\\\"\");\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.BagOfPrimitives",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    final int prime \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d prime * result + (booleanValue ? 1231 : 1237);\r\n    result \u003d prime * result + intValue;\r\n    result \u003d prime * result + (int) (longValue ^ (longValue \u003e\u003e\u003e 32));\r\n    result \u003d prime * result + ((stringValue \u003d\u003d null) ? 0 : stringValue.hashCode());\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.BagOfPrimitives",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    if (this \u003d\u003d o) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof BagOfPrimitives)) {\r\n        return false;\r\n    }\r\n    BagOfPrimitives that \u003d (BagOfPrimitives) o;\r\n    return longValue \u003d\u003d that.longValue \u0026\u0026 getIntValue() \u003d\u003d that.getIntValue() \u0026\u0026 booleanValue \u003d\u003d that.booleanValue \u0026\u0026 Objects.equal(stringValue, that.stringValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.BagOfPrimitives",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return String.format(\"(longValue\u003d%d,intValue\u003d%d,booleanValue\u003d%b,stringValue\u003d%s)\", longValue, intValue, booleanValue, stringValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.BagOfPrimitives",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\"{\");\r\n    sb.append(\"\\\"longValue\\\":\").append(longValue).append(\",\");\r\n    sb.append(\"\\\"intValue\\\":\").append(intValue).append(\",\");\r\n    sb.append(\"\\\"booleanValue\\\":\").append(booleanValue);\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.BagOfPrimitiveWrappers",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\"{\\\"longArray\\\":[\");\r\n    boolean first \u003d true;\r\n    for (long l : longArray) {\r\n        if (!first) {\r\n            sb.append(\",\");\r\n        } else {\r\n            first \u003d false;\r\n        }\r\n        sb.append(l);\r\n    }\r\n    sb.append(\"]}\");\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.PrimitiveArray",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "// Nothing here..\r\n@Override\r\npublic boolean equals(Object other) {\r\n    return other instanceof ClassWithNoFields;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.ClassWithNoFields",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\"{\");\r\n    appendFields(sb);\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.Nested",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public void appendFields(StringBuilder sb) {\r\n    if (primitive1 !\u003d null) {\r\n        sb.append(\"\\\"primitive1\\\":\").append(primitive1.getExpectedJson());\r\n    }\r\n    if (primitive1 !\u003d null \u0026\u0026 primitive2 !\u003d null) {\r\n        sb.append(\",\");\r\n    }\r\n    if (primitive2 !\u003d null) {\r\n        sb.append(\"\\\"primitive2\\\":\").append(primitive2.getExpectedJson());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.Nested",
      "methodName": "appendFields",
      "parameterTypes": [
        "StringBuilder"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\"{\");\r\n    sb.append(\"\\\"longValue\\\":[\").append(longValue[0]).append(\"]\");\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.ClassWithTransientFields",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public BagOfPrimitives getBag() {\r\n    return bag;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.ClassWithCustomTypeConverter",
      "methodName": "getBag",
      "parameterTypes": [],
      "returnType": "BagOfPrimitives"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    return \"{\\\"url\\\":\\\"\" + bag.getExpectedJson() + \"\\\",\\\"value\\\":\" + value + \"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.ClassWithCustomTypeConverter",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public int getValue() {\r\n    return value;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.ClassWithCustomTypeConverter",
      "methodName": "getValue",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    StringBuilder sb \u003d new StringBuilder(\"{\\\"elements\\\":[\");\r\n    boolean first \u003d true;\r\n    for (BagOfPrimitives element : elements) {\r\n        if (first) {\r\n            first \u003d false;\r\n        } else {\r\n            sb.append(\",\");\r\n        }\r\n        sb.append(element.getExpectedJson());\r\n    }\r\n    sb.append(\"]}\");\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.ArrayOfObjects",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    if (ref \u003d\u003d null) {\r\n        return \"{}\";\r\n    }\r\n    return \"{\\\"ref\\\":\" + ref.getExpectedJson() + \"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.ClassOverridingEquals",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object obj) {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.ClassOverridingEquals",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return 1;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.ClassOverridingEquals",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    return \u0027{\u0027 + \"\\\"fooBar\\\":\" + f + \",\\\"Another Foo\\\":\" + g + \u0027}\u0027;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.ClassWithSerializedNameFields",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(src + DIFFERENCE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.CrazyLongTypeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "Long",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return json.getAsLong() - DIFFERENCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.common.TestTypes.CrazyLongTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Long"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.DefaultInetAddressTypeAdapterTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInetAddressSerializationAndDeserialization() throws Exception {\r\n    // we really do want this method\r\n    @SuppressWarnings(\"AddressSelection\")\r\n    InetAddress address \u003d InetAddress.getByName(\"8.8.8.8\");\r\n    String jsonAddress \u003d gson.toJson(address);\r\n    assertThat(jsonAddress).isEqualTo(\"\\\"8.8.8.8\\\"\");\r\n    InetAddress value \u003d gson.fromJson(jsonAddress, InetAddress.class);\r\n    assertThat(address).isEqualTo(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.DefaultInetAddressTypeAdapterTest",
      "methodName": "testInetAddressSerializationAndDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyMapNoTypeSerialization() {\r\n    Map\u003cString, String\u003e emptyMap \u003d new HashMap\u003c\u003e();\r\n    JsonElement element \u003d gson.toJsonTree(emptyMap, emptyMap.getClass());\r\n    assertThat(element).isInstanceOf(JsonObject.class);\r\n    JsonObject emptyMapJsonObject \u003d (JsonObject) element;\r\n    assertThat(emptyMapJsonObject.entrySet()).isEmpty();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.DefaultMapJsonSerializerTest",
      "methodName": "testEmptyMapNoTypeSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyMapSerialization() {\r\n    Type mapType \u003d new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, String\u003e emptyMap \u003d new HashMap\u003c\u003e();\r\n    JsonElement element \u003d gson.toJsonTree(emptyMap, mapType);\r\n    assertThat(element).isInstanceOf(JsonObject.class);\r\n    JsonObject emptyMapJsonObject \u003d (JsonObject) element;\r\n    assertThat(emptyMapJsonObject.entrySet()).isEmpty();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.DefaultMapJsonSerializerTest",
      "methodName": "testEmptyMapSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonEmptyMapSerialization() {\r\n    Type mapType \u003d new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, String\u003e myMap \u003d new HashMap\u003c\u003e();\r\n    String key \u003d \"key1\";\r\n    myMap.put(key, \"value1\");\r\n    Gson gson \u003d new Gson();\r\n    JsonElement element \u003d gson.toJsonTree(myMap, mapType);\r\n    assertThat(element.isJsonObject()).isTrue();\r\n    JsonObject mapJsonObject \u003d element.getAsJsonObject();\r\n    assertThat(mapJsonObject.has(key)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.DefaultMapJsonSerializerTest",
      "methodName": "testNonEmptyMapSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNeverSkipClasses() {\r\n    assertThat(excluder.excludeClass(MockObject.class, true)).isFalse();\r\n    assertThat(excluder.excludeClass(MockObject.class, false)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ExposeAnnotationExclusionStrategyTest",
      "methodName": "testNeverSkipClasses",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipNonAnnotatedFields() throws Exception {\r\n    Field f \u003d createFieldAttributes(\"hiddenField\");\r\n    assertThat(excluder.excludeField(f, true)).isTrue();\r\n    assertThat(excluder.excludeField(f, false)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ExposeAnnotationExclusionStrategyTest",
      "methodName": "testSkipNonAnnotatedFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipExplicitlySkippedFields() throws Exception {\r\n    Field f \u003d createFieldAttributes(\"explicitlyHiddenField\");\r\n    assertThat(excluder.excludeField(f, true)).isTrue();\r\n    assertThat(excluder.excludeField(f, false)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ExposeAnnotationExclusionStrategyTest",
      "methodName": "testSkipExplicitlySkippedFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\r\n    Field f \u003d createFieldAttributes(\"exposedField\");\r\n    assertThat(excluder.excludeField(f, true)).isFalse();\r\n    assertThat(excluder.excludeField(f, false)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ExposeAnnotationExclusionStrategyTest",
      "methodName": "testNeverSkipExposedAnnotatedFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\r\n    Field f \u003d createFieldAttributes(\"explicitlyExposedField\");\r\n    assertThat(excluder.excludeField(f, true)).isFalse();\r\n    assertThat(excluder.excludeField(f, false)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ExposeAnnotationExclusionStrategyTest",
      "methodName": "testNeverSkipExplicitlyExposedAnnotatedFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDifferentSerializeAndDeserializeField() throws Exception {\r\n    Field f \u003d createFieldAttributes(\"explicitlyDifferentModeField\");\r\n    assertThat(excluder.excludeField(f, true)).isFalse();\r\n    assertThat(excluder.excludeField(f, false)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ExposeAnnotationExclusionStrategyTest",
      "methodName": "testDifferentSerializeAndDeserializeField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static Field createFieldAttributes(String fieldName) throws Exception {\r\n    return MockObject.class.getField(fieldName);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ExposeAnnotationExclusionStrategyTest",
      "methodName": "createFieldAttributes",
      "parameterTypes": [
        "String"
      ],
      "returnType": "Field"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    fieldAttributes \u003d new FieldAttributes(Foo.class.getField(\"bar\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributesTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unused\")\r\n@Test\r\npublic void testNullField() {\r\n    try {\r\n        new FieldAttributes(null);\r\n        fail(\"Field parameter can not be null\");\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributesTest",
      "methodName": "testNullField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeclaringClass() {\r\n    assertThat(fieldAttributes.getDeclaringClass()).isAssignableTo(Foo.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributesTest",
      "methodName": "testDeclaringClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testModifiers() {\r\n    assertThat(fieldAttributes.hasModifier(Modifier.STATIC)).isFalse();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.FINAL)).isFalse();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.ABSTRACT)).isFalse();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.VOLATILE)).isFalse();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.PROTECTED)).isFalse();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.PUBLIC)).isTrue();\r\n    assertThat(fieldAttributes.hasModifier(Modifier.TRANSIENT)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributesTest",
      "methodName": "testModifiers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testName() {\r\n    assertThat(fieldAttributes.getName()).isEqualTo(\"bar\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributesTest",
      "methodName": "testName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeclaredTypeAndClass() {\r\n    Type expectedType \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(fieldAttributes.getDeclaredType()).isEqualTo(expectedType);\r\n    assertThat(fieldAttributes.getDeclaredClass()).isAssignableTo(List.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldAttributesTest",
      "methodName": "testDeclaredTypeAndClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSeparateCamelCase() {\r\n    // Map from original -\u003e expected\r\n    String[][] argumentPairs \u003d { { \"a\", \"a\" }, { \"ab\", \"ab\" }, { \"Ab\", \"Ab\" }, { \"aB\", \"a_B\" }, { \"AB\", \"A_B\" }, { \"A_B\", \"A__B\" }, { \"firstSecondThird\", \"first_Second_Third\" }, { \"__\", \"__\" }, { \"_123\", \"_123\" } };\r\n    for (String[] pair : argumentPairs) {\r\n        assertThat(FieldNamingPolicy.separateCamelCase(pair[0], \u0027_\u0027)).isEqualTo(pair[1]);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldNamingPolicyTest",
      "methodName": "testSeparateCamelCase",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUpperCaseFirstLetter() {\r\n    // Map from original -\u003e expected\r\n    String[][] argumentPairs \u003d { { \"a\", \"A\" }, { \"ab\", \"Ab\" }, { \"AB\", \"AB\" }, { \"_a\", \"_A\" }, { \"_ab\", \"_Ab\" }, { \"__\", \"__\" }, { \"_1\", \"_1\" }, // Not a letter, but has uppercase variant (should not be uppercased)\r\n    // See https://github.com/google/gson/issues/1965\r\n    { \"\\u2170\", \"\\u2170\" }, { \"_\\u2170\", \"_\\u2170\" }, { \"\\u2170a\", \"\\u2170A\" } };\r\n    for (String[] pair : argumentPairs) {\r\n        assertThat(FieldNamingPolicy.upperCaseFirstLetter(pair[0])).isEqualTo(pair[1]);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldNamingPolicyTest",
      "methodName": "testUpperCaseFirstLetter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Upper-casing policies should be unaffected by default Locale.\r\n */\r\n@Test\r\npublic void testUpperCasingLocaleIndependent() throws Exception {\r\n    class Dummy {\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        int i;\r\n    }\r\n    FieldNamingPolicy[] policies \u003d { FieldNamingPolicy.UPPER_CAMEL_CASE, FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES, FieldNamingPolicy.UPPER_CASE_WITH_UNDERSCORES };\r\n    Field field \u003d Dummy.class.getDeclaredField(\"i\");\r\n    String name \u003d field.getName();\r\n    String expected \u003d name.toUpperCase(Locale.ROOT);\r\n    Locale oldLocale \u003d Locale.getDefault();\r\n    // Set Turkish as Locale which has special case conversion rules\r\n    Locale.setDefault(new Locale(\"tr\"));\r\n    try {\r\n        // Verify that default Locale has different case conversion rules\r\n        assertWithMessage(\"Test setup is broken\").that(name.toUpperCase(Locale.getDefault())).doesNotMatch(expected);\r\n        for (FieldNamingPolicy policy : policies) {\r\n            // Should ignore default Locale\r\n            assertWithMessage(\"Unexpected conversion for %s\", policy).that(policy.translateName(field)).matches(expected);\r\n        }\r\n    } finally {\r\n        Locale.setDefault(oldLocale);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldNamingPolicyTest",
      "methodName": "testUpperCasingLocaleIndependent",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Lower casing policies should be unaffected by default Locale.\r\n */\r\n@Test\r\npublic void testLowerCasingLocaleIndependent() throws Exception {\r\n    class Dummy {\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        int I;\r\n    }\r\n    FieldNamingPolicy[] policies \u003d { FieldNamingPolicy.LOWER_CASE_WITH_DASHES, FieldNamingPolicy.LOWER_CASE_WITH_DOTS, FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES };\r\n    Field field \u003d Dummy.class.getDeclaredField(\"I\");\r\n    String name \u003d field.getName();\r\n    String expected \u003d name.toLowerCase(Locale.ROOT);\r\n    Locale oldLocale \u003d Locale.getDefault();\r\n    // Set Turkish as Locale which has special case conversion rules\r\n    Locale.setDefault(new Locale(\"tr\"));\r\n    try {\r\n        // Verify that default Locale has different case conversion rules\r\n        assertWithMessage(\"Test setup is broken\").that(name.toLowerCase(Locale.getDefault())).doesNotMatch(expected);\r\n        for (FieldNamingPolicy policy : policies) {\r\n            // Should ignore default Locale\r\n            assertWithMessage(\"Unexpected conversion for %s\", policy).that(policy.translateName(field)).matches(expected);\r\n        }\r\n    } finally {\r\n        Locale.setDefault(oldLocale);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.FieldNamingPolicyTest",
      "methodName": "testLowerCasingLocaleIndependent",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelArrayOfIntsSerialization() {\r\n    int[] target \u003d { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[1,2,3,4,5,6,7,8,9]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testTopLevelArrayOfIntsSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelArrayOfIntsDeserialization() {\r\n    int[] expected \u003d { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    int[] actual \u003d gson.fromJson(\"[1,2,3,4,5,6,7,8,9]\", int[].class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testTopLevelArrayOfIntsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInvalidArrayDeserialization() {\r\n    String json \u003d \"[1, 2 3, 4, 5]\";\r\n    try {\r\n        gson.fromJson(json, int[].class);\r\n        fail(\"Gson should not deserialize array elements with missing ,\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testInvalidArrayDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyArraySerialization() {\r\n    int[] target \u003d {};\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testEmptyArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyArrayDeserialization() {\r\n    int[] actualObject \u003d gson.fromJson(\"[]\", int[].class);\r\n    assertThat(actualObject).hasLength(0);\r\n    Integer[] actualObject2 \u003d gson.fromJson(\"[]\", Integer[].class);\r\n    assertThat(actualObject2).hasLength(0);\r\n    actualObject \u003d gson.fromJson(\"[ ]\", int[].class);\r\n    assertThat(actualObject).hasLength(0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testEmptyArrayDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullsInArraySerialization() {\r\n    String[] array \u003d { \"foo\", null, \"bar\" };\r\n    String expected \u003d \"[\\\"foo\\\",null,\\\"bar\\\"]\";\r\n    String json \u003d gson.toJson(array);\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testNullsInArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullsInArrayDeserialization() {\r\n    String json \u003d \"[\\\"foo\\\",null,\\\"bar\\\"]\";\r\n    String[] expected \u003d { \"foo\", null, \"bar\" };\r\n    String[] target \u003d gson.fromJson(json, expected.getClass());\r\n    assertThat(target).asList().containsAnyIn(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testNullsInArrayDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSingleNullInArraySerialization() {\r\n    BagOfPrimitives[] array \u003d new BagOfPrimitives[1];\r\n    array[0] \u003d null;\r\n    String json \u003d gson.toJson(array);\r\n    assertThat(json).isEqualTo(\"[null]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testSingleNullInArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSingleNullInArrayDeserialization() {\r\n    BagOfPrimitives[] array \u003d gson.fromJson(\"[null]\", BagOfPrimitives[].class);\r\n    assertThat(array).asList().containsExactly((Object) null);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testSingleNullInArrayDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullsInArrayWithSerializeNullPropertySetSerialization() {\r\n    gson \u003d new GsonBuilder().serializeNulls().create();\r\n    String[] array \u003d { \"foo\", null, \"bar\" };\r\n    String expected \u003d \"[\\\"foo\\\",null,\\\"bar\\\"]\";\r\n    String json \u003d gson.toJson(array);\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testNullsInArrayWithSerializeNullPropertySetSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfStringsSerialization() {\r\n    String[] target \u003d { \"Hello\", \"World\" };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[\\\"Hello\\\",\\\"World\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testArrayOfStringsSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfStringsDeserialization() {\r\n    String json \u003d \"[\\\"Hello\\\",\\\"World\\\"]\";\r\n    String[] target \u003d gson.fromJson(json, String[].class);\r\n    assertThat(target).asList().containsExactly(\"Hello\", \"World\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testArrayOfStringsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSingleStringArraySerialization() {\r\n    String[] s \u003d { \"hello\" };\r\n    String output \u003d gson.toJson(s);\r\n    assertThat(output).isEqualTo(\"[\\\"hello\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testSingleStringArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSingleStringArrayDeserialization() {\r\n    String json \u003d \"[\\\"hello\\\"]\";\r\n    String[] arrayType \u003d gson.fromJson(json, String[].class);\r\n    assertThat(arrayType).asList().containsExactly(\"hello\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testSingleStringArrayDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfCollectionSerialization() {\r\n    StringBuilder sb \u003d new StringBuilder(\"[\");\r\n    int arraySize \u003d 3;\r\n    Type typeToSerialize \u003d new TypeToken\u003cCollection\u003cInteger\u003e[]\u003e() {\r\n    }.getType();\r\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\n    Collection\u003cInteger\u003e[] arrayOfCollection \u003d new ArrayList[arraySize];\r\n    for (int i \u003d 0; i \u003c arraySize; ++i) {\r\n        int startValue \u003d (3 * i) + 1;\r\n        sb.append(\u0027[\u0027).append(startValue).append(\u0027,\u0027).append(startValue + 1).append(\u0027]\u0027);\r\n        ArrayList\u003cInteger\u003e tmpList \u003d new ArrayList\u003c\u003e();\r\n        tmpList.add(startValue);\r\n        tmpList.add(startValue + 1);\r\n        arrayOfCollection[i] \u003d tmpList;\r\n        if (i \u003c arraySize - 1) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n    }\r\n    sb.append(\u0027]\u0027);\r\n    String json \u003d gson.toJson(arrayOfCollection, typeToSerialize);\r\n    assertThat(json).isEqualTo(sb.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testArrayOfCollectionSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfCollectionDeserialization() {\r\n    String json \u003d \"[[1,2],[3,4]]\";\r\n    Type type \u003d new TypeToken\u003cCollection\u003cInteger\u003e[]\u003e() {\r\n    }.getType();\r\n    Collection\u003cInteger\u003e[] target \u003d gson.fromJson(json, type);\r\n    assertThat(target.length).isEqualTo(2);\r\n    assertThat(target[0].toArray(new Integer[0])).isEqualTo(new Integer[] { 1, 2 });\r\n    assertThat(target[1].toArray(new Integer[0])).isEqualTo(new Integer[] { 3, 4 });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testArrayOfCollectionDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfPrimitivesAsObjectsSerialization() {\r\n    Object[] objs \u003d new Object[] { 1, \"abc\", 0.3f, 5L };\r\n    String json \u003d gson.toJson(objs);\r\n    assertThat(json).contains(\"abc\");\r\n    assertThat(json).contains(\"0.3\");\r\n    assertThat(json).contains(\"5\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testArrayOfPrimitivesAsObjectsSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfPrimitivesAsObjectsDeserialization() {\r\n    String json \u003d \"[1,\u0027abc\u0027,0.3,1.1,5]\";\r\n    Object[] objs \u003d gson.fromJson(json, Object[].class);\r\n    assertThat(((Number) objs[0]).intValue()).isEqualTo(1);\r\n    assertThat(objs[1]).isEqualTo(\"abc\");\r\n    assertThat(((Number) objs[2]).doubleValue()).isEqualTo(0.3);\r\n    assertThat(new BigDecimal(objs[3].toString())).isEqualTo(new BigDecimal(\"1.1\"));\r\n    assertThat(((Number) objs[4]).shortValue()).isEqualTo(5);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testArrayOfPrimitivesAsObjectsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testObjectArrayWithNonPrimitivesSerialization() {\r\n    ClassWithObjects classWithObjects \u003d new ClassWithObjects();\r\n    BagOfPrimitives bagOfPrimitives \u003d new BagOfPrimitives();\r\n    String classWithObjectsJson \u003d gson.toJson(classWithObjects);\r\n    String bagOfPrimitivesJson \u003d gson.toJson(bagOfPrimitives);\r\n    Object[] objects \u003d { classWithObjects, bagOfPrimitives };\r\n    String json \u003d gson.toJson(objects);\r\n    assertThat(json).contains(classWithObjectsJson);\r\n    assertThat(json).contains(bagOfPrimitivesJson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testObjectArrayWithNonPrimitivesSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfNullSerialization() {\r\n    Object[] array \u003d { null };\r\n    String json \u003d gson.toJson(array);\r\n    assertThat(json).isEqualTo(\"[null]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testArrayOfNullSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfNullDeserialization() {\r\n    String[] values \u003d gson.fromJson(\"[null]\", String[].class);\r\n    assertThat(values[0]).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testArrayOfNullDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Regression tests for Issue 272\r\n */\r\n@Test\r\npublic void testMultidimensionalArraysSerialization() {\r\n    String[][] items \u003d { { \"3m Co\", \"71.72\", \"0.02\", \"0.03\", \"4/2 12:00am\", \"Manufacturing\" }, { \"Alcoa Inc\", \"29.01\", \"0.42\", \"1.47\", \"4/1 12:00am\", \"Manufacturing\" } };\r\n    String json \u003d gson.toJson(items);\r\n    assertThat(json).contains(\"[[\\\"3m Co\");\r\n    assertThat(json).contains(\"Manufacturing\\\"]]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testMultidimensionalArraysSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultidimensionalObjectArraysSerialization() {\r\n    Object[][] array \u003d { new Object[] { 1, 2 } };\r\n    assertThat(gson.toJson(array)).isEqualTo(\"[[1,2]]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testMultidimensionalObjectArraysSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultidimensionalPrimitiveArraysSerialization() {\r\n    int[][] array \u003d { { 1, 2 }, { 3, 4 } };\r\n    assertThat(gson.toJson(array)).isEqualTo(\"[[1,2],[3,4]]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testMultidimensionalPrimitiveArraysSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Regression test for Issue 205\r\n */\r\n@Test\r\npublic void testMixingTypesInObjectArraySerialization() {\r\n    Object[] array \u003d { 1, 2, new Object[] { \"one\", \"two\", 3 } };\r\n    assertThat(gson.toJson(array)).isEqualTo(\"[1,2,[\\\"one\\\",\\\"two\\\",3]]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testMixingTypesInObjectArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Regression tests for Issue 272\r\n */\r\n@Test\r\npublic void testMultidimensionalArraysDeserialization() {\r\n    String json \u003d \"[[\u00273m Co\u0027,\u002771.72\u0027,\u00270.02\u0027,\u00270.03\u0027,\u00274/2 12:00am\u0027,\u0027Manufacturing\u0027],\" + \"[\u0027Alcoa Inc\u0027,\u002729.01\u0027,\u00270.42\u0027,\u00271.47\u0027,\u00274/1 12:00am\u0027,\u0027Manufacturing\u0027]]\";\r\n    String[][] items \u003d gson.fromJson(json, String[][].class);\r\n    assertThat(items[0][0]).isEqualTo(\"3m Co\");\r\n    assertThat(items[1][5]).isEqualTo(\"Manufacturing\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testMultidimensionalArraysDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultidimensionalPrimitiveArraysDeserialization() {\r\n    String json \u003d \"[[1,2],[3,4]]\";\r\n    int[][] expected \u003d { { 1, 2 }, { 3, 4 } };\r\n    assertThat(gson.fromJson(json, int[][].class)).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testMultidimensionalPrimitiveArraysDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * http://code.google.com/p/google-gson/issues/detail?id\u003d342\r\n */\r\n@Test\r\npublic void testArrayElementsAreArrays() {\r\n    Object[] stringArrays \u003d { new String[] { \"test1\", \"test2\" }, new String[] { \"test3\", \"test4\" } };\r\n    assertThat(new Gson().toJson(stringArrays)).isEqualTo(\"[[\\\"test1\\\",\\\"test2\\\"],[\\\"test3\\\",\\\"test4\\\"]]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ArrayTest",
      "methodName": "testArrayElementsAreArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CircularReferenceTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCircularSerialization() {\r\n    ContainsReferenceToSelfType a \u003d new ContainsReferenceToSelfType();\r\n    ContainsReferenceToSelfType b \u003d new ContainsReferenceToSelfType();\r\n    a.children.add(b);\r\n    b.children.add(a);\r\n    try {\r\n        gson.toJson(a);\r\n        fail(\"Circular types should not get printed!\");\r\n    } catch (StackOverflowError expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CircularReferenceTest",
      "methodName": "testCircularSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSelfReferenceIgnoredInSerialization() {\r\n    ClassOverridingEquals objA \u003d new ClassOverridingEquals();\r\n    objA.ref \u003d objA;\r\n    String json \u003d gson.toJson(objA);\r\n    // self-reference is ignored\r\n    assertThat(json).doesNotContain(\"ref\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CircularReferenceTest",
      "methodName": "testSelfReferenceIgnoredInSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSelfReferenceArrayFieldSerialization() {\r\n    ClassWithSelfReferenceArray objA \u003d new ClassWithSelfReferenceArray();\r\n    objA.children \u003d new ClassWithSelfReferenceArray[] { objA };\r\n    try {\r\n        gson.toJson(objA);\r\n        fail(\"Circular reference to self can not be serialized!\");\r\n    } catch (StackOverflowError expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CircularReferenceTest",
      "methodName": "testSelfReferenceArrayFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(ClassWithSelfReference src, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"property\", \"value\");\r\n    obj.add(\"child\", context.serialize(src.child));\r\n    return obj;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CircularReferenceTest",
      "methodName": "serialize",
      "parameterTypes": [
        "ClassWithSelfReference",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSelfReferenceCustomHandlerSerialization() {\r\n    ClassWithSelfReference obj \u003d new ClassWithSelfReference();\r\n    obj.child \u003d obj;\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ClassWithSelfReference.class, new JsonSerializer\u003cClassWithSelfReference\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(ClassWithSelfReference src, Type typeOfSrc, JsonSerializationContext context) {\r\n            JsonObject obj \u003d new JsonObject();\r\n            obj.addProperty(\"property\", \"value\");\r\n            obj.add(\"child\", context.serialize(src.child));\r\n            return obj;\r\n        }\r\n    }).create();\r\n    try {\r\n        gson.toJson(obj);\r\n        fail(\"Circular reference to self can not be serialized!\");\r\n    } catch (StackOverflowError expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CircularReferenceTest",
      "methodName": "testSelfReferenceCustomHandlerSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDirectedAcyclicGraphSerialization() {\r\n    ContainsReferenceToSelfType a \u003d new ContainsReferenceToSelfType();\r\n    ContainsReferenceToSelfType b \u003d new ContainsReferenceToSelfType();\r\n    ContainsReferenceToSelfType c \u003d new ContainsReferenceToSelfType();\r\n    a.children.add(b);\r\n    a.children.add(c);\r\n    b.children.add(c);\r\n    assertThat(gson.toJson(a)).isNotNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CircularReferenceTest",
      "methodName": "testDirectedAcyclicGraphSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDirectedAcyclicGraphDeserialization() {\r\n    String json \u003d \"{\\\"children\\\":[{\\\"children\\\":[{\\\"children\\\":[]}]},{\\\"children\\\":[]}]}\";\r\n    ContainsReferenceToSelfType target \u003d gson.fromJson(json, ContainsReferenceToSelfType.class);\r\n    assertThat(target).isNotNull();\r\n    assertThat(target.children).hasSize(2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CircularReferenceTest",
      "methodName": "testDirectedAcyclicGraphDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelCollectionOfIntegersSerialization() {\r\n    Collection\u003cInteger\u003e target \u003d Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\r\n    Type targetType \u003d new TypeToken\u003cCollection\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(target, targetType);\r\n    assertThat(json).isEqualTo(\"[1,2,3,4,5,6,7,8,9]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testTopLevelCollectionOfIntegersSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelCollectionOfIntegersDeserialization() {\r\n    String json \u003d \"[0,1,2,3,4,5,6,7,8,9]\";\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cInteger\u003e target \u003d gson.fromJson(json, collectionType);\r\n    int[] expected \u003d { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    assertThat(toIntArray(target)).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testTopLevelCollectionOfIntegersDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelListOfIntegerCollectionsDeserialization() {\r\n    String json \u003d \"[[1,2,3],[4,5,6],[7,8,9]]\";\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003cCollection\u003cInteger\u003e\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cCollection\u003cInteger\u003e\u003e target \u003d gson.fromJson(json, collectionType);\r\n    int[][] expected \u003d new int[3][3];\r\n    for (int i \u003d 0; i \u003c 3; ++i) {\r\n        int start \u003d (3 * i) + 1;\r\n        for (int j \u003d 0; j \u003c 3; ++j) {\r\n            expected[i][j] \u003d start + j;\r\n        }\r\n    }\r\n    for (int i \u003d 0; i \u003c 3; i++) {\r\n        assertThat(toIntArray(target.get(i))).isEqualTo(expected[i]);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testTopLevelListOfIntegerCollectionsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"JdkObsolete\")\r\npublic void testLinkedListSerialization() {\r\n    List\u003cString\u003e list \u003d new LinkedList\u003c\u003e();\r\n    list.add(\"a1\");\r\n    list.add(\"a2\");\r\n    Type linkedListType \u003d new TypeToken\u003cLinkedList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(list, linkedListType);\r\n    assertThat(json).contains(\"a1\");\r\n    assertThat(json).contains(\"a2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testLinkedListSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLinkedListDeserialization() {\r\n    String json \u003d \"[\u0027a1\u0027,\u0027a2\u0027]\";\r\n    Type linkedListType \u003d new TypeToken\u003cLinkedList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cString\u003e list \u003d gson.fromJson(json, linkedListType);\r\n    assertThat(list.get(0)).isEqualTo(\"a1\");\r\n    assertThat(list.get(1)).isEqualTo(\"a2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testLinkedListDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"JdkObsolete\")\r\npublic void testQueueSerialization() {\r\n    Queue\u003cString\u003e queue \u003d new LinkedList\u003c\u003e();\r\n    queue.add(\"a1\");\r\n    queue.add(\"a2\");\r\n    Type queueType \u003d new TypeToken\u003cQueue\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(queue, queueType);\r\n    assertThat(json).contains(\"a1\");\r\n    assertThat(json).contains(\"a2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testQueueSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testQueueDeserialization() {\r\n    String json \u003d \"[\u0027a1\u0027,\u0027a2\u0027]\";\r\n    Type queueType \u003d new TypeToken\u003cQueue\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Queue\u003cString\u003e queue \u003d gson.fromJson(json, queueType);\r\n    assertThat(queue.element()).isEqualTo(\"a1\");\r\n    queue.remove();\r\n    assertThat(queue.element()).isEqualTo(\"a2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testQueueDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPriorityQueue() {\r\n    Type type \u003d new TypeToken\u003cPriorityQueue\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    PriorityQueue\u003cInteger\u003e queue \u003d gson.fromJson(\"[10, 20, 22]\", type);\r\n    assertThat(queue.size()).isEqualTo(3);\r\n    String json \u003d gson.toJson(queue);\r\n    assertThat(queue.remove()).isEqualTo(10);\r\n    assertThat(queue.remove()).isEqualTo(20);\r\n    assertThat(queue.remove()).isEqualTo(22);\r\n    assertThat(json).isEqualTo(\"[10,20,22]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testPriorityQueue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVector() {\r\n    Type type \u003d new TypeToken\u003cVector\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    Vector\u003cInteger\u003e target \u003d gson.fromJson(\"[10, 20, 31]\", type);\r\n    assertThat(target.size()).isEqualTo(3);\r\n    assertThat(target.get(0)).isEqualTo(10);\r\n    assertThat(target.get(1)).isEqualTo(20);\r\n    assertThat(target.get(2)).isEqualTo(31);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"[10,20,31]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testVector",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStack() {\r\n    Type type \u003d new TypeToken\u003cStack\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    Stack\u003cInteger\u003e target \u003d gson.fromJson(\"[11, 13, 17]\", type);\r\n    assertThat(target.size()).isEqualTo(3);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(target.pop()).isEqualTo(17);\r\n    assertThat(target.pop()).isEqualTo(13);\r\n    assertThat(target.pop()).isEqualTo(11);\r\n    assertThat(json).isEqualTo(\"[11,13,17]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testStack",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullsInListSerialization() {\r\n    List\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(\"foo\");\r\n    list.add(null);\r\n    list.add(\"bar\");\r\n    String expected \u003d \"[\\\"foo\\\",null,\\\"bar\\\"]\";\r\n    Type typeOfList \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(list, typeOfList);\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testNullsInListSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullsInListDeserialization() {\r\n    List\u003cString\u003e expected \u003d new ArrayList\u003c\u003e();\r\n    expected.add(\"foo\");\r\n    expected.add(null);\r\n    expected.add(\"bar\");\r\n    String json \u003d \"[\\\"foo\\\",null,\\\"bar\\\"]\";\r\n    Type expectedType \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cString\u003e target \u003d gson.fromJson(json, expectedType);\r\n    for (int i \u003d 0; i \u003c expected.size(); ++i) {\r\n        assertThat(target.get(i)).isEqualTo(expected.get(i));\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testNullsInListDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCollectionOfObjectSerialization() {\r\n    List\u003cObject\u003e target \u003d new ArrayList\u003c\u003e();\r\n    target.add(\"Hello\");\r\n    target.add(\"World\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[\\\"Hello\\\",\\\"World\\\"]\");\r\n    Type type \u003d new TypeToken\u003cList\u003cObject\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(gson.toJson(target, type)).isEqualTo(\"[\\\"Hello\\\",\\\"World\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testCollectionOfObjectSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCollectionOfObjectWithNullSerialization() {\r\n    List\u003cObject\u003e target \u003d new ArrayList\u003c\u003e();\r\n    target.add(\"Hello\");\r\n    target.add(null);\r\n    target.add(\"World\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[\\\"Hello\\\",null,\\\"World\\\"]\");\r\n    Type type \u003d new TypeToken\u003cList\u003cObject\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(gson.toJson(target, type)).isEqualTo(\"[\\\"Hello\\\",null,\\\"World\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testCollectionOfObjectWithNullSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCollectionOfStringsSerialization() {\r\n    List\u003cString\u003e target \u003d new ArrayList\u003c\u003e();\r\n    target.add(\"Hello\");\r\n    target.add(\"World\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[\\\"Hello\\\",\\\"World\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testCollectionOfStringsSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCollectionOfBagOfPrimitivesSerialization() {\r\n    List\u003cBagOfPrimitives\u003e target \u003d new ArrayList\u003c\u003e();\r\n    BagOfPrimitives objA \u003d new BagOfPrimitives(3L, 1, true, \"blah\");\r\n    BagOfPrimitives objB \u003d new BagOfPrimitives(2L, 6, false, \"blahB\");\r\n    target.add(objA);\r\n    target.add(objB);\r\n    String result \u003d gson.toJson(target);\r\n    assertThat(result.startsWith(\"[\")).isTrue();\r\n    assertThat(result.endsWith(\"]\")).isTrue();\r\n    for (BagOfPrimitives obj : target) {\r\n        assertThat(result).contains(obj.getExpectedJson());\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testCollectionOfBagOfPrimitivesSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCollectionOfStringsDeserialization() {\r\n    String json \u003d \"[\\\"Hello\\\",\\\"World\\\"]\";\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cString\u003e target \u003d gson.fromJson(json, collectionType);\r\n    assertThat(target).containsExactly(\"Hello\", \"World\").inOrder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testCollectionOfStringsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRawCollectionOfIntegersSerialization() {\r\n    Collection\u003cInteger\u003e target \u003d Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[1,2,3,4,5,6,7,8,9]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testRawCollectionOfIntegersSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testObjectCollectionSerialization() {\r\n    BagOfPrimitives bag1 \u003d new BagOfPrimitives();\r\n    Collection\u003c?\u003e target \u003d Arrays.asList(bag1, bag1, \"test\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(bag1.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testObjectCollectionSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRawCollectionDeserializationNotAllowed() {\r\n    String json \u003d \"[0,1,2,3,4,5,6,7,8,9]\";\r\n    Collection\u003c?\u003e integers \u003d gson.fromJson(json, Collection.class);\r\n    // JsonReader converts numbers to double by default so we need a floating point comparison\r\n    assertThat(integers).containsExactly(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0).inOrder();\r\n    json \u003d \"[\\\"Hello\\\", \\\"World\\\"]\";\r\n    Collection\u003c?\u003e strings \u003d gson.fromJson(json, Collection.class);\r\n    assertThat(strings).containsExactly(\"Hello\", \"World\").inOrder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testRawCollectionDeserializationNotAllowed",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRawCollectionOfBagOfPrimitivesNotAllowed() {\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives(10, 20, false, \"stringValue\");\r\n    String json \u003d \u0027[\u0027 + bag.getExpectedJson() + \u0027,\u0027 + bag.getExpectedJson() + \u0027]\u0027;\r\n    Collection\u003c?\u003e target \u003d gson.fromJson(json, Collection.class);\r\n    assertThat(target.size()).isEqualTo(2);\r\n    for (Object bag1 : target) {\r\n        // Gson 2.0 converts raw objects into maps\r\n        @SuppressWarnings(\"unchecked\")\r\n        Map\u003cString, Object\u003e values \u003d (Map\u003cString, Object\u003e) bag1;\r\n        assertThat(values.containsValue(10.0)).isTrue();\r\n        assertThat(values.containsValue(20.0)).isTrue();\r\n        assertThat(values.containsValue(\"stringValue\")).isTrue();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testRawCollectionOfBagOfPrimitivesNotAllowed",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWildcardPrimitiveCollectionSerilaization() {\r\n    Collection\u003c? extends Integer\u003e target \u003d Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003c? extends Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(target, collectionType);\r\n    assertThat(json).isEqualTo(\"[1,2,3,4,5,6,7,8,9]\");\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"[1,2,3,4,5,6,7,8,9]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testWildcardPrimitiveCollectionSerilaization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWildcardPrimitiveCollectionDeserilaization() {\r\n    String json \u003d \"[1,2,3,4,5,6,7,8,9]\";\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003c? extends Integer\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003c? extends Integer\u003e target \u003d gson.fromJson(json, collectionType);\r\n    assertThat(target.size()).isEqualTo(9);\r\n    assertThat(target).contains(1);\r\n    assertThat(target).contains(2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testWildcardPrimitiveCollectionDeserilaization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWildcardCollectionField() {\r\n    Collection\u003cBagOfPrimitives\u003e collection \u003d new ArrayList\u003c\u003e();\r\n    BagOfPrimitives objA \u003d new BagOfPrimitives(3L, 1, true, \"blah\");\r\n    BagOfPrimitives objB \u003d new BagOfPrimitives(2L, 6, false, \"blahB\");\r\n    collection.add(objA);\r\n    collection.add(objB);\r\n    ObjectWithWildcardCollection target \u003d new ObjectWithWildcardCollection(collection);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(objA.getExpectedJson());\r\n    assertThat(json).contains(objB.getExpectedJson());\r\n    target \u003d gson.fromJson(json, ObjectWithWildcardCollection.class);\r\n    Collection\u003c? extends BagOfPrimitives\u003e deserializedCollection \u003d target.getCollection();\r\n    assertThat(deserializedCollection.size()).isEqualTo(2);\r\n    assertThat(deserializedCollection).contains(objA);\r\n    assertThat(deserializedCollection).contains(objB);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testWildcardCollectionField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFieldIsArrayList() {\r\n    HasArrayListField object \u003d new HasArrayListField();\r\n    object.longs.add(1L);\r\n    object.longs.add(3L);\r\n    String json \u003d gson.toJson(object, HasArrayListField.class);\r\n    assertThat(json).isEqualTo(\"{\\\"longs\\\":[1,3]}\");\r\n    HasArrayListField copy \u003d gson.fromJson(\"{\\\"longs\\\":[1,3]}\", HasArrayListField.class);\r\n    assertThat(copy.longs).isEqualTo(Arrays.asList(1L, 3L));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testFieldIsArrayList",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(List\u003cString\u003e src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(src.get(0) + \";\" + src.get(1));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "serialize",
      "parameterTypes": [
        "List\u003cString\u003e",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUserCollectionTypeAdapter() {\r\n    Type listOfString \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Object stringListSerializer \u003d new JsonSerializer\u003cList\u003cString\u003e\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(List\u003cString\u003e src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(src.get(0) + \";\" + src.get(1));\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(listOfString, stringListSerializer).create();\r\n    assertThat(gson.toJson(Arrays.asList(\"ab\", \"cd\"), listOfString)).isEqualTo(\"\\\"ab;cd\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testUserCollectionTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static int[] toIntArray(Collection\u003c?\u003e collection) {\r\n    int[] ints \u003d new int[collection.size()];\r\n    int i \u003d 0;\r\n    for (Iterator\u003c?\u003e iterator \u003d collection.iterator(); iterator.hasNext(); ++i) {\r\n        Object obj \u003d iterator.next();\r\n        if (obj instanceof Integer) {\r\n            ints[i] \u003d (Integer) obj;\r\n        } else if (obj instanceof Long) {\r\n            ints[i] \u003d ((Long) obj).intValue();\r\n        }\r\n    }\r\n    return ints;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "toIntArray",
      "parameterTypes": [
        "Collection\u003c?\u003e"
      ],
      "returnType": "int[]"
    }
  },
  {
    "sourceCode": "public Collection\u003c? extends BagOfPrimitives\u003e getCollection() {\r\n    return collection;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest.ObjectWithWildcardCollection",
      "methodName": "getCollection",
      "parameterTypes": [],
      "returnType": "Collection\u003c? extends BagOfPrimitives\u003e"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSetSerialization() {\r\n    Set\u003cEntry\u003e set \u003d new HashSet\u003c\u003e();\r\n    set.add(new Entry(1));\r\n    set.add(new Entry(2));\r\n    String json \u003d gson.toJson(set);\r\n    assertThat(json).contains(\"1\");\r\n    assertThat(json).contains(\"2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testSetSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSetDeserialization() {\r\n    String json \u003d \"[{value:1},{value:2}]\";\r\n    Type type \u003d new TypeToken\u003cSet\u003cEntry\u003e\u003e() {\r\n    }.getType();\r\n    Set\u003cEntry\u003e set \u003d gson.fromJson(json, type);\r\n    assertThat(set.size()).isEqualTo(2);\r\n    for (Entry entry : set) {\r\n        assertThat(entry.value).isAnyOf(1, 2);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testSetDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIssue1107() {\r\n    String json \u003d \"{\\n\" + \"  \\\"inBig\\\": {\\n\" + \"    \\\"key\\\": [\\n\" + \"      { \\\"inSmall\\\": \\\"hello\\\" }\\n\" + \"    ]\\n\" + \"  }\\n\" + \"}\";\r\n    BigClass bigClass \u003d new Gson().fromJson(json, BigClass.class);\r\n    SmallClass small \u003d bigClass.inBig.get(\"key\").get(0);\r\n    assertThat(small).isNotNull();\r\n    assertThat(small.inSmall).isEqualTo(\"hello\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CollectionTest",
      "methodName": "testIssue1107",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ConcurrencyTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Source-code based on\r\n * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081\r\n */\r\n@Test\r\npublic void testSingleThreadSerialization() {\r\n    MyObject myObj \u003d new MyObject();\r\n    for (int i \u003d 0; i \u003c 10; i++) {\r\n        String unused \u003d gson.toJson(myObj);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ConcurrencyTest",
      "methodName": "testSingleThreadSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Source-code based on\r\n * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081\r\n */\r\n@Test\r\npublic void testSingleThreadDeserialization() {\r\n    for (int i \u003d 0; i \u003c 10; i++) {\r\n        MyObject unused \u003d gson.fromJson(\"{\u0027a\u0027:\u0027hello\u0027,\u0027b\u0027:\u0027world\u0027,\u0027i\u0027:1}\", MyObject.class);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ConcurrencyTest",
      "methodName": "testSingleThreadDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void run() {\r\n    MyObject myObj \u003d new MyObject();\r\n    try {\r\n        startLatch.await();\r\n        for (int i \u003d 0; i \u003c 10; i++) {\r\n            String unused \u003d gson.toJson(myObj);\r\n        }\r\n    } catch (Throwable t) {\r\n        failed.set(true);\r\n    } finally {\r\n        finishedLatch.countDown();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ConcurrencyTest",
      "methodName": "run",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Source-code based on\r\n * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081\r\n */\r\n@Test\r\npublic void testMultiThreadSerialization() throws InterruptedException {\r\n    final CountDownLatch startLatch \u003d new CountDownLatch(1);\r\n    final CountDownLatch finishedLatch \u003d new CountDownLatch(10);\r\n    final AtomicBoolean failed \u003d new AtomicBoolean(false);\r\n    ExecutorService executor \u003d Executors.newFixedThreadPool(10);\r\n    for (int taskCount \u003d 0; taskCount \u003c 10; taskCount++) {\r\n        executor.execute(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                MyObject myObj \u003d new MyObject();\r\n                try {\r\n                    startLatch.await();\r\n                    for (int i \u003d 0; i \u003c 10; i++) {\r\n                        String unused \u003d gson.toJson(myObj);\r\n                    }\r\n                } catch (Throwable t) {\r\n                    failed.set(true);\r\n                } finally {\r\n                    finishedLatch.countDown();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    startLatch.countDown();\r\n    finishedLatch.await();\r\n    assertThat(failed.get()).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ConcurrencyTest",
      "methodName": "testMultiThreadSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void run() {\r\n    try {\r\n        startLatch.await();\r\n        for (int i \u003d 0; i \u003c 10; i++) {\r\n            MyObject unused \u003d gson.fromJson(\"{\u0027a\u0027:\u0027hello\u0027,\u0027b\u0027:\u0027world\u0027,\u0027i\u0027:1}\", MyObject.class);\r\n        }\r\n    } catch (Throwable t) {\r\n        failed.set(true);\r\n    } finally {\r\n        finishedLatch.countDown();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ConcurrencyTest",
      "methodName": "run",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Source-code based on\r\n * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081\r\n */\r\n@Test\r\npublic void testMultiThreadDeserialization() throws InterruptedException {\r\n    final CountDownLatch startLatch \u003d new CountDownLatch(1);\r\n    final CountDownLatch finishedLatch \u003d new CountDownLatch(10);\r\n    final AtomicBoolean failed \u003d new AtomicBoolean(false);\r\n    ExecutorService executor \u003d Executors.newFixedThreadPool(10);\r\n    for (int taskCount \u003d 0; taskCount \u003c 10; taskCount++) {\r\n        executor.execute(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    startLatch.await();\r\n                    for (int i \u003d 0; i \u003c 10; i++) {\r\n                        MyObject unused \u003d gson.fromJson(\"{\u0027a\u0027:\u0027hello\u0027,\u0027b\u0027:\u0027world\u0027,\u0027i\u0027:1}\", MyObject.class);\r\n                    }\r\n                } catch (Throwable t) {\r\n                    failed.set(true);\r\n                } finally {\r\n                    finishedLatch.countDown();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    startLatch.countDown();\r\n    finishedLatch.await();\r\n    assertThat(failed.get()).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ConcurrencyTest",
      "methodName": "testMultiThreadDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(DataHolder.class, new DataHolderDeserializer()).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultConstructorNotCalledOnObject() {\r\n    DataHolder data \u003d new DataHolder(DEFAULT_VALUE);\r\n    String json \u003d gson.toJson(data);\r\n    DataHolder actual \u003d gson.fromJson(json, DataHolder.class);\r\n    assertThat(actual.getData()).isEqualTo(DEFAULT_VALUE + SUFFIX);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "testDefaultConstructorNotCalledOnObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultConstructorNotCalledOnField() {\r\n    DataHolderWrapper dataWrapper \u003d new DataHolderWrapper(new DataHolder(DEFAULT_VALUE));\r\n    String json \u003d gson.toJson(dataWrapper);\r\n    DataHolderWrapper actual \u003d gson.fromJson(json, DataHolderWrapper.class);\r\n    assertThat(actual.getWrappedData().getData()).isEqualTo(DEFAULT_VALUE + SUFFIX);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "testDefaultConstructorNotCalledOnField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public String getData() {\r\n    return data;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest.DataHolder",
      "methodName": "getData",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public DataHolder getWrappedData() {\r\n    return wrappedData;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest.DataHolderWrapper",
      "methodName": "getWrappedData",
      "parameterTypes": [],
      "returnType": "DataHolder"
    }
  },
  {
    "sourceCode": "@Override\r\npublic DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    JsonObject jsonObj \u003d json.getAsJsonObject();\r\n    String dataString \u003d jsonObj.get(\"data\").getAsString();\r\n    return new DataHolder(dataString + SUFFIX);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest.DataHolderDeserializer",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "DataHolder"
    }
  },
  {
    "sourceCode": "@Override\r\npublic MyBase deserialize(JsonElement json, Type pojoType, JsonDeserializationContext context) throws JsonParseException {\r\n    String type \u003d json.getAsJsonObject().get(MyBase.TYPE_ACCESS).getAsString();\r\n    return context.deserialize(json, SubTypes.valueOf(type).getSubclass());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "MyBase"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonTypeFieldBasedDeserialization() {\r\n    String json \u003d \"{field1:\u0027abc\u0027,field2:\u0027def\u0027,__type__:\u0027SUB_TYPE1\u0027}\";\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(MyBase.class, new JsonDeserializer\u003cMyBase\u003e() {\r\n\r\n        @Override\r\n        public MyBase deserialize(JsonElement json, Type pojoType, JsonDeserializationContext context) throws JsonParseException {\r\n            String type \u003d json.getAsJsonObject().get(MyBase.TYPE_ACCESS).getAsString();\r\n            return context.deserialize(json, SubTypes.valueOf(type).getSubclass());\r\n        }\r\n    }).create();\r\n    SubType1 target \u003d (SubType1) gson.fromJson(json, MyBase.class);\r\n    assertThat(target.field1).isEqualTo(\"abc\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "testJsonTypeFieldBasedDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public Type getSubclass() {\r\n    return subClass;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "getSubclass",
      "parameterTypes": [],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Base"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomDeserializerReturnsNullForTopLevelObject() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonDeserializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return null;\r\n        }\r\n    }).create();\r\n    String json \u003d \"{baseName:\u0027Base\u0027,subName:\u0027SubRevised\u0027}\";\r\n    Base target \u003d gson.fromJson(json, Base.class);\r\n    assertThat(target).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "testCustomDeserializerReturnsNullForTopLevelObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Base"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomDeserializerReturnsNull() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonDeserializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return null;\r\n        }\r\n    }).create();\r\n    String json \u003d \"{base:{baseName:\u0027Base\u0027,subName:\u0027SubRevised\u0027}}\";\r\n    ClassWithBaseField target \u003d gson.fromJson(json, ClassWithBaseField.class);\r\n    assertThat(target.base).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "testCustomDeserializerReturnsNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Base"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomDeserializerReturnsNullForArrayElements() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonDeserializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return null;\r\n        }\r\n    }).create();\r\n    String json \u003d \"[{baseName:\u0027Base\u0027},{baseName:\u0027Base\u0027}]\";\r\n    Base[] target \u003d gson.fromJson(json, Base[].class);\r\n    assertThat(target[0]).isNull();\r\n    assertThat(target[1]).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "testCustomDeserializerReturnsNullForArrayElements",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Base"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomDeserializerReturnsNullForArrayElementsForArrayField() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonDeserializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return null;\r\n        }\r\n    }).create();\r\n    String json \u003d \"{bases:[{baseName:\u0027Base\u0027},{baseName:\u0027Base\u0027}]}\";\r\n    ClassWithBaseArray target \u003d gson.fromJson(json, ClassWithBaseArray.class);\r\n    assertThat(target.bases[0]).isNull();\r\n    assertThat(target.bases[1]).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomDeserializerTest",
      "methodName": "testCustomDeserializerReturnsNullForArrayElementsForArrayField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBaseClassSerializerInvokedForBaseClassFields() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new BaseSerializer()).registerTypeAdapter(Sub.class, new SubSerializer()).create();\r\n    ClassWithBaseField target \u003d new ClassWithBaseField(new Base());\r\n    JsonObject json \u003d (JsonObject) gson.toJsonTree(target);\r\n    JsonObject base \u003d json.get(\"base\").getAsJsonObject();\r\n    assertThat(base.get(Base.SERIALIZER_KEY).getAsString()).isEqualTo(BaseSerializer.NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomSerializerTest",
      "methodName": "testBaseClassSerializerInvokedForBaseClassFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSubClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstances() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new BaseSerializer()).registerTypeAdapter(Sub.class, new SubSerializer()).create();\r\n    ClassWithBaseField target \u003d new ClassWithBaseField(new Sub());\r\n    JsonObject json \u003d (JsonObject) gson.toJsonTree(target);\r\n    JsonObject base \u003d json.get(\"base\").getAsJsonObject();\r\n    assertThat(base.get(Base.SERIALIZER_KEY).getAsString()).isEqualTo(SubSerializer.NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomSerializerTest",
      "methodName": "testSubClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstances",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSubClassSerializerInvokedForBaseClassFieldsHoldingArrayOfSubClassInstances() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new BaseSerializer()).registerTypeAdapter(Sub.class, new SubSerializer()).create();\r\n    ClassWithBaseArrayField target \u003d new ClassWithBaseArrayField(new Base[] { new Sub(), new Sub() });\r\n    JsonObject json \u003d (JsonObject) gson.toJsonTree(target);\r\n    JsonArray array \u003d json.get(\"base\").getAsJsonArray();\r\n    for (JsonElement element : array) {\r\n        JsonElement serializerKey \u003d element.getAsJsonObject().get(Base.SERIALIZER_KEY);\r\n        assertThat(serializerKey.getAsString()).isEqualTo(SubSerializer.NAME);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomSerializerTest",
      "methodName": "testSubClassSerializerInvokedForBaseClassFieldsHoldingArrayOfSubClassInstances",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBaseClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstances() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new BaseSerializer()).create();\r\n    ClassWithBaseField target \u003d new ClassWithBaseField(new Sub());\r\n    JsonObject json \u003d (JsonObject) gson.toJsonTree(target);\r\n    JsonObject base \u003d json.get(\"base\").getAsJsonObject();\r\n    assertThat(base.get(Base.SERIALIZER_KEY).getAsString()).isEqualTo(BaseSerializer.NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomSerializerTest",
      "methodName": "testBaseClassSerializerInvokedForBaseClassFieldsHoldingSubClassInstances",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomSerializerTest",
      "methodName": "serialize",
      "parameterTypes": [
        "Base",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializerReturnsNull() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return null;\r\n        }\r\n    }).create();\r\n    JsonElement json \u003d gson.toJsonTree(new Base());\r\n    assertThat(json.isJsonNull()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomSerializerTest",
      "methodName": "testSerializerReturnsNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    builder \u003d new GsonBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(ClassWithCustomTypeConverter src, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonObject json \u003d new JsonObject();\r\n    json.addProperty(\"bag\", 5);\r\n    json.addProperty(\"value\", 25);\r\n    return json;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "serialize",
      "parameterTypes": [
        "ClassWithCustomTypeConverter",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomSerializers() {\r\n    Gson gson \u003d builder.registerTypeAdapter(ClassWithCustomTypeConverter.class, new JsonSerializer\u003cClassWithCustomTypeConverter\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(ClassWithCustomTypeConverter src, Type typeOfSrc, JsonSerializationContext context) {\r\n            JsonObject json \u003d new JsonObject();\r\n            json.addProperty(\"bag\", 5);\r\n            json.addProperty(\"value\", 25);\r\n            return json;\r\n        }\r\n    }).create();\r\n    ClassWithCustomTypeConverter target \u003d new ClassWithCustomTypeConverter();\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"bag\\\":5,\\\"value\\\":25}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomSerializers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic ClassWithCustomTypeConverter deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n    JsonObject jsonObject \u003d json.getAsJsonObject();\r\n    int value \u003d jsonObject.get(\"bag\").getAsInt();\r\n    return new ClassWithCustomTypeConverter(new BagOfPrimitives(value, value, false, \"\"), value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "ClassWithCustomTypeConverter"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomDeserializers() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ClassWithCustomTypeConverter.class, new JsonDeserializer\u003cClassWithCustomTypeConverter\u003e() {\r\n\r\n        @Override\r\n        public ClassWithCustomTypeConverter deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n            JsonObject jsonObject \u003d json.getAsJsonObject();\r\n            int value \u003d jsonObject.get(\"bag\").getAsInt();\r\n            return new ClassWithCustomTypeConverter(new BagOfPrimitives(value, value, false, \"\"), value);\r\n        }\r\n    }).create();\r\n    String json \u003d \"{\\\"bag\\\":5,\\\"value\\\":25}\";\r\n    ClassWithCustomTypeConverter target \u003d gson.fromJson(json, ClassWithCustomTypeConverter.class);\r\n    assertThat(target.getBag().getIntValue()).isEqualTo(5);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomDeserializers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@Ignore\r\npublic void disable_testCustomSerializersOfSelf() {\r\n    Gson gson \u003d createGsonObjectWithFooTypeAdapter();\r\n    Gson basicGson \u003d new Gson();\r\n    Foo newFooObject \u003d new Foo(1, 2L);\r\n    String jsonFromCustomSerializer \u003d gson.toJson(newFooObject);\r\n    String jsonFromGson \u003d basicGson.toJson(newFooObject);\r\n    assertThat(jsonFromCustomSerializer).isEqualTo(jsonFromGson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "disable_testCustomSerializersOfSelf",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@Ignore\r\npublic void disable_testCustomDeserializersOfSelf() {\r\n    Gson gson \u003d createGsonObjectWithFooTypeAdapter();\r\n    Gson basicGson \u003d new Gson();\r\n    Foo expectedFoo \u003d new Foo(1, 2L);\r\n    String json \u003d basicGson.toJson(expectedFoo);\r\n    Foo newFooObject \u003d gson.fromJson(json, Foo.class);\r\n    assertThat(newFooObject.key).isEqualTo(expectedFoo.key);\r\n    assertThat(newFooObject.value).isEqualTo(expectedFoo.value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "disable_testCustomDeserializersOfSelf",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(BagOfPrimitives src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(6);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "serialize",
      "parameterTypes": [
        "BagOfPrimitives",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomNestedSerializers() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(BagOfPrimitives.class, new JsonSerializer\u003cBagOfPrimitives\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(BagOfPrimitives src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(6);\r\n        }\r\n    }).create();\r\n    ClassWithCustomTypeConverter target \u003d new ClassWithCustomTypeConverter();\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"bag\\\":6,\\\"value\\\":10}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomNestedSerializers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic BagOfPrimitives deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    int value \u003d json.getAsInt();\r\n    return new BagOfPrimitives(value, value, false, \"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "BagOfPrimitives"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomNestedDeserializers() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(BagOfPrimitives.class, new JsonDeserializer\u003cBagOfPrimitives\u003e() {\r\n\r\n        @Override\r\n        public BagOfPrimitives deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            int value \u003d json.getAsInt();\r\n            return new BagOfPrimitives(value, value, false, \"\");\r\n        }\r\n    }).create();\r\n    String json \u003d \"{\\\"bag\\\":7,\\\"value\\\":25}\";\r\n    ClassWithCustomTypeConverter target \u003d gson.fromJson(json, ClassWithCustomTypeConverter.class);\r\n    assertThat(target.getBag().getIntValue()).isEqualTo(7);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomNestedDeserializers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonObject json \u003d new JsonObject();\r\n    json.addProperty(\"value\", src.baseValue);\r\n    return json;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "serialize",
      "parameterTypes": [
        "Base",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomTypeAdapterDoesNotAppliesToSubClasses() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            JsonObject json \u003d new JsonObject();\r\n            json.addProperty(\"value\", src.baseValue);\r\n            return json;\r\n        }\r\n    }).create();\r\n    Base b \u003d new Base();\r\n    String json \u003d gson.toJson(b);\r\n    assertThat(json).contains(\"value\");\r\n    b \u003d new Derived();\r\n    json \u003d gson.toJson(b);\r\n    assertThat(json).contains(\"derivedValue\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomTypeAdapterDoesNotAppliesToSubClasses",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonObject json \u003d new JsonObject();\r\n    json.addProperty(\"value\", src.baseValue);\r\n    return json;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "serialize",
      "parameterTypes": [
        "Base",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            JsonObject json \u003d new JsonObject();\r\n            json.addProperty(\"value\", src.baseValue);\r\n            return json;\r\n        }\r\n    }).create();\r\n    Base b \u003d new Base();\r\n    String json \u003d gson.toJson(b);\r\n    assertThat(json).contains(\"value\");\r\n    b \u003d new Derived();\r\n    json \u003d gson.toJson(b, Base.class);\r\n    assertThat(json).contains(\"value\");\r\n    assertThat(json).doesNotContain(\"derivedValue\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private Gson createGsonObjectWithFooTypeAdapter() {\r\n    return new GsonBuilder().registerTypeAdapter(Foo.class, new FooTypeAdapter()).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "createGsonObjectWithFooTypeAdapter",
      "parameterTypes": [],
      "returnType": "Gson"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return context.deserialize(json, typeOfT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest.FooTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Foo"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return context.serialize(src, typeOfSrc);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest.FooTypeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "Foo",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Boolean s, Type t, JsonSerializationContext c) {\r\n    return new JsonPrimitive(s ? 1 : 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "serialize",
      "parameterTypes": [
        "Boolean",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomSerializerInvokedForPrimitives() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(boolean.class, new JsonSerializer\u003cBoolean\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Boolean s, Type t, JsonSerializationContext c) {\r\n            return new JsonPrimitive(s ? 1 : 0);\r\n        }\r\n    }).create();\r\n    assertThat(gson.toJson(true, boolean.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(true, Boolean.class)).isEqualTo(\"true\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomSerializerInvokedForPrimitives",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Boolean deserialize(JsonElement json, Type t, JsonDeserializationContext context) {\r\n    return json.getAsInt() !\u003d 0;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Boolean"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomDeserializerInvokedForPrimitives() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(boolean.class, new JsonDeserializer\u003cBoolean\u003e() {\r\n\r\n        @Override\r\n        public Boolean deserialize(JsonElement json, Type t, JsonDeserializationContext context) {\r\n            return json.getAsInt() !\u003d 0;\r\n        }\r\n    }).create();\r\n    assertThat(gson.fromJson(\"1\", boolean.class)).isEqualTo(Boolean.TRUE);\r\n    assertThat(gson.fromJson(\"true\", Boolean.class)).isEqualTo(Boolean.TRUE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomDeserializerInvokedForPrimitives",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContext context) {\r\n    StringBuilder sb \u003d new StringBuilder(src.length);\r\n    for (byte b : src) {\r\n        sb.append(b);\r\n    }\r\n    return new JsonPrimitive(sb.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "serialize",
      "parameterTypes": [
        "byte[]",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomByteArraySerializer() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(byte[].class, new JsonSerializer\u003cbyte[]\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContext context) {\r\n            StringBuilder sb \u003d new StringBuilder(src.length);\r\n            for (byte b : src) {\r\n                sb.append(b);\r\n            }\r\n            return new JsonPrimitive(sb.toString());\r\n        }\r\n    }).create();\r\n    byte[] data \u003d { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    String json \u003d gson.toJson(data);\r\n    assertThat(json).isEqualTo(\"\\\"0123456789\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomByteArraySerializer",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic byte[] deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    String str \u003d json.getAsString();\r\n    byte[] data \u003d new byte[str.length()];\r\n    for (int i \u003d 0; i \u003c data.length; ++i) {\r\n        data[i] \u003d Byte.parseByte(\"\" + str.charAt(i));\r\n    }\r\n    return data;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "byte[]"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomByteArrayDeserializerAndInstanceCreator() {\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder().registerTypeAdapter(byte[].class, new JsonDeserializer\u003cbyte[]\u003e() {\r\n\r\n        @Override\r\n        public byte[] deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            String str \u003d json.getAsString();\r\n            byte[] data \u003d new byte[str.length()];\r\n            for (int i \u003d 0; i \u003c data.length; ++i) {\r\n                data[i] \u003d Byte.parseByte(\"\" + str.charAt(i));\r\n            }\r\n            return data;\r\n        }\r\n    });\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String json \u003d \"\u00270123456789\u0027\";\r\n    byte[] actual \u003d gson.fromJson(json, byte[].class);\r\n    byte[] expected \u003d { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n    for (int i \u003d 0; i \u003c actual.length; ++i) {\r\n        assertThat(actual[i]).isEqualTo(expected[i]);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomByteArrayDeserializerAndInstanceCreator",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic StringHolder createInstance(Type type) {\r\n    // Fill up with objects that will be thrown away\r\n    return new StringHolder(\"unknown:thing\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest.StringHolderTypeAdapter",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "StringHolder"
    }
  },
  {
    "sourceCode": "@Override\r\npublic StringHolder deserialize(JsonElement src, Type type, JsonDeserializationContext context) {\r\n    return new StringHolder(src.getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest.StringHolderTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "StringHolder"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(StringHolder src, Type typeOfSrc, JsonSerializationContext context) {\r\n    String contents \u003d src.part1 + \u0027:\u0027 + src.part2;\r\n    return new JsonPrimitive(contents);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest.StringHolderTypeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "StringHolder",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "// Test created from Issue 70\r\n@Test\r\npublic void testCustomAdapterInvokedForCollectionElementSerializationWithType() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    Type setType \u003d new TypeToken\u003cSet\u003cStringHolder\u003e\u003e() {\r\n    }.getType();\r\n    StringHolder holder \u003d new StringHolder(\"Jacob\", \"Tomaw\");\r\n    Set\u003cStringHolder\u003e setOfHolders \u003d new HashSet\u003c\u003e();\r\n    setOfHolders.add(holder);\r\n    String json \u003d gson.toJson(setOfHolders, setType);\r\n    assertThat(json).contains(\"Jacob:Tomaw\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomAdapterInvokedForCollectionElementSerializationWithType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Test created from Issue 70\r\n@Test\r\npublic void testCustomAdapterInvokedForCollectionElementSerialization() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    StringHolder holder \u003d new StringHolder(\"Jacob\", \"Tomaw\");\r\n    Set\u003cStringHolder\u003e setOfHolders \u003d new HashSet\u003c\u003e();\r\n    setOfHolders.add(holder);\r\n    String json \u003d gson.toJson(setOfHolders);\r\n    assertThat(json).contains(\"Jacob:Tomaw\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomAdapterInvokedForCollectionElementSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Test created from Issue 70\r\n@Test\r\npublic void testCustomAdapterInvokedForCollectionElementDeserialization() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    Type setType \u003d new TypeToken\u003cSet\u003cStringHolder\u003e\u003e() {\r\n    }.getType();\r\n    Set\u003cStringHolder\u003e setOfHolders \u003d gson.fromJson(\"[\u0027Jacob:Tomaw\u0027]\", setType);\r\n    assertThat(setOfHolders.size()).isEqualTo(1);\r\n    StringHolder foo \u003d setOfHolders.iterator().next();\r\n    assertThat(foo.part1).isEqualTo(\"Jacob\");\r\n    assertThat(foo.part2).isEqualTo(\"Tomaw\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomAdapterInvokedForCollectionElementDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Test created from Issue 70\r\n@Test\r\npublic void testCustomAdapterInvokedForMapElementSerializationWithType() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    Type mapType \u003d new TypeToken\u003cMap\u003cString, StringHolder\u003e\u003e() {\r\n    }.getType();\r\n    StringHolder holder \u003d new StringHolder(\"Jacob\", \"Tomaw\");\r\n    Map\u003cString, StringHolder\u003e mapOfHolders \u003d new HashMap\u003c\u003e();\r\n    mapOfHolders.put(\"foo\", holder);\r\n    String json \u003d gson.toJson(mapOfHolders, mapType);\r\n    assertThat(json).contains(\"\\\"foo\\\":\\\"Jacob:Tomaw\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomAdapterInvokedForMapElementSerializationWithType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Test created from Issue 70\r\n@Test\r\npublic void testCustomAdapterInvokedForMapElementSerialization() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    StringHolder holder \u003d new StringHolder(\"Jacob\", \"Tomaw\");\r\n    Map\u003cString, StringHolder\u003e mapOfHolders \u003d new HashMap\u003c\u003e();\r\n    mapOfHolders.put(\"foo\", holder);\r\n    String json \u003d gson.toJson(mapOfHolders);\r\n    assertThat(json).contains(\"\\\"foo\\\":\\\"Jacob:Tomaw\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomAdapterInvokedForMapElementSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Test created from Issue 70\r\n@Test\r\npublic void testCustomAdapterInvokedForMapElementDeserialization() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter()).create();\r\n    Type mapType \u003d new TypeToken\u003cMap\u003cString, StringHolder\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, StringHolder\u003e mapOfFoo \u003d gson.fromJson(\"{\u0027foo\u0027:\u0027Jacob:Tomaw\u0027}\", mapType);\r\n    assertThat(mapOfFoo.size()).isEqualTo(1);\r\n    StringHolder foo \u003d mapOfFoo.get(\"foo\");\r\n    assertThat(foo.part1).isEqualTo(\"Jacob\");\r\n    assertThat(foo.part2).isEqualTo(\"Tomaw\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testCustomAdapterInvokedForMapElementDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEnsureCustomSerializerNotInvokedForNullValues() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(DataHolder.class, new DataHolderSerializer()).create();\r\n    DataHolderWrapper target \u003d new DataHolderWrapper(new DataHolder(\"abc\"));\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"{\\\"wrappedData\\\":{\\\"myData\\\":\\\"abc\\\"}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testEnsureCustomSerializerNotInvokedForNullValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEnsureCustomDeserializerNotInvokedForNullValues() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(DataHolder.class, new DataHolderDeserializer()).create();\r\n    String json \u003d \"{wrappedData:null}\";\r\n    DataHolderWrapper actual \u003d gson.fromJson(json, DataHolderWrapper.class);\r\n    assertThat(actual.wrappedData).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testEnsureCustomDeserializerNotInvokedForNullValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Test created from Issue 352\r\n@Test\r\n@SuppressWarnings({ \"JavaUtilDate\", \"UndefinedEquals\" })\r\npublic void testRegisterHierarchyAdapterForDate() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Date.class, new DateTypeAdapter()).create();\r\n    assertThat(gson.toJson(new Date(0))).isEqualTo(\"0\");\r\n    assertThat(gson.toJson(new java.sql.Date(0))).isEqualTo(\"0\");\r\n    assertThat(gson.fromJson(\"0\", Date.class)).isEqualTo(new Date(0));\r\n    assertThat(gson.fromJson(\"0\", java.sql.Date.class)).isEqualTo(new java.sql.Date(0));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest",
      "methodName": "testRegisterHierarchyAdapterForDate",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(DataHolder src, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"myData\", src.data);\r\n    return obj;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest.DataHolderSerializer",
      "methodName": "serialize",
      "parameterTypes": [
        "DataHolder",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    JsonObject jsonObj \u003d json.getAsJsonObject();\r\n    JsonElement jsonElement \u003d jsonObj.get(\"data\");\r\n    if (jsonElement \u003d\u003d null || jsonElement.isJsonNull()) {\r\n        return new DataHolder(null);\r\n    }\r\n    return new DataHolder(jsonElement.getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest.DataHolderDeserializer",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "DataHolder"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n    return typeOfT \u003d\u003d Date.class ? new Date(json.getAsLong()) : new java.sql.Date(json.getAsLong());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest.DateTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Date"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(src.getTime());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.CustomTypeAdaptersTest.DateTypeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "Date",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    this.oldTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"));\r\n    this.oldLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@After\r\npublic void tearDown() {\r\n    TimeZone.setDefault(oldTimeZone);\r\n    Locale.setDefault(oldLocale);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "tearDown",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassSerialization() {\r\n    try {\r\n        gson.toJson(String.class);\r\n        fail();\r\n    } catch (UnsupportedOperationException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Attempted to serialize java.lang.Class: java.lang.String. Forgot to register a type adapter?\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#java-lang-class-unsupported\");\r\n    }\r\n    // Override with a custom type adapter for class.\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();\r\n    assertThat(gson.toJson(String.class)).isEqualTo(\"\\\"java.lang.String\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testClassSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassDeserialization() {\r\n    try {\r\n        gson.fromJson(\"String.class\", Class.class);\r\n        fail();\r\n    } catch (UnsupportedOperationException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#java-lang-class-unsupported\");\r\n    }\r\n    // Override with a custom type adapter for class.\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();\r\n    assertThat(gson.fromJson(\"java.lang.String\", Class.class)).isAssignableTo(String.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testClassDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUrlSerialization() throws Exception {\r\n    String urlValue \u003d \"http://google.com/\";\r\n    URL url \u003d new URL(urlValue);\r\n    assertThat(gson.toJson(url)).isEqualTo(\"\\\"http://google.com/\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testUrlSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUrlDeserialization() {\r\n    String urlValue \u003d \"http://google.com/\";\r\n    String json \u003d \"\u0027http:\\\\/\\\\/google.com\\\\/\u0027\";\r\n    URL target1 \u003d gson.fromJson(json, URL.class);\r\n    assertThat(target1.toExternalForm()).isEqualTo(urlValue);\r\n    URL target2 \u003d gson.fromJson(\u0027\"\u0027 + urlValue + \u0027\"\u0027, URL.class);\r\n    assertThat(target2.toExternalForm()).isEqualTo(urlValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testUrlDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUrlNullSerialization() {\r\n    ClassWithUrlField target \u003d new ClassWithUrlField();\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testUrlNullSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUrlNullDeserialization() {\r\n    String json \u003d \"{}\";\r\n    ClassWithUrlField target \u003d gson.fromJson(json, ClassWithUrlField.class);\r\n    assertThat(target.url).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testUrlNullDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUriSerialization() throws Exception {\r\n    String uriValue \u003d \"http://google.com/\";\r\n    URI uri \u003d new URI(uriValue);\r\n    assertThat(gson.toJson(uri)).isEqualTo(\"\\\"http://google.com/\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testUriSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUriDeserialization() {\r\n    String uriValue \u003d \"http://google.com/\";\r\n    String json \u003d \u0027\"\u0027 + uriValue + \u0027\"\u0027;\r\n    URI target \u003d gson.fromJson(json, URI.class);\r\n    assertThat(target.toASCIIString()).isEqualTo(uriValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testUriDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullSerialization() {\r\n    testNullSerializationAndDeserialization(Boolean.class);\r\n    testNullSerializationAndDeserialization(Byte.class);\r\n    testNullSerializationAndDeserialization(Short.class);\r\n    testNullSerializationAndDeserialization(Integer.class);\r\n    testNullSerializationAndDeserialization(Long.class);\r\n    testNullSerializationAndDeserialization(Double.class);\r\n    testNullSerializationAndDeserialization(Float.class);\r\n    testNullSerializationAndDeserialization(Number.class);\r\n    testNullSerializationAndDeserialization(Character.class);\r\n    testNullSerializationAndDeserialization(String.class);\r\n    testNullSerializationAndDeserialization(StringBuilder.class);\r\n    testNullSerializationAndDeserialization(StringBuffer.class);\r\n    testNullSerializationAndDeserialization(BigDecimal.class);\r\n    testNullSerializationAndDeserialization(BigInteger.class);\r\n    testNullSerializationAndDeserialization(TreeSet.class);\r\n    testNullSerializationAndDeserialization(ArrayList.class);\r\n    testNullSerializationAndDeserialization(HashSet.class);\r\n    testNullSerializationAndDeserialization(Properties.class);\r\n    testNullSerializationAndDeserialization(URL.class);\r\n    testNullSerializationAndDeserialization(URI.class);\r\n    testNullSerializationAndDeserialization(UUID.class);\r\n    testNullSerializationAndDeserialization(Locale.class);\r\n    testNullSerializationAndDeserialization(InetAddress.class);\r\n    testNullSerializationAndDeserialization(BitSet.class);\r\n    testNullSerializationAndDeserialization(Date.class);\r\n    testNullSerializationAndDeserialization(GregorianCalendar.class);\r\n    testNullSerializationAndDeserialization(Calendar.class);\r\n    testNullSerializationAndDeserialization(Class.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testNullSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void testNullSerializationAndDeserialization(Class\u003c?\u003e c) {\r\n    testNullSerializationAndDeserialization(gson, c);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testNullSerializationAndDeserialization",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public static void testNullSerializationAndDeserialization(Gson gson, Class\u003c?\u003e c) {\r\n    assertThat(gson.toJson(null, c)).isEqualTo(\"null\");\r\n    assertThat(gson.fromJson(\"null\", c)).isEqualTo(null);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testNullSerializationAndDeserialization",
      "parameterTypes": [
        "Gson",
        "Class\u003c?\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUuidSerialization() {\r\n    String uuidValue \u003d \"c237bec1-19ef-4858-a98e-521cf0aad4c0\";\r\n    UUID uuid \u003d UUID.fromString(uuidValue);\r\n    assertThat(gson.toJson(uuid)).isEqualTo(\u0027\"\u0027 + uuidValue + \u0027\"\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testUuidSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUuidDeserialization() {\r\n    String uuidValue \u003d \"c237bec1-19ef-4858-a98e-521cf0aad4c0\";\r\n    String json \u003d \u0027\"\u0027 + uuidValue + \u0027\"\u0027;\r\n    UUID target \u003d gson.fromJson(json, UUID.class);\r\n    assertThat(target.toString()).isEqualTo(uuidValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testUuidDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLocaleSerializationWithLanguage() {\r\n    Locale target \u003d new Locale(\"en\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"\\\"en\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testLocaleSerializationWithLanguage",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLocaleDeserializationWithLanguage() {\r\n    String json \u003d \"\\\"en\\\"\";\r\n    Locale locale \u003d gson.fromJson(json, Locale.class);\r\n    assertThat(locale.getLanguage()).isEqualTo(\"en\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testLocaleDeserializationWithLanguage",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLocaleSerializationWithLanguageCountry() {\r\n    Locale target \u003d Locale.CANADA_FRENCH;\r\n    assertThat(gson.toJson(target)).isEqualTo(\"\\\"fr_CA\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testLocaleSerializationWithLanguageCountry",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLocaleDeserializationWithLanguageCountry() {\r\n    String json \u003d \"\\\"fr_CA\\\"\";\r\n    Locale locale \u003d gson.fromJson(json, Locale.class);\r\n    assertThat(locale).isEqualTo(Locale.CANADA_FRENCH);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testLocaleDeserializationWithLanguageCountry",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLocaleSerializationWithLanguageCountryVariant() {\r\n    Locale target \u003d new Locale(\"de\", \"DE\", \"EURO\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"\\\"de_DE_EURO\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testLocaleSerializationWithLanguageCountryVariant",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLocaleDeserializationWithLanguageCountryVariant() {\r\n    String json \u003d \"\\\"de_DE_EURO\\\"\";\r\n    Locale locale \u003d gson.fromJson(json, Locale.class);\r\n    assertThat(locale.getLanguage()).isEqualTo(\"de\");\r\n    assertThat(locale.getCountry()).isEqualTo(\"DE\");\r\n    assertThat(locale.getVariant()).isEqualTo(\"EURO\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testLocaleDeserializationWithLanguageCountryVariant",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalFieldSerialization() {\r\n    ClassWithBigDecimal target \u003d new ClassWithBigDecimal(\"-122.01e-21\");\r\n    String json \u003d gson.toJson(target);\r\n    String actual \u003d json.substring(json.indexOf(\u0027:\u0027) + 1, json.indexOf(\u0027}\u0027));\r\n    assertThat(new BigDecimal(actual)).isEqualTo(target.value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testBigDecimalFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalFieldDeserialization() {\r\n    ClassWithBigDecimal expected \u003d new ClassWithBigDecimal(\"-122.01e-21\");\r\n    String json \u003d expected.getExpectedJson();\r\n    ClassWithBigDecimal actual \u003d gson.fromJson(json, ClassWithBigDecimal.class);\r\n    assertThat(actual.value).isEqualTo(expected.value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testBigDecimalFieldDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBadValueForBigDecimalDeserialization() {\r\n    try {\r\n        gson.fromJson(\"{\\\"value\\\"\u003d1.5e-1.0031}\", ClassWithBigDecimal.class);\r\n        fail(\"Exponent of a BigDecimal must be an integer value.\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testBadValueForBigDecimalDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigIntegerFieldSerialization() {\r\n    ClassWithBigInteger target \u003d new ClassWithBigInteger(\"23232323215323234234324324324324324324\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testBigIntegerFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigIntegerFieldDeserialization() {\r\n    ClassWithBigInteger expected \u003d new ClassWithBigInteger(\"879697697697697697697697697697697697\");\r\n    String json \u003d expected.getExpectedJson();\r\n    ClassWithBigInteger actual \u003d gson.fromJson(json, ClassWithBigInteger.class);\r\n    assertThat(actual.value).isEqualTo(expected.value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testBigIntegerFieldDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testOverrideBigIntegerTypeAdapter() throws Exception {\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(BigInteger.class, new NumberAsStringAdapter(BigInteger.class)).create();\r\n    assertThat(gson.toJson(new BigInteger(\"123\"), BigInteger.class)).isEqualTo(\"\\\"123\\\"\");\r\n    assertThat(gson.fromJson(\"\\\"123\\\"\", BigInteger.class)).isEqualTo(new BigInteger(\"123\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testOverrideBigIntegerTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testOverrideBigDecimalTypeAdapter() throws Exception {\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(BigDecimal.class, new NumberAsStringAdapter(BigDecimal.class)).create();\r\n    assertThat(gson.toJson(new BigDecimal(\"1.1\"), BigDecimal.class)).isEqualTo(\"\\\"1.1\\\"\");\r\n    assertThat(gson.fromJson(\"\\\"1.1\\\"\", BigDecimal.class)).isEqualTo(new BigDecimal(\"1.1\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testOverrideBigDecimalTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSetSerialization() {\r\n    Gson gson \u003d new Gson();\r\n    HashSet\u003cString\u003e s \u003d new HashSet\u003c\u003e();\r\n    s.add(\"blah\");\r\n    String json \u003d gson.toJson(s);\r\n    assertThat(json).isEqualTo(\"[\\\"blah\\\"]\");\r\n    json \u003d gson.toJson(s, Set.class);\r\n    assertThat(json).isEqualTo(\"[\\\"blah\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testSetSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBitSetSerialization() {\r\n    Gson gson \u003d new Gson();\r\n    BitSet bits \u003d new BitSet();\r\n    bits.set(1);\r\n    bits.set(3, 6);\r\n    bits.set(9);\r\n    String json \u003d gson.toJson(bits);\r\n    assertThat(json).isEqualTo(\"[0,1,0,1,1,1,0,0,0,1]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testBitSetSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBitSetDeserialization() {\r\n    BitSet expected \u003d new BitSet();\r\n    expected.set(0);\r\n    expected.set(2, 6);\r\n    expected.set(8);\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(expected);\r\n    assertThat(gson.fromJson(json, BitSet.class)).isEqualTo(expected);\r\n    json \u003d \"[1,0,1,1,1,1,0,0,1,0,0,0]\";\r\n    assertThat(gson.fromJson(json, BitSet.class)).isEqualTo(expected);\r\n    json \u003d \"[\\\"1\\\",\\\"0\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"1\\\"]\";\r\n    assertThat(gson.fromJson(json, BitSet.class)).isEqualTo(expected);\r\n    json \u003d \"[true,false,true,true,true,true,false,false,true,false,false]\";\r\n    assertThat(gson.fromJson(json, BitSet.class)).isEqualTo(expected);\r\n    try {\r\n        gson.fromJson(\"[1, []]\", BitSet.class);\r\n        fail();\r\n    } catch (JsonSyntaxException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid bitset value type: BEGIN_ARRAY; at path $[1]\");\r\n    }\r\n    try {\r\n        gson.fromJson(\"[1, 2]\", BitSet.class);\r\n        fail();\r\n    } catch (JsonSyntaxException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid bitset value 2, expected 0 or 1; at path $[1]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testBitSetDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultDateSerialization() {\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    assertThat(json).matches(\"\\\"Sep 11, 2011,? 10:55:03\\\\hPM\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDefaultDateSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultDateDeserialization() {\r\n    String json \u003d \"\u0027Dec 13, 2009 07:18:02 AM\u0027\";\r\n    Date extracted \u003d gson.fromJson(json, Date.class);\r\n    assertEqualsDate(extracted, 2009, 11, 13);\r\n    assertEqualsTime(extracted, 7, 18, 2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDefaultDateDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Date can not directly be compared with another instance since the deserialization loses the\r\n// millisecond portion.\r\n@SuppressWarnings(\"deprecation\")\r\npublic static void assertEqualsDate(Date date, int year, int month, int day) {\r\n    assertThat(date.getYear()).isEqualTo(year - 1900);\r\n    assertThat(date.getMonth()).isEqualTo(month);\r\n    assertThat(date.getDate()).isEqualTo(day);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "assertEqualsDate",
      "parameterTypes": [
        "Date",
        "int",
        "int",
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"deprecation\")\r\npublic static void assertEqualsTime(Date date, int hours, int minutes, int seconds) {\r\n    assertThat(date.getHours()).isEqualTo(hours);\r\n    assertThat(date.getMinutes()).isEqualTo(minutes);\r\n    assertThat(date.getSeconds()).isEqualTo(seconds);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "assertEqualsTime",
      "parameterTypes": [
        "Date",
        "int",
        "int",
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultDateSerializationUsingBuilder() {\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    assertThat(json).matches(\"\\\"Sep 11, 2011,? 10:55:03\\\\hPM\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDefaultDateSerializationUsingBuilder",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultDateDeserializationUsingBuilder() {\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    Date extracted \u003d gson.fromJson(json, Date.class);\r\n    assertThat(extracted.toString()).isEqualTo(now.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDefaultDateDeserializationUsingBuilder",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultCalendarSerialization() {\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    String json \u003d gson.toJson(Calendar.getInstance());\r\n    assertThat(json).contains(\"year\");\r\n    assertThat(json).contains(\"month\");\r\n    assertThat(json).contains(\"dayOfMonth\");\r\n    assertThat(json).contains(\"hourOfDay\");\r\n    assertThat(json).contains(\"minute\");\r\n    assertThat(json).contains(\"second\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDefaultCalendarSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultCalendarDeserialization() {\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    String json \u003d \"{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}\";\r\n    Calendar cal \u003d gson.fromJson(json, Calendar.class);\r\n    assertThat(cal.get(Calendar.YEAR)).isEqualTo(2009);\r\n    assertThat(cal.get(Calendar.MONTH)).isEqualTo(2);\r\n    assertThat(cal.get(Calendar.DAY_OF_MONTH)).isEqualTo(11);\r\n    assertThat(cal.get(Calendar.HOUR_OF_DAY)).isEqualTo(14);\r\n    assertThat(cal.get(Calendar.MINUTE)).isEqualTo(29);\r\n    assertThat(cal.get(Calendar.SECOND)).isEqualTo(23);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDefaultCalendarDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultGregorianCalendarSerialization() {\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    GregorianCalendar cal \u003d new GregorianCalendar();\r\n    String json \u003d gson.toJson(cal);\r\n    assertThat(json).contains(\"year\");\r\n    assertThat(json).contains(\"month\");\r\n    assertThat(json).contains(\"dayOfMonth\");\r\n    assertThat(json).contains(\"hourOfDay\");\r\n    assertThat(json).contains(\"minute\");\r\n    assertThat(json).contains(\"second\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDefaultGregorianCalendarSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultGregorianCalendarDeserialization() {\r\n    Gson gson \u003d new GsonBuilder().create();\r\n    String json \u003d \"{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}\";\r\n    GregorianCalendar cal \u003d gson.fromJson(json, GregorianCalendar.class);\r\n    assertThat(cal.get(Calendar.YEAR)).isEqualTo(2009);\r\n    assertThat(cal.get(Calendar.MONTH)).isEqualTo(2);\r\n    assertThat(cal.get(Calendar.DAY_OF_MONTH)).isEqualTo(11);\r\n    assertThat(cal.get(Calendar.HOUR_OF_DAY)).isEqualTo(14);\r\n    assertThat(cal.get(Calendar.MINUTE)).isEqualTo(29);\r\n    assertThat(cal.get(Calendar.SECOND)).isEqualTo(23);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDefaultGregorianCalendarDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDateSerializationWithPattern() {\r\n    String pattern \u003d \"yyyy-MM-dd\";\r\n    Gson gson \u003d new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    assertThat(json).isEqualTo(\"\\\"2011-09-11\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDateSerializationWithPattern",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testDateDeserializationWithPattern() {\r\n    String pattern \u003d \"yyyy-MM-dd\";\r\n    Gson gson \u003d new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    Date extracted \u003d gson.fromJson(json, Date.class);\r\n    assertThat(extracted.getYear()).isEqualTo(now.getYear());\r\n    assertThat(extracted.getMonth()).isEqualTo(now.getMonth());\r\n    assertThat(extracted.getDay()).isEqualTo(now.getDay());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDateDeserializationWithPattern",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return new Date(1315806903103L);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Date"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDateSerializationWithPatternNotOverridenByTypeAdapter() {\r\n    String pattern \u003d \"yyyy-MM-dd\";\r\n    Gson gson \u003d new GsonBuilder().setDateFormat(pattern).registerTypeAdapter(Date.class, new JsonDeserializer\u003cDate\u003e() {\r\n\r\n        @Override\r\n        public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return new Date(1315806903103L);\r\n        }\r\n    }).create();\r\n    Date now \u003d new Date(1315806903103L);\r\n    String json \u003d gson.toJson(now);\r\n    assertThat(json).isEqualTo(\"\\\"2011-09-11\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDateSerializationWithPatternNotOverridenByTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// http://code.google.com/p/google-gson/issues/detail?id\u003d230\r\n@Test\r\npublic void testDateSerializationInCollection() {\r\n    Type listOfDates \u003d new TypeToken\u003cList\u003cDate\u003e\u003e() {\r\n    }.getType();\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    try {\r\n        Gson gson \u003d new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create();\r\n        List\u003cDate\u003e dates \u003d Arrays.asList(new Date(0));\r\n        String json \u003d gson.toJson(dates, listOfDates);\r\n        assertThat(json).isEqualTo(\"[\\\"1970-01-01\\\"]\");\r\n        assertThat(gson.\u003cList\u003cDate\u003e\u003efromJson(\"[\\\"1970-01-01\\\"]\", listOfDates).get(0).getTime()).isEqualTo(0L);\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testDateSerializationInCollection",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonPrimitiveSerialization() {\r\n    assertThat(gson.toJson(new JsonPrimitive(5), JsonElement.class)).isEqualTo(\"5\");\r\n    assertThat(gson.toJson(new JsonPrimitive(true), JsonElement.class)).isEqualTo(\"true\");\r\n    assertThat(gson.toJson(new JsonPrimitive(\"foo\"), JsonElement.class)).isEqualTo(\"\\\"foo\\\"\");\r\n    assertThat(gson.toJson(new JsonPrimitive(\u0027a\u0027), JsonElement.class)).isEqualTo(\"\\\"a\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testJsonPrimitiveSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonPrimitiveDeserialization() {\r\n    assertThat(gson.fromJson(\"5\", JsonElement.class)).isEqualTo(new JsonPrimitive(5));\r\n    assertThat(gson.fromJson(\"5\", JsonPrimitive.class)).isEqualTo(new JsonPrimitive(5));\r\n    assertThat(gson.fromJson(\"true\", JsonElement.class)).isEqualTo(new JsonPrimitive(true));\r\n    assertThat(gson.fromJson(\"true\", JsonPrimitive.class)).isEqualTo(new JsonPrimitive(true));\r\n    assertThat(gson.fromJson(\"\\\"foo\\\"\", JsonElement.class)).isEqualTo(new JsonPrimitive(\"foo\"));\r\n    assertThat(gson.fromJson(\"\\\"foo\\\"\", JsonPrimitive.class)).isEqualTo(new JsonPrimitive(\"foo\"));\r\n    assertThat(gson.fromJson(\"\\\"a\\\"\", JsonElement.class)).isEqualTo(new JsonPrimitive(\u0027a\u0027));\r\n    assertThat(gson.fromJson(\"\\\"a\\\"\", JsonPrimitive.class)).isEqualTo(new JsonPrimitive(\u0027a\u0027));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testJsonPrimitiveDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonNullSerialization() {\r\n    assertThat(gson.toJson(JsonNull.INSTANCE, JsonElement.class)).isEqualTo(\"null\");\r\n    assertThat(gson.toJson(JsonNull.INSTANCE, JsonNull.class)).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testJsonNullSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullJsonElementSerialization() {\r\n    assertThat(gson.toJson(null, JsonElement.class)).isEqualTo(\"null\");\r\n    assertThat(gson.toJson(null, JsonNull.class)).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testNullJsonElementSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonArraySerialization() {\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(new JsonPrimitive(1));\r\n    array.add(new JsonPrimitive(2));\r\n    array.add(new JsonPrimitive(3));\r\n    assertThat(gson.toJson(array, JsonElement.class)).isEqualTo(\"[1,2,3]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testJsonArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonArrayDeserialization() {\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(new JsonPrimitive(1));\r\n    array.add(new JsonPrimitive(2));\r\n    array.add(new JsonPrimitive(3));\r\n    String json \u003d \"[1,2,3]\";\r\n    assertThat(gson.fromJson(json, JsonElement.class)).isEqualTo(array);\r\n    assertThat(gson.fromJson(json, JsonArray.class)).isEqualTo(array);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testJsonArrayDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonObjectSerialization() {\r\n    JsonObject object \u003d new JsonObject();\r\n    object.add(\"foo\", new JsonPrimitive(1));\r\n    object.add(\"bar\", new JsonPrimitive(2));\r\n    assertThat(gson.toJson(object, JsonElement.class)).isEqualTo(\"{\\\"foo\\\":1,\\\"bar\\\":2}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testJsonObjectSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonObjectDeserialization() {\r\n    JsonObject object \u003d new JsonObject();\r\n    object.add(\"foo\", new JsonPrimitive(1));\r\n    object.add(\"bar\", new JsonPrimitive(2));\r\n    String json \u003d \"{\\\"foo\\\":1,\\\"bar\\\":2}\";\r\n    JsonElement actual \u003d gson.fromJson(json, JsonElement.class);\r\n    assertThat(actual).isEqualTo(object);\r\n    JsonObject actualObj \u003d gson.fromJson(json, JsonObject.class);\r\n    assertThat(actualObj).isEqualTo(object);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testJsonObjectDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonNullDeserialization() {\r\n    assertThat(gson.fromJson(\"null\", JsonElement.class)).isEqualTo(JsonNull.INSTANCE);\r\n    assertThat(gson.fromJson(\"null\", JsonNull.class)).isEqualTo(JsonNull.INSTANCE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testJsonNullDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonElementTypeMismatch() {\r\n    try {\r\n        gson.fromJson(\"\\\"abc\\\"\", JsonObject.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive; at path $\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testJsonElementTypeMismatch",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "String getExpectedJson() {\r\n    return \"{\\\"value\\\":\" + value.toEngineeringString() + \"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest.ClassWithBigDecimal",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "String getExpectedJson() {\r\n    return \"{\\\"value\\\":\" + value + \"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest.ClassWithBigInteger",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPropertiesSerialization() {\r\n    Properties props \u003d new Properties();\r\n    props.setProperty(\"foo\", \"bar\");\r\n    String json \u003d gson.toJson(props);\r\n    String expected \u003d \"{\\\"foo\\\":\\\"bar\\\"}\";\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testPropertiesSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPropertiesDeserialization() {\r\n    String json \u003d \"{foo:\u0027bar\u0027}\";\r\n    Properties props \u003d gson.fromJson(json, Properties.class);\r\n    assertThat(props.getProperty(\"foo\")).isEqualTo(\"bar\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testPropertiesDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTreeSetSerialization() {\r\n    TreeSet\u003cString\u003e treeSet \u003d new TreeSet\u003c\u003e();\r\n    treeSet.add(\"Value1\");\r\n    String json \u003d gson.toJson(treeSet);\r\n    assertThat(json).isEqualTo(\"[\\\"Value1\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testTreeSetSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTreeSetDeserialization() {\r\n    String json \u003d \"[\u0027Value1\u0027]\";\r\n    Type type \u003d new TypeToken\u003cTreeSet\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    TreeSet\u003cString\u003e treeSet \u003d gson.fromJson(json, type);\r\n    assertThat(treeSet).contains(\"Value1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testTreeSetDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// TODO: b/287969247 - remove when EP bug fixed\r\n@SuppressWarnings(\"UnnecessaryStringBuilder\")\r\n@Test\r\npublic void testStringBuilderSerialization() {\r\n    StringBuilder sb \u003d new StringBuilder(\"abc\");\r\n    String json \u003d gson.toJson(sb);\r\n    assertThat(json).isEqualTo(\"\\\"abc\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testStringBuilderSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringBuilderDeserialization() {\r\n    StringBuilder sb \u003d gson.fromJson(\"\u0027abc\u0027\", StringBuilder.class);\r\n    assertThat(sb.toString()).isEqualTo(\"abc\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testStringBuilderDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"JdkObsolete\")\r\npublic void testStringBufferSerialization() {\r\n    StringBuffer sb \u003d new StringBuffer(\"abc\");\r\n    String json \u003d gson.toJson(sb);\r\n    assertThat(json).isEqualTo(\"\\\"abc\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testStringBufferSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringBufferDeserialization() {\r\n    StringBuffer sb \u003d gson.fromJson(\"\u0027abc\u0027\", StringBuffer.class);\r\n    assertThat(sb.toString()).isEqualTo(\"abc\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest",
      "methodName": "testStringBufferDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Class\u003c?\u003e value) throws IOException {\r\n    out.value(value.getName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest.MyClassTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Class\u003c?\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Class\u003c?\u003e read(JsonReader in) throws IOException {\r\n    String className \u003d in.nextString();\r\n    try {\r\n        return Class.forName(className);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new IOException(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest.MyClassTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Class\u003c?\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    out.value(value.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest.NumberAsStringAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number read(JsonReader in) throws IOException {\r\n    try {\r\n        return constructor.newInstance(in.nextString());\r\n    } catch (Exception e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DefaultTypeAdaptersTest.NumberAsStringAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    stats \u003d new StatsTypeAdapterFactory();\r\n    gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DelegateTypeAdapterTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDelegateInvoked() {\r\n    List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c 10; ++i) {\r\n        bags.add(new BagOfPrimitives(i, i, i % 2 \u003d\u003d 0, String.valueOf(i)));\r\n    }\r\n    String json \u003d gson.toJson(bags);\r\n    gson.fromJson(json, new TypeToken\u003cList\u003cBagOfPrimitives\u003e\u003e() {\r\n    }.getType());\r\n    // 11: 1 list object, and 10 entries. stats invoked on all 5 fields\r\n    assertThat(stats.numReads).isEqualTo(51);\r\n    assertThat(stats.numWrites).isEqualTo(51);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DelegateTypeAdapterTest",
      "methodName": "testDelegateInvoked",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDelegateInvokedOnStrings() {\r\n    String[] bags \u003d { \"1\", \"2\", \"3\", \"4\" };\r\n    String json \u003d gson.toJson(bags);\r\n    gson.fromJson(json, String[].class);\r\n    // 1 array object with 4 elements.\r\n    assertThat(stats.numReads).isEqualTo(5);\r\n    assertThat(stats.numWrites).isEqualTo(5);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DelegateTypeAdapterTest",
      "methodName": "testDelegateInvokedOnStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    ++numWrites;\r\n    delegate.write(out, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DelegateTypeAdapterTest.StatsTypeAdapterFactory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    ++numReads;\r\n    return delegate.read(in);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DelegateTypeAdapterTest.StatsTypeAdapterFactory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    final TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            ++numWrites;\r\n            delegate.write(out, value);\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            ++numReads;\r\n            return delegate.read(in);\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.DelegateTypeAdapterTest.StatsTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelEnumSerialization() {\r\n    String result \u003d gson.toJson(MyEnum.VALUE1);\r\n    assertThat(result).isEqualTo(\u0027\"\u0027 + MyEnum.VALUE1.toString() + \u0027\"\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testTopLevelEnumSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelEnumDeserialization() {\r\n    MyEnum result \u003d gson.fromJson(\u0027\"\u0027 + MyEnum.VALUE1.toString() + \u0027\"\u0027, MyEnum.class);\r\n    assertThat(result).isEqualTo(MyEnum.VALUE1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testTopLevelEnumDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCollectionOfEnumsSerialization() {\r\n    Type type \u003d new TypeToken\u003cCollection\u003cMyEnum\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cMyEnum\u003e target \u003d new ArrayList\u003c\u003e();\r\n    target.add(MyEnum.VALUE1);\r\n    target.add(MyEnum.VALUE2);\r\n    String expectedJson \u003d \"[\\\"VALUE1\\\",\\\"VALUE2\\\"]\";\r\n    String actualJson \u003d gson.toJson(target);\r\n    assertThat(actualJson).isEqualTo(expectedJson);\r\n    actualJson \u003d gson.toJson(target, type);\r\n    assertThat(actualJson).isEqualTo(expectedJson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testCollectionOfEnumsSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCollectionOfEnumsDeserialization() {\r\n    Type type \u003d new TypeToken\u003cCollection\u003cMyEnum\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d \"[\\\"VALUE1\\\",\\\"VALUE2\\\"]\";\r\n    Collection\u003cMyEnum\u003e target \u003d gson.fromJson(json, type);\r\n    MoreAsserts.assertContains(target, MyEnum.VALUE1);\r\n    MoreAsserts.assertContains(target, MyEnum.VALUE2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testCollectionOfEnumsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithEnumFieldSerialization() {\r\n    ClassWithEnumFields target \u003d new ClassWithEnumFields();\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testClassWithEnumFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithEnumFieldDeserialization() {\r\n    String json \u003d \"{value1:\u0027VALUE1\u0027,value2:\u0027VALUE2\u0027}\";\r\n    ClassWithEnumFields target \u003d gson.fromJson(json, ClassWithEnumFields.class);\r\n    assertThat(target.value1).isEqualTo(MyEnum.VALUE1);\r\n    assertThat(target.value2).isEqualTo(MyEnum.VALUE2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testClassWithEnumFieldDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    return \"{\\\"value1\\\":\\\"\" + value1 + \"\\\",\\\"value2\\\":\\\"\" + value2 + \"\\\"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest.ClassWithEnumFields",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Test for issue 226.\r\n */\r\n@Test\r\n@SuppressWarnings(\"GetClassOnEnum\")\r\npublic void testEnumSubclass() {\r\n    assertThat(Roshambo.ROCK.getClass()).isNotEqualTo(Roshambo.class);\r\n    assertThat(gson.toJson(Roshambo.ROCK)).isEqualTo(\"\\\"ROCK\\\"\");\r\n    assertThat(gson.toJson(EnumSet.allOf(Roshambo.class))).isEqualTo(\"[\\\"ROCK\\\",\\\"PAPER\\\",\\\"SCISSORS\\\"]\");\r\n    assertThat(gson.fromJson(\"\\\"ROCK\\\"\", Roshambo.class)).isEqualTo(Roshambo.ROCK);\r\n    assertThat(EnumSet.allOf(Roshambo.class)).isEqualTo(gson.fromJson(\"[\\\"ROCK\\\",\\\"PAPER\\\",\\\"SCISSORS\\\"]\", new TypeToken\u003cSet\u003cRoshambo\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testEnumSubclass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"GetClassOnEnum\")\r\npublic void testEnumSubclassWithRegisteredTypeAdapter() {\r\n    gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Roshambo.class, new MyEnumTypeAdapter()).create();\r\n    assertThat(Roshambo.ROCK.getClass()).isNotEqualTo(Roshambo.class);\r\n    assertThat(gson.toJson(Roshambo.ROCK)).isEqualTo(\"\\\"123ROCK\\\"\");\r\n    assertThat(gson.toJson(EnumSet.allOf(Roshambo.class))).isEqualTo(\"[\\\"123ROCK\\\",\\\"123PAPER\\\",\\\"123SCISSORS\\\"]\");\r\n    assertThat(gson.fromJson(\"\\\"123ROCK\\\"\", Roshambo.class)).isEqualTo(Roshambo.ROCK);\r\n    assertThat(EnumSet.allOf(Roshambo.class)).isEqualTo(gson.fromJson(\"[\\\"123ROCK\\\",\\\"123PAPER\\\",\\\"123SCISSORS\\\"]\", new TypeToken\u003cSet\u003cRoshambo\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testEnumSubclassWithRegisteredTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEnumSubclassAsParameterizedType() {\r\n    Collection\u003cRoshambo\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(Roshambo.ROCK);\r\n    list.add(Roshambo.PAPER);\r\n    String json \u003d gson.toJson(list);\r\n    assertThat(json).isEqualTo(\"[\\\"ROCK\\\",\\\"PAPER\\\"]\");\r\n    Type collectionType \u003d new TypeToken\u003cCollection\u003cRoshambo\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cRoshambo\u003e actualJsonList \u003d gson.fromJson(json, collectionType);\r\n    MoreAsserts.assertContains(actualJsonList, Roshambo.ROCK);\r\n    MoreAsserts.assertContains(actualJsonList, Roshambo.PAPER);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testEnumSubclassAsParameterizedType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEnumCaseMapping() {\r\n    assertThat(gson.fromJson(\"\\\"boy\\\"\", Gender.class)).isEqualTo(Gender.MALE);\r\n    assertThat(gson.toJson(Gender.MALE, Gender.class)).isEqualTo(\"\\\"boy\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testEnumCaseMapping",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEnumSet() {\r\n    EnumSet\u003cRoshambo\u003e foo \u003d EnumSet.of(Roshambo.ROCK, Roshambo.PAPER);\r\n    String json \u003d gson.toJson(foo);\r\n    assertThat(json).isEqualTo(\"[\\\"ROCK\\\",\\\"PAPER\\\"]\");\r\n    Type type \u003d new TypeToken\u003cEnumSet\u003cRoshambo\u003e\u003e() {\r\n    }.getType();\r\n    EnumSet\u003cRoshambo\u003e bar \u003d gson.fromJson(json, type);\r\n    assertThat(bar).containsExactly(Roshambo.ROCK, Roshambo.PAPER).inOrder();\r\n    assertThat(bar).doesNotContain(Roshambo.SCISSORS);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testEnumSet",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEnumMap() {\r\n    EnumMap\u003cMyEnum, String\u003e map \u003d new EnumMap\u003c\u003e(MyEnum.class);\r\n    map.put(MyEnum.VALUE1, \"test\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"VALUE1\\\":\\\"test\\\"}\");\r\n    Type type \u003d new TypeToken\u003cEnumMap\u003cMyEnum, String\u003e\u003e() {\r\n    }.getType();\r\n    EnumMap\u003c?, ?\u003e actualMap \u003d gson.fromJson(\"{\\\"VALUE1\\\":\\\"test\\\"}\", type);\r\n    Map\u003c?, ?\u003e expectedMap \u003d Collections.singletonMap(MyEnum.VALUE1, \"test\");\r\n    assertThat(actualMap).isEqualTo(expectedMap);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testEnumMap",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\nRoshambo defeats() {\r\n    return SCISSORS;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "defeats",
      "parameterTypes": [],
      "returnType": "Roshambo"
    }
  },
  {
    "sourceCode": "@Override\r\nRoshambo defeats() {\r\n    return ROCK;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "defeats",
      "parameterTypes": [],
      "returnType": "Roshambo"
    }
  },
  {
    "sourceCode": "@Override\r\nRoshambo defeats() {\r\n    return PAPER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "defeats",
      "parameterTypes": [],
      "returnType": "Roshambo"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unused\")\r\nabstract Roshambo defeats();",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "defeats",
      "parameterTypes": [],
      "returnType": "Roshambo"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Roshambo src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"123\" + src.name());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest.MyEnumTypeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "Roshambo",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Roshambo deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return Roshambo.valueOf(json.getAsString().substring(3));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest.MyEnumTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Roshambo"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEnumClassWithFields() {\r\n    assertThat(gson.toJson(Color.RED)).isEqualTo(\"\\\"RED\\\"\");\r\n    assertThat(gson.fromJson(\"RED\", Color.class).value).isEqualTo(\"red\");\r\n    assertThat(gson.fromJson(\"BLUE\", Color.class).index).isEqualTo(2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testEnumClassWithFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEnumToStringRead() {\r\n    // Should still be able to read constant name\r\n    assertThat(gson.fromJson(\"\\\"A\\\"\", CustomToString.class)).isEqualTo(CustomToString.A);\r\n    // Should be able to read toString() value\r\n    assertThat(gson.fromJson(\"\\\"test\\\"\", CustomToString.class)).isEqualTo(CustomToString.A);\r\n    assertThat(gson.fromJson(\"\\\"other\\\"\", CustomToString.class)).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testEnumToStringRead",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"test\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Test that enum constant names have higher precedence than {@code toString()}\r\n * result.\r\n */\r\n@Test\r\npublic void testEnumToStringReadInterchanged() {\r\n    assertThat(gson.fromJson(\"\\\"A\\\"\", InterchangedToString.class)).isEqualTo(InterchangedToString.A);\r\n    assertThat(gson.fromJson(\"\\\"B\\\"\", InterchangedToString.class)).isEqualTo(InterchangedToString.B);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "testEnumToStringReadInterchanged",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return toString;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumTest",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumWithObfuscatedTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEnumClassWithObfuscated() {\r\n    for (Gender enumConstant : Gender.class.getEnumConstants()) {\r\n        try {\r\n            Gender.class.getField(enumConstant.name());\r\n            fail(\"Enum is not obfuscated\");\r\n        } catch (NoSuchFieldException ignore) {\r\n        }\r\n    }\r\n    assertThat(gson.fromJson(\"\\\"MAIL\\\"\", Gender.class)).isEqualTo(Gender.MALE);\r\n    assertThat(gson.toJson(Gender.MALE, Gender.class)).isEqualTo(\"\\\"MAIL\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EnumWithObfuscatedTest",
      "methodName": "testEnumClassWithObfuscated",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EscapingTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapingQuotesInStringArray() {\r\n    String[] valueWithQuotes \u003d { \"beforeQuote\\\"afterQuote\" };\r\n    String jsonRepresentation \u003d gson.toJson(valueWithQuotes);\r\n    String[] target \u003d gson.fromJson(jsonRepresentation, String[].class);\r\n    assertThat(target.length).isEqualTo(1);\r\n    assertThat(target[0]).isEqualTo(valueWithQuotes[0]);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EscapingTest",
      "methodName": "testEscapingQuotesInStringArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapeAllHtmlCharacters() {\r\n    List\u003cString\u003e strings \u003d new ArrayList\u003c\u003e();\r\n    strings.add(\"\u003c\");\r\n    strings.add(\"\u003e\");\r\n    strings.add(\"\u003d\");\r\n    strings.add(\"\u0026\");\r\n    strings.add(\"\u0027\");\r\n    strings.add(\"\\\"\");\r\n    assertThat(gson.toJson(strings)).isEqualTo(\"[\\\"\\\\u003c\\\",\\\"\\\\u003e\\\",\\\"\\\\u003d\\\",\\\"\\\\u0026\\\",\\\"\\\\u0027\\\",\\\"\\\\\\\"\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EscapingTest",
      "methodName": "testEscapeAllHtmlCharacters",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapingObjectFields() {\r\n    BagOfPrimitives objWithPrimitives \u003d new BagOfPrimitives(1L, 1, true, \"test with\\\" \u003cscript\u003e\");\r\n    String jsonRepresentation \u003d gson.toJson(objWithPrimitives);\r\n    assertThat(jsonRepresentation).doesNotContain(\"\u003c\");\r\n    assertThat(jsonRepresentation).doesNotContain(\"\u003e\");\r\n    assertThat(jsonRepresentation).contains(\"\\\\\\\"\");\r\n    BagOfPrimitives expectedObject \u003d gson.fromJson(jsonRepresentation, BagOfPrimitives.class);\r\n    assertThat(objWithPrimitives.getExpectedJson()).isEqualTo(expectedObject.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EscapingTest",
      "methodName": "testEscapingObjectFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() {\r\n    Gson escapeHtmlGson \u003d new GsonBuilder().create();\r\n    Gson noEscapeHtmlGson \u003d new GsonBuilder().disableHtmlEscaping().create();\r\n    BagOfPrimitives target \u003d new BagOfPrimitives(1L, 1, true, \"test\u0027 / w\u0027ith\\\" / \\\\ \u003cscript\u003e\");\r\n    String escapedJsonForm \u003d escapeHtmlGson.toJson(target);\r\n    String nonEscapedJsonForm \u003d noEscapeHtmlGson.toJson(target);\r\n    assertThat(escapedJsonForm.equals(nonEscapedJsonForm)).isFalse();\r\n    assertThat(noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)).isEqualTo(target);\r\n    assertThat(escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class)).isEqualTo(target);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EscapingTest",
      "methodName": "testGsonAcceptsEscapedAndNonEscapedJsonDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonDoubleDeserialization() {\r\n    BagOfPrimitives expected \u003d new BagOfPrimitives(3L, 4, true, \"value1\");\r\n    String json \u003d gson.toJson(gson.toJson(expected));\r\n    String value \u003d gson.fromJson(json, String.class);\r\n    BagOfPrimitives actual \u003d gson.fromJson(value, BagOfPrimitives.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.EscapingTest",
      "methodName": "testGsonDoubleDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipField(FieldAttributes f) {\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "shouldSkipField",
      "parameterTypes": [
        "FieldAttributes"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n    return clazz \u003d\u003d SampleObjectForTest.class;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "shouldSkipClass",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    src \u003d new SampleObjectForTest();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExclusionStrategySerialization() {\r\n    Gson gson \u003d createGson(new MyExclusionStrategy(String.class), true);\r\n    String json \u003d gson.toJson(src);\r\n    assertThat(json).doesNotContain(\"\\\"stringField\\\"\");\r\n    assertThat(json).doesNotContain(\"\\\"annotatedField\\\"\");\r\n    assertThat(json).contains(\"\\\"longField\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "testExclusionStrategySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExclusionStrategySerializationDoesNotImpactDeserialization() {\r\n    String json \u003d \"{\\\"annotatedField\\\":1,\\\"stringField\\\":\\\"x\\\",\\\"longField\\\":2}\";\r\n    Gson gson \u003d createGson(new MyExclusionStrategy(String.class), true);\r\n    SampleObjectForTest value \u003d gson.fromJson(json, SampleObjectForTest.class);\r\n    assertThat(value.annotatedField).isEqualTo(1);\r\n    assertThat(value.stringField).isEqualTo(\"x\");\r\n    assertThat(value.longField).isEqualTo(2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "testExclusionStrategySerializationDoesNotImpactDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExclusionStrategyDeserialization() {\r\n    Gson gson \u003d createGson(new MyExclusionStrategy(String.class), false);\r\n    JsonObject json \u003d new JsonObject();\r\n    json.add(\"annotatedField\", new JsonPrimitive(src.annotatedField + 5));\r\n    json.add(\"stringField\", new JsonPrimitive(src.stringField + \"blah,blah\"));\r\n    json.add(\"longField\", new JsonPrimitive(1212311L));\r\n    SampleObjectForTest target \u003d gson.fromJson(json, SampleObjectForTest.class);\r\n    assertThat(target.longField).isEqualTo(1212311L);\r\n    // assert excluded fields are set to the defaults\r\n    assertThat(target.annotatedField).isEqualTo(src.annotatedField);\r\n    assertThat(target.stringField).isEqualTo(src.stringField);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "testExclusionStrategyDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExclusionStrategySerializationDoesNotImpactSerialization() {\r\n    Gson gson \u003d createGson(new MyExclusionStrategy(String.class), false);\r\n    String json \u003d gson.toJson(src);\r\n    assertThat(json).contains(\"\\\"stringField\\\"\");\r\n    assertThat(json).contains(\"\\\"annotatedField\\\"\");\r\n    assertThat(json).contains(\"\\\"longField\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "testExclusionStrategySerializationDoesNotImpactSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExclusionStrategyWithMode() {\r\n    SampleObjectForTest testObj \u003d new SampleObjectForTest(src.annotatedField + 5, src.stringField + \"blah,blah\", src.longField + 655L);\r\n    Gson gson \u003d createGson(new MyExclusionStrategy(String.class), false);\r\n    JsonObject json \u003d gson.toJsonTree(testObj).getAsJsonObject();\r\n    assertThat(json.get(\"annotatedField\").getAsInt()).isEqualTo(testObj.annotatedField);\r\n    assertThat(json.get(\"stringField\").getAsString()).isEqualTo(testObj.stringField);\r\n    assertThat(json.get(\"longField\").getAsLong()).isEqualTo(testObj.longField);\r\n    SampleObjectForTest target \u003d gson.fromJson(json, SampleObjectForTest.class);\r\n    assertThat(target.longField).isEqualTo(testObj.longField);\r\n    // assert excluded fields are set to the defaults\r\n    assertThat(target.annotatedField).isEqualTo(src.annotatedField);\r\n    assertThat(target.stringField).isEqualTo(src.stringField);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "testExclusionStrategyWithMode",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExcludeTopLevelClassSerialization() {\r\n    Gson gson \u003d new GsonBuilder().addSerializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST).create();\r\n    assertThat(gson.toJson(new SampleObjectForTest(), SampleObjectForTest.class)).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "testExcludeTopLevelClassSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExcludeTopLevelClassSerializationDoesNotImpactDeserialization() {\r\n    Gson gson \u003d new GsonBuilder().addSerializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST).create();\r\n    String json \u003d \"{\\\"annotatedField\\\":1,\\\"stringField\\\":\\\"x\\\",\\\"longField\\\":2}\";\r\n    SampleObjectForTest value \u003d gson.fromJson(json, SampleObjectForTest.class);\r\n    assertThat(value.annotatedField).isEqualTo(1);\r\n    assertThat(value.stringField).isEqualTo(\"x\");\r\n    assertThat(value.longField).isEqualTo(2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "testExcludeTopLevelClassSerializationDoesNotImpactDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExcludeTopLevelClassDeserialization() {\r\n    Gson gson \u003d new GsonBuilder().addDeserializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST).create();\r\n    String json \u003d \"{\\\"annotatedField\\\":1,\\\"stringField\\\":\\\"x\\\",\\\"longField\\\":2}\";\r\n    SampleObjectForTest value \u003d gson.fromJson(json, SampleObjectForTest.class);\r\n    assertThat(value).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "testExcludeTopLevelClassDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExcludeTopLevelClassDeserializationDoesNotImpactSerialization() {\r\n    Gson gson \u003d new GsonBuilder().addDeserializationExclusionStrategy(EXCLUDE_SAMPLE_OBJECT_FOR_TEST).create();\r\n    String json \u003d gson.toJson(new SampleObjectForTest(), SampleObjectForTest.class);\r\n    assertThat(json).contains(\"\\\"stringField\\\"\");\r\n    assertThat(json).contains(\"\\\"annotatedField\\\"\");\r\n    assertThat(json).contains(\"\\\"longField\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "testExcludeTopLevelClassDeserializationDoesNotImpactSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static Gson createGson(ExclusionStrategy exclusionStrategy, boolean serialization) {\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    if (serialization) {\r\n        gsonBuilder.addSerializationExclusionStrategy(exclusionStrategy);\r\n    } else {\r\n        gsonBuilder.addDeserializationExclusionStrategy(exclusionStrategy);\r\n    }\r\n    return gsonBuilder.serializeNulls().create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest",
      "methodName": "createGson",
      "parameterTypes": [
        "ExclusionStrategy",
        "boolean"
      ],
      "returnType": "Gson"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n    return (clazz \u003d\u003d typeToSkip);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest.MyExclusionStrategy",
      "methodName": "shouldSkipClass",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipField(FieldAttributes f) {\r\n    return f.getAnnotation(Foo.class) !\u003d null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExclusionStrategyFunctionalTest.MyExclusionStrategy",
      "methodName": "shouldSkipField",
      "parameterTypes": [
        "FieldAttributes"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new GsonBuilder().excludeFieldsWithoutExposeAnnotation().registerTypeAdapter(SomeInterface.class, new SomeInterfaceInstanceCreator()).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullExposeFieldSerialization() {\r\n    ClassWithExposedFields object \u003d new ClassWithExposedFields(null, 1);\r\n    String json \u003d gson.toJson(object);\r\n    assertThat(json).isEqualTo(object.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest",
      "methodName": "testNullExposeFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayWithOneNullExposeFieldObjectSerialization() {\r\n    ClassWithExposedFields object1 \u003d new ClassWithExposedFields(1, 1);\r\n    ClassWithExposedFields object2 \u003d new ClassWithExposedFields(null, 1);\r\n    ClassWithExposedFields object3 \u003d new ClassWithExposedFields(2, 2);\r\n    ClassWithExposedFields[] objects \u003d { object1, object2, object3 };\r\n    String json \u003d gson.toJson(objects);\r\n    String expected \u003d \u0027[\u0027 + object1.getExpectedJson() + \u0027,\u0027 + object2.getExpectedJson() + \u0027,\u0027 + object3.getExpectedJson() + \u0027]\u0027;\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest",
      "methodName": "testArrayWithOneNullExposeFieldObjectSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExposeAnnotationSerialization() {\r\n    ClassWithExposedFields target \u003d new ClassWithExposedFields(1, 2);\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest",
      "methodName": "testExposeAnnotationSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExposeAnnotationDeserialization() {\r\n    String json \u003d \"{a:3,b:4,d:20.0}\";\r\n    ClassWithExposedFields target \u003d gson.fromJson(json, ClassWithExposedFields.class);\r\n    assertThat(target.a).isEqualTo(3);\r\n    assertThat(target.b).isNull();\r\n    assertThat(target.d).isNotEqualTo(20);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest",
      "methodName": "testExposeAnnotationDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNoExposedFieldSerialization() {\r\n    ClassWithNoExposedFields obj \u003d new ClassWithNoExposedFields();\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest",
      "methodName": "testNoExposedFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNoExposedFieldDeserialization() {\r\n    String json \u003d \"{a:4,b:5}\";\r\n    ClassWithNoExposedFields obj \u003d gson.fromJson(json, ClassWithNoExposedFields.class);\r\n    assertThat(obj.a).isEqualTo(0);\r\n    assertThat(obj.b).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest",
      "methodName": "testNoExposedFieldDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExposedInterfaceFieldSerialization() {\r\n    String expected \u003d \"{\\\"interfaceField\\\":{}}\";\r\n    ClassWithInterfaceField target \u003d new ClassWithInterfaceField(new SomeObject());\r\n    String actual \u003d gson.toJson(target);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest",
      "methodName": "testExposedInterfaceFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExposedInterfaceFieldDeserialization() {\r\n    String json \u003d \"{\\\"interfaceField\\\":{}}\";\r\n    ClassWithInterfaceField obj \u003d gson.fromJson(json, ClassWithInterfaceField.class);\r\n    assertThat(obj.interfaceField).isNotNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest",
      "methodName": "testExposedInterfaceFieldDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    StringBuilder sb \u003d new StringBuilder(\"{\");\r\n    if (a !\u003d null) {\r\n        sb.append(\"\\\"a\\\":\").append(a).append(\",\");\r\n    }\r\n    sb.append(\"\\\"d\\\":\").append(d);\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest.ClassWithExposedFields",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic SomeInterface createInstance(Type type) {\r\n    return new SomeObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ExposeFieldsTest.SomeInterfaceInstanceCreator",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "SomeInterface"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    outer \u003d new Outer();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldExclusionTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultInnerClassExclusion() {\r\n    Gson gson \u003d new Gson();\r\n    Outer.Inner target \u003d outer.new Inner(VALUE);\r\n    String result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(target.toJson());\r\n    gson \u003d new GsonBuilder().create();\r\n    target \u003d outer.new Inner(VALUE);\r\n    result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(target.toJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldExclusionTest",
      "methodName": "testDefaultInnerClassExclusion",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInnerClassExclusion() {\r\n    Gson gson \u003d new GsonBuilder().disableInnerClassSerialization().create();\r\n    Outer.Inner target \u003d outer.new Inner(VALUE);\r\n    String result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldExclusionTest",
      "methodName": "testInnerClassExclusion",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultNestedStaticClassIncluded() {\r\n    Gson gson \u003d new Gson();\r\n    Outer.Inner target \u003d outer.new Inner(VALUE);\r\n    String result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(target.toJson());\r\n    gson \u003d new GsonBuilder().create();\r\n    target \u003d outer.new Inner(VALUE);\r\n    result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(target.toJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldExclusionTest",
      "methodName": "testDefaultNestedStaticClassIncluded",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public String toJson() {\r\n    return \"{\\\"value\\\":\\\"\" + value + \"\\\"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldExclusionTest.NestedClass",
      "methodName": "toJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIdentity() {\r\n    Gson gson \u003d getGsonWithNamingPolicy(IDENTITY);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027lowerCamel\u0027:1,\u0027UpperCamel\u0027:2,\u0027_lowerCamelLeadingUnderscore\u0027:3,\" + \"\u0027_UpperCamelLeadingUnderscore\u0027:4,\u0027lower_words\u0027:5,\u0027UPPER_WORDS\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027lowerId\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldNamingTest",
      "methodName": "testIdentity",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUpperCamelCase() {\r\n    Gson gson \u003d getGsonWithNamingPolicy(UPPER_CAMEL_CASE);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027LowerCamel\u0027:1,\u0027UpperCamel\u0027:2,\u0027_LowerCamelLeadingUnderscore\u0027:3,\" + \"\u0027_UpperCamelLeadingUnderscore\u0027:4,\u0027Lower_words\u0027:5,\u0027UPPER_WORDS\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027LowerId\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldNamingTest",
      "methodName": "testUpperCamelCase",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUpperCamelCaseWithSpaces() {\r\n    Gson gson \u003d getGsonWithNamingPolicy(UPPER_CAMEL_CASE_WITH_SPACES);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027Lower Camel\u0027:1,\u0027Upper Camel\u0027:2,\u0027_Lower Camel Leading Underscore\u0027:3,\" + \"\u0027_ Upper Camel Leading Underscore\u0027:4,\u0027Lower_words\u0027:5,\u0027U P P E R_ W O R D S\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027Lower Id\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldNamingTest",
      "methodName": "testUpperCamelCaseWithSpaces",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUpperCaseWithUnderscores() {\r\n    Gson gson \u003d getGsonWithNamingPolicy(UPPER_CASE_WITH_UNDERSCORES);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027LOWER_CAMEL\u0027:1,\u0027UPPER_CAMEL\u0027:2,\u0027_LOWER_CAMEL_LEADING_UNDERSCORE\u0027:3,\" + \"\u0027__UPPER_CAMEL_LEADING_UNDERSCORE\u0027:4,\u0027LOWER_WORDS\u0027:5,\u0027U_P_P_E_R__W_O_R_D_S\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027LOWER_ID\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldNamingTest",
      "methodName": "testUpperCaseWithUnderscores",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLowerCaseWithUnderscores() {\r\n    Gson gson \u003d getGsonWithNamingPolicy(LOWER_CASE_WITH_UNDERSCORES);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027lower_camel\u0027:1,\u0027upper_camel\u0027:2,\u0027_lower_camel_leading_underscore\u0027:3,\" + \"\u0027__upper_camel_leading_underscore\u0027:4,\u0027lower_words\u0027:5,\u0027u_p_p_e_r__w_o_r_d_s\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027lower_id\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldNamingTest",
      "methodName": "testLowerCaseWithUnderscores",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLowerCaseWithDashes() {\r\n    Gson gson \u003d getGsonWithNamingPolicy(LOWER_CASE_WITH_DASHES);\r\n    assertThat(gson.toJson(new TestNames()).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027lower-camel\u0027:1,\u0027upper-camel\u0027:2,\u0027_lower-camel-leading-underscore\u0027:3,\" + \"\u0027_-upper-camel-leading-underscore\u0027:4,\u0027lower_words\u0027:5,\u0027u-p-p-e-r_-w-o-r-d-s\u0027:6,\" + \"\u0027annotatedName\u0027:7,\u0027lower-id\u0027:8,\u0027_9\u0027:9}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldNamingTest",
      "methodName": "testLowerCaseWithDashes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy) {\r\n    return new GsonBuilder().setFieldNamingPolicy(fieldNamingPolicy).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FieldNamingTest",
      "methodName": "getGsonWithNamingPolicy",
      "parameterTypes": [
        "FieldNamingPolicy"
      ],
      "returnType": "Gson"
    }
  },
  {
    "sourceCode": "// Create new input object every time to protect against tests accidentally modifying input\r\nprivate static Map\u003cString, List\u003cInteger\u003e\u003e createInput() {\r\n    Map\u003cString, List\u003cInteger\u003e\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", Arrays.asList(1, 2));\r\n    return map;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "createInput",
      "parameterTypes": [],
      "returnType": "Map\u003cString, List\u003cInteger\u003e\u003e"
    }
  },
  {
    "sourceCode": "private static String buildExpected(String newline, String indent, boolean spaceAfterSeparators) {\r\n    String expected \u003d \"{\u003cEOL\u003e\u003cINDENT\u003e\\\"a\\\":\u003cCOLON_SPACE\u003e[\u003cEOL\u003e\u003cINDENT\u003e\u003cINDENT\u003e1,\u003cCOMMA_SPACE\u003e\u003cEOL\u003e\u003cINDENT\u003e\u003cINDENT\u003e2\u003cEOL\u003e\u003cINDENT\u003e]\u003cEOL\u003e}\";\r\n    String commaSpace \u003d spaceAfterSeparators \u0026\u0026 newline.isEmpty() ? \" \" : \"\";\r\n    return expected.replace(\"\u003cEOL\u003e\", newline).replace(\"\u003cINDENT\u003e\", indent).replace(\"\u003cCOLON_SPACE\u003e\", spaceAfterSeparators ? \" \" : \"\").replace(\"\u003cCOMMA_SPACE\u003e\", commaSpace);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "buildExpected",
      "parameterTypes": [
        "String",
        "String",
        "boolean"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefault() {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    String json \u003d gson.toJson(createInput());\r\n    assertThat(json).isEqualTo(buildExpected(\"\\n\", \"  \", true));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "testDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVariousCombinationsParse() {\r\n    // Mixing various indent and newline styles in the same string, to be parsed.\r\n    String jsonStringMix \u003d \"{\\r\\t\u0027a\u0027:\\r\\n[        1,2\\t]\\n}\";\r\n    TypeToken\u003cMap\u003cString, List\u003cInteger\u003e\u003e\u003e inputType \u003d new TypeToken\u003cMap\u003cString, List\u003cInteger\u003e\u003e\u003e() {\r\n    };\r\n    Map\u003cString, List\u003cInteger\u003e\u003e actualParsed;\r\n    // Test all that all combinations of newline can be parsed and generate the same INPUT.\r\n    for (String indent : TEST_INDENTS) {\r\n        for (String newline : TEST_NEWLINES) {\r\n            FormattingStyle style \u003d FormattingStyle.PRETTY.withNewline(newline).withIndent(indent);\r\n            Gson gson \u003d new GsonBuilder().setFormattingStyle(style).create();\r\n            String toParse \u003d buildExpected(newline, indent, true);\r\n            actualParsed \u003d gson.fromJson(toParse, inputType);\r\n            assertThat(actualParsed).isEqualTo(createInput());\r\n            // Parse the mixed string with the gson parsers configured with various newline / indents.\r\n            actualParsed \u003d gson.fromJson(jsonStringMix, inputType);\r\n            assertThat(actualParsed).isEqualTo(createInput());\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "testVariousCombinationsParse",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static String toJson(Object obj, FormattingStyle style) {\r\n    return new GsonBuilder().setFormattingStyle(style).create().toJson(obj);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "toJson",
      "parameterTypes": [
        "Object",
        "FormattingStyle"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFormatCompact() {\r\n    String json \u003d toJson(createInput(), FormattingStyle.COMPACT);\r\n    String expectedJson \u003d buildExpected(\"\", \"\", false);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Sanity check to verify that `buildExpected` works correctly\r\n    assertThat(json).isEqualTo(\"{\\\"a\\\":[1,2]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "testFormatCompact",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFormatPretty() {\r\n    String json \u003d toJson(createInput(), FormattingStyle.PRETTY);\r\n    String expectedJson \u003d buildExpected(\"\\n\", \"  \", true);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Sanity check to verify that `buildExpected` works correctly\r\n    assertThat(json).isEqualTo(\"{\\n\" + \"  \\\"a\\\": [\\n\" + \"    1,\\n\" + \"    2\\n\" + \"  ]\\n\" + \"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "testFormatPretty",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFormatPrettySingleLine() {\r\n    FormattingStyle style \u003d FormattingStyle.COMPACT.withSpaceAfterSeparators(true);\r\n    String json \u003d toJson(createInput(), style);\r\n    String expectedJson \u003d buildExpected(\"\", \"\", true);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Sanity check to verify that `buildExpected` works correctly\r\n    assertThat(json).isEqualTo(\"{\\\"a\\\": [1, 2]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "testFormatPrettySingleLine",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFormat() {\r\n    for (String newline : TEST_NEWLINES) {\r\n        for (String indent : TEST_INDENTS) {\r\n            for (boolean spaceAfterSeparators : new boolean[] { true, false }) {\r\n                FormattingStyle style \u003d FormattingStyle.COMPACT.withNewline(newline).withIndent(indent).withSpaceAfterSeparators(spaceAfterSeparators);\r\n                String json \u003d toJson(createInput(), style);\r\n                String expectedJson \u003d buildExpected(newline, indent, spaceAfterSeparators);\r\n                assertThat(json).isEqualTo(expectedJson);\r\n            }\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "testFormat",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Should be able to convert {@link FormattingStyle#COMPACT} to {@link FormattingStyle#PRETTY}\r\n * using the {@code withX} methods.\r\n */\r\n@Test\r\npublic void testCompactToPretty() {\r\n    FormattingStyle style \u003d FormattingStyle.COMPACT.withNewline(\"\\n\").withIndent(\"  \").withSpaceAfterSeparators(true);\r\n    String json \u003d toJson(createInput(), style);\r\n    String expectedJson \u003d toJson(createInput(), FormattingStyle.PRETTY);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "testCompactToPretty",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Should be able to convert {@link FormattingStyle#PRETTY} to {@link FormattingStyle#COMPACT}\r\n * using the {@code withX} methods.\r\n */\r\n@Test\r\npublic void testPrettyToCompact() {\r\n    FormattingStyle style \u003d FormattingStyle.PRETTY.withNewline(\"\").withIndent(\"\").withSpaceAfterSeparators(false);\r\n    String json \u003d toJson(createInput(), style);\r\n    String expectedJson \u003d toJson(createInput(), FormattingStyle.COMPACT);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "testPrettyToCompact",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStyleValidations() {\r\n    try {\r\n        // TBD if we want to accept \\u2028 and \\u2029. For now we don\u0027t because JSON specification\r\n        // does not consider them to be newlines\r\n        FormattingStyle.PRETTY.withNewline(\"\\u2028\");\r\n        fail(\"Gson should not accept anything but \\\\r and \\\\n for newline\");\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Only combinations of \\\\n and \\\\r are allowed in newline.\");\r\n    }\r\n    try {\r\n        FormattingStyle.PRETTY.withNewline(\"NL\");\r\n        fail(\"Gson should not accept anything but \\\\r and \\\\n for newline\");\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Only combinations of \\\\n and \\\\r are allowed in newline.\");\r\n    }\r\n    try {\r\n        FormattingStyle.PRETTY.withIndent(\"\\f\");\r\n        fail(\"Gson should not accept anything but space and tab for indent\");\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Only combinations of spaces and tabs are allowed in indent.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.FormattingStyleTest",
      "methodName": "testStyleValidations",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, TestType value) {\r\n    throw new AssertionError(\"Expected during serialization\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.GsonVersionDiagnosticsTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "TestType"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic TestType read(JsonReader in) {\r\n    throw new AssertionError(\"Expected during deserialization\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.GsonVersionDiagnosticsTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "TestType"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() {\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(TestType.class, new TypeAdapter\u003cTestType\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, TestType value) {\r\n            throw new AssertionError(\"Expected during serialization\");\r\n        }\r\n\r\n        @Override\r\n        public TestType read(JsonReader in) {\r\n            throw new AssertionError(\"Expected during deserialization\");\r\n        }\r\n    }).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.GsonVersionDiagnosticsTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVersionPattern() {\r\n    assertThat(\"(GSON 2.8.5)\").matches(GSON_VERSION_PATTERN);\r\n    assertThat(\"(GSON 2.8.5-SNAPSHOT)\").matches(GSON_VERSION_PATTERN);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.GsonVersionDiagnosticsTest",
      "methodName": "testVersionPattern",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAssertionErrorInSerializationPrintsVersion() {\r\n    AssertionError e \u003d assertThrows(AssertionError.class, () -\u003e gson.toJson(new TestType()));\r\n    ensureAssertionErrorPrintsGsonVersion(e);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.GsonVersionDiagnosticsTest",
      "methodName": "testAssertionErrorInSerializationPrintsVersion",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAssertionErrorInDeserializationPrintsVersion() {\r\n    AssertionError e \u003d assertThrows(AssertionError.class, () -\u003e gson.fromJson(\"{\u0027a\u0027:\u0027abc\u0027}\", TestType.class));\r\n    ensureAssertionErrorPrintsGsonVersion(e);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.GsonVersionDiagnosticsTest",
      "methodName": "testAssertionErrorInDeserializationPrintsVersion",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void ensureAssertionErrorPrintsGsonVersion(AssertionError expected) {\r\n    String msg \u003d expected.getMessage();\r\n    // System.err.println(msg);\r\n    int start \u003d msg.indexOf(\"(GSON\");\r\n    assertThat(start \u003e 0).isTrue();\r\n    int end \u003d msg.indexOf(\"):\") + 1;\r\n    assertThat(end \u003e 0 \u0026\u0026 end \u003e start + 6).isTrue();\r\n    String version \u003d msg.substring(start, end);\r\n    // System.err.println(version);\r\n    assertThat(version).matches(GSON_VERSION_PATTERN);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.GsonVersionDiagnosticsTest",
      "methodName": "ensureAssertionErrorPrintsGsonVersion",
      "parameterTypes": [
        "AssertionError"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSubClassSerialization() {\r\n    SubTypeOfNested target \u003d new SubTypeOfNested(new BagOfPrimitives(10, 20, false, \"stringValue\"), new BagOfPrimitives(30, 40, true, \"stringValue\"));\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testSubClassSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSubClassDeserialization() {\r\n    String json \u003d \"{\\\"value\\\":5,\\\"primitive1\\\":{\\\"longValue\\\":10,\\\"intValue\\\":20,\" + \"\\\"booleanValue\\\":false,\\\"stringValue\\\":\\\"stringValue\\\"},\\\"primitive2\\\":\" + \"{\\\"longValue\\\":30,\\\"intValue\\\":40,\\\"booleanValue\\\":true,\" + \"\\\"stringValue\\\":\\\"stringValue\\\"}}\";\r\n    SubTypeOfNested target \u003d gson.fromJson(json, SubTypeOfNested.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testSubClassDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithBaseFieldSerialization() {\r\n    ClassWithBaseField sub \u003d new ClassWithBaseField(new Sub());\r\n    JsonObject json \u003d (JsonObject) gson.toJsonTree(sub);\r\n    JsonElement base \u003d json.getAsJsonObject().get(ClassWithBaseField.FIELD_KEY);\r\n    assertThat(base.getAsJsonObject().get(Sub.SUB_FIELD_KEY).getAsString()).isEqualTo(Sub.SUB_NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testClassWithBaseFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithBaseArrayFieldSerialization() {\r\n    Base[] baseClasses \u003d new Base[] { new Sub(), new Sub() };\r\n    ClassWithBaseArrayField sub \u003d new ClassWithBaseArrayField(baseClasses);\r\n    JsonObject json \u003d gson.toJsonTree(sub).getAsJsonObject();\r\n    JsonArray bases \u003d json.get(ClassWithBaseArrayField.FIELD_KEY).getAsJsonArray();\r\n    for (JsonElement element : bases) {\r\n        assertThat(element.getAsJsonObject().get(Sub.SUB_FIELD_KEY).getAsString()).isEqualTo(Sub.SUB_NAME);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testClassWithBaseArrayFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithBaseCollectionFieldSerialization() {\r\n    Collection\u003cBase\u003e baseClasses \u003d new ArrayList\u003c\u003e();\r\n    baseClasses.add(new Sub());\r\n    baseClasses.add(new Sub());\r\n    ClassWithBaseCollectionField sub \u003d new ClassWithBaseCollectionField(baseClasses);\r\n    JsonObject json \u003d gson.toJsonTree(sub).getAsJsonObject();\r\n    JsonArray bases \u003d json.get(ClassWithBaseArrayField.FIELD_KEY).getAsJsonArray();\r\n    for (JsonElement element : bases) {\r\n        assertThat(element.getAsJsonObject().get(Sub.SUB_FIELD_KEY).getAsString()).isEqualTo(Sub.SUB_NAME);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testClassWithBaseCollectionFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBaseSerializedAsSub() {\r\n    Base base \u003d new Sub();\r\n    JsonObject json \u003d gson.toJsonTree(base).getAsJsonObject();\r\n    assertThat(json.get(Sub.SUB_FIELD_KEY).getAsString()).isEqualTo(Sub.SUB_NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testBaseSerializedAsSub",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBaseSerializedAsSubForToJsonMethod() {\r\n    Base base \u003d new Sub();\r\n    String json \u003d gson.toJson(base);\r\n    assertThat(json).contains(Sub.SUB_NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testBaseSerializedAsSubForToJsonMethod",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBaseSerializedAsBaseWhenSpecifiedWithExplicitType() {\r\n    Base base \u003d new Sub();\r\n    JsonObject json \u003d gson.toJsonTree(base, Base.class).getAsJsonObject();\r\n    assertThat(json.get(Base.BASE_FIELD_KEY).getAsString()).isEqualTo(Base.BASE_NAME);\r\n    assertThat(json.get(Sub.SUB_FIELD_KEY)).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testBaseSerializedAsBaseWhenSpecifiedWithExplicitType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBaseSerializedAsBaseWhenSpecifiedWithExplicitTypeForToJsonMethod() {\r\n    Base base \u003d new Sub();\r\n    String json \u003d gson.toJson(base, Base.class);\r\n    assertThat(json).contains(Base.BASE_NAME);\r\n    assertThat(json).doesNotContain(Sub.SUB_FIELD_KEY);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testBaseSerializedAsBaseWhenSpecifiedWithExplicitTypeForToJsonMethod",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBaseSerializedAsSubWhenSpecifiedWithExplicitType() {\r\n    Base base \u003d new Sub();\r\n    JsonObject json \u003d gson.toJsonTree(base, Sub.class).getAsJsonObject();\r\n    assertThat(json.get(Sub.SUB_FIELD_KEY).getAsString()).isEqualTo(Sub.SUB_NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testBaseSerializedAsSubWhenSpecifiedWithExplicitType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBaseSerializedAsSubWhenSpecifiedWithExplicitTypeForToJsonMethod() {\r\n    Base base \u003d new Sub();\r\n    String json \u003d gson.toJson(base, Sub.class);\r\n    assertThat(json).contains(Sub.SUB_NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testBaseSerializedAsSubWhenSpecifiedWithExplicitTypeForToJsonMethod",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void appendFields(StringBuilder sb) {\r\n    sb.append(\"\\\"value\\\":\").append(value).append(\",\");\r\n    super.appendFields(sb);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest.SubTypeOfNested",
      "methodName": "appendFields",
      "parameterTypes": [
        "StringBuilder"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"JdkObsolete\")\r\npublic void testSubInterfacesOfCollectionSerialization() {\r\n    List\u003cInteger\u003e list \u003d new LinkedList\u003c\u003e();\r\n    list.add(0);\r\n    list.add(1);\r\n    list.add(2);\r\n    list.add(3);\r\n    Queue\u003cLong\u003e queue \u003d new LinkedList\u003c\u003e();\r\n    queue.add(0L);\r\n    queue.add(1L);\r\n    queue.add(2L);\r\n    queue.add(3L);\r\n    Set\u003cFloat\u003e set \u003d new TreeSet\u003c\u003e();\r\n    set.add(0.1F);\r\n    set.add(0.2F);\r\n    set.add(0.3F);\r\n    set.add(0.4F);\r\n    SortedSet\u003cCharacter\u003e sortedSet \u003d new TreeSet\u003c\u003e();\r\n    sortedSet.add(\u0027a\u0027);\r\n    sortedSet.add(\u0027b\u0027);\r\n    sortedSet.add(\u0027c\u0027);\r\n    sortedSet.add(\u0027d\u0027);\r\n    ClassWithSubInterfacesOfCollection target \u003d new ClassWithSubInterfacesOfCollection(list, queue, set, sortedSet);\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testSubInterfacesOfCollectionSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSubInterfacesOfCollectionDeserialization() {\r\n    String json \u003d \"{\\\"list\\\":[0,1,2,3],\\\"queue\\\":[0,1,2,3],\\\"set\\\":[0.1,0.2,0.3,0.4],\" + \"\\\"sortedSet\\\":[\\\"a\\\",\\\"b\\\",\\\"c\\\",\\\"d\\\"]\" + \"}\";\r\n    ClassWithSubInterfacesOfCollection target \u003d gson.fromJson(json, ClassWithSubInterfacesOfCollection.class);\r\n    assertThat(target.listContains(0, 1, 2, 3)).isTrue();\r\n    assertThat(target.queueContains(0, 1, 2, 3)).isTrue();\r\n    assertThat(target.setContains(0.1F, 0.2F, 0.3F, 0.4F)).isTrue();\r\n    assertThat(target.sortedSetContains(\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest",
      "methodName": "testSubInterfacesOfCollectionDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "boolean listContains(int... values) {\r\n    for (int value : values) {\r\n        if (!list.contains(value)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest.ClassWithSubInterfacesOfCollection",
      "methodName": "listContains",
      "parameterTypes": [
        "int"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "boolean queueContains(long... values) {\r\n    for (long value : values) {\r\n        if (!queue.contains(value)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest.ClassWithSubInterfacesOfCollection",
      "methodName": "queueContains",
      "parameterTypes": [
        "long"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "boolean setContains(float... values) {\r\n    for (float value : values) {\r\n        if (!set.contains(value)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest.ClassWithSubInterfacesOfCollection",
      "methodName": "setContains",
      "parameterTypes": [
        "float"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "boolean sortedSetContains(char... values) {\r\n    for (char value : values) {\r\n        if (!sortedSet.contains(value)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest.ClassWithSubInterfacesOfCollection",
      "methodName": "sortedSetContains",
      "parameterTypes": [
        "char"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\"{\");\r\n    sb.append(\"\\\"list\\\":\");\r\n    append(sb, list).append(\",\");\r\n    sb.append(\"\\\"queue\\\":\");\r\n    append(sb, queue).append(\",\");\r\n    sb.append(\"\\\"set\\\":\");\r\n    append(sb, set).append(\",\");\r\n    sb.append(\"\\\"sortedSet\\\":\");\r\n    append(sb, sortedSet);\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest.ClassWithSubInterfacesOfCollection",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\nprivate StringBuilder append(StringBuilder sb, Collection\u003c?\u003e c) {\r\n    sb.append(\"[\");\r\n    boolean first \u003d true;\r\n    for (Object o : c) {\r\n        if (!first) {\r\n            sb.append(\",\");\r\n        } else {\r\n            first \u003d false;\r\n        }\r\n        if (o instanceof String || o instanceof Character) {\r\n            sb.append(\u0027\\\"\u0027);\r\n        }\r\n        sb.append(o.toString());\r\n        if (o instanceof String || o instanceof Character) {\r\n            sb.append(\u0027\\\"\u0027);\r\n        }\r\n    }\r\n    sb.append(\"]\");\r\n    return sb;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InheritanceTest.ClassWithSubInterfacesOfCollection",
      "methodName": "append",
      "parameterTypes": [
        "StringBuilder",
        "Collection\u003c?\u003e"
      ],
      "returnType": "StringBuilder"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Base createInstance(Type type) {\r\n    return new Base();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InstanceCreatorTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "Base"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInstanceCreatorReturnsBaseType() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new InstanceCreator\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base createInstance(Type type) {\r\n            return new Base();\r\n        }\r\n    }).create();\r\n    String json \u003d \"{baseName:\u0027BaseRevised\u0027,subName:\u0027Sub\u0027}\";\r\n    Base base \u003d gson.fromJson(json, Base.class);\r\n    assertThat(base.baseName).isEqualTo(\"BaseRevised\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InstanceCreatorTest",
      "methodName": "testInstanceCreatorReturnsBaseType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Base createInstance(Type type) {\r\n    return new Sub();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InstanceCreatorTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "Base"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInstanceCreatorReturnsSubTypeForTopLevelObject() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new InstanceCreator\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base createInstance(Type type) {\r\n            return new Sub();\r\n        }\r\n    }).create();\r\n    String json \u003d \"{baseName:\u0027Base\u0027,subName:\u0027SubRevised\u0027}\";\r\n    Base base \u003d gson.fromJson(json, Base.class);\r\n    assertThat(base instanceof Sub).isTrue();\r\n    Sub sub \u003d (Sub) base;\r\n    assertThat(\"SubRevised\".equals(sub.subName)).isFalse();\r\n    assertThat(sub.subName).isEqualTo(Sub.SUB_NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InstanceCreatorTest",
      "methodName": "testInstanceCreatorReturnsSubTypeForTopLevelObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Base createInstance(Type type) {\r\n    return new Sub();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InstanceCreatorTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "Base"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInstanceCreatorReturnsSubTypeForField() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new InstanceCreator\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base createInstance(Type type) {\r\n            return new Sub();\r\n        }\r\n    }).create();\r\n    String json \u003d \"{base:{baseName:\u0027Base\u0027,subName:\u0027SubRevised\u0027}}\";\r\n    ClassWithBaseField target \u003d gson.fromJson(json, ClassWithBaseField.class);\r\n    assertThat(target.base instanceof Sub).isTrue();\r\n    assertThat(((Sub) target.base).subName).isEqualTo(Sub.SUB_NAME);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InstanceCreatorTest",
      "methodName": "testInstanceCreatorReturnsSubTypeForField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic List\u003cString\u003e createInstance(Type type) {\r\n    return new SubArrayList\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InstanceCreatorTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "List\u003cString\u003e"
    }
  },
  {
    "sourceCode": "// This regressed in Gson 2.0 and 2.1\r\n@Test\r\npublic void testInstanceCreatorForCollectionType() {\r\n    @SuppressWarnings(\"serial\")\r\n    class SubArrayList\u003cT\u003e extends ArrayList\u003cT\u003e {\r\n    }\r\n    InstanceCreator\u003cList\u003cString\u003e\u003e listCreator \u003d new InstanceCreator\u003cList\u003cString\u003e\u003e() {\r\n\r\n        @Override\r\n        public List\u003cString\u003e createInstance(Type type) {\r\n            return new SubArrayList\u003c\u003e();\r\n        }\r\n    };\r\n    Type listOfStringType \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(listOfStringType, listCreator).create();\r\n    List\u003cString\u003e list \u003d gson.fromJson(\"[\\\"a\\\"]\", listOfStringType);\r\n    assertThat(list.getClass()).isEqualTo(SubArrayList.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InstanceCreatorTest",
      "methodName": "testInstanceCreatorForCollectionType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic SortedSet\u003c?\u003e createInstance(Type type) {\r\n    return new SubTreeSet\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InstanceCreatorTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "SortedSet\u003c?\u003e"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Test\r\npublic void testInstanceCreatorForParametrizedType() {\r\n    @SuppressWarnings(\"serial\")\r\n    class SubTreeSet\u003cT\u003e extends TreeSet\u003cT\u003e {\r\n    }\r\n    InstanceCreator\u003cSortedSet\u003c?\u003e\u003e sortedSetCreator \u003d new InstanceCreator\u003cSortedSet\u003c?\u003e\u003e() {\r\n\r\n        @Override\r\n        public SortedSet\u003c?\u003e createInstance(Type type) {\r\n            return new SubTreeSet\u003c\u003e();\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(SortedSet.class, sortedSetCreator).create();\r\n    Type sortedSetType \u003d new TypeToken\u003cSortedSet\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    SortedSet\u003cString\u003e set \u003d gson.fromJson(\"[\\\"a\\\"]\", sortedSetType);\r\n    assertThat(set.first()).isEqualTo(\"a\");\r\n    assertThat(set.getClass()).isEqualTo(SubTreeSet.class);\r\n    set \u003d gson.fromJson(\"[\\\"b\\\"]\", SortedSet.class);\r\n    assertThat(set.first()).isEqualTo(\"b\");\r\n    assertThat(set.getClass()).isEqualTo(SubTreeSet.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InstanceCreatorTest",
      "methodName": "testInstanceCreatorForParametrizedType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n    obj \u003d new TestObject(\"StringValue\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InterfaceTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializingObjectImplementingInterface() {\r\n    assertThat(gson.toJson(obj)).isEqualTo(OBJ_JSON);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InterfaceTest",
      "methodName": "testSerializingObjectImplementingInterface",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializingInterfaceObjectField() {\r\n    TestObjectWrapper objWrapper \u003d new TestObjectWrapper(obj);\r\n    assertThat(gson.toJson(objWrapper)).isEqualTo(\"{\\\"obj\\\":\" + OBJ_JSON + \"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InterfaceTest",
      "methodName": "testSerializingInterfaceObjectField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InternationalizationTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringsWithUnicodeChineseCharactersSerialization() {\r\n    String target \u003d \"\\u597d\\u597d\\u597d\";\r\n    String json \u003d gson.toJson(target);\r\n    String expected \u003d \u0027\"\u0027 + target + \u0027\"\u0027;\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InternationalizationTest",
      "methodName": "testStringsWithUnicodeChineseCharactersSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringsWithUnicodeChineseCharactersDeserialization() {\r\n    String expected \u003d \"\\u597d\\u597d\\u597d\";\r\n    String json \u003d \u0027\"\u0027 + expected + \u0027\"\u0027;\r\n    String actual \u003d gson.fromJson(json, String.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InternationalizationTest",
      "methodName": "testStringsWithUnicodeChineseCharactersDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringsWithUnicodeChineseCharactersEscapedDeserialization() {\r\n    String actual \u003d gson.fromJson(\"\u0027\\\\u597d\\\\u597d\\\\u597d\u0027\", String.class);\r\n    assertThat(actual).isEqualTo(\"\\u597d\\u597d\\u597d\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InternationalizationTest",
      "methodName": "testStringsWithUnicodeChineseCharactersEscapedDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSupplementaryUnicodeSerialization() {\r\n    // Supplementary code point U+1F60A\r\n    String supplementaryCodePoint \u003d new String(new int[] { 0x1F60A }, 0, 1);\r\n    String json \u003d gson.toJson(supplementaryCodePoint);\r\n    assertThat(json).isEqualTo(\u0027\"\u0027 + supplementaryCodePoint + \u0027\"\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InternationalizationTest",
      "methodName": "testSupplementaryUnicodeSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSupplementaryUnicodeDeserialization() {\r\n    // Supplementary code point U+1F60A\r\n    String supplementaryCodePoint \u003d new String(new int[] { 0x1F60A }, 0, 1);\r\n    String actual \u003d gson.fromJson(\u0027\"\u0027 + supplementaryCodePoint + \u0027\"\u0027, String.class);\r\n    assertThat(actual).isEqualTo(supplementaryCodePoint);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InternationalizationTest",
      "methodName": "testSupplementaryUnicodeDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSupplementaryUnicodeEscapedDeserialization() {\r\n    // Supplementary code point U+1F60A\r\n    String supplementaryCodePoint \u003d new String(new int[] { 0x1F60A }, 0, 1);\r\n    String actual \u003d gson.fromJson(\"\\\"\\\\uD83D\\\\uDE0A\\\"\", String.class);\r\n    assertThat(actual).isEqualTo(supplementaryCodePoint);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.InternationalizationTest",
      "methodName": "testSupplementaryUnicodeEscapedDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFirstNameIsChosenForSerialization() {\r\n    RecordWithCustomNames target \u003d new RecordWithCustomNames(\"v1\", \"v2\");\r\n    // Ensure name1 occurs exactly once, and name2 and name3 don\u0027t appear\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"name\\\":\\\"v1\\\",\\\"name1\\\":\\\"v2\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testFirstNameIsChosenForSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultipleNamesDeserializedCorrectly() {\r\n    assertThat(gson.fromJson(\"{\u0027name\u0027:\u0027v1\u0027}\", RecordWithCustomNames.class).a).isEqualTo(\"v1\");\r\n    // Both name1 and name2 gets deserialized to b\r\n    assertThat(gson.fromJson(\"{\u0027name\u0027: \u0027v1\u0027, \u0027name1\u0027:\u0027v11\u0027}\", RecordWithCustomNames.class).b).isEqualTo(\"v11\");\r\n    assertThat(gson.fromJson(\"{\u0027name\u0027: \u0027v1\u0027, \u0027name2\u0027:\u0027v2\u0027}\", RecordWithCustomNames.class).b).isEqualTo(\"v2\");\r\n    assertThat(gson.fromJson(\"{\u0027name\u0027: \u0027v1\u0027, \u0027name3\u0027:\u0027v3\u0027}\", RecordWithCustomNames.class).b).isEqualTo(\"v3\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testMultipleNamesDeserializedCorrectly",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultipleNamesInTheSameString() {\r\n    // The last value takes precedence\r\n    assertThat(gson.fromJson(\"{\u0027name\u0027: \u0027foo\u0027, \u0027name1\u0027:\u0027v1\u0027,\u0027name2\u0027:\u0027v2\u0027,\u0027name3\u0027:\u0027v3\u0027}\", RecordWithCustomNames.class).b).isEqualTo(\"v3\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testMultipleNamesInTheSameString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SerializedName(\"a\")\r\n@Override\r\npublic int i() {\r\n    return i;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "i",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializedNameOnAccessor() {\r\n    record LocalRecord(int i) {\r\n\r\n        @SerializedName(\"a\")\r\n        @Override\r\n        public int i() {\r\n            return i;\r\n        }\r\n    }\r\n    var exception \u003d assertThrows(JsonIOException.class, () -\u003e gson.getAdapter(LocalRecord.class));\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"@SerializedName on method \u0027\" + LocalRecord.class.getName() + \"#i()\u0027 is not supported\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testSerializedNameOnAccessor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFieldNamingStrategy() {\r\n    record LocalRecord(int i) {\r\n    }\r\n    Gson gson \u003d new GsonBuilder().setFieldNamingStrategy(f -\u003e f.getName() + \"-custom\").create();\r\n    assertThat(gson.toJson(new LocalRecord(1))).isEqualTo(\"{\\\"i-custom\\\":1}\");\r\n    assertThat(gson.fromJson(\"{\\\"i-custom\\\":2}\", LocalRecord.class)).isEqualTo(new LocalRecord(2));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testFieldNamingStrategy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUnknownJsonProperty() {\r\n    record LocalRecord(int i) {\r\n    }\r\n    // Unknown property \u0027x\u0027 should be ignored\r\n    assertThat(gson.fromJson(\"{\\\"i\\\":1,\\\"x\\\":2}\", LocalRecord.class)).isEqualTo(new LocalRecord(1));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testUnknownJsonProperty",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDuplicateJsonProperties() {\r\n    record LocalRecord(Integer a, Integer b) {\r\n    }\r\n    String json \u003d \"{\\\"a\\\":null,\\\"a\\\":2,\\\"b\\\":1,\\\"b\\\":null}\";\r\n    // Should use value of last occurrence\r\n    assertThat(gson.fromJson(json, LocalRecord.class)).isEqualTo(new LocalRecord(2, null));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testDuplicateJsonProperties",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testConstructorRuns() {\r\n    record LocalRecord(String s) {\r\n\r\n        LocalRecord {\r\n            s \u003d \"custom-\" + s;\r\n        }\r\n    }\r\n    LocalRecord deserialized \u003d gson.fromJson(\"{\\\"s\\\": null}\", LocalRecord.class);\r\n    assertThat(deserialized).isEqualTo(new LocalRecord(null));\r\n    assertThat(deserialized.s()).isEqualTo(\"custom-null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testConstructorRuns",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior when the canonical constructor throws an exception\r\n */\r\n@Test\r\n@SuppressWarnings(\"StaticAssignmentOfThrowable\")\r\npublic void testThrowingConstructor() {\r\n    record LocalRecord(String s) {\r\n\r\n        static final RuntimeException thrownException \u003d new RuntimeException(\"Custom exception\");\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        LocalRecord {\r\n            throw thrownException;\r\n        }\r\n    }\r\n    try {\r\n        gson.fromJson(\"{\\\"s\\\":\\\"value\\\"}\", LocalRecord.class);\r\n        fail();\r\n    }// TODO: Adjust this once Gson throws more specific exception type\r\n     catch (RuntimeException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Failed to invoke constructor \u0027\" + LocalRecord.class.getName() + \"(String)\u0027 with args [value]\");\r\n        assertThat(e).hasCauseThat().isSameInstanceAs(LocalRecord.thrownException);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testThrowingConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String s() {\r\n    return \"accessor-value\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "s",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAccessorIsCalled() {\r\n    record LocalRecord(String s) {\r\n\r\n        @Override\r\n        public String s() {\r\n            return \"accessor-value\";\r\n        }\r\n    }\r\n    assertThat(gson.toJson(new LocalRecord(null))).isEqualTo(\"{\\\"s\\\":\\\"accessor-value\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testAccessorIsCalled",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String s() {\r\n    throw thrownException;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "s",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior when a record accessor method throws an exception\r\n */\r\n@Test\r\n@SuppressWarnings(\"StaticAssignmentOfThrowable\")\r\npublic void testThrowingAccessor() {\r\n    record LocalRecord(String s) {\r\n\r\n        static final RuntimeException thrownException \u003d new RuntimeException(\"Custom exception\");\r\n\r\n        @Override\r\n        public String s() {\r\n            throw thrownException;\r\n        }\r\n    }\r\n    try {\r\n        gson.toJson(new LocalRecord(\"a\"));\r\n        fail();\r\n    } catch (JsonIOException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Accessor method \u0027\" + LocalRecord.class.getName() + \"#s()\u0027 threw exception\");\r\n        assertThat(e).hasCauseThat().isSameInstanceAs(LocalRecord.thrownException);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testThrowingAccessor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior for a record without components\r\n */\r\n@Test\r\npublic void testEmptyRecord() {\r\n    record EmptyRecord() {\r\n    }\r\n    assertThat(gson.toJson(new EmptyRecord())).isEqualTo(\"{}\");\r\n    assertThat(gson.fromJson(\"{}\", EmptyRecord.class)).isEqualTo(new EmptyRecord());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testEmptyRecord",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior when {@code null} is serialized / deserialized as record value;\r\n * basically makes sure the adapter is \u0027null-safe\u0027\r\n */\r\n@Test\r\npublic void testRecordNull() throws IOException {\r\n    record LocalRecord(int i) {\r\n    }\r\n    TypeAdapter\u003cLocalRecord\u003e adapter \u003d gson.getAdapter(LocalRecord.class);\r\n    assertThat(adapter.toJson(null)).isEqualTo(\"null\");\r\n    assertThat(adapter.fromJson(\"null\")).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testRecordNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveDefaultValues() {\r\n    RecordWithPrimitives expected \u003d new RecordWithPrimitives(\"s\", (byte) 0, (short) 0, 0, 0, 0, 0, \u0027\\0\u0027, false);\r\n    assertThat(gson.fromJson(\"{\u0027aString\u0027: \u0027s\u0027}\", RecordWithPrimitives.class)).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testPrimitiveDefaultValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveJsonNullValue() {\r\n    String s \u003d \"{\u0027aString\u0027: \u0027s\u0027, \u0027aByte\u0027: null, \u0027aShort\u0027: 0}\";\r\n    var e \u003d assertThrows(JsonParseException.class, () -\u003e gson.fromJson(s, RecordWithPrimitives.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"null is not allowed as value for record component \u0027aByte\u0027 of primitive type; at path $.aByte\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testPrimitiveJsonNullValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Byte read(JsonReader in) throws IOException {\r\n    in.skipValue();\r\n    // Always return null\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Byte"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Byte value) {\r\n    throw new AssertionError(\"not needed for test\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Byte"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior when JSON contains non-null value, but custom adapter returns null\r\n * for primitive component\r\n */\r\n@Test\r\npublic void testPrimitiveAdapterNullValue() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(byte.class, new TypeAdapter\u003cByte\u003e() {\r\n\r\n        @Override\r\n        public Byte read(JsonReader in) throws IOException {\r\n            in.skipValue();\r\n            // Always return null\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Byte value) {\r\n            throw new AssertionError(\"not needed for test\");\r\n        }\r\n    }).create();\r\n    String s \u003d \"{\u0027aString\u0027: \u0027s\u0027, \u0027aByte\u0027: 0}\";\r\n    var exception \u003d assertThrows(JsonParseException.class, () -\u003e gson.fromJson(s, RecordWithPrimitives.class));\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"null is not allowed as value for record component \u0027aByte\u0027 of primitive type; at path $.aByte\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testPrimitiveAdapterNullValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior when value of Object component is missing; should default to null\r\n */\r\n@Test\r\npublic void testObjectDefaultValue() {\r\n    record LocalRecord(String s, int i) {\r\n    }\r\n    assertThat(gson.fromJson(\"{\\\"i\\\":1}\", LocalRecord.class)).isEqualTo(new LocalRecord(null, 1));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testObjectDefaultValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests serialization of a record with {@code static} field.\r\n *\r\n * \u003cp\u003eImportant: It is not documented that this is officially supported; this\r\n * test just checks the current behavior.\r\n */\r\n@Test\r\npublic void testStaticFieldSerialization() {\r\n    // By default Gson should ignore static fields\r\n    assertThat(gson.toJson(new RecordWithStaticField())).isEqualTo(\"{}\");\r\n    Gson gson \u003d new GsonBuilder().// Include static fields\r\n    excludeFieldsWithModifiers(0).create();\r\n    String json \u003d gson.toJson(new RecordWithStaticField());\r\n    assertThat(json).isEqualTo(\"{\\\"s\\\":\\\"initial\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testStaticFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests deserialization of a record with {@code static} field.\r\n *\r\n * \u003cp\u003eImportant: It is not documented that this is officially supported; this\r\n * test just checks the current behavior.\r\n */\r\n@Test\r\npublic void testStaticFieldDeserialization() {\r\n    // By default Gson should ignore static fields\r\n    gson.fromJson(\"{\\\"s\\\":\\\"custom\\\"}\", RecordWithStaticField.class);\r\n    assertThat(RecordWithStaticField.s).isEqualTo(\"initial\");\r\n    Gson gson \u003d new GsonBuilder().// Include static fields\r\n    excludeFieldsWithModifiers(0).create();\r\n    String oldValue \u003d RecordWithStaticField.s;\r\n    try {\r\n        RecordWithStaticField obj \u003d gson.fromJson(\"{\\\"s\\\":\\\"custom\\\"}\", RecordWithStaticField.class);\r\n        assertThat(obj).isNotNull();\r\n        // Currently record deserialization always ignores static fields\r\n        assertThat(RecordWithStaticField.s).isEqualTo(\"initial\");\r\n    } finally {\r\n        RecordWithStaticField.s \u003d oldValue;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testStaticFieldDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExposeAnnotation() {\r\n    record RecordWithExpose(@Expose int a, int b) {\r\n    }\r\n    Gson gson \u003d new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();\r\n    String json \u003d gson.toJson(new RecordWithExpose(1, 2));\r\n    assertThat(json).isEqualTo(\"{\\\"a\\\":1}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testExposeAnnotation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipField(FieldAttributes f) {\r\n    return f.getName().equals(\"a\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "shouldSkipField",
      "parameterTypes": [
        "FieldAttributes"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n    return clazz \u003d\u003d double.class;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "shouldSkipClass",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFieldExclusionStrategy() {\r\n    record LocalRecord(int a, int b, double c) {\r\n    }\r\n    Gson gson \u003d new GsonBuilder().setExclusionStrategies(new ExclusionStrategy() {\r\n\r\n        @Override\r\n        public boolean shouldSkipField(FieldAttributes f) {\r\n            return f.getName().equals(\"a\");\r\n        }\r\n\r\n        @Override\r\n        public boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n            return clazz \u003d\u003d double.class;\r\n        }\r\n    }).create();\r\n    assertThat(gson.toJson(new LocalRecord(1, 2, 3.0))).isEqualTo(\"{\\\"b\\\":2}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testFieldExclusionStrategy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n    return \"deserializer-\" + json.getAsString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"serializer-\" + src);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "serialize",
      "parameterTypes": [
        "String",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonAdapterAnnotation() {\r\n    record Adapter() implements JsonSerializer\u003cString\u003e, JsonDeserializer\u003cString\u003e {\r\n\r\n        @Override\r\n        public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n            return \"deserializer-\" + json.getAsString();\r\n        }\r\n\r\n        @Override\r\n        public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"serializer-\" + src);\r\n        }\r\n    }\r\n    record LocalRecord(@JsonAdapter(Adapter.class) String s) {\r\n    }\r\n    assertThat(gson.toJson(new LocalRecord(\"a\"))).isEqualTo(\"{\\\"s\\\":\\\"serializer-a\\\"}\");\r\n    assertThat(gson.fromJson(\"{\\\"s\\\":\\\"a\\\"}\", LocalRecord.class)).isEqualTo(new LocalRecord(\"deserializer-a\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testJsonAdapterAnnotation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassReflectionFilter() {\r\n    record Allowed(int a) {\r\n    }\r\n    record Blocked(int b) {\r\n    }\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(c -\u003e c \u003d\u003d Allowed.class ? FilterResult.ALLOW : FilterResult.BLOCK_ALL).create();\r\n    String json \u003d gson.toJson(new Allowed(1));\r\n    assertThat(json).isEqualTo(\"{\\\"a\\\":1}\");\r\n    var exception \u003d assertThrows(JsonIOException.class, () -\u003e gson.toJson(new Blocked(1)));\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class \" + Blocked.class.getName() + \". Register a TypeAdapter for this type or adjust the access filter.\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testClassReflectionFilter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReflectionFilterBlockInaccessible() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(c -\u003e FilterResult.BLOCK_INACCESSIBLE).create();\r\n    var exception \u003d assertThrows(JsonIOException.class, () -\u003e gson.toJson(new PrivateRecord(1)));\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"Constructor \u0027com.google.gson.functional.Java17RecordTest$PrivateRecord(int)\u0027 is not accessible and\" + \" ReflectionAccessFilter does not permit making it accessible. Register a TypeAdapter for the declaring\" + \" type, adjust the access filter or increase the visibility of the element and its declaring type.\");\r\n    exception \u003d assertThrows(JsonIOException.class, () -\u003e gson.fromJson(\"{}\", PrivateRecord.class));\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"Constructor \u0027com.google.gson.functional.Java17RecordTest$PrivateRecord(int)\u0027 is not accessible and\" + \" ReflectionAccessFilter does not permit making it accessible. Register a TypeAdapter for the declaring\" + \" type, adjust the access filter or increase the visibility of the element and its declaring type.\");\r\n    assertThat(gson.toJson(new PublicRecord(1))).isEqualTo(\"{\\\"i\\\":1}\");\r\n    assertThat(gson.fromJson(\"{\\\"i\\\":2}\", PublicRecord.class)).isEqualTo(new PublicRecord(2));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testReflectionFilterBlockInaccessible",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior when {@code java.lang.Record} is used as type for serialization\r\n * and deserialization.\r\n */\r\n@Test\r\npublic void testRecordBaseClass() {\r\n    record LocalRecord(int i) {\r\n    }\r\n    assertThat(gson.toJson(new LocalRecord(1), Record.class)).isEqualTo(\"{}\");\r\n    var exception \u003d assertThrows(JsonIOException.class, () -\u003e gson.fromJson(\"{}\", Record.class));\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"Abstract classes can\u0027t be instantiated! Adjust the R8 configuration or register an InstanceCreator\" + \" or a TypeAdapter for this type. Class name: java.lang.Record\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#r8-abstract-class\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.Java17RecordTest",
      "methodName": "testRecordBaseClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilConcurrentAtomicTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAtomicBoolean() {\r\n    AtomicBoolean target \u003d gson.fromJson(\"true\", AtomicBoolean.class);\r\n    assertThat(target.get()).isTrue();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"true\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilConcurrentAtomicTest",
      "methodName": "testAtomicBoolean",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAtomicInteger() {\r\n    AtomicInteger target \u003d gson.fromJson(\"10\", AtomicInteger.class);\r\n    assertThat(target.get()).isEqualTo(10);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"10\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilConcurrentAtomicTest",
      "methodName": "testAtomicInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAtomicLong() {\r\n    AtomicLong target \u003d gson.fromJson(\"10\", AtomicLong.class);\r\n    assertThat(target.get()).isEqualTo(10);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"10\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilConcurrentAtomicTest",
      "methodName": "testAtomicLong",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAtomicLongWithStringSerializationPolicy() {\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\r\n    AtomicLongHolder target \u003d gson.fromJson(\"{\u0027value\u0027:\u002710\u0027}\", AtomicLongHolder.class);\r\n    assertThat(target.value.get()).isEqualTo(10);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"{\\\"value\\\":\\\"10\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilConcurrentAtomicTest",
      "methodName": "testAtomicLongWithStringSerializationPolicy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAtomicIntegerArray() {\r\n    AtomicIntegerArray target \u003d gson.fromJson(\"[10, 13, 14]\", AtomicIntegerArray.class);\r\n    assertThat(target.length()).isEqualTo(3);\r\n    assertThat(target.get(0)).isEqualTo(10);\r\n    assertThat(target.get(1)).isEqualTo(13);\r\n    assertThat(target.get(2)).isEqualTo(14);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"[10,13,14]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilConcurrentAtomicTest",
      "methodName": "testAtomicIntegerArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAtomicLongArray() {\r\n    AtomicLongArray target \u003d gson.fromJson(\"[10, 13, 14]\", AtomicLongArray.class);\r\n    assertThat(target.length()).isEqualTo(3);\r\n    assertThat(target.get(0)).isEqualTo(10);\r\n    assertThat(target.get(1)).isEqualTo(13);\r\n    assertThat(target.get(2)).isEqualTo(14);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"[10,13,14]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilConcurrentAtomicTest",
      "methodName": "testAtomicLongArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAtomicLongArrayWithStringSerializationPolicy() {\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\r\n    AtomicLongArray target \u003d gson.fromJson(\"[\u002710\u0027, \u002713\u0027, \u002714\u0027]\", AtomicLongArray.class);\r\n    assertThat(target.length()).isEqualTo(3);\r\n    assertThat(target.get(0)).isEqualTo(10);\r\n    assertThat(target.get(1)).isEqualTo(13);\r\n    assertThat(target.get(2)).isEqualTo(14);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"[\\\"10\\\",\\\"13\\\",\\\"14\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilConcurrentAtomicTest",
      "methodName": "testAtomicLongArrayWithStringSerializationPolicy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCurrency() {\r\n    CurrencyHolder target \u003d gson.fromJson(\"{\u0027value\u0027:\u0027USD\u0027}\", CurrencyHolder.class);\r\n    assertThat(target.value.getCurrencyCode()).isEqualTo(\"USD\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).isEqualTo(\"{\\\"value\\\":\\\"USD\\\"}\");\r\n    // null handling\r\n    target \u003d gson.fromJson(\"{\u0027value\u0027:null}\", CurrencyHolder.class);\r\n    assertThat(target.value).isNull();\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilTest",
      "methodName": "testCurrency",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testProperties() {\r\n    Properties props \u003d gson.fromJson(\"{\u0027a\u0027:\u0027v1\u0027,\u0027b\u0027:\u0027v2\u0027}\", Properties.class);\r\n    assertThat(props.getProperty(\"a\")).isEqualTo(\"v1\");\r\n    assertThat(props.getProperty(\"b\")).isEqualTo(\"v2\");\r\n    String json \u003d gson.toJson(props);\r\n    assertThat(json).contains(\"\\\"a\\\":\\\"v1\\\"\");\r\n    assertThat(json).contains(\"\\\"b\\\":\\\"v2\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JavaUtilTest",
      "methodName": "testProperties",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonAdapterInvoked() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new A(\"bar\"));\r\n    assertThat(json).isEqualTo(\"\\\"jsonAdapter\\\"\");\r\n    // Also invoke the JsonAdapter javadoc sample\r\n    json \u003d gson.toJson(new User(\"Inderjeet\", \"Singh\"));\r\n    assertThat(json).isEqualTo(\"{\\\"name\\\":\\\"Inderjeet Singh\\\"}\");\r\n    User user \u003d gson.fromJson(\"{\u0027name\u0027:\u0027Joel Leitch\u0027}\", User.class);\r\n    assertThat(user.firstName).isEqualTo(\"Joel\");\r\n    assertThat(user.lastName).isEqualTo(\"Leitch\");\r\n    json \u003d gson.toJson(Foo.BAR);\r\n    assertThat(json).isEqualTo(\"\\\"bar\\\"\");\r\n    Foo baz \u003d gson.fromJson(\"\\\"baz\\\"\", Foo.class);\r\n    assertThat(baz).isEqualTo(Foo.BAZ);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testJsonAdapterInvoked",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonAdapterFactoryInvoked() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new C(\"bar\"));\r\n    assertThat(json).isEqualTo(\"\\\"jsonAdapterFactory\\\"\");\r\n    C c \u003d gson.fromJson(\"\\\"bar\\\"\", C.class);\r\n    assertThat(c.value).isEqualTo(\"jsonAdapterFactory\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testJsonAdapterFactoryInvoked",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, A value) throws IOException {\r\n    out.value(\"registeredAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "A"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic A read(JsonReader in) throws IOException {\r\n    return new A(in.nextString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "A"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRegisteredAdapterOverridesJsonAdapter() {\r\n    TypeAdapter\u003cA\u003e typeAdapter \u003d new TypeAdapter\u003cA\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, A value) throws IOException {\r\n            out.value(\"registeredAdapter\");\r\n        }\r\n\r\n        @Override\r\n        public A read(JsonReader in) throws IOException {\r\n            return new A(in.nextString());\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(A.class, typeAdapter).create();\r\n    String json \u003d gson.toJson(new A(\"abcd\"));\r\n    assertThat(json).isEqualTo(\"\\\"registeredAdapter\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testRegisteredAdapterOverridesJsonAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(A src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"registeredSerializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "serialize",
      "parameterTypes": [
        "A",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * The serializer overrides field adapter, but for deserializer the fieldAdapter is used.\r\n */\r\n@Test\r\npublic void testRegisteredSerializerOverridesJsonAdapter() {\r\n    JsonSerializer\u003cA\u003e serializer \u003d new JsonSerializer\u003cA\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(A src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"registeredSerializer\");\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(A.class, serializer).create();\r\n    String json \u003d gson.toJson(new A(\"abcd\"));\r\n    assertThat(json).isEqualTo(\"\\\"registeredSerializer\\\"\");\r\n    A target \u003d gson.fromJson(\"abcd\", A.class);\r\n    assertThat(target.value).isEqualTo(\"jsonAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testRegisteredSerializerOverridesJsonAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic A deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return new A(\"registeredDeserializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "A"
    }
  },
  {
    "sourceCode": "/**\r\n * The deserializer overrides Json adapter, but for serializer the jsonAdapter is used.\r\n */\r\n@Test\r\npublic void testRegisteredDeserializerOverridesJsonAdapter() {\r\n    JsonDeserializer\u003cA\u003e deserializer \u003d new JsonDeserializer\u003cA\u003e() {\r\n\r\n        @Override\r\n        public A deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return new A(\"registeredDeserializer\");\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(A.class, deserializer).create();\r\n    String json \u003d gson.toJson(new A(\"abcd\"));\r\n    assertThat(json).isEqualTo(\"\\\"jsonAdapter\\\"\");\r\n    A target \u003d gson.fromJson(\"abcd\", A.class);\r\n    assertThat(target.value).isEqualTo(\"registeredDeserializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testRegisteredDeserializerOverridesJsonAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIncorrectTypeAdapterFails() {\r\n    try {\r\n        String json \u003d new Gson().toJson(new ClassWithIncorrectJsonAdapter(\"bar\"));\r\n        fail(json);\r\n    } catch (ClassCastException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testIncorrectTypeAdapterFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSuperclassTypeAdapterNotInvoked() {\r\n    String json \u003d new Gson().toJson(new B(\"bar\"));\r\n    assertThat(json).doesNotContain(\"jsonAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testSuperclassTypeAdapterNotInvoked",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullSafeObject() {\r\n    Gson gson \u003d new Gson();\r\n    NullableClass fromJson \u003d gson.fromJson(\"null\", NullableClass.class);\r\n    assertThat(fromJson).isNull();\r\n    fromJson \u003d gson.fromJson(\"\\\"ignored\\\"\", NullableClass.class);\r\n    assertThat(fromJson).isNotNull();\r\n    String json \u003d gson.toJson(null, NullableClass.class);\r\n    assertThat(json).isEqualTo(\"null\");\r\n    json \u003d gson.toJson(new NullableClass());\r\n    assertThat(json).isEqualTo(\"\\\"nullable\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testNullSafeObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior when a {@link TypeAdapterFactory} registered with {@code @JsonAdapter} returns\r\n * {@code null}, indicating that it cannot handle the type and Gson should try a different factory\r\n * instead.\r\n */\r\n@Test\r\npublic void testFactoryReturningNull() {\r\n    Gson gson \u003d new Gson();\r\n    assertThat(gson.fromJson(\"null\", WithNullReturningFactory.class)).isNull();\r\n    assertThat(gson.toJson(null, WithNullReturningFactory.class)).isEqualTo(\"null\");\r\n    TypeToken\u003cWithNullReturningFactory\u003cString\u003e\u003e stringTypeArg \u003d new TypeToken\u003cWithNullReturningFactory\u003cString\u003e\u003e() {\r\n    };\r\n    WithNullReturningFactory\u003c?\u003e deserialized \u003d gson.fromJson(\"\\\"a\\\"\", stringTypeArg);\r\n    assertThat(deserialized.t).isEqualTo(\"custom-read:a\");\r\n    assertThat(gson.fromJson(\"null\", stringTypeArg)).isNull();\r\n    assertThat(gson.toJson(new WithNullReturningFactory\u003c\u003e(\"b\"), stringTypeArg.getType())).isEqualTo(\"\\\"custom-write:b\\\"\");\r\n    assertThat(gson.toJson(null, stringTypeArg.getType())).isEqualTo(\"null\");\r\n    // Factory should return `null` for this type and Gson should fall back to reflection-based adapter\r\n    TypeToken\u003cWithNullReturningFactory\u003cInteger\u003e\u003e numberTypeArg \u003d new TypeToken\u003cWithNullReturningFactory\u003cInteger\u003e\u003e() {\r\n    };\r\n    deserialized \u003d gson.fromJson(\"{\\\"t\\\":1}\", numberTypeArg);\r\n    assertThat(deserialized.t).isEqualTo(1);\r\n    assertThat(gson.toJson(new WithNullReturningFactory\u003c\u003e(2), numberTypeArg.getType())).isEqualTo(\"{\\\"t\\\":2}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testFactoryReturningNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, WithNullReturningFactory\u003cString\u003e value) throws IOException {\r\n    out.value(\"custom-write:\" + value.t);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithNullReturningFactory.NullReturningFactory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "WithNullReturningFactory\u003cString\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic WithNullReturningFactory\u003cString\u003e read(JsonReader in) throws IOException {\r\n    return new WithNullReturningFactory\u003c\u003e(\"custom-read:\" + in.nextString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithNullReturningFactory.NullReturningFactory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "WithNullReturningFactory\u003cString\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    // Don\u0027t handle raw (non-parameterized) type\r\n    if (type.getType() instanceof Class) {\r\n        return null;\r\n    }\r\n    ParameterizedType parameterizedType \u003d (ParameterizedType) type.getType();\r\n    // Makes this test a bit more realistic by only conditionally returning null (instead of always)\r\n    if (parameterizedType.getActualTypeArguments()[0] !\u003d String.class) {\r\n        return null;\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cT\u003e adapter \u003d (TypeAdapter\u003cT\u003e) new TypeAdapter\u003cWithNullReturningFactory\u003cString\u003e\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, WithNullReturningFactory\u003cString\u003e value) throws IOException {\r\n            out.value(\"custom-write:\" + value.t);\r\n        }\r\n\r\n        @Override\r\n        public WithNullReturningFactory\u003cString\u003e read(JsonReader in) throws IOException {\r\n            return new WithNullReturningFactory\u003c\u003e(\"custom-read:\" + in.nextString());\r\n        }\r\n    };\r\n    return adapter;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithNullReturningFactory.NullReturningFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, A value) throws IOException {\r\n    out.value(\"jsonAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.A.JsonAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "A"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic A read(JsonReader in) throws IOException {\r\n    in.nextString();\r\n    return new A(\"jsonAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.A.JsonAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "A"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    out.value(\"jsonAdapterFactory\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.C.JsonAdapterFactory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    in.nextString();\r\n    return (T) new C(\"jsonAdapterFactory\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.C.JsonAdapterFactory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, final TypeToken\u003cT\u003e type) {\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            out.value(\"jsonAdapterFactory\");\r\n        }\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            in.nextString();\r\n            return (T) new C(\"jsonAdapterFactory\");\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.C.JsonAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, User user) throws IOException {\r\n    // implement write: combine firstName and lastName into name\r\n    out.beginObject();\r\n    out.name(\"name\");\r\n    out.value(user.firstName + \" \" + user.lastName);\r\n    out.endObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.UserJsonAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "User"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic User read(JsonReader in) throws IOException {\r\n    // implement read: split name into firstName and lastName\r\n    in.beginObject();\r\n    in.nextName();\r\n    List\u003cString\u003e nameParts \u003d Splitter.on(\" \").splitToList(in.nextString());\r\n    in.endObject();\r\n    return new User(nameParts.get(0), nameParts.get(1));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.UserJsonAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "User"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, NullableClass value) throws IOException {\r\n    out.value(\"nullable\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.NullableClassJsonAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "NullableClass"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic NullableClass read(JsonReader in) throws IOException {\r\n    in.nextString();\r\n    return new NullableClass();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.NullableClassJsonAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "NullableClass"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Foo value) throws IOException {\r\n    out.value(value.name().toLowerCase(Locale.US));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.FooJsonAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Foo"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Foo read(JsonReader in) throws IOException {\r\n    return Foo.valueOf(in.nextString().toUpperCase(Locale.US));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.FooJsonAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Foo"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIncorrectJsonAdapterType() {\r\n    try {\r\n        new Gson().toJson(new D());\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testIncorrectJsonAdapterType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Verifies that {@link TypeAdapterFactory} specified by {@code @JsonAdapter} can\r\n * call {@link Gson#getDelegateAdapter} without any issues, despite the factory\r\n * not being directly registered on Gson.\r\n */\r\n@Test\r\npublic void testDelegatingAdapterFactory() {\r\n    @SuppressWarnings(\"unchecked\")\r\n    WithDelegatingFactory\u003cString\u003e deserialized \u003d new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    deserialized \u003d new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", new TypeToken\u003cWithDelegatingFactory\u003cString\u003e\u003e() {\r\n    });\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelegatingFactory\u003cString\u003e serialized \u003d new WithDelegatingFactory\u003c\u003e(\"se\");\r\n    assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testDelegatingAdapterFactory",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    // Perform custom deserialization\r\n    in.beginObject();\r\n    assertThat(in.nextName()).isEqualTo(\"custom\");\r\n    T t \u003d delegate.read(in);\r\n    in.endObject();\r\n    return t;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithDelegatingFactory.Factory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    // Perform custom serialization\r\n    out.beginObject();\r\n    out.name(\"custom\");\r\n    delegate.write(out, value);\r\n    out.endObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithDelegatingFactory.Factory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    if (type.getRawType() !\u003d WithDelegatingFactory.class) {\r\n        return null;\r\n    }\r\n    TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            // Perform custom deserialization\r\n            in.beginObject();\r\n            assertThat(in.nextName()).isEqualTo(\"custom\");\r\n            T t \u003d delegate.read(in);\r\n            in.endObject();\r\n            return t;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            // Perform custom serialization\r\n            out.beginObject();\r\n            out.name(\"custom\");\r\n            delegate.write(out, value);\r\n            out.endObject();\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithDelegatingFactory.Factory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Similar to {@link #testDelegatingAdapterFactory}, except that the delegate is not\r\n * looked up in {@code create} but instead in the adapter methods.\r\n */\r\n@Test\r\npublic void testDelegatingAdapterFactory_Delayed() {\r\n    WithDelayedDelegatingFactory deserialized \u003d new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelayedDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelayedDelegatingFactory serialized \u003d new WithDelayedDelegatingFactory(\"se\");\r\n    assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testDelegatingAdapterFactory_Delayed",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// suppress Error Prone warning; should be clear that `Factory` refers to enclosing class\r\n@SuppressWarnings(\"SameNameButDifferent\")\r\nprivate TypeAdapter\u003cT\u003e delegate() {\r\n    return gson.getDelegateAdapter(Factory.this, type);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithDelayedDelegatingFactory.Factory",
      "methodName": "delegate",
      "parameterTypes": [],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    // Perform custom deserialization\r\n    in.beginObject();\r\n    assertThat(in.nextName()).isEqualTo(\"custom\");\r\n    T t \u003d delegate().read(in);\r\n    in.endObject();\r\n    return t;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithDelayedDelegatingFactory.Factory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    // Perform custom serialization\r\n    out.beginObject();\r\n    out.name(\"custom\");\r\n    delegate().write(out, value);\r\n    out.endObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithDelayedDelegatingFactory.Factory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        // suppress Error Prone warning; should be clear that `Factory` refers to enclosing class\r\n        @SuppressWarnings(\"SameNameButDifferent\")\r\n        private TypeAdapter\u003cT\u003e delegate() {\r\n            return gson.getDelegateAdapter(Factory.this, type);\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            // Perform custom deserialization\r\n            in.beginObject();\r\n            assertThat(in.nextName()).isEqualTo(\"custom\");\r\n            T t \u003d delegate().read(in);\r\n            in.endObject();\r\n            return t;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            // Perform custom serialization\r\n            out.beginObject();\r\n            out.name(\"custom\");\r\n            delegate().write(out, value);\r\n            out.endObject();\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithDelayedDelegatingFactory.Factory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior of {@link Gson#getDelegateAdapter} when \u003ci\u003edifferent\u003c/i\u003e instances of the same\r\n * factory class are used; one registered on the {@code GsonBuilder} and the other implicitly\r\n * through {@code @JsonAdapter}.\r\n */\r\n@Test\r\npublic void testDelegating_SameFactoryClass() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(new WithDelegatingFactory.Factory()).create();\r\n    // Should use both factories, and therefore have `{\"custom\": ... }` twice\r\n    WithDelegatingFactory\u003c?\u003e deserialized \u003d gson.fromJson(\"{\\\"custom\\\":{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelegatingFactory\u003cString\u003e serialized \u003d new WithDelegatingFactory\u003c\u003e(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testDelegating_SameFactoryClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior of {@link Gson#getDelegateAdapter} when the \u003ci\u003esame\u003c/i\u003e instance of a factory\r\n * is used (through {@link InstanceCreator}).\r\n *\r\n * \u003cp\u003e\u003cb\u003eImportant:\u003c/b\u003e This situation is likely a rare corner case; the purpose of this test is\r\n * to verify that Gson behaves reasonable, mainly that it does not cause a {@link StackOverflowError}\r\n * due to infinite recursion. This test is not intended to dictate an expected behavior.\r\n */\r\n@Test\r\npublic void testDelegating_SameFactoryInstance() {\r\n    WithDelegatingFactory.Factory factory \u003d new WithDelegatingFactory.Factory();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(factory).// Always provides same instance for factory\r\n    registerTypeAdapter(WithDelegatingFactory.Factory.class, (InstanceCreator\u003c?\u003e) type -\u003e factory).create();\r\n    // Current Gson.getDelegateAdapter implementation cannot tell when call is related to @JsonAdapter\r\n    // or not, it can only work based on the `skipPast` factory, so if the same factory instance is used\r\n    // the one registered with `GsonBuilder.registerTypeAdapterFactory` actually skips past the @JsonAdapter\r\n    // one, so the JSON string is `{\"custom\": ...}` instead of `{\"custom\":{\"custom\":...}}`\r\n    WithDelegatingFactory\u003c?\u003e deserialized \u003d gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelegatingFactory\u003cString\u003e serialized \u003d new WithDelegatingFactory\u003c\u003e(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testDelegating_SameFactoryInstance",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String read(JsonReader in) throws IOException {\r\n    return in.nextString() + \"-str\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, String value) throws IOException {\r\n    out.value(value + \"-str\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior of {@link Gson#getDelegateAdapter} when \u003ci\u003edifferent\u003c/i\u003e instances of the same\r\n * factory class are used; one specified with {@code @JsonAdapter} on a class, and the other specified\r\n * with {@code @JsonAdapter} on a field of that class.\r\n *\r\n * \u003cp\u003e\u003cb\u003eImportant:\u003c/b\u003e This situation is likely a rare corner case; the purpose of this test is\r\n * to verify that Gson behaves reasonable, mainly that it does not cause a {@link StackOverflowError}\r\n * due to infinite recursion. This test is not intended to dictate an expected behavior.\r\n */\r\n@Test\r\npublic void testDelegating_SameFactoryClass_OnClassAndField() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(String.class, new TypeAdapter\u003cString\u003e() {\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            return in.nextString() + \"-str\";\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            out.value(value + \"-str\");\r\n        }\r\n    }).create();\r\n    // Should use both factories, and therefore have `{\"custom\": ... }` once for class and once for the field,\r\n    // and for field also properly delegate to custom String adapter defined above\r\n    WithDelegatingFactoryOnClassAndField deserialized \u003d gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"de\\\"}}}\", WithDelegatingFactoryOnClassAndField.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de-str\");\r\n    WithDelegatingFactoryOnClassAndField serialized \u003d new WithDelegatingFactoryOnClassAndField(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"se-str\\\"}}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testDelegating_SameFactoryClass_OnClassAndField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String read(JsonReader in) throws IOException {\r\n    return in.nextString() + \"-str\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, String value) throws IOException {\r\n    out.value(value + \"-str\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior of {@link Gson#getDelegateAdapter} when the \u003ci\u003esame\u003c/i\u003e instance of a factory\r\n * is used (through {@link InstanceCreator}); specified with {@code @JsonAdapter} on a class,\r\n * and also specified with {@code @JsonAdapter} on a field of that class.\r\n *\r\n * \u003cp\u003e\u003cb\u003eImportant:\u003c/b\u003e This situation is likely a rare corner case; the purpose of this test is\r\n * to verify that Gson behaves reasonable, mainly that it does not cause a {@link StackOverflowError}\r\n * due to infinite recursion. This test is not intended to dictate an expected behavior.\r\n */\r\n@Test\r\npublic void testDelegating_SameFactoryInstance_OnClassAndField() {\r\n    WithDelegatingFactoryOnClassAndField.Factory factory \u003d new WithDelegatingFactoryOnClassAndField.Factory();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(String.class, new TypeAdapter\u003cString\u003e() {\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            return in.nextString() + \"-str\";\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            out.value(value + \"-str\");\r\n        }\r\n    }).// Always provides same instance for factory\r\n    registerTypeAdapter(WithDelegatingFactoryOnClassAndField.Factory.class, (InstanceCreator\u003c?\u003e) type -\u003e factory).create();\r\n    // Because field type (`String`) differs from declaring class, JsonAdapterAnnotationTypeAdapterFactory does\r\n    // not confuse factories and this behaves as expected: Both the declaring class and the field each have\r\n    // `{\"custom\": ...}` and delegation for the field to the custom String adapter defined above works properly\r\n    WithDelegatingFactoryOnClassAndField deserialized \u003d gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"de\\\"}}}\", WithDelegatingFactoryOnClassAndField.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de-str\");\r\n    WithDelegatingFactoryOnClassAndField serialized \u003d new WithDelegatingFactoryOnClassAndField(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"se-str\\\"}}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testDelegating_SameFactoryInstance_OnClassAndField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    // Perform custom deserialization\r\n    in.beginObject();\r\n    assertThat(in.nextName()).isEqualTo(\"custom\");\r\n    T t \u003d delegate.read(in);\r\n    in.endObject();\r\n    return t;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithDelegatingFactoryOnClassAndField.Factory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    // Perform custom serialization\r\n    out.beginObject();\r\n    out.name(\"custom\");\r\n    delegate.write(out, value);\r\n    out.endObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithDelegatingFactoryOnClassAndField.Factory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    TypeAdapter\u003cT\u003e delegate \u003d gson.getDelegateAdapter(this, type);\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            // Perform custom deserialization\r\n            in.beginObject();\r\n            assertThat(in.nextName()).isEqualTo(\"custom\");\r\n            T t \u003d delegate.read(in);\r\n            in.endObject();\r\n            return t;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            // Perform custom serialization\r\n            out.beginObject();\r\n            out.name(\"custom\");\r\n            delegate.write(out, value);\r\n            out.endObject();\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithDelegatingFactoryOnClassAndField.Factory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests usage of {@link JsonSerializer} as {@link JsonAdapter} value\r\n */\r\n@Test\r\npublic void testJsonSerializer() {\r\n    Gson gson \u003d new Gson();\r\n    // Verify that delegate deserializer (reflection deserializer) is used\r\n    WithJsonSerializer deserialized \u003d gson.fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithJsonSerializer.class);\r\n    assertThat(deserialized.f).isEqualTo(\"test\");\r\n    String json \u003d gson.toJson(new WithJsonSerializer());\r\n    // Uses custom serializer which always returns `true`\r\n    assertThat(json).isEqualTo(\"true\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testJsonSerializer",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(WithJsonSerializer src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(true);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithJsonSerializer.Serializer",
      "methodName": "serialize",
      "parameterTypes": [
        "WithJsonSerializer",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests usage of {@link JsonDeserializer} as {@link JsonAdapter} value\r\n */\r\n@Test\r\npublic void testJsonDeserializer() {\r\n    Gson gson \u003d new Gson();\r\n    WithJsonDeserializer deserialized \u003d gson.fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithJsonDeserializer.class);\r\n    // Uses custom deserializer which always uses \"123\" as field value\r\n    assertThat(deserialized.f).isEqualTo(\"123\");\r\n    // Verify that delegate serializer (reflection serializer) is used\r\n    String json \u003d gson.toJson(new WithJsonDeserializer(\"abc\"));\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":\\\"abc\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testJsonDeserializer",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic WithJsonDeserializer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n    return new WithJsonDeserializer(\"123\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.WithJsonDeserializer.Deserializer",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "WithJsonDeserializer"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests creation of the adapter referenced by {@code @JsonAdapter} using an {@link InstanceCreator}.\r\n */\r\n@Test\r\npublic void testAdapterCreatedByInstanceCreator() {\r\n    CreatedByInstanceCreator.Serializer serializer \u003d new CreatedByInstanceCreator.Serializer(\"custom\");\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(CreatedByInstanceCreator.Serializer.class, (InstanceCreator\u003c?\u003e) t -\u003e serializer).create();\r\n    String json \u003d gson.toJson(new CreatedByInstanceCreator());\r\n    assertThat(json).isEqualTo(\"\\\"custom\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testAdapterCreatedByInstanceCreator",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(CreatedByInstanceCreator src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.CreatedByInstanceCreator.Serializer",
      "methodName": "serialize",
      "parameterTypes": [
        "CreatedByInstanceCreator",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests creation of the adapter referenced by {@code @JsonAdapter} using JDK Unsafe.\r\n */\r\n@Test\r\npublic void testAdapterCreatedByJdkUnsafe() {\r\n    String json \u003d new Gson().toJson(new CreatedByJdkUnsafe());\r\n    assertThat(json).isEqualTo(\"false\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest",
      "methodName": "testAdapterCreatedByJdkUnsafe",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(CreatedByJdkUnsafe src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(wasInitialized);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.CreatedByJdkUnsafe.Serializer",
      "methodName": "serialize",
      "parameterTypes": [
        "CreatedByJdkUnsafe",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassAnnotationAdapterTakesPrecedenceOverDefault() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Computer(new User(\"Inderjeet Singh\")));\r\n    assertThat(json).isEqualTo(\"{\\\"user\\\":\\\"UserClassAnnotationAdapter\\\"}\");\r\n    Computer computer \u003d gson.fromJson(\"{\u0027user\u0027:\u0027Inderjeet Singh\u0027}\", Computer.class);\r\n    assertThat(computer.user.name).isEqualTo(\"UserClassAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testClassAnnotationAdapterTakesPrecedenceOverDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassAnnotationAdapterFactoryTakesPrecedenceOverDefault() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Gizmo(new Part(\"Part\")));\r\n    assertThat(json).isEqualTo(\"{\\\"part\\\":\\\"GizmoPartTypeAdapterFactory\\\"}\");\r\n    Gizmo computer \u003d gson.fromJson(\"{\u0027part\u0027:\u0027Part\u0027}\", Gizmo.class);\r\n    assertThat(computer.part.name).isEqualTo(\"GizmoPartTypeAdapterFactory\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testClassAnnotationAdapterFactoryTakesPrecedenceOverDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRegisteredTypeAdapterTakesPrecedenceOverClassAnnotationAdapter() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(User.class, new RegisteredUserAdapter()).create();\r\n    String json \u003d gson.toJson(new Computer(new User(\"Inderjeet Singh\")));\r\n    assertThat(json).isEqualTo(\"{\\\"user\\\":\\\"RegisteredUserAdapter\\\"}\");\r\n    Computer computer \u003d gson.fromJson(\"{\u0027user\u0027:\u0027Inderjeet Singh\u0027}\", Computer.class);\r\n    assertThat(computer.user.name).isEqualTo(\"RegisteredUserAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testRegisteredTypeAdapterTakesPrecedenceOverClassAnnotationAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Part part) {\r\n    throw new AssertionError();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Part"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Part read(JsonReader in) {\r\n    throw new AssertionError();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Part"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFieldAnnotationTakesPrecedenceOverRegisteredTypeAdapter() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Part.class, new TypeAdapter\u003cPart\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Part part) {\r\n            throw new AssertionError();\r\n        }\r\n\r\n        @Override\r\n        public Part read(JsonReader in) {\r\n            throw new AssertionError();\r\n        }\r\n    }).create();\r\n    String json \u003d gson.toJson(new Gadget(new Part(\"screen\")));\r\n    assertThat(json).isEqualTo(\"{\\\"part\\\":\\\"PartJsonFieldAnnotationAdapter\\\"}\");\r\n    Gadget gadget \u003d gson.fromJson(\"{\u0027part\u0027:\u0027screen\u0027}\", Gadget.class);\r\n    assertThat(gadget.part.name).isEqualTo(\"PartJsonFieldAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testFieldAnnotationTakesPrecedenceOverRegisteredTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFieldAnnotationTakesPrecedenceOverClassAnnotation() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Computer2(new User(\"Inderjeet Singh\")));\r\n    assertThat(json).isEqualTo(\"{\\\"user\\\":\\\"UserFieldAnnotationAdapter\\\"}\");\r\n    Computer2 target \u003d gson.fromJson(\"{\u0027user\u0027:\u0027Interjeet Singh\u0027}\", Computer2.class);\r\n    assertThat(target.user.name).isEqualTo(\"UserFieldAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testFieldAnnotationTakesPrecedenceOverClassAnnotation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Part part) throws IOException {\r\n    out.value(\"PartJsonFieldAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.PartJsonFieldAnnotationAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Part"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Part read(JsonReader in) throws IOException {\r\n    String unused \u003d in.nextString();\r\n    return new Part(\"PartJsonFieldAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.PartJsonFieldAnnotationAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Part"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    out.value(\"GizmoPartTypeAdapterFactory\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.GizmoPartTypeAdapterFactory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    String unused \u003d in.nextString();\r\n    return (T) new Part(\"GizmoPartTypeAdapterFactory\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.GizmoPartTypeAdapterFactory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, final TypeToken\u003cT\u003e type) {\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            out.value(\"GizmoPartTypeAdapterFactory\");\r\n        }\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            String unused \u003d in.nextString();\r\n            return (T) new Part(\"GizmoPartTypeAdapterFactory\");\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.GizmoPartTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, User user) throws IOException {\r\n    out.value(\"UserClassAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.UserClassAnnotationAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "User"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic User read(JsonReader in) throws IOException {\r\n    String unused \u003d in.nextString();\r\n    return new User(\"UserClassAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.UserClassAnnotationAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "User"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, User user) throws IOException {\r\n    out.value(\"UserFieldAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.UserFieldAnnotationAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "User"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic User read(JsonReader in) throws IOException {\r\n    String unused \u003d in.nextString();\r\n    return new User(\"UserFieldAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.UserFieldAnnotationAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "User"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, User user) throws IOException {\r\n    out.value(\"RegisteredUserAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.RegisteredUserAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "User"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic User read(JsonReader in) throws IOException {\r\n    String unused \u003d in.nextString();\r\n    return new User(\"RegisteredUserAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.RegisteredUserAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "User"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonAdapterInvokedOnlyForAnnotatedFields() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d \"{\u0027part1\u0027:\u0027name\u0027,\u0027part2\u0027:{\u0027name\u0027:\u0027name2\u0027}}\";\r\n    GadgetWithTwoParts gadget \u003d gson.fromJson(json, GadgetWithTwoParts.class);\r\n    assertThat(gadget.part1.name).isEqualTo(\"PartJsonFieldAnnotationAdapter\");\r\n    assertThat(gadget.part2.name).isEqualTo(\"name2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testJsonAdapterInvokedOnlyForAnnotatedFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonAdapterWrappedInNullSafeAsRequested() {\r\n    Gson gson \u003d new Gson();\r\n    String fromJson \u003d \"{\u0027part\u0027:null}\";\r\n    GadgetWithOptionalPart gadget \u003d gson.fromJson(fromJson, GadgetWithOptionalPart.class);\r\n    assertThat(gadget.part).isNull();\r\n    String toJson \u003d gson.toJson(gadget);\r\n    assertThat(toJson).doesNotContain(\"PartJsonFieldAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testJsonAdapterWrappedInNullSafeAsRequested",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Regression test contributed through https://github.com/google/gson/issues/831\r\n */\r\n@Test\r\npublic void testNonPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new GadgetWithOptionalPart(new Part(\"foo\")));\r\n    assertThat(json).isEqualTo(\"{\\\"part\\\":\\\"PartJsonFieldAnnotationAdapter\\\"}\");\r\n    GadgetWithOptionalPart gadget \u003d gson.fromJson(\"{\u0027part\u0027:\u0027foo\u0027}\", GadgetWithOptionalPart.class);\r\n    assertThat(gadget.part.name).isEqualTo(\"PartJsonFieldAnnotationAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testNonPrimitiveFieldAnnotationTakesPrecedenceOverDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Regression test contributed through https://github.com/google/gson/issues/831\r\n */\r\n@Test\r\npublic void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new GadgetWithPrimitivePart(42));\r\n    assertThat(json).isEqualTo(\"{\\\"part\\\":\\\"42\\\"}\");\r\n    GadgetWithPrimitivePart gadget \u003d gson.fromJson(json, GadgetWithPrimitivePart.class);\r\n    assertThat(gadget.part).isEqualTo(42);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testPrimitiveFieldAnnotationTakesPrecedenceOverDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Long value) throws IOException {\r\n    out.value(value.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.LongToStringTypeAdapterFactory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Long"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Long read(JsonReader in) throws IOException {\r\n    return in.nextLong();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.LongToStringTypeAdapterFactory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Long"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, final TypeToken\u003cT\u003e type) {\r\n    Class\u003c?\u003e cls \u003d type.getRawType();\r\n    if (Long.class.isAssignableFrom(cls)) {\r\n        return (TypeAdapter\u003cT\u003e) ADAPTER;\r\n    } else if (long.class.isAssignableFrom(cls)) {\r\n        return (TypeAdapter\u003cT\u003e) ADAPTER;\r\n    }\r\n    throw new IllegalStateException(\"Non-long field of type \" + type + \" annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.LongToStringTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFieldAnnotationWorksForParameterizedType() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Gizmo2(Arrays.asList(new Part(\"Part\"))));\r\n    assertThat(json).isEqualTo(\"{\\\"part\\\":\\\"GizmoPartTypeAdapterFactory\\\"}\");\r\n    Gizmo2 computer \u003d gson.fromJson(\"{\u0027part\u0027:\u0027Part\u0027}\", Gizmo2.class);\r\n    assertThat(computer.part.get(0).name).isEqualTo(\"GizmoPartTypeAdapterFactory\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testFieldAnnotationWorksForParameterizedType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    out.value(\"GizmoPartTypeAdapterFactory\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.Gizmo2PartTypeAdapterFactory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    String unused \u003d in.nextString();\r\n    return (T) Arrays.asList(new Part(\"GizmoPartTypeAdapterFactory\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.Gizmo2PartTypeAdapterFactory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, final TypeToken\u003cT\u003e type) {\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            out.value(\"GizmoPartTypeAdapterFactory\");\r\n        }\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            String unused \u003d in.nextString();\r\n            return (T) Arrays.asList(new Part(\"GizmoPartTypeAdapterFactory\"));\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.Gizmo2PartTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Verify that {@link JsonAdapter} annotation can overwrite adapters which\r\n * can normally not be overwritten (in this case adapter for {@link JsonElement}).\r\n */\r\n@Test\r\npublic void testOverwriteBuiltIn() {\r\n    BuiltInOverwriting obj \u003d new BuiltInOverwriting();\r\n    obj.f \u003d new JsonPrimitive(true);\r\n    String json \u003d new Gson().toJson(obj);\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":\\\"\" + JsonElementAdapter.SERIALIZED + \"\\\"}\");\r\n    BuiltInOverwriting deserialized \u003d new Gson().fromJson(\"{\\\"f\\\": 2}\", BuiltInOverwriting.class);\r\n    assertThat(deserialized.f).isEqualTo(JsonElementAdapter.DESERIALIZED);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testOverwriteBuiltIn",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement read(JsonReader in) throws IOException {\r\n    in.skipValue();\r\n    return DESERIALIZED;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.JsonElementAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, JsonElement value) throws IOException {\r\n    out.value(SERIALIZED);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.JsonElementAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "JsonElement"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipField(FieldAttributes f) {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "shouldSkipField",
      "parameterTypes": [
        "FieldAttributes"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "shouldSkipClass",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Verify that exclusion strategy preventing serialization has higher precedence than\r\n * {@link JsonAdapter} annotation.\r\n */\r\n@Test\r\npublic void testExcludeSerializePrecedence() {\r\n    Gson gson \u003d new GsonBuilder().addSerializationExclusionStrategy(new ExclusionStrategy() {\r\n\r\n        @Override\r\n        public boolean shouldSkipField(FieldAttributes f) {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n            return false;\r\n        }\r\n    }).create();\r\n    DelegatingAndOverwriting obj \u003d new DelegatingAndOverwriting();\r\n    obj.f \u003d 1;\r\n    obj.f2 \u003d new JsonPrimitive(2);\r\n    obj.f3 \u003d new JsonPrimitive(true);\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n    DelegatingAndOverwriting deserialized \u003d gson.fromJson(\"{\\\"f\\\":1,\\\"f2\\\":2,\\\"f3\\\":3}\", DelegatingAndOverwriting.class);\r\n    assertThat(deserialized.f).isEqualTo(Integer.valueOf(1));\r\n    assertThat(deserialized.f2).isEqualTo(new JsonPrimitive(2));\r\n    // Verify that for deserialization type adapter specified by @JsonAdapter is used\r\n    assertThat(deserialized.f3).isEqualTo(JsonElementAdapter.DESERIALIZED);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testExcludeSerializePrecedence",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipField(FieldAttributes f) {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "shouldSkipField",
      "parameterTypes": [
        "FieldAttributes"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "shouldSkipClass",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Verify that exclusion strategy preventing deserialization has higher precedence than\r\n * {@link JsonAdapter} annotation.\r\n */\r\n@Test\r\npublic void testExcludeDeserializePrecedence() {\r\n    Gson gson \u003d new GsonBuilder().addDeserializationExclusionStrategy(new ExclusionStrategy() {\r\n\r\n        @Override\r\n        public boolean shouldSkipField(FieldAttributes f) {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n            return false;\r\n        }\r\n    }).create();\r\n    DelegatingAndOverwriting obj \u003d new DelegatingAndOverwriting();\r\n    obj.f \u003d 1;\r\n    obj.f2 \u003d new JsonPrimitive(2);\r\n    obj.f3 \u003d new JsonPrimitive(true);\r\n    String json \u003d gson.toJson(obj);\r\n    // Verify that for serialization type adapters specified by @JsonAdapter are used\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":1,\\\"f2\\\":2,\\\"f3\\\":\\\"\" + JsonElementAdapter.SERIALIZED + \"\\\"}\");\r\n    DelegatingAndOverwriting deserialized \u003d gson.fromJson(\"{\\\"f\\\":1,\\\"f2\\\":2,\\\"f3\\\":3}\", DelegatingAndOverwriting.class);\r\n    assertThat(deserialized.f).isNull();\r\n    assertThat(deserialized.f2).isNull();\r\n    assertThat(deserialized.f3).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testExcludeDeserializePrecedence",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipField(FieldAttributes f) {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "shouldSkipField",
      "parameterTypes": [
        "FieldAttributes"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "shouldSkipClass",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * Verify that exclusion strategy preventing serialization and deserialization has\r\n * higher precedence than {@link JsonAdapter} annotation.\r\n *\r\n * \u003cp\u003eThis is a separate test method because {@link ReflectiveTypeAdapterFactory} handles\r\n * this case differently.\r\n */\r\n@Test\r\npublic void testExcludePrecedence() {\r\n    Gson gson \u003d new GsonBuilder().setExclusionStrategies(new ExclusionStrategy() {\r\n\r\n        @Override\r\n        public boolean shouldSkipField(FieldAttributes f) {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n            return false;\r\n        }\r\n    }).create();\r\n    DelegatingAndOverwriting obj \u003d new DelegatingAndOverwriting();\r\n    obj.f \u003d 1;\r\n    obj.f2 \u003d new JsonPrimitive(2);\r\n    obj.f3 \u003d new JsonPrimitive(true);\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n    DelegatingAndOverwriting deserialized \u003d gson.fromJson(\"{\\\"f\\\":1,\\\"f2\\\":2,\\\"f3\\\":3}\", DelegatingAndOverwriting.class);\r\n    assertThat(deserialized.f).isNull();\r\n    assertThat(deserialized.f2).isNull();\r\n    assertThat(deserialized.f3).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testExcludePrecedence",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    return gson.getDelegateAdapter(this, type);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.DelegatingAndOverwriting.DelegatingAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Verifies that {@link TypeAdapterFactory} specified by {@code @JsonAdapter} can\r\n * call {@link Gson#getDelegateAdapter} without any issues, despite the factory\r\n * not being directly registered on Gson.\r\n */\r\n@Test\r\npublic void testDelegatingAdapterFactory() {\r\n    @SuppressWarnings(\"unchecked\")\r\n    WithDelegatingFactory\u003cString\u003e deserialized \u003d new Gson().fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"test-custom\");\r\n    deserialized \u003d new Gson().fromJson(\"{\\\"f\\\":\\\"test\\\"}\", new TypeToken\u003cWithDelegatingFactory\u003cString\u003e\u003e() {\r\n    });\r\n    assertThat(deserialized.f).isEqualTo(\"test-custom\");\r\n    WithDelegatingFactory\u003cString\u003e serialized \u003d new WithDelegatingFactory\u003c\u003e();\r\n    serialized.f \u003d \"value\";\r\n    assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"f\\\":\\\"value-custom\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testDelegatingAdapterFactory",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String read(JsonReader in) throws IOException {\r\n    // Perform custom deserialization\r\n    return delegate.read(in) + \"-custom\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.WithDelegatingFactory.Factory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, String value) throws IOException {\r\n    // Perform custom serialization\r\n    delegate.write(out, value + \"-custom\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.WithDelegatingFactory.Factory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    TypeAdapter\u003cString\u003e delegate \u003d (TypeAdapter\u003cString\u003e) gson.getDelegateAdapter(this, type);\r\n    return (TypeAdapter\u003cT\u003e) new TypeAdapter\u003cString\u003e() {\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            // Perform custom deserialization\r\n            return delegate.read(in) + \"-custom\";\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            // Perform custom serialization\r\n            delegate.write(out, value + \"-custom\");\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.WithDelegatingFactory.Factory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Similar to {@link #testDelegatingAdapterFactory}, except that the delegate is not\r\n * looked up in {@code create} but instead in the adapter methods.\r\n */\r\n@Test\r\npublic void testDelegatingAdapterFactory_Delayed() {\r\n    WithDelayedDelegatingFactory deserialized \u003d new Gson().fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithDelayedDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"test-custom\");\r\n    WithDelayedDelegatingFactory serialized \u003d new WithDelayedDelegatingFactory();\r\n    serialized.f \u003d \"value\";\r\n    assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"f\\\":\\\"value-custom\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testDelegatingAdapterFactory_Delayed",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private TypeAdapter\u003cString\u003e delegate() {\r\n    return (TypeAdapter\u003cString\u003e) gson.getDelegateAdapter(Factory.this, type);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.WithDelayedDelegatingFactory.Factory",
      "methodName": "delegate",
      "parameterTypes": [],
      "returnType": "TypeAdapter\u003cString\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String read(JsonReader in) throws IOException {\r\n    // Perform custom deserialization\r\n    return delegate().read(in) + \"-custom\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.WithDelayedDelegatingFactory.Factory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, String value) throws IOException {\r\n    // Perform custom serialization\r\n    delegate().write(out, value + \"-custom\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.WithDelayedDelegatingFactory.Factory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    return (TypeAdapter\u003cT\u003e) new TypeAdapter\u003cString\u003e() {\r\n\r\n        private TypeAdapter\u003cString\u003e delegate() {\r\n            return (TypeAdapter\u003cString\u003e) gson.getDelegateAdapter(Factory.this, type);\r\n        }\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            // Perform custom deserialization\r\n            return delegate().read(in) + \"-custom\";\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            // Perform custom serialization\r\n            delegate().write(out, value + \"-custom\");\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.WithDelayedDelegatingFactory.Factory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests usage of {@link Gson#getAdapter(TypeToken)} in the {@code create} method of the factory.\r\n * Existing code was using that as workaround because {@link Gson#getDelegateAdapter} previously\r\n * did not work in combination with {@code @JsonAdapter}, see https://github.com/google/gson/issues/1028.\r\n */\r\n@Test\r\npublic void testGetAdapterDelegation() {\r\n    Gson gson \u003d new Gson();\r\n    GetAdapterDelegation deserialized \u003d gson.fromJson(\"{\\\"f\\\":\\\"de\\\"}\", GetAdapterDelegation.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de-custom\");\r\n    String json \u003d gson.toJson(new GetAdapterDelegation(\"se\"));\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":\\\"se-custom\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testGetAdapterDelegation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String read(JsonReader in) throws IOException {\r\n    return delegate.read(in) + \"-custom\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.GetAdapterDelegation.Factory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, String value) throws IOException {\r\n    delegate.write(out, value + \"-custom\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.GetAdapterDelegation.Factory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    // Uses `Gson.getAdapter` instead of `Gson.getDelegateAdapter`\r\n    TypeAdapter\u003cString\u003e delegate \u003d (TypeAdapter\u003cString\u003e) gson.getAdapter(type);\r\n    return (TypeAdapter\u003cT\u003e) new TypeAdapter\u003cString\u003e() {\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            return delegate.read(in) + \"-custom\";\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            delegate.write(out, value + \"-custom\");\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.GetAdapterDelegation.Factory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests usage of {@link JsonSerializer} as {@link JsonAdapter} value on a field\r\n */\r\n@Test\r\npublic void testJsonSerializer() {\r\n    Gson gson \u003d new Gson();\r\n    // Verify that delegate deserializer for List is used\r\n    WithJsonSerializer deserialized \u003d gson.fromJson(\"{\\\"f\\\":[1,2,3]}\", WithJsonSerializer.class);\r\n    assertThat(deserialized.f).isEqualTo(Arrays.asList(1, 2, 3));\r\n    String json \u003d gson.toJson(new WithJsonSerializer());\r\n    // Uses custom serializer which always returns `true`\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":true}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testJsonSerializer",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(List\u003cInteger\u003e src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(true);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.WithJsonSerializer.Serializer",
      "methodName": "serialize",
      "parameterTypes": [
        "List\u003cInteger\u003e",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests usage of {@link JsonDeserializer} as {@link JsonAdapter} value on a field\r\n */\r\n@Test\r\npublic void testJsonDeserializer() {\r\n    Gson gson \u003d new Gson();\r\n    WithJsonDeserializer deserialized \u003d gson.fromJson(\"{\\\"f\\\":[5]}\", WithJsonDeserializer.class);\r\n    // Uses custom deserializer which always returns `[3, 2, 1]`\r\n    assertThat(deserialized.f).isEqualTo(Arrays.asList(3, 2, 1));\r\n    // Verify that delegate serializer for List is used\r\n    String json \u003d gson.toJson(new WithJsonDeserializer(Arrays.asList(4, 5, 6)));\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":[4,5,6]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest",
      "methodName": "testJsonDeserializer",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic List\u003cInteger\u003e deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n    return Arrays.asList(3, 2, 1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.WithJsonDeserializer.Deserializer",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "List\u003cInteger\u003e"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonSerializerDeserializerBasedJsonAdapterOnFields() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Computer(new User(\"Inderjeet Singh\"), null, new User(\"Jesse Wilson\")));\r\n    assertThat(json).isEqualTo(\"{\\\"user1\\\":\\\"UserSerializer\\\",\\\"user3\\\":\\\"UserSerializerDeserializer\\\"}\");\r\n    Computer computer \u003d gson.fromJson(\"{\u0027user2\u0027:\u0027Jesse Wilson\u0027,\u0027user3\u0027:\u0027Jake Wharton\u0027}\", Computer.class);\r\n    assertThat(computer.user2.name).isEqualTo(\"UserDeserializer\");\r\n    assertThat(computer.user3.name).isEqualTo(\"UserSerializerDeserializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest",
      "methodName": "testJsonSerializerDeserializerBasedJsonAdapterOnFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"UserSerializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest.UserSerializer",
      "methodName": "serialize",
      "parameterTypes": [
        "User",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return new User(\"UserDeserializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest.UserDeserializer",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "User"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"UserSerializerDeserializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest.UserSerializerDeserializer",
      "methodName": "serialize",
      "parameterTypes": [
        "User",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return new User(\"UserSerializerDeserializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest.UserSerializerDeserializer",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "User"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonSerializerDeserializerBasedJsonAdapterOnClass() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new Computer2(new User2(\"Inderjeet Singh\")));\r\n    assertThat(json).isEqualTo(\"{\\\"user\\\":\\\"UserSerializerDeserializer2\\\"}\");\r\n    Computer2 computer \u003d gson.fromJson(\"{\u0027user\u0027:\u0027Inderjeet Singh\u0027}\", Computer2.class);\r\n    assertThat(computer.user.name).isEqualTo(\"UserSerializerDeserializer2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest",
      "methodName": "testJsonSerializerDeserializerBasedJsonAdapterOnClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(User2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"UserSerializerDeserializer2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest.UserSerializerDeserializer2",
      "methodName": "serialize",
      "parameterTypes": [
        "User2",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic User2 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return new User2(\"UserSerializerDeserializer2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest.UserSerializerDeserializer2",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "User2"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDifferentJsonAdaptersForGenericFieldsOfSameRawType() {\r\n    Container c \u003d new Container(\"Foo\", 10);\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(c);\r\n    assertThat(json).contains(\"\\\"a\\\":\\\"BaseStringAdapter\\\"\");\r\n    assertThat(json).contains(\"\\\"b\\\":\\\"BaseIntegerAdapter\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest",
      "methodName": "testDifferentJsonAdaptersForGenericFieldsOfSameRawType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Base\u003cString\u003e src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"BaseStringAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest.BaseStringAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "Base\u003cString\u003e",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Base\u003cInteger\u003e src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"BaseIntegerAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest.BaseIntegerAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "Base\u003cInteger\u003e",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic User read(JsonReader in) throws IOException {\r\n    in.nextNull();\r\n    return new User(\"fallback-read\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "User"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, User value) throws IOException {\r\n    assertThat(value).isNull();\r\n    out.value(\"fallback-write\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "User"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonAdapterNullSafe() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(User.class, new TypeAdapter\u003cUser\u003e() {\r\n\r\n        @Override\r\n        public User read(JsonReader in) throws IOException {\r\n            in.nextNull();\r\n            return new User(\"fallback-read\");\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, User value) throws IOException {\r\n            assertThat(value).isNull();\r\n            out.value(\"fallback-write\");\r\n        }\r\n    }).serializeNulls().create();\r\n    String json \u003d gson.toJson(new WithNullSafe(null, null, null, null));\r\n    // Only nullSafe\u003dtrue serializer writes null; for @JsonAdapter with deserializer nullSafe is ignored when serializing\r\n    assertThat(json).isEqualTo(\"{\\\"userS\\\":\\\"UserSerializer\\\",\\\"userSN\\\":null,\\\"userD\\\":\\\"fallback-write\\\",\\\"userDN\\\":\\\"fallback-write\\\"}\");\r\n    WithNullSafe deserialized \u003d gson.fromJson(\"{\\\"userS\\\":null,\\\"userSN\\\":null,\\\"userD\\\":null,\\\"userDN\\\":null}\", WithNullSafe.class);\r\n    // For @JsonAdapter with serializer nullSafe is ignored when deserializing\r\n    assertThat(deserialized.userS.name).isEqualTo(\"fallback-read\");\r\n    assertThat(deserialized.userSN.name).isEqualTo(\"fallback-read\");\r\n    assertThat(deserialized.userD.name).isEqualTo(\"UserDeserializer\");\r\n    assertThat(deserialized.userDN).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonAdapterSerializerDeserializerTest",
      "methodName": "testJsonAdapterNullSafe",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonParserTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseInvalidJson() {\r\n    try {\r\n        gson.fromJson(\"[[]\", Object[].class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonParserTest",
      "methodName": "testParseInvalidJson",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializingCustomTree() {\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"stringValue\", \"foo\");\r\n    obj.addProperty(\"intValue\", 11);\r\n    BagOfPrimitives target \u003d gson.fromJson(obj, BagOfPrimitives.class);\r\n    assertThat(target.intValue).isEqualTo(11);\r\n    assertThat(target.stringValue).isEqualTo(\"foo\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonParserTest",
      "methodName": "testDeserializingCustomTree",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBadTypeForDeserializingCustomTree() {\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"stringValue\", \"foo\");\r\n    obj.addProperty(\"intValue\", 11);\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(obj);\r\n    try {\r\n        gson.fromJson(array, BagOfPrimitives.class);\r\n        fail(\"BagOfPrimitives is not an array\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonParserTest",
      "methodName": "testBadTypeForDeserializingCustomTree",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBadFieldTypeForCustomDeserializerCustomTree() {\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(new JsonPrimitive(\"blah\"));\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"stringValue\", \"foo\");\r\n    obj.addProperty(\"intValue\", 11);\r\n    obj.add(\"longValue\", array);\r\n    try {\r\n        gson.fromJson(obj, BagOfPrimitives.class);\r\n        fail(\"BagOfPrimitives is not an array\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonParserTest",
      "methodName": "testBadFieldTypeForCustomDeserializerCustomTree",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBadFieldTypeForDeserializingCustomTree() {\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(new JsonPrimitive(\"blah\"));\r\n    JsonObject primitive1 \u003d new JsonObject();\r\n    primitive1.addProperty(\"string\", \"foo\");\r\n    primitive1.addProperty(\"intValue\", 11);\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.add(\"primitive1\", primitive1);\r\n    obj.add(\"primitive2\", array);\r\n    try {\r\n        gson.fromJson(obj, Nested.class);\r\n        fail(\"Nested has field BagOfPrimitives which is not an array\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonParserTest",
      "methodName": "testBadFieldTypeForDeserializingCustomTree",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testChangingCustomTreeAndDeserializing() {\r\n    StringReader json \u003d new StringReader(\"{\u0027stringValue\u0027:\u0027no message\u0027,\u0027intValue\u0027:10,\u0027longValue\u0027:20}\");\r\n    JsonObject obj \u003d (JsonObject) JsonParser.parseReader(json);\r\n    obj.remove(\"stringValue\");\r\n    obj.addProperty(\"stringValue\", \"fooBar\");\r\n    BagOfPrimitives target \u003d gson.fromJson(obj, BagOfPrimitives.class);\r\n    assertThat(target.intValue).isEqualTo(10);\r\n    assertThat(target.longValue).isEqualTo(20);\r\n    assertThat(target.stringValue).isEqualTo(\"fooBar\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonParserTest",
      "methodName": "testChangingCustomTreeAndDeserializing",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExtraCommasInArrays() {\r\n    Type type \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(Arrays.asList(\"a\", null, \"b\", null, null)).isEqualTo(gson.fromJson(\"[a,,b,,]\", type));\r\n    assertThat(Arrays.asList(null, null)).isEqualTo(gson.fromJson(\"[,]\", type));\r\n    assertThat(Arrays.asList(\"a\", null)).isEqualTo(gson.fromJson(\"[a,]\", type));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonParserTest",
      "methodName": "testExtraCommasInArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExtraCommasInMaps() {\r\n    Type type \u003d new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n    }.getType();\r\n    try {\r\n        gson.fromJson(\"{a:b,}\", type);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonParserTest",
      "methodName": "testExtraCommasInMaps",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonTreeTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testToJsonTree() {\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives(10L, 5, false, \"foo\");\r\n    JsonElement json \u003d gson.toJsonTree(bag);\r\n    assertThat(json.isJsonObject()).isTrue();\r\n    JsonObject obj \u003d json.getAsJsonObject();\r\n    Set\u003cEntry\u003cString, JsonElement\u003e\u003e children \u003d obj.entrySet();\r\n    assertThat(children).hasSize(4);\r\n    assertContains(obj, new JsonPrimitive(10L));\r\n    assertContains(obj, new JsonPrimitive(5));\r\n    assertContains(obj, new JsonPrimitive(false));\r\n    assertContains(obj, new JsonPrimitive(\"foo\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonTreeTest",
      "methodName": "testToJsonTree",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testToJsonTreeObjectType() {\r\n    SubTypeOfBagOfPrimitives bag \u003d new SubTypeOfBagOfPrimitives(10L, 5, false, \"foo\", 1.4F);\r\n    JsonElement json \u003d gson.toJsonTree(bag, BagOfPrimitives.class);\r\n    assertThat(json.isJsonObject()).isTrue();\r\n    JsonObject obj \u003d json.getAsJsonObject();\r\n    Set\u003cEntry\u003cString, JsonElement\u003e\u003e children \u003d obj.entrySet();\r\n    assertThat(children).hasSize(4);\r\n    assertContains(obj, new JsonPrimitive(10L));\r\n    assertContains(obj, new JsonPrimitive(5));\r\n    assertContains(obj, new JsonPrimitive(false));\r\n    assertContains(obj, new JsonPrimitive(\"foo\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonTreeTest",
      "methodName": "testToJsonTreeObjectType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonTreeToString() {\r\n    SubTypeOfBagOfPrimitives bag \u003d new SubTypeOfBagOfPrimitives(10L, 5, false, \"foo\", 1.4F);\r\n    String json1 \u003d gson.toJson(bag);\r\n    JsonElement jsonElement \u003d gson.toJsonTree(bag, SubTypeOfBagOfPrimitives.class);\r\n    String json2 \u003d gson.toJson(jsonElement);\r\n    assertThat(json2).isEqualTo(json1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonTreeTest",
      "methodName": "testJsonTreeToString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonTreeNull() {\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives(10L, 5, false, null);\r\n    JsonObject jsonElement \u003d (JsonObject) gson.toJsonTree(bag, BagOfPrimitives.class);\r\n    assertThat(jsonElement.has(\"stringValue\")).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonTreeTest",
      "methodName": "testJsonTreeNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void assertContains(JsonObject json, JsonPrimitive child) {\r\n    for (Map.Entry\u003cString, JsonElement\u003e entry : json.entrySet()) {\r\n        JsonElement node \u003d entry.getValue();\r\n        if (node.isJsonPrimitive()) {\r\n            if (node.getAsJsonPrimitive().equals(child)) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    fail();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.JsonTreeTest",
      "methodName": "assertContains",
      "parameterTypes": [
        "JsonObject",
        "JsonPrimitive"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// for GsonBuilder.setLenient\r\n@SuppressWarnings({ \"deprecation\", \"InlineMeInliner\" })\r\n@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new GsonBuilder().setLenient().create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.LeniencyTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientFromJson() {\r\n    List\u003cString\u003e json \u003d gson.fromJson(\"\" + \"[ # One!\\n\" + \"  \u0027Hi\u0027 #Element!\\n\" + \"] # Array!\", new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(json).isEqualTo(singletonList(\"Hi\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.LeniencyTest",
      "methodName": "testLenientFromJson",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeComplexMapWithTypeAdapter() {\r\n    Type type \u003d new TypeToken\u003cMap\u003cPoint, String\u003e\u003e() {\r\n    }.getType();\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    Map\u003cPoint, String\u003e original \u003d new LinkedHashMap\u003c\u003e();\r\n    original.put(new Point(5, 5), \"a\");\r\n    original.put(new Point(8, 8), \"b\");\r\n    String json \u003d gson.toJson(original, type);\r\n    assertThat(json).isEqualTo(\"[[{\\\"x\\\":5,\\\"y\\\":5},\\\"a\\\"],[{\\\"x\\\":8,\\\"y\\\":8},\\\"b\\\"]]\");\r\n    assertThat(gson.\u003cMap\u003cPoint, String\u003e\u003efromJson(json, type)).isEqualTo(original);\r\n    // test that registering a type adapter for one map doesn\u0027t interfere with others\r\n    Map\u003cString, Boolean\u003e otherMap \u003d new LinkedHashMap\u003c\u003e();\r\n    otherMap.put(\"t\", true);\r\n    otherMap.put(\"f\", false);\r\n    assertThat(gson.toJson(otherMap, Map.class)).isEqualTo(\"{\\\"t\\\":true,\\\"f\\\":false}\");\r\n    assertThat(gson.toJson(otherMap, new TypeToken\u003cMap\u003cString, Boolean\u003e\u003e() {\r\n    }.getType())).isEqualTo(\"{\\\"t\\\":true,\\\"f\\\":false}\");\r\n    assertThat(gson.\u003cObject\u003efromJson(\"{\\\"t\\\":true,\\\"f\\\":false}\", new TypeToken\u003cMap\u003cString, Boolean\u003e\u003e() {\r\n    }.getType())).isEqualTo(otherMap);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapAsArrayTypeAdapterTest",
      "methodName": "testSerializeComplexMapWithTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@Ignore\r\npublic void testTwoTypesCollapseToOneSerialize() {\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    Map\u003cNumber, String\u003e original \u003d new LinkedHashMap\u003c\u003e();\r\n    original.put(1.0D, \"a\");\r\n    original.put(1.0F, \"b\");\r\n    try {\r\n        gson.toJson(original, new TypeToken\u003cMap\u003cNumber, String\u003e\u003e() {\r\n        }.getType());\r\n        // we no longer hash keys at serialization time\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapAsArrayTypeAdapterTest",
      "methodName": "testTwoTypesCollapseToOneSerialize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTwoTypesCollapseToOneDeserialize() {\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    String s \u003d \"[[\\\"1.00\\\",\\\"a\\\"],[\\\"1.0\\\",\\\"b\\\"]]\";\r\n    try {\r\n        gson.fromJson(s, new TypeToken\u003cMap\u003cDouble, String\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapAsArrayTypeAdapterTest",
      "methodName": "testTwoTypesCollapseToOneDeserialize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultipleEnableComplexKeyRegistrationHasNoEffect() {\r\n    Type type \u003d new TypeToken\u003cMap\u003cPoint, String\u003e\u003e() {\r\n    }.getType();\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().enableComplexMapKeySerialization().create();\r\n    Map\u003cPoint, String\u003e original \u003d new LinkedHashMap\u003c\u003e();\r\n    original.put(new Point(6, 5), \"abc\");\r\n    original.put(new Point(1, 8), \"def\");\r\n    String json \u003d gson.toJson(original, type);\r\n    assertThat(json).isEqualTo(\"[[{\\\"x\\\":6,\\\"y\\\":5},\\\"abc\\\"],[{\\\"x\\\":1,\\\"y\\\":8},\\\"def\\\"]]\");\r\n    assertThat(gson.\u003cMap\u003cPoint, String\u003e\u003efromJson(json, type)).isEqualTo(original);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapAsArrayTypeAdapterTest",
      "methodName": "testMultipleEnableComplexKeyRegistrationHasNoEffect",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapWithTypeVariableSerialization() {\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    PointWithProperty\u003cPoint\u003e map \u003d new PointWithProperty\u003c\u003e();\r\n    map.map.put(new Point(2, 3), new Point(4, 5));\r\n    Type type \u003d new TypeToken\u003cPointWithProperty\u003cPoint\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, type);\r\n    assertThat(json).isEqualTo(\"{\\\"map\\\":[[{\\\"x\\\":2,\\\"y\\\":3},{\\\"x\\\":4,\\\"y\\\":5}]]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapAsArrayTypeAdapterTest",
      "methodName": "testMapWithTypeVariableSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapWithTypeVariableDeserialization() {\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    String json \u003d \"{map:[[{x:2,y:3},{x:4,y:5}]]}\";\r\n    Type type \u003d new TypeToken\u003cPointWithProperty\u003cPoint\u003e\u003e() {\r\n    }.getType();\r\n    PointWithProperty\u003cPoint\u003e map \u003d gson.fromJson(json, type);\r\n    Point key \u003d map.map.keySet().iterator().next();\r\n    Point value \u003d map.map.values().iterator().next();\r\n    assertThat(key).isEqualTo(new Point(2, 3));\r\n    assertThat(value).isEqualTo(new Point(4, 5));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapAsArrayTypeAdapterTest",
      "methodName": "testMapWithTypeVariableDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    return o instanceof Point \u0026\u0026 ((Point) o).x \u003d\u003d x \u0026\u0026 ((Point) o).y \u003d\u003d y;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapAsArrayTypeAdapterTest.Point",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return x * 37 + y;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapAsArrayTypeAdapterTest.Point",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"(\" + x + \",\" + y + \")\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapAsArrayTypeAdapterTest.Point",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapSerialization() {\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", 1);\r\n    map.put(\"b\", 2);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).contains(\"\\\"a\\\":1\");\r\n    assertThat(json).contains(\"\\\"b\\\":2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapDeserialization() {\r\n    String json \u003d \"{\\\"a\\\":1,\\\"b\\\":2}\";\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Integer\u003e target \u003d gson.fromJson(json, typeOfMap);\r\n    assertThat(target.get(\"a\")).isEqualTo(1);\r\n    assertThat(target.get(\"b\")).isEqualTo(2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testObjectMapSerialization() {\r\n    Map\u003cString, Object\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", 1);\r\n    map.put(\"b\", \"string\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).contains(\"\\\"a\\\":1\");\r\n    assertThat(json).contains(\"\\\"b\\\":\\\"string\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testObjectMapSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapSerializationEmpty() {\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSerializationEmpty",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapDeserializationEmpty() {\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Integer\u003e map \u003d gson.fromJson(\"{}\", typeOfMap);\r\n    assertThat(map).isEmpty();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapDeserializationEmpty",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapSerializationWithNullValue() {\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"abc\", null);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    // Maps are represented as JSON objects, so ignoring null field\r\n    assertThat(json).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSerializationWithNullValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapDeserializationWithNullValue() {\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Integer\u003e map \u003d gson.fromJson(\"{\\\"abc\\\":null}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"abc\")).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapDeserializationWithNullValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapSerializationWithNullValueButSerializeNulls() {\r\n    gson \u003d new GsonBuilder().serializeNulls().create();\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"abc\", null);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).isEqualTo(\"{\\\"abc\\\":null}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSerializationWithNullValueButSerializeNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapSerializationWithNullKey() {\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(null, 123);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).isEqualTo(\"{\\\"null\\\":123}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSerializationWithNullKey",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapDeserializationWithNullKey() {\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Integer\u003e map \u003d gson.fromJson(\"{\\\"null\\\":123}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"null\")).isEqualTo(123);\r\n    assertThat(map.get(null)).isNull();\r\n    map \u003d gson.fromJson(\"{null:123}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"null\")).isEqualTo(123);\r\n    assertThat(map.get(null)).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapDeserializationWithNullKey",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapSerializationWithIntegerKeys() {\r\n    Map\u003cInteger, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(123, \"456\");\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).isEqualTo(\"{\\\"123\\\":\\\"456\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSerializationWithIntegerKeys",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapDeserializationWithIntegerKeys() {\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapDeserializationWithIntegerKeys",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapDeserializationWithUnquotedIntegerKeys() {\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cInteger, String\u003e map \u003d gson.fromJson(\"{123:\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapDeserializationWithUnquotedIntegerKeys",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapDeserializationWithLongKeys() {\r\n    long longValue \u003d 9876543210L;\r\n    String json \u003d String.format(\"{\\\"%d\\\":\\\"456\\\"}\", longValue);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cLong, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cLong, String\u003e map \u003d gson.fromJson(json, typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(longValue);\r\n    assertThat(map.get(longValue)).isEqualTo(\"456\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapDeserializationWithLongKeys",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapDeserializationWithUnquotedLongKeys() {\r\n    long longKey \u003d 9876543210L;\r\n    String json \u003d String.format(\"{%d:\\\"456\\\"}\", longKey);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cLong, String\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cLong, String\u003e map \u003d gson.fromJson(json, typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(longKey);\r\n    assertThat(map.get(longKey)).isEqualTo(\"456\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapDeserializationWithUnquotedLongKeys",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testHashMapDeserialization() {\r\n    Type typeOfMap \u003d new TypeToken\u003cHashMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    HashMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testHashMapDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSortedMap() {\r\n    Type typeOfMap \u003d new TypeToken\u003cSortedMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    SortedMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testSortedMap",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testConcurrentMap() {\r\n    Type typeOfMap \u003d new TypeToken\u003cConcurrentMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    ConcurrentMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"123\\\":\\\"456\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testConcurrentMap",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testConcurrentHashMap() {\r\n    Type typeOfMap \u003d new TypeToken\u003cConcurrentHashMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    ConcurrentHashMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"123\\\":\\\"456\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testConcurrentHashMap",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testConcurrentNavigableMap() {\r\n    Type typeOfMap \u003d new TypeToken\u003cConcurrentNavigableMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    ConcurrentNavigableMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"123\\\":\\\"456\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testConcurrentNavigableMap",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testConcurrentSkipListMap() {\r\n    Type typeOfMap \u003d new TypeToken\u003cConcurrentSkipListMap\u003cInteger, String\u003e\u003e() {\r\n    }.getType();\r\n    ConcurrentSkipListMap\u003cInteger, String\u003e map \u003d gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map).containsKey(123);\r\n    assertThat(map.get(123)).isEqualTo(\"456\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"123\\\":\\\"456\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testConcurrentSkipListMap",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedMapSubclassSerialization() {\r\n    MyParameterizedMap\u003cString, String\u003e map \u003d new MyParameterizedMap\u003c\u003e(10);\r\n    map.put(\"a\", \"b\");\r\n    Type type \u003d new TypeToken\u003cMyParameterizedMap\u003cString, String\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, type);\r\n    assertThat(json).contains(\"\\\"a\\\":\\\"b\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testParameterizedMapSubclassSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapSubclassSerialization() {\r\n    MyMap map \u003d new MyMap();\r\n    map.put(\"a\", \"b\");\r\n    String json \u003d gson.toJson(map, MyMap.class);\r\n    assertThat(json).contains(\"\\\"a\\\":\\\"b\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSubclassSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapStandardSubclassDeserialization() {\r\n    String json \u003d \"{a:\u00271\u0027,b:\u00272\u0027}\";\r\n    Type type \u003d new TypeToken\u003cLinkedHashMap\u003cString, String\u003e\u003e() {\r\n    }.getType();\r\n    LinkedHashMap\u003cString, String\u003e map \u003d gson.fromJson(json, type);\r\n    assertThat(map).containsEntry(\"a\", \"1\");\r\n    assertThat(map).containsEntry(\"b\", \"2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapStandardSubclassDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic MyMap createInstance(Type type) {\r\n    return new MyMap();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "MyMap"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapSubclassDeserialization() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(MyMap.class, new InstanceCreator\u003cMyMap\u003e() {\r\n\r\n        @Override\r\n        public MyMap createInstance(Type type) {\r\n            return new MyMap();\r\n        }\r\n    }).create();\r\n    String json \u003d \"{\\\"a\\\":1,\\\"b\\\":2}\";\r\n    MyMap map \u003d gson.fromJson(json, MyMap.class);\r\n    assertThat(map.get(\"a\")).isEqualTo(\"1\");\r\n    assertThat(map.get(\"b\")).isEqualTo(\"2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSubclassDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Map\u003cString, Long\u003e src, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonArray array \u003d new JsonArray();\r\n    for (long value : src.values()) {\r\n        array.add(new JsonPrimitive(value));\r\n    }\r\n    return array;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "serialize",
      "parameterTypes": [
        "Map\u003cString, Long\u003e",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomSerializerForSpecificMapType() {\r\n    Type type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, Map.class, String.class, Long.class);\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(type, new JsonSerializer\u003cMap\u003cString, Long\u003e\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Map\u003cString, Long\u003e src, Type typeOfSrc, JsonSerializationContext context) {\r\n            JsonArray array \u003d new JsonArray();\r\n            for (long value : src.values()) {\r\n                array.add(new JsonPrimitive(value));\r\n            }\r\n            return array;\r\n        }\r\n    }).create();\r\n    Map\u003cString, Long\u003e src \u003d new LinkedHashMap\u003c\u003e();\r\n    src.put(\"one\", 1L);\r\n    src.put(\"two\", 2L);\r\n    src.put(\"three\", 3L);\r\n    assertThat(gson.toJson(src, type)).isEqualTo(\"[1,2,3]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testCustomSerializerForSpecificMapType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to http://code.google.com/p/google-gson/issues/detail?id\u003d99\r\n */\r\n@Test\r\npublic void testMapSerializationWithNullValues() {\r\n    ClassWithAMap target \u003d new ClassWithAMap();\r\n    target.map.put(\"name1\", null);\r\n    target.map.put(\"name2\", \"value2\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"name1\");\r\n    assertThat(json).contains(\"name2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSerializationWithNullValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to http://code.google.com/p/google-gson/issues/detail?id\u003d99\r\n */\r\n@Test\r\npublic void testMapSerializationWithNullValuesSerialized() {\r\n    Gson gson \u003d new GsonBuilder().serializeNulls().create();\r\n    ClassWithAMap target \u003d new ClassWithAMap();\r\n    target.map.put(\"name1\", null);\r\n    target.map.put(\"name2\", \"value2\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"name1\");\r\n    assertThat(json).contains(\"name2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSerializationWithNullValuesSerialized",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapSerializationWithWildcardValues() {\r\n    Map\u003cString, ? extends Collection\u003c? extends Integer\u003e\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"test\", null);\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, ? extends Collection\u003c? extends Integer\u003e\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(map, typeOfMap);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapSerializationWithWildcardValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapDeserializationWithWildcardValues() {\r\n    Type typeOfMap \u003d new TypeToken\u003cMap\u003cString, ? extends Long\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, ? extends Long\u003e map \u003d gson.fromJson(\"{\\\"test\\\":123}\", typeOfMap);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"test\")).isEqualTo(123L);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapDeserializationWithWildcardValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * From bug report http://code.google.com/p/google-gson/issues/detail?id\u003d95\r\n */\r\n@Test\r\npublic void testMapOfMapSerialization() {\r\n    Map\u003cString, Map\u003cString, String\u003e\u003e map \u003d new HashMap\u003c\u003e();\r\n    Map\u003cString, String\u003e nestedMap \u003d new HashMap\u003c\u003e();\r\n    nestedMap.put(\"1\", \"1\");\r\n    nestedMap.put(\"2\", \"2\");\r\n    map.put(\"nestedMap\", nestedMap);\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).contains(\"nestedMap\");\r\n    assertThat(json).contains(\"\\\"1\\\":\\\"1\\\"\");\r\n    assertThat(json).contains(\"\\\"2\\\":\\\"2\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapOfMapSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * From bug report http://code.google.com/p/google-gson/issues/detail?id\u003d95\r\n */\r\n@Test\r\npublic void testMapOfMapDeserialization() {\r\n    String json \u003d \"{nestedMap:{\u00272\u0027:\u00272\u0027,\u00271\u0027:\u00271\u0027}}\";\r\n    Type type \u003d new TypeToken\u003cMap\u003cString, Map\u003cString, String\u003e\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Map\u003cString, String\u003e\u003e map \u003d gson.fromJson(json, type);\r\n    Map\u003cString, String\u003e nested \u003d map.get(\"nestedMap\");\r\n    assertThat(nested.get(\"1\")).isEqualTo(\"1\");\r\n    assertThat(nested.get(\"2\")).isEqualTo(\"2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapOfMapDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * From bug report http://code.google.com/p/google-gson/issues/detail?id\u003d178\r\n */\r\n@Test\r\npublic void testMapWithQuotes() {\r\n    Map\u003cString, String\u003e map \u003d new HashMap\u003c\u003e();\r\n    map.put(\"a\\\"b\", \"c\\\"d\");\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\\"a\\\\\\\"b\\\":\\\"c\\\\\\\"d\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapWithQuotes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * From issue 227.\r\n */\r\n@Test\r\npublic void testWriteMapsWithEmptyStringKey() {\r\n    Map\u003cString, Boolean\u003e map \u003d new HashMap\u003c\u003e();\r\n    map.put(\"\", true);\r\n    assertThat(gson.toJson(map)).isEqualTo(\"{\\\"\\\":true}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testWriteMapsWithEmptyStringKey",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadMapsWithEmptyStringKey() {\r\n    Map\u003cString, Boolean\u003e map \u003d gson.fromJson(\"{\\\"\\\":true}\", new TypeToken\u003cMap\u003cString, Boolean\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(map.get(\"\")).isEqualTo(Boolean.TRUE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testReadMapsWithEmptyStringKey",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * From bug report http://code.google.com/p/google-gson/issues/detail?id\u003d204\r\n */\r\n@Test\r\npublic void testSerializeMaps() {\r\n    Map\u003cString, Object\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", 12);\r\n    map.put(\"b\", null);\r\n    LinkedHashMap\u003cString, Object\u003e innerMap \u003d new LinkedHashMap\u003c\u003e();\r\n    innerMap.put(\"test\", 1);\r\n    innerMap.put(\"TestStringArray\", new String[] { \"one\", \"two\" });\r\n    map.put(\"c\", innerMap);\r\n    assertThat(new GsonBuilder().serializeNulls().create().toJson(map)).isEqualTo(\"{\\\"a\\\":12,\\\"b\\\":null,\\\"c\\\":{\\\"test\\\":1,\\\"TestStringArray\\\":[\\\"one\\\",\\\"two\\\"]}}\");\r\n    assertThat(new GsonBuilder().setPrettyPrinting().serializeNulls().create().toJson(map)).isEqualTo(\"{\\n  \\\"a\\\": 12,\\n  \\\"b\\\": null,\\n  \\\"c\\\": \" + \"{\\n    \\\"test\\\": 1,\\n    \\\"TestStringArray\\\": \" + \"[\\n      \\\"one\\\",\\n      \\\"two\\\"\\n    ]\\n  }\\n}\");\r\n    assertThat(new GsonBuilder().create().toJson(map)).isEqualTo(\"{\\\"a\\\":12,\\\"c\\\":{\\\"test\\\":1,\\\"TestStringArray\\\":[\\\"one\\\",\\\"two\\\"]}}\");\r\n    assertThat(new GsonBuilder().setPrettyPrinting().create().toJson(map)).isEqualTo(\"{\\n  \\\"a\\\": 12,\\n  \\\"c\\\": \" + \"{\\n    \\\"test\\\": 1,\\n    \\\"TestStringArray\\\": \" + \"[\\n      \\\"one\\\",\\n      \\\"two\\\"\\n    ]\\n  }\\n}\");\r\n    innerMap.put(\"d\", \"e\");\r\n    assertThat(new Gson().toJson(map)).isEqualTo(\"{\\\"a\\\":12,\\\"c\\\":{\\\"test\\\":1,\\\"TestStringArray\\\":[\\\"one\\\",\\\"two\\\"],\\\"d\\\":\\\"e\\\"}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testSerializeMaps",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic final void testInterfaceTypeMap() {\r\n    MapClass element \u003d new MapClass();\r\n    TestTypes.Sub subType \u003d new TestTypes.Sub();\r\n    element.addBase(\"Test\", subType);\r\n    element.addSub(\"Test\", subType);\r\n    String subTypeJson \u003d new Gson().toJson(subType);\r\n    String expected \u003d \"{\\\"bases\\\":{\\\"Test\\\":\" + subTypeJson + \"},\" + \"\\\"subs\\\":{\\\"Test\\\":\" + subTypeJson + \"}}\";\r\n    Gson gsonWithComplexKeys \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    String json \u003d gsonWithComplexKeys.toJson(element);\r\n    assertThat(json).isEqualTo(expected);\r\n    Gson gson \u003d new Gson();\r\n    json \u003d gson.toJson(element);\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testInterfaceTypeMap",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(TestTypes.Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return baseTypeJsonElement;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "serialize",
      "parameterTypes": [
        "TestTypes.Base",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic final void testInterfaceTypeMapWithSerializer() {\r\n    MapClass element \u003d new MapClass();\r\n    TestTypes.Sub subType \u003d new TestTypes.Sub();\r\n    element.addBase(\"Test\", subType);\r\n    element.addSub(\"Test\", subType);\r\n    Gson tempGson \u003d new Gson();\r\n    String subTypeJson \u003d tempGson.toJson(subType);\r\n    final JsonElement baseTypeJsonElement \u003d tempGson.toJsonTree(subType, TestTypes.Base.class);\r\n    String baseTypeJson \u003d tempGson.toJson(baseTypeJsonElement);\r\n    String expected \u003d \"{\\\"bases\\\":{\\\"Test\\\":\" + baseTypeJson + \"},\" + \"\\\"subs\\\":{\\\"Test\\\":\" + subTypeJson + \"}}\";\r\n    JsonSerializer\u003cTestTypes.Base\u003e baseTypeAdapter \u003d new JsonSerializer\u003cTestTypes.Base\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(TestTypes.Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return baseTypeJsonElement;\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().enableComplexMapKeySerialization().registerTypeAdapter(TestTypes.Base.class, baseTypeAdapter).create();\r\n    String json \u003d gson.toJson(element);\r\n    assertThat(json).isEqualTo(expected);\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(TestTypes.Base.class, baseTypeAdapter).create();\r\n    json \u003d gson.toJson(element);\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testInterfaceTypeMapWithSerializer",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGeneralMapField() {\r\n    MapWithGeneralMapParameters map \u003d new MapWithGeneralMapParameters();\r\n    map.map.put(\"string\", \"testString\");\r\n    map.map.put(\"stringArray\", new String[] { \"one\", \"two\" });\r\n    map.map.put(\"objectArray\", new Object[] { 1, 2L, \"three\" });\r\n    String expected \u003d \"{\\\"map\\\":{\\\"string\\\":\\\"testString\\\",\\\"stringArray\\\":\" + \"[\\\"one\\\",\\\"two\\\"],\\\"objectArray\\\":[1,2,\\\"three\\\"]}}\";\r\n    assertThat(gson.toJson(map)).isEqualTo(expected);\r\n    gson \u003d new GsonBuilder().enableComplexMapKeySerialization().create();\r\n    assertThat(gson.toJson(map)).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testGeneralMapField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testComplexKeysSerialization() {\r\n    Map\u003cPoint, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(new Point(2, 3), \"a\");\r\n    map.put(new Point(5, 7), \"b\");\r\n    String json \u003d \"{\\\"2,3\\\":\\\"a\\\",\\\"5,7\\\":\\\"b\\\"}\";\r\n    assertThat(gson.toJson(map, new TypeToken\u003cMap\u003cPoint, String\u003e\u003e() {\r\n    }.getType())).isEqualTo(json);\r\n    assertThat(gson.toJson(map, Map.class)).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testComplexKeysSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testComplexKeysDeserialization() {\r\n    String json \u003d \"{\u00272,3\u0027:\u0027a\u0027,\u00275,7\u0027:\u0027b\u0027}\";\r\n    try {\r\n        gson.fromJson(json, new TypeToken\u003cMap\u003cPoint, String\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testComplexKeysDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringKeyDeserialization() {\r\n    String json \u003d \"{\u00272,3\u0027:\u0027a\u0027,\u00275,7\u0027:\u0027b\u0027}\";\r\n    Map\u003cString, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"2,3\", \"a\");\r\n    map.put(\"5,7\", \"b\");\r\n    assertThat(map).isEqualTo(gson.fromJson(json, new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testStringKeyDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNumberKeyDeserialization() {\r\n    String json \u003d \"{\u00272.3\u0027:\u0027a\u0027,\u00275.7\u0027:\u0027b\u0027}\";\r\n    Map\u003cDouble, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(2.3, \"a\");\r\n    map.put(5.7, \"b\");\r\n    assertThat(map).isEqualTo(gson.fromJson(json, new TypeToken\u003cMap\u003cDouble, String\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testNumberKeyDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBooleanKeyDeserialization() {\r\n    String json \u003d \"{\u0027true\u0027:\u0027a\u0027,\u0027false\u0027:\u0027b\u0027}\";\r\n    Map\u003cBoolean, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(true, \"a\");\r\n    map.put(false, \"b\");\r\n    assertThat(map).isEqualTo(gson.fromJson(json, new TypeToken\u003cMap\u003cBoolean, String\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testBooleanKeyDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapDeserializationWithDuplicateKeys() {\r\n    try {\r\n        gson.fromJson(\"{\u0027a\u0027:1,\u0027a\u0027:2}\", new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapDeserializationWithDuplicateKeys",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeMapOfMaps() {\r\n    Type type \u003d new TypeToken\u003cMap\u003cString, Map\u003cString, String\u003e\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Map\u003cString, String\u003e\u003e map \u003d newMap(\"a\", newMap(\"ka1\", \"va1\", \"ka2\", \"va2\"), \"b\", newMap(\"kb1\", \"vb1\", \"kb2\", \"vb2\"));\r\n    assertThat(gson.toJson(map, type).replace(\u0027\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027a\u0027:{\u0027ka1\u0027:\u0027va1\u0027,\u0027ka2\u0027:\u0027va2\u0027},\u0027b\u0027:{\u0027kb1\u0027:\u0027vb1\u0027,\u0027kb2\u0027:\u0027vb2\u0027}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testSerializeMapOfMaps",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeerializeMapOfMaps() {\r\n    Type type \u003d new TypeToken\u003cMap\u003cString, Map\u003cString, String\u003e\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Map\u003cString, String\u003e\u003e map \u003d newMap(\"a\", newMap(\"ka1\", \"va1\", \"ka2\", \"va2\"), \"b\", newMap(\"kb1\", \"vb1\", \"kb2\", \"vb2\"));\r\n    String json \u003d \"{\u0027a\u0027:{\u0027ka1\u0027:\u0027va1\u0027,\u0027ka2\u0027:\u0027va2\u0027},\u0027b\u0027:{\u0027kb1\u0027:\u0027vb1\u0027,\u0027kb2\u0027:\u0027vb2\u0027}}\";\r\n    assertThat(map).isEqualTo(gson.fromJson(json, type));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testDeerializeMapOfMaps",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private \u003cK, V\u003e Map\u003cK, V\u003e newMap(K key1, V value1, K key2, V value2) {\r\n    Map\u003cK, V\u003e result \u003d new LinkedHashMap\u003c\u003e();\r\n    result.put(key1, value1);\r\n    result.put(key2, value2);\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "newMap",
      "parameterTypes": [
        "K",
        "V",
        "K",
        "V"
      ],
      "returnType": "Map\u003cK, V\u003e"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapNamePromotionWithJsonElementReader() {\r\n    String json \u003d \"{\u00272.3\u0027:\u0027a\u0027}\";\r\n    Map\u003cDouble, String\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(2.3, \"a\");\r\n    JsonElement tree \u003d JsonParser.parseString(json);\r\n    assertThat(map).isEqualTo(gson.fromJson(tree, new TypeToken\u003cMap\u003cDouble, String\u003e\u003e() {\r\n    }.getType()));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest",
      "methodName": "testMapNamePromotionWithJsonElementReader",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    return o instanceof Point \u0026\u0026 x \u003d\u003d ((Point) o).x \u0026\u0026 y \u003d\u003d ((Point) o).y;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest.Point",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return x * 37 + y;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest.Point",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return x + \",\" + y;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest.Point",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public final void addBase(String name, TestTypes.Base value) {\r\n    bases.put(name, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest.MapClass",
      "methodName": "addBase",
      "parameterTypes": [
        "String",
        "TestTypes.Base"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public final void addSub(String name, TestTypes.Sub value) {\r\n    subs.put(name, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MapTest.MapClass",
      "methodName": "addSub",
      "parameterTypes": [
        "String",
        "TestTypes.Sub"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MoreSpecificTypeSerializationTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSubclassFields() {\r\n    ClassWithBaseFields target \u003d new ClassWithBaseFields(new Sub(1, 2));\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"b\\\":1\");\r\n    assertThat(json).contains(\"\\\"s\\\":2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MoreSpecificTypeSerializationTest",
      "methodName": "testSubclassFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testListOfSubclassFields() {\r\n    Collection\u003cBase\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(new Base(1));\r\n    list.add(new Sub(2, 3));\r\n    ClassWithContainersOfBaseFields target \u003d new ClassWithContainersOfBaseFields(list, null);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"{\\\"b\\\":1}\");\r\n    assertThat(json).contains(\"{\\\"s\\\":3,\\\"b\\\":2}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MoreSpecificTypeSerializationTest",
      "methodName": "testListOfSubclassFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapOfSubclassFields() {\r\n    Map\u003cString, Base\u003e map \u003d new HashMap\u003c\u003e();\r\n    map.put(\"base\", new Base(1));\r\n    map.put(\"sub\", new Sub(2, 3));\r\n    ClassWithContainersOfBaseFields target \u003d new ClassWithContainersOfBaseFields(null, map);\r\n    JsonObject json \u003d gson.toJsonTree(target).getAsJsonObject().get(\"map\").getAsJsonObject();\r\n    assertThat(json.get(\"base\").getAsJsonObject().get(\"b\").getAsInt()).isEqualTo(1);\r\n    JsonObject sub \u003d json.get(\"sub\").getAsJsonObject();\r\n    assertThat(sub.get(\"b\").getAsInt()).isEqualTo(2);\r\n    assertThat(sub.get(\"s\").getAsInt()).isEqualTo(3);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MoreSpecificTypeSerializationTest",
      "methodName": "testMapOfSubclassFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * For parameterized type, Gson ignores the more-specific type and sticks to the declared type\r\n */\r\n@Test\r\npublic void testParameterizedSubclassFields() {\r\n    ClassWithParameterizedBaseFields target \u003d new ClassWithParameterizedBaseFields(new ParameterizedSub\u003c\u003e(\"one\", \"two\"));\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"t\\\":\\\"one\\\"\");\r\n    assertThat(json).doesNotContain(\"\\\"s\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MoreSpecificTypeSerializationTest",
      "methodName": "testParameterizedSubclassFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * For parameterized type in a List, Gson ignores the more-specific type and sticks to\r\n * the declared type\r\n */\r\n@Test\r\npublic void testListOfParameterizedSubclassFields() {\r\n    Collection\u003cParameterizedBase\u003cString\u003e\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(new ParameterizedBase\u003c\u003e(\"one\"));\r\n    list.add(new ParameterizedSub\u003c\u003e(\"two\", \"three\"));\r\n    ClassWithContainersOfParameterizedBaseFields target \u003d new ClassWithContainersOfParameterizedBaseFields(list, null);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"{\\\"t\\\":\\\"one\\\"}\");\r\n    assertThat(json).doesNotContain(\"\\\"s\\\":\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MoreSpecificTypeSerializationTest",
      "methodName": "testListOfParameterizedSubclassFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * For parameterized type in a map, Gson ignores the more-specific type and sticks to the\r\n * declared type\r\n */\r\n@Test\r\npublic void testMapOfParameterizedSubclassFields() {\r\n    Map\u003cString, ParameterizedBase\u003cString\u003e\u003e map \u003d new HashMap\u003c\u003e();\r\n    map.put(\"base\", new ParameterizedBase\u003c\u003e(\"one\"));\r\n    map.put(\"sub\", new ParameterizedSub\u003c\u003e(\"two\", \"three\"));\r\n    ClassWithContainersOfParameterizedBaseFields target \u003d new ClassWithContainersOfParameterizedBaseFields(null, map);\r\n    JsonObject json \u003d gson.toJsonTree(target).getAsJsonObject().get(\"map\").getAsJsonObject();\r\n    assertThat(json.get(\"base\").getAsJsonObject().get(\"t\").getAsString()).isEqualTo(\"one\");\r\n    JsonObject sub \u003d json.get(\"sub\").getAsJsonObject();\r\n    assertThat(sub.get(\"t\").getAsString()).isEqualTo(\"two\");\r\n    assertThat(sub.get(\"s\")).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.MoreSpecificTypeSerializationTest",
      "methodName": "testMapOfParameterizedSubclassFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    builder \u003d new GsonBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithNonDefaultFieldNamingPolicySerialization() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"SomeConstantStringInstanceField\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithNonDefaultFieldNamingPolicySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithNonDefaultFieldNamingPolicyDeserialiation() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();\r\n    String target \u003d \"{\\\"SomeConstantStringInstanceField\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithNonDefaultFieldNamingPolicyDeserialiation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithLowerCaseDashPolicySerialization() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"some-constant-string-instance-field\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithLowerCaseDashPolicySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithLowerCaseDotPolicySerialization() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"some.constant.string.instance.field\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithLowerCaseDotPolicySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithLowerCaseDotPolicyDeserialiation() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();\r\n    String target \u003d \"{\\\"some.constant.string.instance.field\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithLowerCaseDotPolicyDeserialiation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithLowerCaseDashPolicyDeserialiation() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();\r\n    String target \u003d \"{\\\"some-constant-string-instance-field\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithLowerCaseDashPolicyDeserialiation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithLowerCaseUnderscorePolicySerialization() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"some_constant_string_instance_field\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithLowerCaseUnderscorePolicySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithLowerCaseUnderscorePolicyDeserialiation() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\r\n    String target \u003d \"{\\\"some_constant_string_instance_field\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithLowerCaseUnderscorePolicyDeserialiation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithSerializedNameFieldNamingPolicySerialization() {\r\n    Gson gson \u003d builder.create();\r\n    ClassWithSerializedNameFields expected \u003d new ClassWithSerializedNameFields(5, 6);\r\n    String actual \u003d gson.toJson(expected);\r\n    assertThat(actual).isEqualTo(expected.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithSerializedNameFieldNamingPolicySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithSerializedNameFieldNamingPolicyDeserialization() {\r\n    Gson gson \u003d builder.create();\r\n    ClassWithSerializedNameFields expected \u003d new ClassWithSerializedNameFields(5, 7);\r\n    ClassWithSerializedNameFields actual \u003d gson.fromJson(expected.getExpectedJson(), ClassWithSerializedNameFields.class);\r\n    assertThat(actual.f).isEqualTo(expected.f);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithSerializedNameFieldNamingPolicyDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerialization() {\r\n    Gson gson \u003d builder.create();\r\n    try {\r\n        ClassWithDuplicateFields target \u003d new ClassWithDuplicateFields(10);\r\n        gson.toJson(target);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Class com.google.gson.functional.NamingPolicyTest$ClassWithDuplicateFields declares multiple JSON fields named \u0027a\u0027;\" + \" conflict is caused by fields com.google.gson.functional.NamingPolicyTest$ClassWithDuplicateFields#a and\" + \" com.google.gson.functional.NamingPolicyTest$ClassWithDuplicateFields#b\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#duplicate-fields\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return \"x\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonDuplicateNameDueToBadNamingPolicy() {\r\n    Gson gson \u003d builder.setFieldNamingStrategy(new FieldNamingStrategy() {\r\n\r\n        @Override\r\n        public String translateName(Field f) {\r\n            return \"x\";\r\n        }\r\n    }).create();\r\n    try {\r\n        gson.toJson(new ClassWithTwoFields());\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Class com.google.gson.functional.NamingPolicyTest$ClassWithTwoFields declares multiple JSON fields named \u0027x\u0027;\" + \" conflict is caused by fields com.google.gson.functional.NamingPolicyTest$ClassWithTwoFields#a and\" + \" com.google.gson.functional.NamingPolicyTest$ClassWithTwoFields#b\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#duplicate-fields\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonDuplicateNameDueToBadNamingPolicy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithUpperCamelCaseSpacesPolicySerialiation() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"Some Constant String Instance Field\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithUpperCamelCaseSpacesPolicySerialiation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES).create();\r\n    String target \u003d \"{\\\"Some Constant String Instance Field\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithUpperCamelCaseSpacesPolicyDeserialiation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithUpperCaseUnderscorePolicySerialization() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CASE_WITH_UNDERSCORES).create();\r\n    StringWrapper target \u003d new StringWrapper(\"blah\");\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"SOME_CONSTANT_STRING_INSTANCE_FIELD\\\":\\\"\" + target.someConstantStringInstanceField + \"\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithUpperCaseUnderscorePolicySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonWithUpperCaseUnderscorePolicyDeserialiation() {\r\n    Gson gson \u003d builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CASE_WITH_UNDERSCORES).create();\r\n    String target \u003d \"{\\\"SOME_CONSTANT_STRING_INSTANCE_FIELD\\\":\\\"someValue\\\"}\";\r\n    StringWrapper deserializedObject \u003d gson.fromJson(target, StringWrapper.class);\r\n    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testGsonWithUpperCaseUnderscorePolicyDeserialiation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeprecatedNamingStrategy() {\r\n    Gson gson \u003d builder.setFieldNamingStrategy(new UpperCaseNamingStrategy()).create();\r\n    ClassWithDuplicateFields target \u003d new ClassWithDuplicateFields(10);\r\n    String actual \u003d gson.toJson(target);\r\n    assertThat(actual).isEqualTo(\"{\\\"A\\\":10}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testDeprecatedNamingStrategy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testComplexFieldNameStrategy() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(new ClassWithComplexFieldName(10));\r\n    String escapedFieldName \u003d \"@value\\\\\\\"_s$\\\\\\\\\";\r\n    assertThat(json).isEqualTo(\"{\\\"\" + escapedFieldName + \"\\\":10}\");\r\n    ClassWithComplexFieldName obj \u003d gson.fromJson(json, ClassWithComplexFieldName.class);\r\n    assertThat(obj.value).isEqualTo(10);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testComplexFieldNameStrategy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * http://code.google.com/p/google-gson/issues/detail?id\u003d349\r\n */\r\n@Test\r\npublic void testAtSignInSerializedName() {\r\n    assertThat(new Gson().toJson(new AtName())).isEqualTo(\"{\\\"@foo\\\":\\\"bar\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest",
      "methodName": "testAtSignInSerializedName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return f.getName().toUpperCase(Locale.ROOT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NamingPolicyTest.UpperCaseNamingStrategy",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gsonBuilder \u003d new GsonBuilder().serializeNulls();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelNullObjectSerialization() {\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String actual \u003d gson.toJson(null);\r\n    assertThat(actual).isEqualTo(\"null\");\r\n    actual \u003d gson.toJson(null, String.class);\r\n    assertThat(actual).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testTopLevelNullObjectSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelNullObjectDeserialization() {\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String actual \u003d gson.fromJson(\"null\", String.class);\r\n    assertThat(actual).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testTopLevelNullObjectDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExplicitSerializationOfNulls() {\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithObjects target \u003d new ClassWithObjects(null);\r\n    String actual \u003d gson.toJson(target);\r\n    String expected \u003d \"{\\\"bag\\\":null}\";\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testExplicitSerializationOfNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExplicitDeserializationOfNulls() {\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithObjects target \u003d gson.fromJson(\"{\\\"bag\\\":null}\", ClassWithObjects.class);\r\n    assertThat(target.bag).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testExplicitDeserializationOfNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExplicitSerializationOfNullArrayMembers() {\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithMembers target \u003d new ClassWithMembers();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"array\\\":null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testExplicitSerializationOfNullArrayMembers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Added to verify http://code.google.com/p/google-gson/issues/detail?id\u003d68\r\n */\r\n@Test\r\npublic void testNullWrappedPrimitiveMemberSerialization() {\r\n    Gson gson \u003d gsonBuilder.serializeNulls().create();\r\n    ClassWithNullWrappedPrimitive target \u003d new ClassWithNullWrappedPrimitive();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"value\\\":null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testNullWrappedPrimitiveMemberSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Added to verify http://code.google.com/p/google-gson/issues/detail?id\u003d68\r\n */\r\n@Test\r\npublic void testNullWrappedPrimitiveMemberDeserialization() {\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String json \u003d \"{\u0027value\u0027:null}\";\r\n    ClassWithNullWrappedPrimitive target \u003d gson.fromJson(json, ClassWithNullWrappedPrimitive.class);\r\n    assertThat(target.value).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testNullWrappedPrimitiveMemberDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExplicitSerializationOfNullCollectionMembers() {\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithMembers target \u003d new ClassWithMembers();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"col\\\":null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testExplicitSerializationOfNullCollectionMembers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExplicitSerializationOfNullStringMembers() {\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithMembers target \u003d new ClassWithMembers();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"str\\\":null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testExplicitSerializationOfNullStringMembers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomSerializationOfNulls() {\r\n    gsonBuilder.registerTypeAdapter(ClassWithObjects.class, new ClassWithObjectsSerializer());\r\n    Gson gson \u003d gsonBuilder.create();\r\n    ClassWithObjects target \u003d new ClassWithObjects(new BagOfPrimitives());\r\n    String actual \u003d gson.toJson(target);\r\n    String expected \u003d \"{\\\"bag\\\":null}\";\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testCustomSerializationOfNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrintPrintingObjectWithNulls() {\r\n    gsonBuilder \u003d new GsonBuilder();\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String result \u003d gson.toJson(new ClassWithMembers());\r\n    assertThat(result).isEqualTo(\"{}\");\r\n    gson \u003d gsonBuilder.serializeNulls().create();\r\n    result \u003d gson.toJson(new ClassWithMembers());\r\n    assertThat(result).contains(\"\\\"str\\\":null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testPrintPrintingObjectWithNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrintPrintingArraysWithNulls() {\r\n    gsonBuilder \u003d new GsonBuilder();\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String result \u003d gson.toJson(new String[] { \"1\", null, \"3\" });\r\n    assertThat(result).isEqualTo(\"[\\\"1\\\",null,\\\"3\\\"]\");\r\n    gson \u003d gsonBuilder.serializeNulls().create();\r\n    result \u003d gson.toJson(new String[] { \"1\", null, \"3\" });\r\n    assertThat(result).isEqualTo(\"[\\\"1\\\",null,\\\"3\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testPrintPrintingArraysWithNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// test for issue 389\r\n@Test\r\npublic void testAbsentJsonElementsAreSetToNull() {\r\n    Gson gson \u003d new Gson();\r\n    ClassWithInitializedMembers target \u003d gson.fromJson(\"{array:[1,2,3]}\", ClassWithInitializedMembers.class);\r\n    assertThat(target.array).hasLength(3);\r\n    assertThat(target.array[1]).isEqualTo(2);\r\n    assertThat(target.str1).isEqualTo(ClassWithInitializedMembers.MY_STRING_DEFAULT);\r\n    assertThat(target.str2).isNull();\r\n    assertThat(target.int1).isEqualTo(ClassWithInitializedMembers.MY_INT_DEFAULT);\r\n    // test the default value of a primitive int field per JVM spec\r\n    assertThat(target.int2).isEqualTo(0);\r\n    assertThat(target.bool1).isEqualTo(ClassWithInitializedMembers.MY_BOOLEAN_DEFAULT);\r\n    // test the default value of a primitive boolean field per JVM spec\r\n    assertThat(target.bool2).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testAbsentJsonElementsAreSetToNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(ClassWithObjects src, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.add(\"bag\", JsonNull.INSTANCE);\r\n    return obj;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest.ClassWithObjectsSerializer",
      "methodName": "serialize",
      "parameterTypes": [
        "ClassWithObjects",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExplicitNullSetsFieldToNullDuringDeserialization() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d \"{value:null}\";\r\n    ObjectWithField obj \u003d gson.fromJson(json, ObjectWithField.class);\r\n    assertThat(obj.value).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testExplicitNullSetsFieldToNullDuringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(ObjectWithField src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return context.serialize(null);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "serialize",
      "parameterTypes": [
        "ObjectWithField",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomTypeAdapterPassesNullSerialization() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ObjectWithField.class, new JsonSerializer\u003cObjectWithField\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(ObjectWithField src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return context.serialize(null);\r\n        }\r\n    }).create();\r\n    ObjectWithField target \u003d new ObjectWithField();\r\n    target.value \u003d \"value1\";\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"value1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testCustomTypeAdapterPassesNullSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic ObjectWithField deserialize(JsonElement json, Type type, JsonDeserializationContext context) {\r\n    return context.deserialize(null, type);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "ObjectWithField"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomTypeAdapterPassesNullDesrialization() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ObjectWithField.class, new JsonDeserializer\u003cObjectWithField\u003e() {\r\n\r\n        @Override\r\n        public ObjectWithField deserialize(JsonElement json, Type type, JsonDeserializationContext context) {\r\n            return context.deserialize(null, type);\r\n        }\r\n    }).create();\r\n    String json \u003d \"{value:\u0027value1\u0027}\";\r\n    ObjectWithField target \u003d gson.fromJson(json, ObjectWithField.class);\r\n    assertThat(target).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NullObjectAndFieldTest",
      "methodName": "testCustomTypeAdapterPassesNullDesrialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static JsonReader jsonReader(String json) {\r\n    return new JsonReader(new StringReader(json));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NumberLimitsTest",
      "methodName": "jsonReader",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonReader"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests how {@link JsonReader} behaves for large numbers.\r\n *\r\n * \u003cp\u003eCurrently {@link JsonReader} itself does not enforce any limits.\r\n * The reasons for this are:\r\n * \u003cul\u003e\r\n *   \u003cli\u003eMethods such as {@link JsonReader#nextDouble()} seem to have no problem\r\n *       parsing extremely large or small numbers (it rounds to 0 or Infinity)\r\n *       (to be verified?; if it had performance problems with certain numbers, then\r\n *        it would affect other parts of Gson which parse as float or double as well)\r\n *   \u003cli\u003eEnforcing limits only when a JSON number is encountered would be ineffective\r\n *       unless users explicitly call {@link JsonReader#peek()} and check if the value\r\n *       is a JSON number. Otherwise the limits could be circumvented because\r\n *       {@link JsonReader#nextString()} reads both strings and numbers, and for\r\n *       JSON strings no restrictions are enforced.\r\n * \u003c/ul\u003e\r\n */\r\n@Test\r\npublic void testJsonReader() throws IOException {\r\n    JsonReader reader \u003d jsonReader(\"1\".repeat(1000));\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextString()).isEqualTo(\"1\".repeat(1000));\r\n    JsonReader reader2 \u003d jsonReader(\"1\".repeat(MAX_LENGTH + 1));\r\n    // Currently JsonReader does not recognize large JSON numbers as numbers but treats them\r\n    // as unquoted string\r\n    MalformedJsonException e \u003d assertThrows(MalformedJsonException.class, () -\u003e reader2.peek());\r\n    assertThat(e).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON\");\r\n    reader \u003d jsonReader(\"1e9999\");\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextString()).isEqualTo(\"1e9999\");\r\n    reader \u003d jsonReader(\"1e+9999\");\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextString()).isEqualTo(\"1e+9999\");\r\n    reader \u003d jsonReader(\"1e10000\");\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextString()).isEqualTo(\"1e10000\");\r\n    reader \u003d jsonReader(\"1e00001\");\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextString()).isEqualTo(\"1e00001\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NumberLimitsTest",
      "methodName": "testJsonReader",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonPrimitive() {\r\n    assertThat(new JsonPrimitive(\"1\".repeat(MAX_LENGTH)).getAsBigDecimal()).isEqualTo(new BigDecimal(\"1\".repeat(MAX_LENGTH)));\r\n    assertThat(new JsonPrimitive(\"1e9999\").getAsBigDecimal()).isEqualTo(new BigDecimal(\"1e9999\"));\r\n    assertThat(new JsonPrimitive(\"1e-9999\").getAsBigDecimal()).isEqualTo(new BigDecimal(\"1e-9999\"));\r\n    NumberFormatException e \u003d assertThrows(NumberFormatException.class, () -\u003e new JsonPrimitive(\"1\".repeat(MAX_LENGTH + 1)).getAsBigDecimal());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Number string too large: 111111111111111111111111111111...\");\r\n    e \u003d assertThrows(NumberFormatException.class, () -\u003e new JsonPrimitive(\"1e10000\").getAsBigDecimal());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Number has unsupported scale: 1e10000\");\r\n    e \u003d assertThrows(NumberFormatException.class, () -\u003e new JsonPrimitive(\"1e-10000\").getAsBigDecimal());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Number has unsupported scale: 1e-10000\");\r\n    assertThat(new JsonPrimitive(\"1\".repeat(MAX_LENGTH)).getAsBigInteger()).isEqualTo(new BigInteger(\"1\".repeat(MAX_LENGTH)));\r\n    e \u003d assertThrows(NumberFormatException.class, () -\u003e new JsonPrimitive(\"1\".repeat(MAX_LENGTH + 1)).getAsBigInteger());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Number string too large: 111111111111111111111111111111...\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NumberLimitsTest",
      "methodName": "testJsonPrimitive",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testToNumberPolicy() throws IOException {\r\n    ToNumberStrategy strategy \u003d ToNumberPolicy.BIG_DECIMAL;\r\n    assertThat(strategy.readNumber(jsonReader(\"\\\"\" + \"1\".repeat(MAX_LENGTH) + \"\\\"\"))).isEqualTo(new BigDecimal(\"1\".repeat(MAX_LENGTH)));\r\n    assertThat(strategy.readNumber(jsonReader(\"1e9999\"))).isEqualTo(new BigDecimal(\"1e9999\"));\r\n    JsonParseException e \u003d assertThrows(JsonParseException.class, () -\u003e strategy.readNumber(jsonReader(\"\\\"\" + \"1\".repeat(MAX_LENGTH + 1) + \"\\\"\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Cannot parse \" + \"1\".repeat(MAX_LENGTH + 1) + \"; at path $\");\r\n    assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Number string too large: 111111111111111111111111111111...\");\r\n    e \u003d assertThrows(JsonParseException.class, () -\u003e strategy.readNumber(jsonReader(\"\\\"1e10000\\\"\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Cannot parse 1e10000; at path $\");\r\n    assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Number has unsupported scale: 1e10000\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NumberLimitsTest",
      "methodName": "testToNumberPolicy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLazilyParsedNumber() throws IOException {\r\n    assertThat(new LazilyParsedNumber(\"1\".repeat(MAX_LENGTH)).intValue()).isEqualTo(new BigDecimal(\"1\".repeat(MAX_LENGTH)).intValue());\r\n    assertThat(new LazilyParsedNumber(\"1e9999\").intValue()).isEqualTo(new BigDecimal(\"1e9999\").intValue());\r\n    NumberFormatException e \u003d assertThrows(NumberFormatException.class, () -\u003e new LazilyParsedNumber(\"1\".repeat(MAX_LENGTH + 1)).intValue());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Number string too large: 111111111111111111111111111111...\");\r\n    e \u003d assertThrows(NumberFormatException.class, () -\u003e new LazilyParsedNumber(\"1e10000\").intValue());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Number has unsupported scale: 1e10000\");\r\n    e \u003d assertThrows(NumberFormatException.class, () -\u003e new LazilyParsedNumber(\"1e10000\").longValue());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Number has unsupported scale: 1e10000\");\r\n    ObjectOutputStream objOut \u003d new ObjectOutputStream(OutputStream.nullOutputStream());\r\n    // Number is serialized as BigDecimal; should also enforce limits during this conversion\r\n    e \u003d assertThrows(NumberFormatException.class, () -\u003e objOut.writeObject(new LazilyParsedNumber(\"1e10000\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Number has unsupported scale: 1e10000\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NumberLimitsTest",
      "methodName": "testLazilyParsedNumber",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalAdapter() throws IOException {\r\n    TypeAdapter\u003cBigDecimal\u003e adapter \u003d new Gson().getAdapter(BigDecimal.class);\r\n    assertThat(adapter.fromJson(\"\\\"\" + \"1\".repeat(MAX_LENGTH) + \"\\\"\")).isEqualTo(new BigDecimal(\"1\".repeat(MAX_LENGTH)));\r\n    assertThat(adapter.fromJson(\"\\\"1e9999\\\"\")).isEqualTo(new BigDecimal(\"1e9999\"));\r\n    JsonSyntaxException e \u003d assertThrows(JsonSyntaxException.class, () -\u003e adapter.fromJson(\"\\\"\" + \"1\".repeat(MAX_LENGTH + 1) + \"\\\"\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Failed parsing \u0027\" + \"1\".repeat(MAX_LENGTH + 1) + \"\u0027 as BigDecimal; at path $\");\r\n    assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Number string too large: 111111111111111111111111111111...\");\r\n    e \u003d assertThrows(JsonSyntaxException.class, () -\u003e adapter.fromJson(\"\\\"1e10000\\\"\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Failed parsing \u00271e10000\u0027 as BigDecimal; at path $\");\r\n    assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Number has unsupported scale: 1e10000\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NumberLimitsTest",
      "methodName": "testBigDecimalAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigIntegerAdapter() throws IOException {\r\n    TypeAdapter\u003cBigInteger\u003e adapter \u003d new Gson().getAdapter(BigInteger.class);\r\n    assertThat(adapter.fromJson(\"\\\"\" + \"1\".repeat(MAX_LENGTH) + \"\\\"\")).isEqualTo(new BigInteger(\"1\".repeat(MAX_LENGTH)));\r\n    JsonSyntaxException e \u003d assertThrows(JsonSyntaxException.class, () -\u003e adapter.fromJson(\"\\\"\" + \"1\".repeat(MAX_LENGTH + 1) + \"\\\"\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Failed parsing \u0027\" + \"1\".repeat(MAX_LENGTH + 1) + \"\u0027 as BigInteger; at path $\");\r\n    assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Number string too large: 111111111111111111111111111111...\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.NumberLimitsTest",
      "methodName": "testBigIntegerAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n    oldTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"));\r\n    oldLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@After\r\npublic void tearDown() {\r\n    TimeZone.setDefault(oldTimeZone);\r\n    Locale.setDefault(oldLocale);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "tearDown",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonInSingleQuotesDeserialization() {\r\n    String json \u003d \"{\u0027stringValue\u0027:\u0027no message\u0027,\u0027intValue\u0027:10,\u0027longValue\u0027:20}\";\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.stringValue).isEqualTo(\"no message\");\r\n    assertThat(target.intValue).isEqualTo(10);\r\n    assertThat(target.longValue).isEqualTo(20);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testJsonInSingleQuotesDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonInMixedQuotesDeserialization() {\r\n    String json \u003d \"{\\\"stringValue\\\":\u0027no message\u0027,\u0027intValue\u0027:10,\u0027longValue\u0027:20}\";\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.stringValue).isEqualTo(\"no message\");\r\n    assertThat(target.intValue).isEqualTo(10);\r\n    assertThat(target.longValue).isEqualTo(20);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testJsonInMixedQuotesDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBagOfPrimitivesSerialization() {\r\n    BagOfPrimitives target \u003d new BagOfPrimitives(10, 20, false, \"stringValue\");\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testBagOfPrimitivesSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBagOfPrimitivesDeserialization() {\r\n    BagOfPrimitives src \u003d new BagOfPrimitives(10, 20, false, \"stringValue\");\r\n    String json \u003d src.getExpectedJson();\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testBagOfPrimitivesDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBagOfPrimitiveWrappersSerialization() {\r\n    BagOfPrimitiveWrappers target \u003d new BagOfPrimitiveWrappers(10L, 20, false);\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testBagOfPrimitiveWrappersSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBagOfPrimitiveWrappersDeserialization() {\r\n    BagOfPrimitiveWrappers target \u003d new BagOfPrimitiveWrappers(10L, 20, false);\r\n    String jsonString \u003d target.getExpectedJson();\r\n    target \u003d gson.fromJson(jsonString, BagOfPrimitiveWrappers.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(jsonString);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testBagOfPrimitiveWrappersDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithTransientFieldsSerialization() {\r\n    ClassWithTransientFields\u003cLong\u003e target \u003d new ClassWithTransientFields\u003c\u003e(1L);\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testClassWithTransientFieldsSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithTransientFieldsDeserialization() {\r\n    String json \u003d \"{\\\"longValue\\\":[1]}\";\r\n    ClassWithTransientFields\u003c?\u003e target \u003d gson.fromJson(json, ClassWithTransientFields.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testClassWithTransientFieldsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored() {\r\n    String json \u003d \"{\\\"transientLongValue\\\":1,\\\"longValue\\\":[1]}\";\r\n    ClassWithTransientFields\u003c?\u003e target \u003d gson.fromJson(json, ClassWithTransientFields.class);\r\n    assertThat(target.transientLongValue !\u003d 1).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithNoFieldsSerialization() {\r\n    assertThat(gson.toJson(new ClassWithNoFields())).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testClassWithNoFieldsSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithNoFieldsDeserialization() {\r\n    String json \u003d \"{}\";\r\n    ClassWithNoFields target \u003d gson.fromJson(json, ClassWithNoFields.class);\r\n    ClassWithNoFields expected \u003d new ClassWithNoFields();\r\n    assertThat(target).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testClassWithNoFieldsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipField(FieldAttributes f) {\r\n    // Skip all fields for deserialization\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "shouldSkipField",
      "parameterTypes": [
        "FieldAttributes"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "shouldSkipClass",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithDuplicateFields() {\r\n    String expectedMessage \u003d \"Class com.google.gson.functional.ObjectTest$Subclass declares multiple JSON fields named \u0027s\u0027;\" + \" conflict is caused by fields com.google.gson.functional.ObjectTest$Superclass1#s and\" + \" com.google.gson.functional.ObjectTest$Superclass2#s\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#duplicate-fields\";\r\n    try {\r\n        gson.getAdapter(Subclass.class);\r\n        fail();\r\n    } catch (IllegalArgumentException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    }\r\n    // Detection should also work properly when duplicate fields exist only for serialization\r\n    Gson gson \u003d new GsonBuilder().addDeserializationExclusionStrategy(new ExclusionStrategy() {\r\n\r\n        @Override\r\n        public boolean shouldSkipField(FieldAttributes f) {\r\n            // Skip all fields for deserialization\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n            return false;\r\n        }\r\n    }).create();\r\n    try {\r\n        gson.getAdapter(Subclass.class);\r\n        fail();\r\n    } catch (IllegalArgumentException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testClassWithDuplicateFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNestedSerialization() {\r\n    Nested target \u003d new Nested(new BagOfPrimitives(10, 20, false, \"stringValue\"), new BagOfPrimitives(30, 40, true, \"stringValue\"));\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testNestedSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNestedDeserialization() {\r\n    String json \u003d \"{\\\"primitive1\\\":{\\\"longValue\\\":10,\\\"intValue\\\":20,\\\"booleanValue\\\":false,\" + \"\\\"stringValue\\\":\\\"stringValue\\\"},\\\"primitive2\\\":{\\\"longValue\\\":30,\\\"intValue\\\":40,\" + \"\\\"booleanValue\\\":true,\\\"stringValue\\\":\\\"stringValue\\\"}}\";\r\n    Nested target \u003d gson.fromJson(json, Nested.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testNestedDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullSerialization() {\r\n    assertThat(gson.toJson(null)).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testNullSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyStringDeserialization() {\r\n    Object object \u003d gson.fromJson(\"\", Object.class);\r\n    assertThat(object).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testEmptyStringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTruncatedDeserialization() {\r\n    try {\r\n        gson.fromJson(\"[\\\"a\\\", \\\"b\\\",\", new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testTruncatedDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullDeserialization() {\r\n    String myNullObject \u003d null;\r\n    Object object \u003d gson.fromJson(myNullObject, Object.class);\r\n    assertThat(object).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testNullDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullFieldsSerialization() {\r\n    Nested target \u003d new Nested(new BagOfPrimitives(10, 20, false, \"stringValue\"), null);\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testNullFieldsSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullFieldsDeserialization() {\r\n    String json \u003d \"{\\\"primitive1\\\":{\\\"longValue\\\":10,\\\"intValue\\\":20,\\\"booleanValue\\\":false\" + \",\\\"stringValue\\\":\\\"stringValue\\\"}}\";\r\n    Nested target \u003d gson.fromJson(json, Nested.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testNullFieldsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfObjectsSerialization() {\r\n    ArrayOfObjects target \u003d new ArrayOfObjects();\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testArrayOfObjectsSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfObjectsDeserialization() {\r\n    String json \u003d new ArrayOfObjects().getExpectedJson();\r\n    ArrayOfObjects target \u003d gson.fromJson(json, ArrayOfObjects.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testArrayOfObjectsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfArraysSerialization() {\r\n    ArrayOfArrays target \u003d new ArrayOfArrays();\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testArrayOfArraysSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfArraysDeserialization() {\r\n    String json \u003d new ArrayOfArrays().getExpectedJson();\r\n    ArrayOfArrays target \u003d gson.fromJson(json, ArrayOfArrays.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testArrayOfArraysDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayOfObjectsAsFields() {\r\n    ClassWithObjects classWithObjects \u003d new ClassWithObjects();\r\n    BagOfPrimitives bagOfPrimitives \u003d new BagOfPrimitives();\r\n    String stringValue \u003d \"someStringValueInArray\";\r\n    String classWithObjectsJson \u003d gson.toJson(classWithObjects);\r\n    String bagOfPrimitivesJson \u003d gson.toJson(bagOfPrimitives);\r\n    ClassWithArray classWithArray \u003d new ClassWithArray(new Object[] { stringValue, classWithObjects, bagOfPrimitives });\r\n    String json \u003d gson.toJson(classWithArray);\r\n    assertThat(json).contains(classWithObjectsJson);\r\n    assertThat(json).contains(bagOfPrimitivesJson);\r\n    assertThat(json).contains(\"\\\"\" + stringValue + \"\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testArrayOfObjectsAsFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id\u003d14\r\n */\r\n@Test\r\npublic void testNullArraysDeserialization() {\r\n    String json \u003d \"{\\\"array\\\": null}\";\r\n    ClassWithArray target \u003d gson.fromJson(json, ClassWithArray.class);\r\n    assertThat(target.array).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testNullArraysDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id\u003d14\r\n */\r\n@Test\r\npublic void testNullObjectFieldsDeserialization() {\r\n    String json \u003d \"{\\\"bag\\\": null}\";\r\n    ClassWithObjects target \u003d gson.fromJson(json, ClassWithObjects.class);\r\n    assertThat(target.bag).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testNullObjectFieldsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyCollectionInAnObjectDeserialization() {\r\n    String json \u003d \"{\\\"children\\\":[]}\";\r\n    ClassWithCollectionField target \u003d gson.fromJson(json, ClassWithCollectionField.class);\r\n    assertThat(target).isNotNull();\r\n    assertThat(target.children).isEmpty();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testEmptyCollectionInAnObjectDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveArrayInAnObjectDeserialization() {\r\n    String json \u003d \"{\\\"longArray\\\":[0,1,2,3,4,5,6,7,8,9]}\";\r\n    PrimitiveArray target \u003d gson.fromJson(json, PrimitiveArray.class);\r\n    assertThat(target.getExpectedJson()).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testPrimitiveArrayInAnObjectDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id\u003d14\r\n */\r\n@Test\r\npublic void testNullPrimitiveFieldsDeserialization() {\r\n    String json \u003d \"{\\\"longValue\\\":null}\";\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.longValue).isEqualTo(BagOfPrimitives.DEFAULT_VALUE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testNullPrimitiveFieldsDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyCollectionInAnObjectSerialization() {\r\n    ClassWithCollectionField target \u003d new ClassWithCollectionField();\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"children\\\":[]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testEmptyCollectionInAnObjectSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrivateNoArgConstructorDeserialization() {\r\n    ClassWithPrivateNoArgsConstructor target \u003d gson.fromJson(\"{\\\"a\\\":20}\", ClassWithPrivateNoArgsConstructor.class);\r\n    assertThat(target.a).isEqualTo(20);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testPrivateNoArgConstructorDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAnonymousLocalClassesSerialization() {\r\n    assertThat(gson.toJson(new ClassWithNoFields() {\r\n    })).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testAnonymousLocalClassesSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(ClassWithNoFields src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "serialize",
      "parameterTypes": [
        "ClassWithNoFields",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAnonymousLocalClassesCustomSerialization() {\r\n    gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(ClassWithNoFields.class, new JsonSerializer\u003cClassWithNoFields\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(ClassWithNoFields src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonObject();\r\n        }\r\n    }).create();\r\n    assertThat(gson.toJson(new ClassWithNoFields() {\r\n    })).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testAnonymousLocalClassesCustomSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveArrayFieldSerialization() {\r\n    PrimitiveArray target \u003d new PrimitiveArray(new long[] { 1L, 2L, 3L });\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testPrimitiveArrayFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests that a class field with type Object can be serialized properly.\r\n * See issue 54\r\n */\r\n@Test\r\npublic void testClassWithObjectFieldSerialization() {\r\n    ClassWithObjectField obj \u003d new ClassWithObjectField();\r\n    obj.member \u003d \"abc\";\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).contains(\"abc\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testClassWithObjectFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInnerClassSerialization() {\r\n    Parent p \u003d new Parent();\r\n    Parent.Child c \u003d p.new Child();\r\n    String json \u003d gson.toJson(c);\r\n    assertThat(json).contains(\"value2\");\r\n    assertThat(json).doesNotContain(\"value1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testInnerClassSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Parent.Child createInstance(Type type) {\r\n    return p.new Child();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "Parent.Child"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInnerClassDeserialization() {\r\n    final Parent p \u003d new Parent();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Parent.Child.class, new InstanceCreator\u003cParent.Child\u003e() {\r\n\r\n        @Override\r\n        public Parent.Child createInstance(Type type) {\r\n            return p.new Child();\r\n        }\r\n    }).create();\r\n    String json \u003d \"{\u0027value2\u0027:3}\";\r\n    Parent.Child c \u003d gson.fromJson(json, Parent.Child.class);\r\n    assertThat(c.value2).isEqualTo(3);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testInnerClassDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    StringBuilder sb \u003d new StringBuilder(\"{\\\"elements\\\":[\");\r\n    boolean first \u003d true;\r\n    for (BagOfPrimitives[] row : elements) {\r\n        if (first) {\r\n            first \u003d false;\r\n        } else {\r\n            sb.append(\",\");\r\n        }\r\n        boolean firstOfRow \u003d true;\r\n        sb.append(\"[\");\r\n        for (BagOfPrimitives element : row) {\r\n            if (firstOfRow) {\r\n                firstOfRow \u003d false;\r\n            } else {\r\n                sb.append(\",\");\r\n            }\r\n            sb.append(element.getExpectedJson());\r\n        }\r\n        sb.append(\"]\");\r\n    }\r\n    sb.append(\"]}\");\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest.ArrayOfArrays",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * In response to Issue 41 http://code.google.com/p/google-gson/issues/detail?id\u003d41\r\n */\r\n@Test\r\npublic void testObjectFieldNamesWithoutQuotesDeserialization() {\r\n    String json \u003d \"{longValue:1,\u0027booleanValue\u0027:true,\\\"stringValue\\\":\u0027bar\u0027}\";\r\n    BagOfPrimitives bag \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(bag.longValue).isEqualTo(1);\r\n    assertThat(bag.booleanValue).isTrue();\r\n    assertThat(bag.stringValue).isEqualTo(\"bar\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testObjectFieldNamesWithoutQuotesDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringFieldWithNumberValueDeserialization() {\r\n    String json \u003d \"{\\\"stringValue\\\":1}\";\r\n    BagOfPrimitives bag \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(bag.stringValue).isEqualTo(\"1\");\r\n    json \u003d \"{\\\"stringValue\\\":1.5E+6}\";\r\n    bag \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(bag.stringValue).isEqualTo(\"1.5E+6\");\r\n    json \u003d \"{\\\"stringValue\\\":true}\";\r\n    bag \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(bag.stringValue).isEqualTo(\"true\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testStringFieldWithNumberValueDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created to reproduce issue 140\r\n */\r\n@Test\r\npublic void testStringFieldWithEmptyValueSerialization() {\r\n    ClassWithEmptyStringFields target \u003d new ClassWithEmptyStringFields();\r\n    target.a \u003d \"5794749\";\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"a\\\":\\\"5794749\\\"\");\r\n    assertThat(json).contains(\"\\\"b\\\":\\\"\\\"\");\r\n    assertThat(json).contains(\"\\\"c\\\":\\\"\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testStringFieldWithEmptyValueSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created to reproduce issue 140\r\n */\r\n@Test\r\npublic void testStringFieldWithEmptyValueDeserialization() {\r\n    String json \u003d \"{a:\\\"5794749\\\",b:\\\"\\\",c:\\\"\\\"}\";\r\n    ClassWithEmptyStringFields target \u003d gson.fromJson(json, ClassWithEmptyStringFields.class);\r\n    assertThat(target.a).isEqualTo(\"5794749\");\r\n    assertThat(target.b).isEqualTo(\"\");\r\n    assertThat(target.c).isEqualTo(\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testStringFieldWithEmptyValueDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonObjectSerialization() {\r\n    Gson gson \u003d new GsonBuilder().serializeNulls().create();\r\n    JsonObject obj \u003d new JsonObject();\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testJsonObjectSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Test for issue 215.\r\n */\r\n@Test\r\npublic void testSingletonLists() {\r\n    Gson gson \u003d new Gson();\r\n    Product product \u003d new Product();\r\n    assertThat(gson.toJson(product)).isEqualTo(\"{\\\"attributes\\\":[],\\\"departments\\\":[]}\");\r\n    Product unused1 \u003d gson.fromJson(gson.toJson(product), Product.class);\r\n    product.departments.add(new Department());\r\n    assertThat(gson.toJson(product)).isEqualTo(\"{\\\"attributes\\\":[],\\\"departments\\\":[{\\\"name\\\":\\\"abc\\\",\\\"code\\\":\\\"123\\\"}]}\");\r\n    Product unused2 \u003d gson.fromJson(gson.toJson(product), Product.class);\r\n    product.attributes.add(\"456\");\r\n    assertThat(gson.toJson(product)).isEqualTo(\"{\\\"attributes\\\":[\\\"456\\\"],\\\"departments\\\":[{\\\"name\\\":\\\"abc\\\",\\\"code\\\":\\\"123\\\"}]}\");\r\n    Product unused3 \u003d gson.fromJson(gson.toJson(product), Product.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testSingletonLists",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// http://code.google.com/p/google-gson/issues/detail?id\u003d270\r\n@Test\r\n@SuppressWarnings(\"JavaUtilDate\")\r\npublic void testDateAsMapObjectField() {\r\n    HasObjectMap a \u003d new HasObjectMap();\r\n    a.map.put(\"date\", new Date(0));\r\n    assertThat(gson.toJson(a)).matches(\"\\\\{\\\"map\\\":\\\\{\\\"date\\\":\\\"Dec 31, 1969,? 4:00:00\\\\hPM\\\"\\\\}\\\\}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testDateAsMapObjectField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests serialization of a class with {@code static} field.\r\n *\r\n * \u003cp\u003eImportant: It is not documented that this is officially supported; this\r\n * test just checks the current behavior.\r\n */\r\n@Test\r\npublic void testStaticFieldSerialization() {\r\n    // By default Gson should ignore static fields\r\n    assertThat(gson.toJson(new ClassWithStaticField())).isEqualTo(\"{}\");\r\n    Gson gson \u003d new GsonBuilder().// Include static fields\r\n    excludeFieldsWithModifiers(0).create();\r\n    String json \u003d gson.toJson(new ClassWithStaticField());\r\n    assertThat(json).isEqualTo(\"{\\\"s\\\":\\\"initial\\\"}\");\r\n    json \u003d gson.toJson(new ClassWithStaticFinalField());\r\n    assertThat(json).isEqualTo(\"{\\\"s\\\":\\\"initial\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testStaticFieldSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests deserialization of a class with {@code static} field.\r\n *\r\n * \u003cp\u003eImportant: It is not documented that this is officially supported; this\r\n * test just checks the current behavior.\r\n */\r\n@Test\r\npublic void testStaticFieldDeserialization() {\r\n    // By default Gson should ignore static fields\r\n    ClassWithStaticField unused \u003d gson.fromJson(\"{\\\"s\\\":\\\"custom\\\"}\", ClassWithStaticField.class);\r\n    assertThat(ClassWithStaticField.s).isEqualTo(\"initial\");\r\n    Gson gson \u003d new GsonBuilder().// Include static fields\r\n    excludeFieldsWithModifiers(0).create();\r\n    String oldValue \u003d ClassWithStaticField.s;\r\n    try {\r\n        ClassWithStaticField obj \u003d gson.fromJson(\"{\\\"s\\\":\\\"custom\\\"}\", ClassWithStaticField.class);\r\n        assertThat(obj).isNotNull();\r\n        assertThat(ClassWithStaticField.s).isEqualTo(\"custom\");\r\n    } finally {\r\n        ClassWithStaticField.s \u003d oldValue;\r\n    }\r\n    try {\r\n        gson.fromJson(\"{\\\"s\\\":\\\"custom\\\"}\", ClassWithStaticFinalField.class);\r\n        fail();\r\n    } catch (JsonIOException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Cannot set value of \u0027static final\u0027 field \u0027com.google.gson.functional.ObjectTest$ClassWithStaticFinalField#s\u0027\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testStaticFieldDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testThrowingDefaultConstructor() {\r\n    try {\r\n        gson.fromJson(\"{}\", ClassWithThrowingConstructor.class);\r\n        fail();\r\n    }// TODO: Adjust this once Gson throws more specific exception type\r\n     catch (RuntimeException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Failed to invoke constructor \u0027com.google.gson.functional.ObjectTest$ClassWithThrowingConstructor()\u0027 with no args\");\r\n        assertThat(e).hasCauseThat().isSameInstanceAs(ClassWithThrowingConstructor.thrownException);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ObjectTest",
      "methodName": "testThrowingDefaultConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedTypesSerialization() {\r\n    MyParameterizedType\u003cInteger\u003e src \u003d new MyParameterizedType\u003c\u003e(10);\r\n    Type typeOfSrc \u003d new TypeToken\u003cMyParameterizedType\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(src, typeOfSrc);\r\n    assertThat(json).isEqualTo(src.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testParameterizedTypesSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedTypeDeserialization() {\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n    MyParameterizedType\u003cBagOfPrimitives\u003e expected \u003d new MyParameterizedType\u003c\u003e(bag);\r\n    Type expectedType \u003d new TypeToken\u003cMyParameterizedType\u003cBagOfPrimitives\u003e\u003e() {\r\n    }.getType();\r\n    BagOfPrimitives bagDefaultInstance \u003d new BagOfPrimitives();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(expectedType, new MyParameterizedTypeInstanceCreator\u003c\u003e(bagDefaultInstance)).create();\r\n    String json \u003d expected.getExpectedJson();\r\n    MyParameterizedType\u003cBagOfPrimitives\u003e actual \u003d gson.fromJson(json, expectedType);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testParameterizedTypeDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTypesWithMultipleParametersSerialization() {\r\n    MultiParameters\u003cInteger, Float, Double, String, BagOfPrimitives\u003e src \u003d new MultiParameters\u003c\u003e(10, 1.0F, 2.1D, \"abc\", new BagOfPrimitives());\r\n    Type typeOfSrc \u003d new TypeToken\u003cMultiParameters\u003cInteger, Float, Double, String, BagOfPrimitives\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(src, typeOfSrc);\r\n    String expected \u003d \"{\\\"a\\\":10,\\\"b\\\":1.0,\\\"c\\\":2.1,\\\"d\\\":\\\"abc\\\",\" + \"\\\"e\\\":{\\\"longValue\\\":0,\\\"intValue\\\":0,\\\"booleanValue\\\":false,\\\"stringValue\\\":\\\"\\\"}}\";\r\n    assertThat(json).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testTypesWithMultipleParametersSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTypesWithMultipleParametersDeserialization() {\r\n    Type typeOfTarget \u003d new TypeToken\u003cMultiParameters\u003cInteger, Float, Double, String, BagOfPrimitives\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d \"{\\\"a\\\":10,\\\"b\\\":1.0,\\\"c\\\":2.1,\\\"d\\\":\\\"abc\\\",\" + \"\\\"e\\\":{\\\"longValue\\\":0,\\\"intValue\\\":0,\\\"booleanValue\\\":false,\\\"stringValue\\\":\\\"\\\"}}\";\r\n    MultiParameters\u003cInteger, Float, Double, String, BagOfPrimitives\u003e target \u003d gson.fromJson(json, typeOfTarget);\r\n    MultiParameters\u003cInteger, Float, Double, String, BagOfPrimitives\u003e expected \u003d new MultiParameters\u003c\u003e(10, 1.0F, 2.1D, \"abc\", new BagOfPrimitives());\r\n    assertThat(target).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testTypesWithMultipleParametersDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedTypeWithCustomSerializer() {\r\n    Type ptIntegerType \u003d new TypeToken\u003cMyParameterizedType\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    Type ptStringType \u003d new TypeToken\u003cMyParameterizedType\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ptIntegerType, new MyParameterizedTypeAdapter\u003cInteger\u003e()).registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter\u003cString\u003e()).create();\r\n    MyParameterizedType\u003cInteger\u003e intTarget \u003d new MyParameterizedType\u003c\u003e(10);\r\n    String json \u003d gson.toJson(intTarget, ptIntegerType);\r\n    assertThat(json).isEqualTo(MyParameterizedTypeAdapter.\u003cInteger\u003egetExpectedJson(intTarget));\r\n    MyParameterizedType\u003cString\u003e stringTarget \u003d new MyParameterizedType\u003c\u003e(\"abc\");\r\n    json \u003d gson.toJson(stringTarget, ptStringType);\r\n    assertThat(json).isEqualTo(MyParameterizedTypeAdapter.\u003cString\u003egetExpectedJson(stringTarget));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testParameterizedTypeWithCustomSerializer",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedTypesWithCustomDeserializer() {\r\n    Type ptIntegerType \u003d new TypeToken\u003cMyParameterizedType\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    Type ptStringType \u003d new TypeToken\u003cMyParameterizedType\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(ptIntegerType, new MyParameterizedTypeAdapter\u003cInteger\u003e()).registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter\u003cString\u003e()).registerTypeAdapter(ptStringType, new MyParameterizedTypeInstanceCreator\u003c\u003e(\"\")).registerTypeAdapter(ptIntegerType, new MyParameterizedTypeInstanceCreator\u003c\u003e(0)).create();\r\n    MyParameterizedType\u003cInteger\u003e src \u003d new MyParameterizedType\u003c\u003e(10);\r\n    String json \u003d MyParameterizedTypeAdapter.\u003cInteger\u003egetExpectedJson(src);\r\n    MyParameterizedType\u003cInteger\u003e intTarget \u003d gson.fromJson(json, ptIntegerType);\r\n    assertThat(intTarget.value).isEqualTo(10);\r\n    MyParameterizedType\u003cString\u003e srcStr \u003d new MyParameterizedType\u003c\u003e(\"abc\");\r\n    json \u003d MyParameterizedTypeAdapter.\u003cString\u003egetExpectedJson(srcStr);\r\n    MyParameterizedType\u003cString\u003e stringTarget \u003d gson.fromJson(json, ptStringType);\r\n    assertThat(stringTarget.value).isEqualTo(\"abc\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testParameterizedTypesWithCustomDeserializer",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedTypesWithWriterSerialization() {\r\n    Writer writer \u003d new StringWriter();\r\n    MyParameterizedType\u003cInteger\u003e src \u003d new MyParameterizedType\u003c\u003e(10);\r\n    Type typeOfSrc \u003d new TypeToken\u003cMyParameterizedType\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    gson.toJson(src, typeOfSrc, writer);\r\n    assertThat(writer.toString()).isEqualTo(src.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testParameterizedTypesWithWriterSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedTypeWithReaderDeserialization() {\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n    MyParameterizedType\u003cBagOfPrimitives\u003e expected \u003d new MyParameterizedType\u003c\u003e(bag);\r\n    Type expectedType \u003d new TypeToken\u003cMyParameterizedType\u003cBagOfPrimitives\u003e\u003e() {\r\n    }.getType();\r\n    BagOfPrimitives bagDefaultInstance \u003d new BagOfPrimitives();\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(expectedType, new MyParameterizedTypeInstanceCreator\u003c\u003e(bagDefaultInstance)).create();\r\n    Reader json \u003d new StringReader(expected.getExpectedJson());\r\n    MyParameterizedType\u003cBagOfPrimitives\u003e actual \u003d gson.fromJson(json, expectedType);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testParameterizedTypeWithReaderDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"varargs\")\r\n@SafeVarargs\r\nprivate static \u003cT\u003e T[] arrayOf(T... args) {\r\n    return args;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "arrayOf",
      "parameterTypes": [
        "T"
      ],
      "returnType": "T[]"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVariableTypeFieldsAndGenericArraysSerialization() {\r\n    Integer obj \u003d 0;\r\n    Integer[] array \u003d { 1, 2, 3 };\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(4);\r\n    list.add(5);\r\n    List\u003cInteger\u003e[] arrayOfLists \u003d arrayOf(list, list);\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(obj, array, list, arrayOfLists, list, arrayOfLists);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    assertThat(json).isEqualTo(objToSerialize.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testVariableTypeFieldsAndGenericArraysSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVariableTypeFieldsAndGenericArraysDeserialization() {\r\n    Integer obj \u003d 0;\r\n    Integer[] array \u003d { 1, 2, 3 };\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(4);\r\n    list.add(5);\r\n    List\u003cInteger\u003e[] arrayOfLists \u003d arrayOf(list, list);\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(obj, array, list, arrayOfLists, list, arrayOfLists);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    ObjectWithTypeVariables\u003cInteger\u003e objAfterDeserialization \u003d gson.fromJson(json, typeOfSrc);\r\n    assertThat(json).isEqualTo(objAfterDeserialization.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testVariableTypeFieldsAndGenericArraysDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVariableTypeDeserialization() {\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(0, null, null, null, null, null);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    ObjectWithTypeVariables\u003cInteger\u003e objAfterDeserialization \u003d gson.fromJson(json, typeOfSrc);\r\n    assertThat(json).isEqualTo(objAfterDeserialization.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testVariableTypeDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVariableTypeArrayDeserialization() {\r\n    Integer[] array \u003d { 1, 2, 3 };\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(null, array, null, null, null, null);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    ObjectWithTypeVariables\u003cInteger\u003e objAfterDeserialization \u003d gson.fromJson(json, typeOfSrc);\r\n    assertThat(json).isEqualTo(objAfterDeserialization.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testVariableTypeArrayDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedTypeWithVariableTypeDeserialization() {\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(4);\r\n    list.add(5);\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(null, null, list, null, null, null);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    ObjectWithTypeVariables\u003cInteger\u003e objAfterDeserialization \u003d gson.fromJson(json, typeOfSrc);\r\n    assertThat(json).isEqualTo(objAfterDeserialization.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testParameterizedTypeWithVariableTypeDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedTypeGenericArraysSerialization() {\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(1);\r\n    list.add(2);\r\n    List\u003cInteger\u003e[] arrayOfLists \u003d arrayOf(list, list);\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(null, null, null, arrayOfLists, null, null);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    assertThat(json).isEqualTo(\"{\\\"arrayOfListOfTypeParameters\\\":[[1,2],[1,2]]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testParameterizedTypeGenericArraysSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedTypeGenericArraysDeserialization() {\r\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(1);\r\n    list.add(2);\r\n    List\u003cInteger\u003e[] arrayOfLists \u003d arrayOf(list, list);\r\n    Type typeOfSrc \u003d new TypeToken\u003cObjectWithTypeVariables\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    ObjectWithTypeVariables\u003cInteger\u003e objToSerialize \u003d new ObjectWithTypeVariables\u003c\u003e(null, null, null, arrayOfLists, null, null);\r\n    String json \u003d gson.toJson(objToSerialize, typeOfSrc);\r\n    ObjectWithTypeVariables\u003cInteger\u003e objAfterDeserialization \u003d gson.fromJson(json, typeOfSrc);\r\n    assertThat(json).isEqualTo(objAfterDeserialization.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testParameterizedTypeGenericArraysDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    StringBuilder sb \u003d new StringBuilder().append(\"{\");\r\n    boolean needsComma \u003d false;\r\n    if (typeParameterObj !\u003d null) {\r\n        sb.append(\"\\\"typeParameterObj\\\":\").append(toString(typeParameterObj));\r\n        needsComma \u003d true;\r\n    }\r\n    if (typeParameterArray !\u003d null) {\r\n        if (needsComma) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"\\\"typeParameterArray\\\":[\");\r\n        appendObjectsToBuilder(sb, Arrays.asList(typeParameterArray));\r\n        sb.append(\u0027]\u0027);\r\n        needsComma \u003d true;\r\n    }\r\n    if (listOfTypeParameters !\u003d null) {\r\n        if (needsComma) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"\\\"listOfTypeParameters\\\":[\");\r\n        appendObjectsToBuilder(sb, listOfTypeParameters);\r\n        sb.append(\u0027]\u0027);\r\n        needsComma \u003d true;\r\n    }\r\n    if (arrayOfListOfTypeParameters !\u003d null) {\r\n        if (needsComma) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"\\\"arrayOfListOfTypeParameters\\\":[\");\r\n        appendObjectsToBuilder(sb, arrayOfListOfTypeParameters);\r\n        sb.append(\u0027]\u0027);\r\n        needsComma \u003d true;\r\n    }\r\n    if (listOfWildcardTypeParameters !\u003d null) {\r\n        if (needsComma) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"\\\"listOfWildcardTypeParameters\\\":[\");\r\n        appendObjectsToBuilder(sb, listOfWildcardTypeParameters);\r\n        sb.append(\u0027]\u0027);\r\n        needsComma \u003d true;\r\n    }\r\n    if (arrayOfListOfWildcardTypeParameters !\u003d null) {\r\n        if (needsComma) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"\\\"arrayOfListOfWildcardTypeParameters\\\":[\");\r\n        appendObjectsToBuilder(sb, arrayOfListOfWildcardTypeParameters);\r\n        sb.append(\u0027]\u0027);\r\n        needsComma \u003d true;\r\n    }\r\n    sb.append(\u0027}\u0027);\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest.ObjectWithTypeVariables",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "private void appendObjectsToBuilder(StringBuilder sb, Iterable\u003c? extends T\u003e iterable) {\r\n    boolean isFirst \u003d true;\r\n    for (T obj : iterable) {\r\n        if (!isFirst) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        isFirst \u003d false;\r\n        sb.append(toString(obj));\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest.ObjectWithTypeVariables",
      "methodName": "appendObjectsToBuilder",
      "parameterTypes": [
        "StringBuilder",
        "Iterable\u003c? extends T\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void appendObjectsToBuilder(StringBuilder sb, List\u003c? extends T\u003e[] arrayOfList) {\r\n    boolean isFirst \u003d true;\r\n    for (List\u003c? extends T\u003e list : arrayOfList) {\r\n        if (!isFirst) {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        isFirst \u003d false;\r\n        if (list !\u003d null) {\r\n            sb.append(\u0027[\u0027);\r\n            appendObjectsToBuilder(sb, list);\r\n            sb.append(\u0027]\u0027);\r\n        } else {\r\n            sb.append(\"null\");\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest.ObjectWithTypeVariables",
      "methodName": "appendObjectsToBuilder",
      "parameterTypes": [
        "StringBuilder",
        "List\u003c? extends T\u003e[]"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public String toString(T obj) {\r\n    return obj.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest.ObjectWithTypeVariables",
      "methodName": "toString",
      "parameterTypes": [
        "T"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    final int prime \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d prime * result + ((a \u003d\u003d null) ? 0 : a.hashCode());\r\n    result \u003d prime * result + ((b \u003d\u003d null) ? 0 : b.hashCode());\r\n    result \u003d prime * result + ((c \u003d\u003d null) ? 0 : c.hashCode());\r\n    result \u003d prime * result + ((d \u003d\u003d null) ? 0 : d.hashCode());\r\n    result \u003d prime * result + ((e \u003d\u003d null) ? 0 : e.hashCode());\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest.MultiParameters",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    if (this \u003d\u003d o) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof MultiParameters\u003c?, ?, ?, ?, ?\u003e)) {\r\n        return false;\r\n    }\r\n    MultiParameters\u003c?, ?, ?, ?, ?\u003e that \u003d (MultiParameters\u003c?, ?, ?, ?, ?\u003e) o;\r\n    return Objects.equal(a, that.a) \u0026\u0026 Objects.equal(b, that.b) \u0026\u0026 Objects.equal(c, that.c) \u0026\u0026 Objects.equal(d, that.d) \u0026\u0026 Objects.equal(e, that.e);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest.MultiParameters",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeepParameterizedTypeSerialization() {\r\n    Amount\u003cMyQuantity\u003e amount \u003d new Amount\u003c\u003e();\r\n    String json \u003d gson.toJson(amount);\r\n    assertThat(json).contains(\"value\");\r\n    assertThat(json).contains(\"30\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testDeepParameterizedTypeSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeepParameterizedTypeDeserialization() {\r\n    String json \u003d \"{value:30}\";\r\n    Type type \u003d new TypeToken\u003cAmount\u003cMyQuantity\u003e\u003e() {\r\n    }.getType();\r\n    Amount\u003cMyQuantity\u003e amount \u003d gson.fromJson(json, type);\r\n    assertThat(amount.value).isEqualTo(30);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testDeepParameterizedTypeDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// End: tests to reproduce issue 103\r\nprivate static void assertCorrectlyDeserialized(Object object) {\r\n    @SuppressWarnings(\"unchecked\")\r\n    List\u003cQuantity\u003e list \u003d (List\u003cQuantity\u003e) object;\r\n    assertThat(list.size()).isEqualTo(1);\r\n    assertThat(list.get(0).q).isEqualTo(4);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "assertCorrectlyDeserialized",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonFromJsonTypeToken() {\r\n    TypeToken\u003cList\u003cQuantity\u003e\u003e typeToken \u003d new TypeToken\u003cList\u003cQuantity\u003e\u003e() {\r\n    };\r\n    Type type \u003d typeToken.getType();\r\n    {\r\n        JsonObject jsonObject \u003d new JsonObject();\r\n        jsonObject.addProperty(\"q\", 4);\r\n        JsonArray jsonArray \u003d new JsonArray();\r\n        jsonArray.add(jsonObject);\r\n        assertCorrectlyDeserialized(gson.fromJson(jsonArray, typeToken));\r\n        assertCorrectlyDeserialized(gson.fromJson(jsonArray, type));\r\n    }\r\n    String json \u003d \"[{\\\"q\\\":4}]\";\r\n    {\r\n        assertCorrectlyDeserialized(gson.fromJson(json, typeToken));\r\n        assertCorrectlyDeserialized(gson.fromJson(json, type));\r\n    }\r\n    {\r\n        assertCorrectlyDeserialized(gson.fromJson(new StringReader(json), typeToken));\r\n        assertCorrectlyDeserialized(gson.fromJson(new StringReader(json), type));\r\n    }\r\n    {\r\n        JsonReader reader \u003d new JsonReader(new StringReader(json));\r\n        assertCorrectlyDeserialized(gson.fromJson(reader, typeToken));\r\n        reader \u003d new JsonReader(new StringReader(json));\r\n        assertCorrectlyDeserialized(gson.fromJson(reader, type));\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ParameterizedTypesTest",
      "methodName": "testGsonFromJsonTypeToken",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrettyPrintingTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrettyPrintList() {\r\n    BagOfPrimitives b \u003d new BagOfPrimitives();\r\n    List\u003cBagOfPrimitives\u003e listOfB \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c 15; ++i) {\r\n        listOfB.add(b);\r\n    }\r\n    Type typeOfSrc \u003d new TypeToken\u003cList\u003cBagOfPrimitives\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(listOfB, typeOfSrc);\r\n    print(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrettyPrintingTest",
      "methodName": "testPrettyPrintList",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrettyPrintArrayOfObjects() {\r\n    ArrayOfObjects target \u003d new ArrayOfObjects();\r\n    String json \u003d gson.toJson(target);\r\n    print(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrettyPrintingTest",
      "methodName": "testPrettyPrintArrayOfObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrettyPrintArrayOfPrimitives() {\r\n    int[] ints \u003d new int[] { 1, 2, 3, 4, 5 };\r\n    String json \u003d gson.toJson(ints);\r\n    assertThat(json).isEqualTo(\"[\\n  1,\\n  2,\\n  3,\\n  4,\\n  5\\n]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrettyPrintingTest",
      "methodName": "testPrettyPrintArrayOfPrimitives",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrettyPrintArrayOfPrimitiveArrays() {\r\n    int[][] ints \u003d new int[][] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 }, { 9, 0 }, { 10 } };\r\n    String json \u003d gson.toJson(ints);\r\n    assertThat(json).isEqualTo(\"[\\n  [\\n    1,\\n    2\\n  ],\\n  [\\n    3,\\n    4\\n  ],\\n  [\\n    5,\\n    6\\n  ],\" + \"\\n  [\\n    7,\\n    8\\n  ],\\n  [\\n    9,\\n    0\\n  ],\\n  [\\n    10\\n  ]\\n]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrettyPrintingTest",
      "methodName": "testPrettyPrintArrayOfPrimitiveArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrettyPrintListOfPrimitiveArrays() {\r\n    List\u003cInteger[]\u003e list \u003d Arrays.asList(new Integer[][] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 }, { 9, 0 }, { 10 } });\r\n    String json \u003d gson.toJson(list);\r\n    assertThat(json).isEqualTo(\"[\\n  [\\n    1,\\n    2\\n  ],\\n  [\\n    3,\\n    4\\n  ],\\n  [\\n    5,\\n    6\\n  ],\" + \"\\n  [\\n    7,\\n    8\\n  ],\\n  [\\n    9,\\n    0\\n  ],\\n  [\\n    10\\n  ]\\n]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrettyPrintingTest",
      "methodName": "testPrettyPrintListOfPrimitiveArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMap() {\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"abc\", 1);\r\n    map.put(\"def\", 5);\r\n    String json \u003d gson.toJson(map);\r\n    assertThat(json).isEqualTo(\"{\\n  \\\"abc\\\": 1,\\n  \\\"def\\\": 5\\n}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrettyPrintingTest",
      "methodName": "testMap",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// In response to bug 153\r\n@Test\r\npublic void testEmptyMapField() {\r\n    ClassWithMap obj \u003d new ClassWithMap();\r\n    obj.map \u003d new LinkedHashMap\u003c\u003e();\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).contains(\"{\\n  \\\"map\\\": {},\\n  \\\"value\\\": 2\\n}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrettyPrintingTest",
      "methodName": "testEmptyMapField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultipleArrays() {\r\n    int[][][] ints \u003d new int[][][] { { { 1 }, { 2 } } };\r\n    String json \u003d gson.toJson(ints);\r\n    assertThat(json).isEqualTo(\"[\\n  [\\n    [\\n      1\\n    ],\\n    [\\n      2\\n    ]\\n  ]\\n]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrettyPrintingTest",
      "methodName": "testMultipleArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void print(String msg) {\r\n    if (DEBUG) {\r\n        System.out.println(msg);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrettyPrintingTest",
      "methodName": "print",
      "parameterTypes": [
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveCharacterTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveCharacterAutoboxedSerialization() {\r\n    assertThat(gson.toJson(\u0027A\u0027)).isEqualTo(\"\\\"A\\\"\");\r\n    assertThat(gson.toJson(\u0027A\u0027, char.class)).isEqualTo(\"\\\"A\\\"\");\r\n    assertThat(gson.toJson(\u0027A\u0027, Character.class)).isEqualTo(\"\\\"A\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveCharacterTest",
      "methodName": "testPrimitiveCharacterAutoboxedSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveCharacterAutoboxedDeserialization() {\r\n    char expected \u003d \u0027a\u0027;\r\n    char actual \u003d gson.fromJson(\"a\", char.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    actual \u003d gson.fromJson(\"\\\"a\\\"\", char.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    actual \u003d gson.fromJson(\"a\", Character.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveCharacterTest",
      "methodName": "testPrimitiveCharacterAutoboxedDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveIntegerAutoboxedSerialization() {\r\n    assertThat(gson.toJson(1)).isEqualTo(\"1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveIntegerAutoboxedSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveIntegerAutoboxedDeserialization() {\r\n    int expected \u003d 1;\r\n    int actual \u003d gson.fromJson(\"1\", int.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    actual \u003d gson.fromJson(\"1\", Integer.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveIntegerAutoboxedDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testByteSerialization() {\r\n    assertThat(gson.toJson(1, byte.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(1, Byte.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(Byte.MIN_VALUE, Byte.class)).isEqualTo(Byte.toString(Byte.MIN_VALUE));\r\n    assertThat(gson.toJson(Byte.MAX_VALUE, Byte.class)).isEqualTo(Byte.toString(Byte.MAX_VALUE));\r\n    // Should perform narrowing conversion\r\n    assertThat(gson.toJson(128, Byte.class)).isEqualTo(\"-128\");\r\n    assertThat(gson.toJson(1.5, Byte.class)).isEqualTo(\"1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testByteSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testByteDeserialization() {\r\n    Byte boxed \u003d gson.fromJson(\"1\", Byte.class);\r\n    assertThat(boxed).isEqualTo(1);\r\n    byte primitive \u003d gson.fromJson(\"1\", byte.class);\r\n    assertThat(primitive).isEqualTo(1);\r\n    byte[] bytes \u003d gson.fromJson(\"[-128, 0, 127, 255]\", byte[].class);\r\n    assertThat(bytes).isEqualTo(new byte[] { -128, 0, 127, -1 });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testByteDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testByteDeserializationLossy() {\r\n    JsonSyntaxException e \u003d assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"-129\", byte.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Lossy conversion from -129 to byte; at path $\");\r\n    e \u003d assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"256\", byte.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Lossy conversion from 256 to byte; at path $\");\r\n    e \u003d assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"2147483648\", byte.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.lang.NumberFormatException: Expected an int but was 2147483648 at line 1 column 11 path $\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testByteDeserializationLossy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testShortSerialization() {\r\n    assertThat(gson.toJson(1, short.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(1, Short.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(Short.MIN_VALUE, Short.class)).isEqualTo(Short.toString(Short.MIN_VALUE));\r\n    assertThat(gson.toJson(Short.MAX_VALUE, Short.class)).isEqualTo(Short.toString(Short.MAX_VALUE));\r\n    // Should perform widening conversion\r\n    assertThat(gson.toJson((byte) 1, Short.class)).isEqualTo(\"1\");\r\n    // Should perform narrowing conversion\r\n    assertThat(gson.toJson(32768, Short.class)).isEqualTo(\"-32768\");\r\n    assertThat(gson.toJson(1.5, Short.class)).isEqualTo(\"1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testShortSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testShortDeserialization() {\r\n    Short boxed \u003d gson.fromJson(\"1\", Short.class);\r\n    assertThat(boxed).isEqualTo(1);\r\n    short primitive \u003d gson.fromJson(\"1\", short.class);\r\n    assertThat(primitive).isEqualTo(1);\r\n    short[] shorts \u003d gson.fromJson(\"[-32768, 0, 32767, 65535]\", short[].class);\r\n    assertThat(shorts).isEqualTo(new short[] { -32768, 0, 32767, -1 });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testShortDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testShortDeserializationLossy() {\r\n    JsonSyntaxException e \u003d assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"-32769\", short.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Lossy conversion from -32769 to short; at path $\");\r\n    e \u003d assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"65536\", short.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Lossy conversion from 65536 to short; at path $\");\r\n    e \u003d assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"2147483648\", short.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.lang.NumberFormatException: Expected an int but was 2147483648 at line 1 column 11 path $\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testShortDeserializationLossy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIntSerialization() {\r\n    assertThat(gson.toJson(1, int.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(1, Integer.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(Integer.MIN_VALUE, Integer.class)).isEqualTo(Integer.toString(Integer.MIN_VALUE));\r\n    assertThat(gson.toJson(Integer.MAX_VALUE, Integer.class)).isEqualTo(Integer.toString(Integer.MAX_VALUE));\r\n    // Should perform widening conversion\r\n    assertThat(gson.toJson((byte) 1, Integer.class)).isEqualTo(\"1\");\r\n    // Should perform narrowing conversion\r\n    assertThat(gson.toJson(2147483648L, Integer.class)).isEqualTo(\"-2147483648\");\r\n    assertThat(gson.toJson(1.5, Integer.class)).isEqualTo(\"1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testIntSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLongSerialization() {\r\n    assertThat(gson.toJson(1L, long.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(1L, Long.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(Long.MIN_VALUE, Long.class)).isEqualTo(Long.toString(Long.MIN_VALUE));\r\n    assertThat(gson.toJson(Long.MAX_VALUE, Long.class)).isEqualTo(Long.toString(Long.MAX_VALUE));\r\n    // Should perform widening conversion\r\n    assertThat(gson.toJson((byte) 1, Long.class)).isEqualTo(\"1\");\r\n    // Should perform narrowing conversion\r\n    assertThat(gson.toJson(1.5, Long.class)).isEqualTo(\"1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testLongSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFloatSerialization() {\r\n    assertThat(gson.toJson(1.5f, float.class)).isEqualTo(\"1.5\");\r\n    assertThat(gson.toJson(1.5f, Float.class)).isEqualTo(\"1.5\");\r\n    assertThat(gson.toJson(Float.MIN_VALUE, Float.class)).isEqualTo(Float.toString(Float.MIN_VALUE));\r\n    assertThat(gson.toJson(Float.MAX_VALUE, Float.class)).isEqualTo(Float.toString(Float.MAX_VALUE));\r\n    // Should perform widening conversion\r\n    assertThat(gson.toJson((byte) 1, Float.class)).isEqualTo(\"1.0\");\r\n    // (This widening conversion is actually lossy)\r\n    assertThat(gson.toJson(Long.MAX_VALUE - 10L, Float.class)).isEqualTo(Float.toString((float) (Long.MAX_VALUE - 10L)));\r\n    // Should perform narrowing conversion\r\n    gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    assertThat(gson.toJson(Double.MAX_VALUE, Float.class)).isEqualTo(\"Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testFloatSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleSerialization() {\r\n    assertThat(gson.toJson(1.5, double.class)).isEqualTo(\"1.5\");\r\n    assertThat(gson.toJson(1.5, Double.class)).isEqualTo(\"1.5\");\r\n    assertThat(gson.toJson(Double.MIN_VALUE, Double.class)).isEqualTo(Double.toString(Double.MIN_VALUE));\r\n    assertThat(gson.toJson(Double.MAX_VALUE, Double.class)).isEqualTo(Double.toString(Double.MAX_VALUE));\r\n    // Should perform widening conversion\r\n    assertThat(gson.toJson((byte) 1, Double.class)).isEqualTo(\"1.0\");\r\n    // (This widening conversion is actually lossy)\r\n    assertThat(gson.toJson(Long.MAX_VALUE - 10L, Double.class)).isEqualTo(Double.toString((double) (Long.MAX_VALUE - 10L)));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDoubleSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveIntegerAutoboxedInASingleElementArraySerialization() {\r\n    int[] target \u003d { -9332 };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[-9332]\");\r\n    assertThat(gson.toJson(target, int[].class)).isEqualTo(\"[-9332]\");\r\n    assertThat(gson.toJson(target, Integer[].class)).isEqualTo(\"[-9332]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveIntegerAutoboxedInASingleElementArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReallyLongValuesSerialization() {\r\n    long value \u003d 333961828784581L;\r\n    assertThat(gson.toJson(value)).isEqualTo(\"333961828784581\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testReallyLongValuesSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReallyLongValuesDeserialization() {\r\n    String json \u003d \"333961828784581\";\r\n    long value \u003d gson.fromJson(json, Long.class);\r\n    assertThat(value).isEqualTo(333961828784581L);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testReallyLongValuesDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveLongAutoboxedSerialization() {\r\n    assertThat(gson.toJson(1L, long.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(1L, Long.class)).isEqualTo(\"1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveLongAutoboxedSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveLongAutoboxedDeserialization() {\r\n    long expected \u003d 1L;\r\n    long actual \u003d gson.fromJson(\"1\", long.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    actual \u003d gson.fromJson(\"1\", Long.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveLongAutoboxedDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveLongAutoboxedInASingleElementArraySerialization() {\r\n    long[] target \u003d { -23L };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[-23]\");\r\n    assertThat(gson.toJson(target, long[].class)).isEqualTo(\"[-23]\");\r\n    assertThat(gson.toJson(target, Long[].class)).isEqualTo(\"[-23]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveLongAutoboxedInASingleElementArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveBooleanAutoboxedSerialization() {\r\n    assertThat(gson.toJson(true)).isEqualTo(\"true\");\r\n    assertThat(gson.toJson(false)).isEqualTo(\"false\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveBooleanAutoboxedSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBooleanDeserialization() {\r\n    boolean value \u003d gson.fromJson(\"false\", boolean.class);\r\n    assertThat(value).isEqualTo(false);\r\n    value \u003d gson.fromJson(\"true\", boolean.class);\r\n    assertThat(value).isEqualTo(true);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBooleanDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveBooleanAutoboxedInASingleElementArraySerialization() {\r\n    boolean[] target \u003d { false };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[false]\");\r\n    assertThat(gson.toJson(target, boolean[].class)).isEqualTo(\"[false]\");\r\n    assertThat(gson.toJson(target, Boolean[].class)).isEqualTo(\"[false]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveBooleanAutoboxedInASingleElementArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNumberSerialization() {\r\n    Number expected \u003d 1L;\r\n    String json \u003d gson.toJson(expected);\r\n    assertThat(json).isEqualTo(expected.toString());\r\n    json \u003d gson.toJson(expected, Number.class);\r\n    assertThat(json).isEqualTo(expected.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testNumberSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNumberDeserialization() {\r\n    String json \u003d \"1\";\r\n    Number expected \u003d Integer.valueOf(json);\r\n    Number actual \u003d gson.fromJson(json, Number.class);\r\n    assertThat(actual.intValue()).isEqualTo(expected.intValue());\r\n    json \u003d String.valueOf(Long.MAX_VALUE);\r\n    expected \u003d Long.valueOf(json);\r\n    actual \u003d gson.fromJson(json, Number.class);\r\n    assertThat(actual.longValue()).isEqualTo(expected.longValue());\r\n    json \u003d \"1.0\";\r\n    actual \u003d gson.fromJson(json, Number.class);\r\n    assertThat(actual.longValue()).isEqualTo(1L);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testNumberDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNumberAsStringDeserialization() {\r\n    Number value \u003d gson.fromJson(\"\\\"18\\\"\", Number.class);\r\n    assertThat(value.intValue()).isEqualTo(18);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testNumberAsStringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveDoubleAutoboxedSerialization() {\r\n    assertThat(gson.toJson(-122.08234335D)).isEqualTo(\"-122.08234335\");\r\n    assertThat(gson.toJson(122.08112002D)).isEqualTo(\"122.08112002\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveDoubleAutoboxedSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveDoubleAutoboxedDeserialization() {\r\n    double actual \u003d gson.fromJson(\"-122.08858585\", double.class);\r\n    assertThat(actual).isEqualTo(-122.08858585D);\r\n    actual \u003d gson.fromJson(\"122.023900008000\", Double.class);\r\n    assertThat(actual).isEqualTo(122.023900008D);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveDoubleAutoboxedDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveDoubleAutoboxedInASingleElementArraySerialization() {\r\n    double[] target \u003d { -122.08D };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[-122.08]\");\r\n    assertThat(gson.toJson(target, double[].class)).isEqualTo(\"[-122.08]\");\r\n    assertThat(gson.toJson(target, Double[].class)).isEqualTo(\"[-122.08]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveDoubleAutoboxedInASingleElementArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleAsStringRepresentationDeserialization() {\r\n    String doubleValue \u003d \"1.0043E+5\";\r\n    Double expected \u003d Double.valueOf(doubleValue);\r\n    Double actual \u003d gson.fromJson(doubleValue, Double.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    double actual1 \u003d gson.fromJson(doubleValue, double.class);\r\n    assertThat(actual1).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDoubleAsStringRepresentationDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleNoFractAsStringRepresentationDeserialization() {\r\n    String doubleValue \u003d \"1E+5\";\r\n    Double expected \u003d Double.valueOf(doubleValue);\r\n    Double actual \u003d gson.fromJson(doubleValue, Double.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    double actual1 \u003d gson.fromJson(doubleValue, double.class);\r\n    assertThat(actual1).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDoubleNoFractAsStringRepresentationDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleArrayDeserialization() {\r\n    String json \u003d \"[0.0, 0.004761904761904762, 3.4013606962703525E-4, 7.936508173034305E-4,\" + \"0.0011904761904761906, 0.0]\";\r\n    double[] values \u003d gson.fromJson(json, double[].class);\r\n    assertThat(values).hasLength(6);\r\n    assertThat(values[0]).isEqualTo(0.0);\r\n    assertThat(values[1]).isEqualTo(0.004761904761904762);\r\n    assertThat(values[2]).isEqualTo(3.4013606962703525E-4);\r\n    assertThat(values[3]).isEqualTo(7.936508173034305E-4);\r\n    assertThat(values[4]).isEqualTo(0.0011904761904761906);\r\n    assertThat(values[5]).isEqualTo(0.0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDoubleArrayDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLargeDoubleDeserialization() {\r\n    String doubleValue \u003d \"1.234567899E8\";\r\n    Double expected \u003d Double.valueOf(doubleValue);\r\n    Double actual \u003d gson.fromJson(doubleValue, Double.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n    double actual1 \u003d gson.fromJson(doubleValue, double.class);\r\n    assertThat(actual1).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testLargeDoubleDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalSerialization() {\r\n    BigDecimal target \u003d new BigDecimal(\"-122.0e-21\");\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(new BigDecimal(json)).isEqualTo(target);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigDecimalSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalDeserialization() {\r\n    BigDecimal target \u003d new BigDecimal(\"-122.0e-21\");\r\n    String json \u003d \"-122.0e-21\";\r\n    assertThat(gson.fromJson(json, BigDecimal.class)).isEqualTo(target);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigDecimalDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalInASingleElementArraySerialization() {\r\n    BigDecimal[] target \u003d { new BigDecimal(\"-122.08e-21\") };\r\n    String json \u003d gson.toJson(target);\r\n    String actual \u003d extractElementFromArray(json);\r\n    assertThat(new BigDecimal(actual)).isEqualTo(target[0]);\r\n    json \u003d gson.toJson(target, BigDecimal[].class);\r\n    actual \u003d extractElementFromArray(json);\r\n    assertThat(new BigDecimal(actual)).isEqualTo(target[0]);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigDecimalInASingleElementArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSmallValueForBigDecimalSerialization() {\r\n    BigDecimal target \u003d new BigDecimal(\"1.55\");\r\n    String actual \u003d gson.toJson(target);\r\n    assertThat(actual).isEqualTo(target.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testSmallValueForBigDecimalSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSmallValueForBigDecimalDeserialization() {\r\n    BigDecimal expected \u003d new BigDecimal(\"1.55\");\r\n    BigDecimal actual \u003d gson.fromJson(\"1.55\", BigDecimal.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testSmallValueForBigDecimalDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalPreservePrecisionSerialization() {\r\n    String expectedValue \u003d \"1.000\";\r\n    BigDecimal obj \u003d new BigDecimal(expectedValue);\r\n    String actualValue \u003d gson.toJson(obj);\r\n    assertThat(actualValue).isEqualTo(expectedValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigDecimalPreservePrecisionSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalPreservePrecisionDeserialization() {\r\n    String json \u003d \"1.000\";\r\n    BigDecimal expected \u003d new BigDecimal(json);\r\n    BigDecimal actual \u003d gson.fromJson(json, BigDecimal.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigDecimalPreservePrecisionDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalAsStringRepresentationDeserialization() {\r\n    String doubleValue \u003d \"0.05E+5\";\r\n    BigDecimal expected \u003d new BigDecimal(doubleValue);\r\n    BigDecimal actual \u003d gson.fromJson(doubleValue, BigDecimal.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigDecimalAsStringRepresentationDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalNoFractAsStringRepresentationDeserialization() {\r\n    String doubleValue \u003d \"5E+5\";\r\n    BigDecimal expected \u003d new BigDecimal(doubleValue);\r\n    BigDecimal actual \u003d gson.fromJson(doubleValue, BigDecimal.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigDecimalNoFractAsStringRepresentationDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigIntegerSerialization() {\r\n    BigInteger target \u003d new BigInteger(\"12121211243123245845384534687435634558945453489543985435\");\r\n    assertThat(gson.toJson(target)).isEqualTo(target.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigIntegerSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigIntegerDeserialization() {\r\n    String json \u003d \"12121211243123245845384534687435634558945453489543985435\";\r\n    BigInteger target \u003d new BigInteger(json);\r\n    assertThat(gson.fromJson(json, BigInteger.class)).isEqualTo(target);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigIntegerDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigIntegerInASingleElementArraySerialization() {\r\n    BigInteger[] target \u003d { new BigInteger(\"1212121243434324323254365345367456456456465464564564\") };\r\n    String json \u003d gson.toJson(target);\r\n    String actual \u003d extractElementFromArray(json);\r\n    assertThat(new BigInteger(actual)).isEqualTo(target[0]);\r\n    json \u003d gson.toJson(target, BigInteger[].class);\r\n    actual \u003d extractElementFromArray(json);\r\n    assertThat(new BigInteger(actual)).isEqualTo(target[0]);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigIntegerInASingleElementArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSmallValueForBigIntegerSerialization() {\r\n    BigInteger target \u003d new BigInteger(\"15\");\r\n    String actual \u003d gson.toJson(target);\r\n    assertThat(actual).isEqualTo(target.toString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testSmallValueForBigIntegerSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSmallValueForBigIntegerDeserialization() {\r\n    BigInteger expected \u003d new BigInteger(\"15\");\r\n    BigInteger actual \u003d gson.fromJson(\"15\", BigInteger.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testSmallValueForBigIntegerDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBadValueForBigIntegerDeserialization() {\r\n    try {\r\n        gson.fromJson(\"15.099\", BigInteger.class);\r\n        fail(\"BigInteger can not be decimal values.\");\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBadValueForBigIntegerDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLazilyParsedNumberSerialization() {\r\n    LazilyParsedNumber target \u003d new LazilyParsedNumber(\"1.5\");\r\n    String actual \u003d gson.toJson(target);\r\n    assertThat(actual).isEqualTo(\"1.5\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testLazilyParsedNumberSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLazilyParsedNumberDeserialization() {\r\n    LazilyParsedNumber expected \u003d new LazilyParsedNumber(\"1.5\");\r\n    LazilyParsedNumber actual \u003d gson.fromJson(\"1.5\", LazilyParsedNumber.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testLazilyParsedNumberDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMoreSpecificSerialization() {\r\n    Gson gson \u003d new Gson();\r\n    String expected \u003d \"This is a string\";\r\n    String expectedJson \u003d gson.toJson(expected);\r\n    Serializable serializableString \u003d expected;\r\n    String actualJson \u003d gson.toJson(serializableString, Serializable.class);\r\n    assertThat(actualJson).isNotEqualTo(expectedJson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testMoreSpecificSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private String extractElementFromArray(String json) {\r\n    return json.substring(json.indexOf(\u0027[\u0027) + 1, json.indexOf(\u0027]\u0027));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "extractElementFromArray",
      "parameterTypes": [
        "String"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleNaNSerializationNotSupportedByDefault() {\r\n    try {\r\n        double nan \u003d Double.NaN;\r\n        gson.toJson(nan);\r\n        fail(\"Gson should not accept NaN for serialization\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Double.NaN);\r\n        fail(\"Gson should not accept NaN for serialization\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDoubleNaNSerializationNotSupportedByDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleNaNSerialization() {\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    double nan \u003d Double.NaN;\r\n    assertThat(gson.toJson(nan)).isEqualTo(\"NaN\");\r\n    assertThat(gson.toJson(Double.NaN)).isEqualTo(\"NaN\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDoubleNaNSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleNaNDeserialization() {\r\n    assertThat(Double.isNaN(gson.fromJson(\"NaN\", Double.class))).isTrue();\r\n    assertThat(Double.isNaN(gson.fromJson(\"NaN\", double.class))).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDoubleNaNDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFloatNaNSerializationNotSupportedByDefault() {\r\n    try {\r\n        float nan \u003d Float.NaN;\r\n        gson.toJson(nan);\r\n        fail(\"Gson should not accept NaN for serialization\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Float.NaN);\r\n        fail(\"Gson should not accept NaN for serialization\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testFloatNaNSerializationNotSupportedByDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFloatNaNSerialization() {\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    float nan \u003d Float.NaN;\r\n    assertThat(gson.toJson(nan)).isEqualTo(\"NaN\");\r\n    assertThat(gson.toJson(Float.NaN)).isEqualTo(\"NaN\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testFloatNaNSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFloatNaNDeserialization() {\r\n    assertThat(Float.isNaN(gson.fromJson(\"NaN\", Float.class))).isTrue();\r\n    assertThat(Float.isNaN(gson.fromJson(\"NaN\", float.class))).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testFloatNaNDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalNaNDeserializationNotSupported() {\r\n    try {\r\n        gson.fromJson(\"NaN\", BigDecimal.class);\r\n        fail(\"Gson should not accept NaN for deserialization by default.\");\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigDecimalNaNDeserializationNotSupported",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleInfinitySerializationNotSupportedByDefault() {\r\n    try {\r\n        double infinity \u003d Double.POSITIVE_INFINITY;\r\n        gson.toJson(infinity);\r\n        fail(\"Gson should not accept positive infinity for serialization by default.\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Double.POSITIVE_INFINITY);\r\n        fail(\"Gson should not accept positive infinity for serialization by default.\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDoubleInfinitySerializationNotSupportedByDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleInfinitySerialization() {\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    double infinity \u003d Double.POSITIVE_INFINITY;\r\n    assertThat(gson.toJson(infinity)).isEqualTo(\"Infinity\");\r\n    assertThat(gson.toJson(Double.POSITIVE_INFINITY)).isEqualTo(\"Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDoubleInfinitySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleInfinityDeserialization() {\r\n    assertThat(Double.isInfinite(gson.fromJson(\"Infinity\", Double.class))).isTrue();\r\n    assertThat(Double.isInfinite(gson.fromJson(\"Infinity\", double.class))).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDoubleInfinityDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFloatInfinitySerializationNotSupportedByDefault() {\r\n    try {\r\n        float infinity \u003d Float.POSITIVE_INFINITY;\r\n        gson.toJson(infinity);\r\n        fail(\"Gson should not accept positive infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Float.POSITIVE_INFINITY);\r\n        fail(\"Gson should not accept positive infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testFloatInfinitySerializationNotSupportedByDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFloatInfinitySerialization() {\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    float infinity \u003d Float.POSITIVE_INFINITY;\r\n    assertThat(gson.toJson(infinity)).isEqualTo(\"Infinity\");\r\n    assertThat(gson.toJson(Float.POSITIVE_INFINITY)).isEqualTo(\"Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testFloatInfinitySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFloatInfinityDeserialization() {\r\n    assertThat(Float.isInfinite(gson.fromJson(\"Infinity\", Float.class))).isTrue();\r\n    assertThat(Float.isInfinite(gson.fromJson(\"Infinity\", float.class))).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testFloatInfinityDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalInfinityDeserializationNotSupported() {\r\n    try {\r\n        gson.fromJson(\"Infinity\", BigDecimal.class);\r\n        fail(\"Gson should not accept positive infinity for deserialization with BigDecimal\");\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigDecimalInfinityDeserializationNotSupported",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNegativeInfinitySerializationNotSupportedByDefault() {\r\n    try {\r\n        double negativeInfinity \u003d Double.NEGATIVE_INFINITY;\r\n        gson.toJson(negativeInfinity);\r\n        fail(\"Gson should not accept negative infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Double.NEGATIVE_INFINITY);\r\n        fail(\"Gson should not accept negative infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testNegativeInfinitySerializationNotSupportedByDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNegativeInfinitySerialization() {\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    double negativeInfinity \u003d Double.NEGATIVE_INFINITY;\r\n    assertThat(gson.toJson(negativeInfinity)).isEqualTo(\"-Infinity\");\r\n    assertThat(gson.toJson(Double.NEGATIVE_INFINITY)).isEqualTo(\"-Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testNegativeInfinitySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNegativeInfinityDeserialization() {\r\n    assertThat(Double.isInfinite(gson.fromJson(\"-Infinity\", double.class))).isTrue();\r\n    assertThat(Double.isInfinite(gson.fromJson(\"-Infinity\", Double.class))).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testNegativeInfinityDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNegativeInfinityFloatSerializationNotSupportedByDefault() {\r\n    try {\r\n        float negativeInfinity \u003d Float.NEGATIVE_INFINITY;\r\n        gson.toJson(negativeInfinity);\r\n        fail(\"Gson should not accept negative infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        gson.toJson(Float.NEGATIVE_INFINITY);\r\n        fail(\"Gson should not accept negative infinity for serialization by default\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testNegativeInfinityFloatSerializationNotSupportedByDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNegativeInfinityFloatSerialization() {\r\n    Gson gson \u003d new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n    float negativeInfinity \u003d Float.NEGATIVE_INFINITY;\r\n    assertThat(gson.toJson(negativeInfinity)).isEqualTo(\"-Infinity\");\r\n    assertThat(gson.toJson(Float.NEGATIVE_INFINITY)).isEqualTo(\"-Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testNegativeInfinityFloatSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNegativeInfinityFloatDeserialization() {\r\n    assertThat(Float.isInfinite(gson.fromJson(\"-Infinity\", float.class))).isTrue();\r\n    assertThat(Float.isInfinite(gson.fromJson(\"-Infinity\", Float.class))).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testNegativeInfinityFloatDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimalNegativeInfinityDeserializationNotSupported() {\r\n    try {\r\n        gson.fromJson(\"-Infinity\", BigDecimal.class);\r\n        fail(\"Gson should not accept positive infinity for deserialization\");\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testBigDecimalNegativeInfinityDeserializationNotSupported",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLongAsStringSerialization() {\r\n    gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\r\n    String result \u003d gson.toJson(15L);\r\n    assertThat(result).isEqualTo(\"\\\"15\\\"\");\r\n    // Test with an integer and ensure its still a number\r\n    result \u003d gson.toJson(2);\r\n    assertThat(result).isEqualTo(\"2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testLongAsStringSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLongAsStringDeserialization() {\r\n    long value \u003d gson.fromJson(\"\\\"15\\\"\", long.class);\r\n    assertThat(value).isEqualTo(15);\r\n    gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\r\n    value \u003d gson.fromJson(\"\\\"25\\\"\", long.class);\r\n    assertThat(value).isEqualTo(25);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testLongAsStringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testQuotedStringSerializationAndDeserialization() {\r\n    String value \u003d \"String Blah Blah Blah...1, 2, 3\";\r\n    String serializedForm \u003d gson.toJson(value);\r\n    assertThat(serializedForm).isEqualTo(\"\\\"\" + value + \"\\\"\");\r\n    String actual \u003d gson.fromJson(serializedForm, String.class);\r\n    assertThat(actual).isEqualTo(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testQuotedStringSerializationAndDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUnquotedStringDeserializationFails() {\r\n    assertThat(gson.fromJson(\"UnquotedSingleWord\", String.class)).isEqualTo(\"UnquotedSingleWord\");\r\n    String value \u003d \"String Blah Blah Blah...1, 2, 3\";\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(value, String.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testUnquotedStringDeserializationFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testHtmlCharacterSerialization() {\r\n    String target \u003d \"\u003cscript\u003evar a \u003d 12;\u003c/script\u003e\";\r\n    String result \u003d gson.toJson(target);\r\n    assertThat(result).isNotEqualTo(\u0027\"\u0027 + target + \u0027\"\u0027);\r\n    gson \u003d new GsonBuilder().disableHtmlEscaping().create();\r\n    result \u003d gson.toJson(target);\r\n    assertThat(result).isEqualTo(\u0027\"\u0027 + target + \u0027\"\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testHtmlCharacterSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializePrimitiveWrapperAsObjectField() {\r\n    String json \u003d \"{i:10}\";\r\n    ClassWithIntegerField target \u003d gson.fromJson(json, ClassWithIntegerField.class);\r\n    assertThat(target.i).isEqualTo(10);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializePrimitiveWrapperAsObjectField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrimitiveClassLiteral() {\r\n    assertThat(gson.fromJson(\"1\", int.class)).isEqualTo(1);\r\n    assertThat(gson.fromJson(new StringReader(\"1\"), int.class)).isEqualTo(1);\r\n    assertThat(gson.fromJson(new JsonPrimitive(1), int.class)).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testPrimitiveClassLiteral",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonObjectAsLongPrimitive() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"{\u0027abc\u0027:1}\", long.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonObjectAsLongPrimitive",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonArrayAsLongWrapper() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"[1,2,3]\", Long.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonArrayAsLongWrapper",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonArrayAsInt() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"[1, 2, 3, 4]\", int.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonArrayAsInt",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonObjectAsInteger() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"{}\", Integer.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonObjectAsInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonObjectAsShortPrimitive() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"{\u0027abc\u0027:1}\", short.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonObjectAsShortPrimitive",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonArrayAsShortWrapper() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"[\u0027a\u0027,\u0027b\u0027]\", Short.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonArrayAsShortWrapper",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonArrayAsDoublePrimitive() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"[1,2]\", double.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonArrayAsDoublePrimitive",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonObjectAsDoubleWrapper() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"{\u0027abc\u0027:1}\", Double.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonObjectAsDoubleWrapper",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonObjectAsFloatPrimitive() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"{\u0027abc\u0027:1}\", float.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonObjectAsFloatPrimitive",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonArrayAsFloatWrapper() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"[1,2,3]\", Float.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonArrayAsFloatWrapper",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonObjectAsBytePrimitive() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"{\u0027abc\u0027:1}\", byte.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonObjectAsBytePrimitive",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonArrayAsByteWrapper() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"[1,2,3,4]\", Byte.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonArrayAsByteWrapper",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonObjectAsBooleanPrimitive() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"{\u0027abc\u0027:1}\", boolean.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonObjectAsBooleanPrimitive",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonArrayAsBooleanWrapper() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"[1,2,3,4]\", Boolean.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonArrayAsBooleanWrapper",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonArrayAsBigDecimal() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"[1,2,3,4]\", BigDecimal.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonArrayAsBigDecimal",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonObjectAsBigDecimal() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"{\u0027a\u0027:1}\", BigDecimal.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonObjectAsBigDecimal",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonArrayAsBigInteger() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"[1,2,3,4]\", BigInteger.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonArrayAsBigInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonObjectAsBigInteger() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"{\u0027c\u0027:2}\", BigInteger.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonObjectAsBigInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonArrayAsNumber() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"[1,2,3,4]\", Number.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonArrayAsNumber",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeJsonObjectAsNumber() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"{\u0027c\u0027:2}\", Number.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializeJsonObjectAsNumber",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializingDecimalPointValueZeroSucceeds() {\r\n    assertThat(gson.fromJson(\"1.0\", Integer.class)).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializingDecimalPointValueZeroSucceeds",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializingNonZeroDecimalPointValuesAsIntegerFails() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"1.02\", Byte.class));\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"1.02\", Short.class));\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"1.02\", Integer.class));\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"1.02\", Long.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializingNonZeroDecimalPointValuesAsIntegerFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializingBigDecimalAsIntegerFails() {\r\n    JsonSyntaxException e \u003d assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"-122.08e-213\", Integer.class));\r\n    assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Expected an int but was -122.08e-213 at line 1 column 13 path $\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializingBigDecimalAsIntegerFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializingBigIntegerAsInteger() {\r\n    String number \u003d \"12121211243123245845384534687435634558945453489543985435\";\r\n    JsonSyntaxException e \u003d assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(number, Integer.class));\r\n    assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Expected an int but was \" + number + \" at line 1 column 57 path $\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializingBigIntegerAsInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializingBigIntegerAsLong() {\r\n    String number \u003d \"12121211243123245845384534687435634558945453489543985435\";\r\n    JsonSyntaxException e \u003d assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(number, Long.class));\r\n    assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Expected a long but was \" + number + \" at line 1 column 57 path $\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializingBigIntegerAsLong",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testValueVeryCloseToZeroIsZero() {\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", byte.class)).isEqualTo(0);\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", short.class)).isEqualTo(0);\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", int.class)).isEqualTo(0);\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", long.class)).isEqualTo(0);\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", float.class)).isEqualTo(-0.0f);\r\n    assertThat(gson.fromJson(\"-122.08e-2132\", double.class)).isEqualTo(-0.0);\r\n    assertThat(gson.fromJson(\"122.08e-2132\", float.class)).isEqualTo(0.0f);\r\n    assertThat(gson.fromJson(\"122.08e-2132\", double.class)).isEqualTo(0.0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testValueVeryCloseToZeroIsZero",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializingBigDecimalAsBigIntegerFails() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e gson.fromJson(\"-122.08e-213\", BigInteger.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializingBigDecimalAsBigIntegerFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializingBigIntegerAsBigDecimal() {\r\n    BigDecimal actual \u003d gson.fromJson(\"12121211243123245845384534687435634558945453489543985435\", BigDecimal.class);\r\n    assertThat(actual.toPlainString()).isEqualTo(\"12121211243123245845384534687435634558945453489543985435\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testDeserializingBigIntegerAsBigDecimal",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringsAsBooleans() {\r\n    String json \u003d \"[\u0027true\u0027, \u0027false\u0027, \u0027TRUE\u0027, \u0027yes\u0027, \u00271\u0027]\";\r\n    List\u003cBoolean\u003e deserialized \u003d gson.fromJson(json, new TypeToken\u003cList\u003cBoolean\u003e\u003e() {\r\n    });\r\n    assertThat(deserialized).isEqualTo(Arrays.asList(true, false, true, false, false));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrimitiveTest",
      "methodName": "testStringsAsBooleans",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrintFormattingTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCompactFormattingLeavesNoWhiteSpace() {\r\n    List\u003cObject\u003e list \u003d new ArrayList\u003c\u003e();\r\n    list.add(new BagOfPrimitives());\r\n    list.add(new Nested());\r\n    list.add(new PrimitiveArray());\r\n    list.add(new ClassWithTransientFields\u003c\u003e());\r\n    String json \u003d gson.toJson(list);\r\n    assertContainsNoWhiteSpace(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrintFormattingTest",
      "methodName": "testCompactFormattingLeavesNoWhiteSpace",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonObjectWithNullValues() {\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"field1\", \"value1\");\r\n    obj.addProperty(\"field2\", (String) null);\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).contains(\"field1\");\r\n    assertThat(json).doesNotContain(\"field2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrintFormattingTest",
      "methodName": "testJsonObjectWithNullValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonObjectWithNullValuesSerialized() {\r\n    gson \u003d new GsonBuilder().serializeNulls().create();\r\n    JsonObject obj \u003d new JsonObject();\r\n    obj.addProperty(\"field1\", \"value1\");\r\n    obj.addProperty(\"field2\", (String) null);\r\n    String json \u003d gson.toJson(obj);\r\n    assertThat(json).contains(\"field1\");\r\n    assertThat(json).contains(\"field2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrintFormattingTest",
      "methodName": "testJsonObjectWithNullValuesSerialized",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"LoopOverCharArray\")\r\nprivate static void assertContainsNoWhiteSpace(String str) {\r\n    for (char c : str.toCharArray()) {\r\n        assertThat(Character.isWhitespace(c)).isFalse();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.PrintFormattingTest",
      "methodName": "assertContainsNoWhiteSpace",
      "parameterTypes": [
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RawSerializationTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCollectionOfPrimitives() {\r\n    Collection\u003cInteger\u003e ints \u003d Arrays.asList(1, 2, 3, 4, 5);\r\n    String json \u003d gson.toJson(ints);\r\n    assertThat(json).isEqualTo(\"[1,2,3,4,5]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RawSerializationTest",
      "methodName": "testCollectionOfPrimitives",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCollectionOfObjects() {\r\n    Collection\u003cFoo\u003e foos \u003d Arrays.asList(new Foo(1), new Foo(2));\r\n    String json \u003d gson.toJson(foos);\r\n    assertThat(json).isEqualTo(\"[{\\\"b\\\":1},{\\\"b\\\":2}]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RawSerializationTest",
      "methodName": "testCollectionOfObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedObject() {\r\n    Bar\u003cFoo\u003e bar \u003d new Bar\u003c\u003e(new Foo(1));\r\n    String expectedJson \u003d \"{\\\"t\\\":{\\\"b\\\":1}}\";\r\n    // Ensure that serialization works without specifying the type explicitly\r\n    String json \u003d gson.toJson(bar);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Ensure that serialization also works when the type is specified explicitly\r\n    json \u003d gson.toJson(bar, new TypeToken\u003cBar\u003cFoo\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(json).isEqualTo(expectedJson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RawSerializationTest",
      "methodName": "testParameterizedObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTwoLevelParameterizedObject() {\r\n    Bar\u003cBar\u003cFoo\u003e\u003e bar \u003d new Bar\u003c\u003e(new Bar\u003c\u003e(new Foo(1)));\r\n    String expectedJson \u003d \"{\\\"t\\\":{\\\"t\\\":{\\\"b\\\":1}}}\";\r\n    // Ensure that serialization works without specifying the type explicitly\r\n    String json \u003d gson.toJson(bar);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Ensure that serialization also works when the type is specified explicitly\r\n    json \u003d gson.toJson(bar, new TypeToken\u003cBar\u003cBar\u003cFoo\u003e\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(json).isEqualTo(expectedJson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RawSerializationTest",
      "methodName": "testTwoLevelParameterizedObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testThreeLevelParameterizedObject() {\r\n    Bar\u003cBar\u003cBar\u003cFoo\u003e\u003e\u003e bar \u003d new Bar\u003c\u003e(new Bar\u003c\u003e(new Bar\u003c\u003e(new Foo(1))));\r\n    String expectedJson \u003d \"{\\\"t\\\":{\\\"t\\\":{\\\"t\\\":{\\\"b\\\":1}}}}\";\r\n    // Ensure that serialization works without specifying the type explicitly\r\n    String json \u003d gson.toJson(bar);\r\n    assertThat(json).isEqualTo(expectedJson);\r\n    // Ensure that serialization also works when the type is specified explicitly\r\n    json \u003d gson.toJson(bar, new TypeToken\u003cBar\u003cBar\u003cBar\u003cFoo\u003e\u003e\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(json).isEqualTo(expectedJson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RawSerializationTest",
      "methodName": "testThreeLevelParameterizedObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWriterForSerialization() {\r\n    Writer writer \u003d new StringWriter();\r\n    BagOfPrimitives src \u003d new BagOfPrimitives();\r\n    gson.toJson(src, writer);\r\n    assertThat(writer.toString()).isEqualTo(src.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testWriterForSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReaderForDeserialization() {\r\n    BagOfPrimitives expected \u003d new BagOfPrimitives();\r\n    Reader json \u003d new StringReader(expected.getExpectedJson());\r\n    BagOfPrimitives actual \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testReaderForDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelNullObjectSerializationWithWriter() {\r\n    StringWriter writer \u003d new StringWriter();\r\n    gson.toJson(null, writer);\r\n    assertThat(writer.toString()).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testTopLevelNullObjectSerializationWithWriter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelNullObjectDeserializationWithReader() {\r\n    StringReader reader \u003d new StringReader(\"null\");\r\n    Integer nullIntObject \u003d gson.fromJson(reader, Integer.class);\r\n    assertThat(nullIntObject).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testTopLevelNullObjectDeserializationWithReader",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelNullObjectSerializationWithWriterAndSerializeNulls() {\r\n    Gson gson \u003d new GsonBuilder().serializeNulls().create();\r\n    StringWriter writer \u003d new StringWriter();\r\n    gson.toJson(null, writer);\r\n    assertThat(writer.toString()).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testTopLevelNullObjectSerializationWithWriterAndSerializeNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelNullObjectDeserializationWithReaderAndSerializeNulls() {\r\n    Gson gson \u003d new GsonBuilder().serializeNulls().create();\r\n    StringReader reader \u003d new StringReader(\"null\");\r\n    Integer nullIntObject \u003d gson.fromJson(reader, Integer.class);\r\n    assertThat(nullIntObject).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testTopLevelNullObjectDeserializationWithReaderAndSerializeNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadWriteTwoStrings() throws IOException {\r\n    Gson gson \u003d new Gson();\r\n    CharArrayWriter writer \u003d new CharArrayWriter();\r\n    writer.write(gson.toJson(\"one\").toCharArray());\r\n    writer.write(gson.toJson(\"two\").toCharArray());\r\n    CharArrayReader reader \u003d new CharArrayReader(writer.toCharArray());\r\n    JsonStreamParser parser \u003d new JsonStreamParser(reader);\r\n    String actualOne \u003d gson.fromJson(parser.next(), String.class);\r\n    assertThat(actualOne).isEqualTo(\"one\");\r\n    String actualTwo \u003d gson.fromJson(parser.next(), String.class);\r\n    assertThat(actualTwo).isEqualTo(\"two\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testReadWriteTwoStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadWriteTwoObjects() throws IOException {\r\n    Gson gson \u003d new Gson();\r\n    CharArrayWriter writer \u003d new CharArrayWriter();\r\n    BagOfPrimitives expectedOne \u003d new BagOfPrimitives(1, 1, true, \"one\");\r\n    writer.write(gson.toJson(expectedOne).toCharArray());\r\n    BagOfPrimitives expectedTwo \u003d new BagOfPrimitives(2, 2, false, \"two\");\r\n    writer.write(gson.toJson(expectedTwo).toCharArray());\r\n    CharArrayReader reader \u003d new CharArrayReader(writer.toCharArray());\r\n    JsonStreamParser parser \u003d new JsonStreamParser(reader);\r\n    BagOfPrimitives actualOne \u003d gson.fromJson(parser.next(), BagOfPrimitives.class);\r\n    assertThat(actualOne.stringValue).isEqualTo(\"one\");\r\n    BagOfPrimitives actualTwo \u003d gson.fromJson(parser.next(), BagOfPrimitives.class);\r\n    assertThat(actualTwo.stringValue).isEqualTo(\"two\");\r\n    assertThat(parser.hasNext()).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testReadWriteTwoObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTypeMismatchThrowsJsonSyntaxExceptionForStrings() {\r\n    try {\r\n        gson.fromJson(\"true\", new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testTypeMismatchThrowsJsonSyntaxExceptionForStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTypeMismatchThrowsJsonSyntaxExceptionForReaders() {\r\n    try {\r\n        gson.fromJson(new StringReader(\"true\"), new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testTypeMismatchThrowsJsonSyntaxExceptionForReaders",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic Appendable append(char c) throws IOException {\r\n    stringBuilder.append(c);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "append",
      "parameterTypes": [
        "char"
      ],
      "returnType": "Appendable"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic Appendable append(CharSequence csq) throws IOException {\r\n    if (csq \u003d\u003d null) {\r\n        // Requirement by Writer.append\r\n        csq \u003d \"null\";\r\n    }\r\n    append(csq, 0, csq.length());\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "append",
      "parameterTypes": [
        "CharSequence"
      ],
      "returnType": "Appendable"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\n@Override\r\npublic Appendable append(CharSequence csq, int start, int end) throws IOException {\r\n    if (csq \u003d\u003d null) {\r\n        // Requirement by Writer.append\r\n        csq \u003d \"null\";\r\n    }\r\n    // According to doc, toString() must return string representation\r\n    String s \u003d csq.toString();\r\n    toStringCallCount++;\r\n    stringBuilder.append(s, start, end);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "append",
      "parameterTypes": [
        "CharSequence",
        "int",
        "int"
      ],
      "returnType": "Appendable"
    }
  },
  {
    "sourceCode": "/**\r\n * Verifies that passing an {@link Appendable} which is not an instance of {@link Writer}\r\n * to {@code Gson.toJson} works correctly.\r\n */\r\n@Test\r\npublic void testToJsonAppendable() {\r\n    class CustomAppendable implements Appendable {\r\n\r\n        final StringBuilder stringBuilder \u003d new StringBuilder();\r\n\r\n        int toStringCallCount \u003d 0;\r\n\r\n        @CanIgnoreReturnValue\r\n        @Override\r\n        public Appendable append(char c) throws IOException {\r\n            stringBuilder.append(c);\r\n            return this;\r\n        }\r\n\r\n        @CanIgnoreReturnValue\r\n        @Override\r\n        public Appendable append(CharSequence csq) throws IOException {\r\n            if (csq \u003d\u003d null) {\r\n                // Requirement by Writer.append\r\n                csq \u003d \"null\";\r\n            }\r\n            append(csq, 0, csq.length());\r\n            return this;\r\n        }\r\n\r\n        @CanIgnoreReturnValue\r\n        @Override\r\n        public Appendable append(CharSequence csq, int start, int end) throws IOException {\r\n            if (csq \u003d\u003d null) {\r\n                // Requirement by Writer.append\r\n                csq \u003d \"null\";\r\n            }\r\n            // According to doc, toString() must return string representation\r\n            String s \u003d csq.toString();\r\n            toStringCallCount++;\r\n            stringBuilder.append(s, start, end);\r\n            return this;\r\n        }\r\n    }\r\n    CustomAppendable appendable \u003d new CustomAppendable();\r\n    gson.toJson(Arrays.asList(\"test\", 123, true), appendable);\r\n    // Make sure CharSequence.toString() was called at least two times to verify that\r\n    // CurrentWrite.cachedString is properly overwritten when char array changes\r\n    assertThat(appendable.toStringCallCount \u003e\u003d 2).isTrue();\r\n    assertThat(appendable.stringBuilder.toString()).isEqualTo(\"[\\\"test\\\",123,true]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReadersWritersTest",
      "methodName": "testToJsonAppendable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int read(char[] cbuf, int off, int len) throws IOException {\r\n    return 0;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest.ClassExtendingJdkClass",
      "methodName": "read",
      "parameterTypes": [
        "char[]",
        "int",
        "int"
      ],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void close() throws IOException {\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest.ClassExtendingJdkClass",
      "methodName": "close",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBlockInaccessibleJava() throws ReflectiveOperationException {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_INACCESSIBLE_JAVA).create();\r\n    // Serialization should fail for classes with non-public fields\r\n    try {\r\n        gson.toJson(new File(\"a\"));\r\n        fail(\"Expected exception; test needs to be run with Java \u003e\u003d 9\");\r\n    } catch (JsonIOException expected) {\r\n        // Note: This test is rather brittle and depends on the JDK implementation\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Field \u0027java.io.File#path\u0027 is not accessible and ReflectionAccessFilter does not permit\" + \" making it accessible. Register a TypeAdapter for the declaring type, adjust the access\" + \" filter or increase the visibility of the element and its declaring type.\");\r\n    }\r\n    // But serialization should succeed for classes with only public fields.\r\n    // Not many JDK classes have mutable public fields, thank goodness, but java.awt.Point does.\r\n    Class\u003c?\u003e pointClass \u003d null;\r\n    try {\r\n        pointClass \u003d Class.forName(\"java.awt.Point\");\r\n    } catch (ClassNotFoundException e) {\r\n    }\r\n    assumeNotNull(pointClass);\r\n    Constructor\u003c?\u003e pointConstructor \u003d pointClass.getConstructor(int.class, int.class);\r\n    Object point \u003d pointConstructor.newInstance(1, 2);\r\n    String json \u003d gson.toJson(point);\r\n    assertThat(json).isEqualTo(\"{\\\"x\\\":1,\\\"y\\\":2}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testBlockInaccessibleJava",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBlockInaccessibleJavaExtendingJdkClass() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_INACCESSIBLE_JAVA).create();\r\n    try {\r\n        gson.toJson(new ClassExtendingJdkClass());\r\n        fail(\"Expected exception; test needs to be run with Java \u003e\u003d 9\");\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Field \u0027java.io.Reader#lock\u0027 is not accessible and ReflectionAccessFilter does not permit\" + \" making it accessible. Register a TypeAdapter for the declaring type, adjust the access\" + \" filter or increase the visibility of the element and its declaring type.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testBlockInaccessibleJavaExtendingJdkClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBlockAllJava() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_ALL_JAVA).create();\r\n    // Serialization should fail for any Java class\r\n    try {\r\n        gson.toJson(Thread.currentThread());\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class java.lang.Thread.\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testBlockAllJava",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBlockAllJavaExtendingJdkClass() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_ALL_JAVA).create();\r\n    try {\r\n        gson.toJson(new ClassExtendingJdkClass());\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class java.io.Reader\" + \" (supertype of class com.google.gson.functional.ReflectionAccessFilterTest$ClassExtendingJdkClass).\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testBlockAllJavaExtendingJdkClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return FilterResult.BLOCK_INACCESSIBLE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBlockInaccessibleStaticField() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).// Include static fields\r\n    excludeFieldsWithModifiers(0).create();\r\n    try {\r\n        gson.toJson(new ClassWithStaticField());\r\n        fail(\"Expected exception; test needs to be run with Java \u003e\u003d 9\");\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Field \u0027com.google.gson.functional.ReflectionAccessFilterTest$ClassWithStaticField#i\u0027\" + \" is not accessible and ReflectionAccessFilter does not permit making it accessible.\" + \" Register a TypeAdapter for the declaring type, adjust the access filter or increase\" + \" the visibility of the element and its declaring type.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testBlockInaccessibleStaticField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    // INDECISIVE should delegate to previous filter\r\n    return rawClass \u003d\u003d SubTestClass.class ? FilterResult.ALLOW : FilterResult.INDECISIVE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    // INDECISIVE in last filter should act like ALLOW\r\n    return SuperTestClass.class.isAssignableFrom(rawClass) ? FilterResult.BLOCK_ALL : FilterResult.INDECISIVE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDelegation() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            // INDECISIVE in last filter should act like ALLOW\r\n            return SuperTestClass.class.isAssignableFrom(rawClass) ? FilterResult.BLOCK_ALL : FilterResult.INDECISIVE;\r\n        }\r\n    }).addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            // INDECISIVE should delegate to previous filter\r\n            return rawClass \u003d\u003d SubTestClass.class ? FilterResult.ALLOW : FilterResult.INDECISIVE;\r\n        }\r\n    }).create();\r\n    // Filter disallows SuperTestClass\r\n    try {\r\n        gson.toJson(new SuperTestClass());\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$SuperTestClass.\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n    // But registration order is reversed, so filter for SubTestClass allows reflection\r\n    String json \u003d gson.toJson(new SubTestClass());\r\n    assertThat(json).isEqualTo(\"{\\\"i\\\":1}\");\r\n    // And unrelated class should not be affected\r\n    json \u003d gson.toJson(new OtherClass());\r\n    assertThat(json).isEqualTo(\"{\\\"i\\\":2}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testDelegation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return FilterResult.BLOCK_INACCESSIBLE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return rawClass \u003d\u003d ClassWithPrivateField.class ? FilterResult.ALLOW : FilterResult.INDECISIVE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAllowForSupertype() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).create();\r\n    // First make sure test is implemented correctly and access is blocked\r\n    try {\r\n        gson.toJson(new ExtendingClassWithPrivateField());\r\n        fail(\"Expected exception; test needs to be run with Java \u003e\u003d 9\");\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Field \u0027com.google.gson.functional.ReflectionAccessFilterTest$ClassWithPrivateField#i\u0027\" + \" is not accessible and ReflectionAccessFilter does not permit making it accessible.\" + \" Register a TypeAdapter for the declaring type, adjust the access filter or increase\" + \" the visibility of the element and its declaring type.\");\r\n    }\r\n    gson \u003d gson.newBuilder().// Allow reflective access for supertype\r\n    addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return rawClass \u003d\u003d ClassWithPrivateField.class ? FilterResult.ALLOW : FilterResult.INDECISIVE;\r\n        }\r\n    }).create();\r\n    // Inherited (inaccessible) private field should have been made accessible\r\n    String json \u003d gson.toJson(new ExtendingClassWithPrivateField());\r\n    assertThat(json).isEqualTo(\"{\\\"i\\\":1}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testAllowForSupertype",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return FilterResult.BLOCK_INACCESSIBLE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInaccessibleNoArgsConstructor() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).create();\r\n    try {\r\n        gson.fromJson(\"{}\", ClassWithPrivateNoArgsConstructor.class);\r\n        fail(\"Expected exception; test needs to be run with Java \u003e\u003d 9\");\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unable to invoke no-args constructor of class com.google.gson.functional.ReflectionAccessFilterTest$ClassWithPrivateNoArgsConstructor;\" + \" constructor is not accessible and ReflectionAccessFilter does not permit making it accessible. Register an\" + \" InstanceCreator or a TypeAdapter for this type, change the visibility of the constructor or adjust the access filter.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testInaccessibleNoArgsConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    // Even BLOCK_INACCESSIBLE should prevent usage of Unsafe for object creation\r\n    return FilterResult.BLOCK_INACCESSIBLE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "@Override\r\npublic ClassWithoutNoArgsConstructor read(JsonReader in) throws IOException {\r\n    in.skipValue();\r\n    return new ClassWithoutNoArgsConstructor(\"TypeAdapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "ClassWithoutNoArgsConstructor"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, ClassWithoutNoArgsConstructor value) {\r\n    throw new AssertionError(\"Not needed for test\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "ClassWithoutNoArgsConstructor"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic ClassWithoutNoArgsConstructor createInstance(Type type) {\r\n    return new ClassWithoutNoArgsConstructor(\"InstanceCreator\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "ClassWithoutNoArgsConstructor"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClassWithoutNoArgsConstructor() {\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            // Even BLOCK_INACCESSIBLE should prevent usage of Unsafe for object creation\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    });\r\n    Gson gson \u003d gsonBuilder.create();\r\n    try {\r\n        gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unable to create instance of class com.google.gson.functional.ReflectionAccessFilterTest$ClassWithoutNoArgsConstructor;\" + \" ReflectionAccessFilter does not permit using reflection or Unsafe. Register an InstanceCreator\" + \" or a TypeAdapter for this type or adjust the access filter to allow using reflection.\");\r\n    }\r\n    // But should not fail when custom TypeAdapter is specified\r\n    gson \u003d gson.newBuilder().registerTypeAdapter(ClassWithoutNoArgsConstructor.class, new TypeAdapter\u003cClassWithoutNoArgsConstructor\u003e() {\r\n\r\n        @Override\r\n        public ClassWithoutNoArgsConstructor read(JsonReader in) throws IOException {\r\n            in.skipValue();\r\n            return new ClassWithoutNoArgsConstructor(\"TypeAdapter\");\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, ClassWithoutNoArgsConstructor value) {\r\n            throw new AssertionError(\"Not needed for test\");\r\n        }\r\n    }).create();\r\n    ClassWithoutNoArgsConstructor deserialized \u003d gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n    assertThat(deserialized.s).isEqualTo(\"TypeAdapter\");\r\n    // But should not fail when custom InstanceCreator is specified\r\n    gson \u003d gsonBuilder.registerTypeAdapter(ClassWithoutNoArgsConstructor.class, new InstanceCreator\u003cClassWithoutNoArgsConstructor\u003e() {\r\n\r\n        @Override\r\n        public ClassWithoutNoArgsConstructor createInstance(Type type) {\r\n            return new ClassWithoutNoArgsConstructor(\"InstanceCreator\");\r\n        }\r\n    }).create();\r\n    deserialized \u003d gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n    assertThat(deserialized.s).isEqualTo(\"InstanceCreator\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testClassWithoutNoArgsConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(OtherClass src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(123);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "serialize",
      "parameterTypes": [
        "OtherClass",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return FilterResult.BLOCK_ALL;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "/**\r\n * When using {@link FilterResult#BLOCK_ALL}, registering only a {@link JsonSerializer}\r\n * but not performing any deserialization should not throw any exception.\r\n */\r\n@Test\r\npublic void testBlockAllPartial() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_ALL;\r\n        }\r\n    }).registerTypeAdapter(OtherClass.class, new JsonSerializer\u003cOtherClass\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(OtherClass src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(123);\r\n        }\r\n    }).create();\r\n    String json \u003d gson.toJson(new OtherClass());\r\n    assertThat(json).isEqualTo(\"123\");\r\n    // But deserialization should fail\r\n    try {\r\n        gson.fromJson(\"{}\", OtherClass.class);\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class com.google.gson.functional.ReflectionAccessFilterTest$OtherClass.\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testBlockAllPartial",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return FilterResult.BLOCK_ALL;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "/**\r\n * Should not fail when deserializing collection interface\r\n * (Even though this goes through {@link ConstructorConstructor} as well)\r\n */\r\n@Test\r\npublic void testBlockAllCollectionInterface() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_ALL;\r\n        }\r\n    }).create();\r\n    List\u003c?\u003e deserialized \u003d gson.fromJson(\"[1.0]\", List.class);\r\n    assertThat(deserialized.get(0)).isEqualTo(1.0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testBlockAllCollectionInterface",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return FilterResult.BLOCK_ALL;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "/**\r\n * Should not fail when deserializing specific collection implementation\r\n * (Even though this goes through {@link ConstructorConstructor} as well)\r\n */\r\n@Test\r\npublic void testBlockAllCollectionImplementation() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_ALL;\r\n        }\r\n    }).create();\r\n    List\u003c?\u003e deserialized \u003d gson.fromJson(\"[1.0]\", LinkedList.class);\r\n    assertThat(deserialized.get(0)).isEqualTo(1.0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testBlockAllCollectionImplementation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic FilterResult check(Class\u003c?\u003e rawClass) {\r\n    return FilterResult.BLOCK_INACCESSIBLE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "check",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "FilterResult"
    }
  },
  {
    "sourceCode": "/**\r\n * When trying to deserialize interface an exception for that should\r\n * be thrown, even if {@link FilterResult#BLOCK_INACCESSIBLE} is used\r\n */\r\n@Test\r\npublic void testBlockInaccessibleInterface() {\r\n    Gson gson \u003d new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class\u003c?\u003e rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).create();\r\n    try {\r\n        gson.fromJson(\"{}\", Runnable.class);\r\n        fail();\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Interfaces can\u0027t be instantiated! Register an InstanceCreator or a TypeAdapter for\" + \" this type. Interface name: java.lang.Runnable\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessFilterTest",
      "methodName": "testBlockInaccessibleInterface",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static Class\u003c?\u003e loadClassWithDifferentClassLoader(Class\u003c?\u003e c) throws Exception {\r\n    URL url \u003d c.getProtectionDomain().getCodeSource().getLocation();\r\n    URLClassLoader classLoader \u003d new URLClassLoader(new URL[] { url }, null);\r\n    return classLoader.loadClass(c.getName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessTest",
      "methodName": "loadClassWithDifferentClassLoader",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "Class\u003c?\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void checkPermission(Permission perm) {\r\n    if (accessDeclaredMembers.equals(perm)) {\r\n        throw new SecurityException(\"Gson: no-member-access\");\r\n    }\r\n    if (suppressAccessChecks.equals(perm)) {\r\n        throw new SecurityException(\"Gson: no-suppress-access-check\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessTest",
      "methodName": "checkPermission",
      "parameterTypes": [
        "Permission"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Object value) throws IOException {\r\n    out.value(\"custom-write\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Object read(JsonReader in) throws IOException {\r\n    in.skipValue();\r\n    wasReadCalled.set(true);\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "// java.lang.SecurityManager deprecation in Java 17\r\n@SuppressWarnings(\"removal\")\r\n@Test\r\npublic void testRestrictiveSecurityManager() throws Exception {\r\n    // Must use separate class loader, otherwise permission is not checked, see Class.getDeclaredFields()\r\n    Class\u003c?\u003e clazz \u003d loadClassWithDifferentClassLoader(ClassWithPrivateMembers.class);\r\n    final Permission accessDeclaredMembers \u003d new RuntimePermission(\"accessDeclaredMembers\");\r\n    final Permission suppressAccessChecks \u003d new ReflectPermission(\"suppressAccessChecks\");\r\n    SecurityManager original \u003d System.getSecurityManager();\r\n    SecurityManager restrictiveManager \u003d new SecurityManager() {\r\n\r\n        @Override\r\n        public void checkPermission(Permission perm) {\r\n            if (accessDeclaredMembers.equals(perm)) {\r\n                throw new SecurityException(\"Gson: no-member-access\");\r\n            }\r\n            if (suppressAccessChecks.equals(perm)) {\r\n                throw new SecurityException(\"Gson: no-suppress-access-check\");\r\n            }\r\n        }\r\n    };\r\n    System.setSecurityManager(restrictiveManager);\r\n    try {\r\n        Gson gson \u003d new Gson();\r\n        try {\r\n            // Getting reflection based adapter should fail\r\n            gson.getAdapter(clazz);\r\n            fail();\r\n        } catch (SecurityException e) {\r\n            assertThat(e).hasMessageThat().isEqualTo(\"Gson: no-member-access\");\r\n        }\r\n        final AtomicBoolean wasReadCalled \u003d new AtomicBoolean(false);\r\n        gson \u003d new GsonBuilder().registerTypeAdapter(clazz, new TypeAdapter\u003cObject\u003e() {\r\n\r\n            @Override\r\n            public void write(JsonWriter out, Object value) throws IOException {\r\n                out.value(\"custom-write\");\r\n            }\r\n\r\n            @Override\r\n            public Object read(JsonReader in) throws IOException {\r\n                in.skipValue();\r\n                wasReadCalled.set(true);\r\n                return null;\r\n            }\r\n        }).create();\r\n        assertThat(gson.toJson(null, clazz)).isEqualTo(\"\\\"custom-write\\\"\");\r\n        assertThat(gson.fromJson(\"{}\", clazz)).isNull();\r\n        assertThat(wasReadCalled.get()).isTrue();\r\n    } finally {\r\n        System.setSecurityManager(original);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessTest",
      "methodName": "testRestrictiveSecurityManager",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static JsonIOException assertInaccessibleException(String json, Class\u003c?\u003e toDeserialize) {\r\n    Gson gson \u003d new Gson();\r\n    try {\r\n        gson.fromJson(json, toDeserialize);\r\n        throw new AssertionError(\"Missing exception; test has to be run with `--illegal-access\u003ddeny`\");\r\n    } catch (JsonSyntaxException e) {\r\n        throw new AssertionError(\"Unexpected exception; test has to be run with `--illegal-access\u003ddeny`\", e);\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().endsWith(\"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#reflection-inaccessible\");\r\n        // Return exception for further assertions\r\n        return expected;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessTest",
      "methodName": "assertInaccessibleException",
      "parameterTypes": [
        "String",
        "Class\u003c?\u003e"
      ],
      "returnType": "JsonIOException"
    }
  },
  {
    "sourceCode": "/**\r\n * Test serializing an instance of a non-accessible internal class, but where\r\n * Gson supports serializing one of its superinterfaces.\r\n *\r\n * \u003cp\u003eHere {@link Collections#emptyList()} is used which returns an instance\r\n * of the internal class {@code java.util.Collections.EmptyList}. Gson should\r\n * serialize the object as {@code List} despite the internal class not being\r\n * accessible.\r\n *\r\n * \u003cp\u003eSee https://github.com/google/gson/issues/1875\r\n */\r\n@Test\r\npublic void testSerializeInternalImplementationObject() {\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(Collections.emptyList());\r\n    assertThat(json).isEqualTo(\"[]\");\r\n    // But deserialization should fail\r\n    Class\u003c?\u003e internalClass \u003d Collections.emptyList().getClass();\r\n    JsonIOException exception \u003d assertInaccessibleException(\"[]\", internalClass);\r\n    // Don\u0027t check exact class name because it is a JDK implementation detail\r\n    assertThat(exception).hasMessageThat().startsWith(\"Failed making constructor \u0027\");\r\n    assertThat(exception).hasMessageThat().contains(\"\u0027 accessible; either increase its visibility or\" + \" write a custom InstanceCreator or TypeAdapter for its declaring type: \");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessTest",
      "methodName": "testSerializeInternalImplementationObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInaccessibleField() {\r\n    JsonIOException exception \u003d assertInaccessibleException(\"{}\", Throwable.class);\r\n    // Don\u0027t check exact field name because it is a JDK implementation detail\r\n    assertThat(exception).hasMessageThat().startsWith(\"Failed making field \u0027java.lang.Throwable#\");\r\n    assertThat(exception).hasMessageThat().contains(\"\u0027 accessible; either increase its visibility or\" + \" write a custom TypeAdapter for its declaring type.\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReflectionAccessTest",
      "methodName": "testInaccessibleField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() {\r\n    gson \u003d new GsonBuilder().create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReusedTypeVariablesFullyResolveTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// The instances were being unmarshaled as Strings instead of TestEnums\r\n@SuppressWarnings(\"ConstantConditions\")\r\n@Test\r\npublic void testGenericsPreservation() {\r\n    TestEnumSetCollection withSet \u003d gson.fromJson(\"{\\\"collection\\\":[\\\"ONE\\\",\\\"THREE\\\"]}\", TestEnumSetCollection.class);\r\n    Iterator\u003cTestEnum\u003e iterator \u003d withSet.collection.iterator();\r\n    assertThat(withSet).isNotNull();\r\n    assertThat(withSet.collection).isNotNull();\r\n    assertThat(withSet.collection).hasSize(2);\r\n    TestEnum first \u003d iterator.next();\r\n    TestEnum second \u003d iterator.next();\r\n    assertThat(first).isInstanceOf(TestEnum.class);\r\n    assertThat(second).isInstanceOf(TestEnum.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ReusedTypeVariablesFullyResolveTest",
      "methodName": "testGenericsPreservation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This test also ensures that {@link TypeAdapterFactory} registered through {@link JsonAdapter}\r\n * work correctly for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)}.\r\n */\r\n@Test\r\npublic void testSubclassesAutomaticallySerialized() {\r\n    Shape shape \u003d new Circle(25);\r\n    String json \u003d gson.toJson(shape);\r\n    shape \u003d gson.fromJson(json, Shape.class);\r\n    assertThat(((Circle) shape).radius).isEqualTo(25);\r\n    shape \u003d new Square(15);\r\n    json \u003d gson.toJson(shape);\r\n    shape \u003d gson.fromJson(json, Shape.class);\r\n    assertThat(((Square) shape).side).isEqualTo(15);\r\n    assertThat(shape.type).isEqualTo(ShapeType.SQUARE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest",
      "methodName": "testSubclassesAutomaticallySerialized",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a new runtime type adapter using for {@code baseType} using {@code\r\n * typeFieldName} as the type field name. Type field names are case sensitive.\r\n */\r\npublic static \u003cT\u003e RuntimeTypeAdapterFactory\u003cT\u003e of(Class\u003cT\u003e baseType, String typeFieldName) {\r\n    return new RuntimeTypeAdapterFactory\u003c\u003e(baseType, typeFieldName);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest.RuntimeTypeAdapterFactory",
      "methodName": "of",
      "parameterTypes": [
        "Class\u003cT\u003e",
        "String"
      ],
      "returnType": "RuntimeTypeAdapterFactory\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a new runtime type adapter for {@code baseType} using {@code \"type\"} as\r\n * the type field name.\r\n */\r\npublic static \u003cT\u003e RuntimeTypeAdapterFactory\u003cT\u003e of(Class\u003cT\u003e baseType) {\r\n    return new RuntimeTypeAdapterFactory\u003c\u003e(baseType, \"type\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest.RuntimeTypeAdapterFactory",
      "methodName": "of",
      "parameterTypes": [
        "Class\u003cT\u003e"
      ],
      "returnType": "RuntimeTypeAdapterFactory\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Registers {@code type} identified by {@code label}. Labels are case\r\n * sensitive.\r\n *\r\n * @throws IllegalArgumentException if either {@code type} or {@code label}\r\n *     have already been registered on this type adapter.\r\n */\r\n@CanIgnoreReturnValue\r\npublic RuntimeTypeAdapterFactory\u003cT\u003e registerSubtype(Class\u003c? extends T\u003e type, String label) {\r\n    if (type \u003d\u003d null || label \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {\r\n        throw new IllegalArgumentException(\"types and labels must be unique\");\r\n    }\r\n    labelToSubtype.put(label, type);\r\n    subtypeToLabel.put(type, label);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest.RuntimeTypeAdapterFactory",
      "methodName": "registerSubtype",
      "parameterTypes": [
        "Class\u003c? extends T\u003e",
        "String"
      ],
      "returnType": "RuntimeTypeAdapterFactory\u003cT\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * Registers {@code type} identified by its {@link Class#getSimpleName simple\r\n * name}. Labels are case sensitive.\r\n *\r\n * @throws IllegalArgumentException if either {@code type} or its simple name\r\n *     have already been registered on this type adapter.\r\n */\r\n@CanIgnoreReturnValue\r\npublic RuntimeTypeAdapterFactory\u003cT\u003e registerSubtype(Class\u003c? extends T\u003e type) {\r\n    return registerSubtype(type, type.getSimpleName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest.RuntimeTypeAdapterFactory",
      "methodName": "registerSubtype",
      "parameterTypes": [
        "Class\u003c? extends T\u003e"
      ],
      "returnType": "RuntimeTypeAdapterFactory\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic R read(JsonReader in) {\r\n    JsonElement jsonElement \u003d Streams.parse(in);\r\n    JsonElement labelJsonElement \u003d jsonElement.getAsJsonObject().get(typeFieldName);\r\n    if (labelJsonElement \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n    }\r\n    String label \u003d labelJsonElement.getAsString();\r\n    // registration requires that subtype extends T\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) labelToDelegate.get(label);\r\n    if (delegate \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n    }\r\n    return delegate.fromJsonTree(jsonElement);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest.RuntimeTypeAdapterFactory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "R"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, R value) throws IOException {\r\n    Class\u003c?\u003e srcType \u003d value.getClass();\r\n    String label \u003d subtypeToLabel.get(srcType);\r\n    // registration requires that subtype extends T\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) subtypeToDelegate.get(srcType);\r\n    if (delegate \u003d\u003d null) {\r\n        throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n    }\r\n    JsonObject jsonObject \u003d delegate.toJsonTree(value).getAsJsonObject();\r\n    if (!jsonObject.has(typeFieldName)) {\r\n        JsonObject clone \u003d new JsonObject();\r\n        clone.add(typeFieldName, new JsonPrimitive(label));\r\n        for (Map.Entry\u003cString, JsonElement\u003e e : jsonObject.entrySet()) {\r\n            clone.add(e.getKey(), e.getValue());\r\n        }\r\n        jsonObject \u003d clone;\r\n    }\r\n    Streams.write(jsonObject, out);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest.RuntimeTypeAdapterFactory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "R"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cR\u003e TypeAdapter\u003cR\u003e create(Gson gson, TypeToken\u003cR\u003e type) {\r\n    if (type.getRawType() !\u003d baseType) {\r\n        return null;\r\n    }\r\n    final Map\u003cString, TypeAdapter\u003c?\u003e\u003e labelToDelegate \u003d new LinkedHashMap\u003c\u003e();\r\n    final Map\u003cClass\u003c?\u003e, TypeAdapter\u003c?\u003e\u003e subtypeToDelegate \u003d new LinkedHashMap\u003c\u003e();\r\n    for (Map.Entry\u003cString, Class\u003c?\u003e\u003e entry : labelToSubtype.entrySet()) {\r\n        TypeAdapter\u003c?\u003e delegate \u003d gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));\r\n        labelToDelegate.put(entry.getKey(), delegate);\r\n        subtypeToDelegate.put(entry.getValue(), delegate);\r\n    }\r\n    return new TypeAdapter\u003cR\u003e() {\r\n\r\n        @Override\r\n        public R read(JsonReader in) {\r\n            JsonElement jsonElement \u003d Streams.parse(in);\r\n            JsonElement labelJsonElement \u003d jsonElement.getAsJsonObject().get(typeFieldName);\r\n            if (labelJsonElement \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n            }\r\n            String label \u003d labelJsonElement.getAsString();\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) labelToDelegate.get(label);\r\n            if (delegate \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n            }\r\n            return delegate.fromJsonTree(jsonElement);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, R value) throws IOException {\r\n            Class\u003c?\u003e srcType \u003d value.getClass();\r\n            String label \u003d subtypeToLabel.get(srcType);\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter\u003cR\u003e delegate \u003d (TypeAdapter\u003cR\u003e) subtypeToDelegate.get(srcType);\r\n            if (delegate \u003d\u003d null) {\r\n                throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n            }\r\n            JsonObject jsonObject \u003d delegate.toJsonTree(value).getAsJsonObject();\r\n            if (!jsonObject.has(typeFieldName)) {\r\n                JsonObject clone \u003d new JsonObject();\r\n                clone.add(typeFieldName, new JsonPrimitive(label));\r\n                for (Map.Entry\u003cString, JsonElement\u003e e : jsonObject.entrySet()) {\r\n                    clone.add(e.getKey(), e.getValue());\r\n                }\r\n                jsonObject \u003d clone;\r\n            }\r\n            Streams.write(jsonObject, out);\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest.RuntimeTypeAdapterFactory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cR\u003e"
      ],
      "returnType": "TypeAdapter\u003cR\u003e"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gsonBuilder \u003d new GsonBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.SecurityTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonExecutableJsonSerialization() {\r\n    Gson gson \u003d gsonBuilder.generateNonExecutableJson().create();\r\n    String json \u003d gson.toJson(new BagOfPrimitives());\r\n    assertThat(json.startsWith(JSON_NON_EXECUTABLE_PREFIX)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.SecurityTest",
      "methodName": "testNonExecutableJsonSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonExecutableJsonDeserialization() {\r\n    String json \u003d JSON_NON_EXECUTABLE_PREFIX + \"{longValue:1}\";\r\n    Gson gson \u003d gsonBuilder.create();\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.longValue).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.SecurityTest",
      "methodName": "testNonExecutableJsonDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonWithNonExectuableTokenSerialization() {\r\n    Gson gson \u003d gsonBuilder.generateNonExecutableJson().create();\r\n    String json \u003d gson.toJson(JSON_NON_EXECUTABLE_PREFIX);\r\n    assertThat(json).contains(\")]}\u0027\\n\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.SecurityTest",
      "methodName": "testJsonWithNonExectuableTokenSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n *  Gson should be able to deserialize a stream with non-exectuable token even if it is created\r\n *  without {@link GsonBuilder#generateNonExecutableJson()}.\r\n */\r\n@Test\r\npublic void testJsonWithNonExectuableTokenWithRegularGsonDeserialization() {\r\n    Gson gson \u003d gsonBuilder.create();\r\n    String json \u003d JSON_NON_EXECUTABLE_PREFIX + \"{stringValue:\u0027)]}\\\\u0027\\\\n\u0027}\";\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.stringValue).isEqualTo(\")]}\u0027\\n\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.SecurityTest",
      "methodName": "testJsonWithNonExectuableTokenWithRegularGsonDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n *  Gson should be able to deserialize a stream with non-exectuable token if it is created\r\n *  with {@link GsonBuilder#generateNonExecutableJson()}.\r\n */\r\n@Test\r\npublic void testJsonWithNonExectuableTokenWithConfiguredGsonDeserialization() {\r\n    // Gson should be able to deserialize a stream with non-exectuable token even if it is created\r\n    Gson gson \u003d gsonBuilder.generateNonExecutableJson().create();\r\n    String json \u003d JSON_NON_EXECUTABLE_PREFIX + \"{intValue:2,stringValue:\u0027)]}\\\\u0027\\\\n\u0027}\";\r\n    BagOfPrimitives target \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(target.stringValue).isEqualTo(\")]}\u0027\\n\");\r\n    assertThat(target.intValue).isEqualTo(2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.SecurityTest",
      "methodName": "testJsonWithNonExectuableTokenWithConfiguredGsonDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFirstNameIsChosenForSerialization() {\r\n    MyClass target \u003d new MyClass(\"v1\", \"v2\");\r\n    // Ensure name1 occurs exactly once, and name2 and name3 don\u0027t appear\r\n    assertThat(gson.toJson(target)).isEqualTo(\"{\\\"name\\\":\\\"v1\\\",\\\"name1\\\":\\\"v2\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.SerializedNameTest",
      "methodName": "testFirstNameIsChosenForSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultipleNamesDeserializedCorrectly() {\r\n    assertThat(gson.fromJson(\"{\u0027name\u0027:\u0027v1\u0027}\", MyClass.class).a).isEqualTo(\"v1\");\r\n    // Both name1 and name2 gets deserialized to b\r\n    assertThat(gson.fromJson(\"{\u0027name1\u0027:\u0027v11\u0027}\", MyClass.class).b).isEqualTo(\"v11\");\r\n    assertThat(gson.fromJson(\"{\u0027name2\u0027:\u0027v2\u0027}\", MyClass.class).b).isEqualTo(\"v2\");\r\n    assertThat(gson.fromJson(\"{\u0027name3\u0027:\u0027v3\u0027}\", MyClass.class).b).isEqualTo(\"v3\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.SerializedNameTest",
      "methodName": "testMultipleNamesDeserializedCorrectly",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultipleNamesInTheSameString() {\r\n    // The last value takes precedence\r\n    assertThat(gson.fromJson(\"{\u0027name1\u0027:\u0027v1\u0027,\u0027name2\u0027:\u0027v2\u0027,\u0027name3\u0027:\u0027v3\u0027}\", MyClass.class).b).isEqualTo(\"v3\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.SerializedNameTest",
      "methodName": "testMultipleNamesInTheSameString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerialize() {\r\n    Truck truck \u003d new Truck();\r\n    truck.passengers \u003d Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29));\r\n    truck.horsePower \u003d 300;\r\n    assertThat(truckAdapter.toJson(truck).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027horsePower\u0027:300.0,\" + \"\u0027passengers\u0027:[{\u0027age\u0027:29,\u0027name\u0027:\u0027Jesse\u0027},{\u0027age\u0027:29,\u0027name\u0027:\u0027Jodie\u0027}]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testSerialize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserialize() throws IOException {\r\n    String json \u003d \"{\u0027horsePower\u0027:300.0,\" + \"\u0027passengers\u0027:[{\u0027age\u0027:29,\u0027name\u0027:\u0027Jesse\u0027},{\u0027age\u0027:29,\u0027name\u0027:\u0027Jodie\u0027}]}\";\r\n    Truck truck \u003d truckAdapter.fromJson(json.replace(\u0027\\\u0027\u0027, \u0027\\\"\u0027));\r\n    assertThat(truck.horsePower).isEqualTo(300.0);\r\n    assertThat(truck.passengers).isEqualTo(Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29)));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testDeserialize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeNullField() {\r\n    Truck truck \u003d new Truck();\r\n    truck.passengers \u003d null;\r\n    assertThat(truckAdapter.toJson(truck).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:null}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testSerializeNullField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeNullField() throws IOException {\r\n    Truck truck \u003d truckAdapter.fromJson(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:null}\".replace(\u0027\\\u0027\u0027, \u0027\\\"\u0027));\r\n    assertThat(truck.passengers).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testDeserializeNullField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeNullObject() {\r\n    Truck truck \u003d new Truck();\r\n    truck.passengers \u003d Arrays.asList((Person) null);\r\n    assertThat(truckAdapter.toJson(truck).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:[null]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testSerializeNullObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeNullObject() throws IOException {\r\n    Truck truck \u003d truckAdapter.fromJson(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:[null]}\".replace(\u0027\\\u0027\u0027, \u0027\\\"\u0027));\r\n    assertThat(truck.passengers).isEqualTo(Arrays.asList((Person) null));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testDeserializeNullObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeWithCustomTypeAdapter() {\r\n    usePersonNameAdapter();\r\n    Truck truck \u003d new Truck();\r\n    truck.passengers \u003d Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29));\r\n    assertThat(truckAdapter.toJson(truck).replace(\u0027\\\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:[\u0027Jesse\u0027,\u0027Jodie\u0027]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testSerializeWithCustomTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeWithCustomTypeAdapter() throws IOException {\r\n    usePersonNameAdapter();\r\n    Truck truck \u003d truckAdapter.fromJson(\"{\u0027horsePower\u0027:0.0,\u0027passengers\u0027:[\u0027Jesse\u0027,\u0027Jodie\u0027]}\".replace(\u0027\\\u0027\u0027, \u0027\\\"\u0027));\r\n    assertThat(truck.passengers).isEqualTo(Arrays.asList(new Person(\"Jesse\", -1), new Person(\"Jodie\", -1)));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testDeserializeWithCustomTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Person read(JsonReader in) throws IOException {\r\n    String name \u003d in.nextString();\r\n    return new Person(name, -1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Person"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Person value) throws IOException {\r\n    out.value(value.name);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Person"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void usePersonNameAdapter() {\r\n    TypeAdapter\u003cPerson\u003e personNameAdapter \u003d new TypeAdapter\u003cPerson\u003e() {\r\n\r\n        @Override\r\n        public Person read(JsonReader in) throws IOException {\r\n            String name \u003d in.nextString();\r\n            return new Person(name, -1);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Person value) throws IOException {\r\n            out.value(value.name);\r\n        }\r\n    };\r\n    miniGson \u003d new GsonBuilder().registerTypeAdapter(Person.class, personNameAdapter).create();\r\n    truckAdapter \u003d miniGson.getAdapter(Truck.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "usePersonNameAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeMap() {\r\n    Map\u003cString, Double\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", 5.0);\r\n    map.put(\"b\", 10.0);\r\n    assertThat(mapAdapter.toJson(map).replace(\u0027\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027a\u0027:5.0,\u0027b\u0027:10.0}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testSerializeMap",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeMap() throws IOException {\r\n    Map\u003cString, Double\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", 5.0);\r\n    map.put(\"b\", 10.0);\r\n    assertThat(mapAdapter.fromJson(\"{\u0027a\u0027:5.0,\u0027b\u0027:10.0}\".replace(\u0027\\\u0027\u0027, \u0027\\\"\u0027))).isEqualTo(map);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testDeserializeMap",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerialize1dArray() {\r\n    TypeAdapter\u003cdouble[]\u003e arrayAdapter \u003d miniGson.getAdapter(new TypeToken\u003cdouble[]\u003e() {\r\n    });\r\n    assertThat(arrayAdapter.toJson(new double[] { 1.0, 2.0, 3.0 })).isEqualTo(\"[1.0,2.0,3.0]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testSerialize1dArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserialize1dArray() throws IOException {\r\n    TypeAdapter\u003cdouble[]\u003e arrayAdapter \u003d miniGson.getAdapter(new TypeToken\u003cdouble[]\u003e() {\r\n    });\r\n    double[] array \u003d arrayAdapter.fromJson(\"[1.0,2.0,3.0]\");\r\n    assertThat(array).isEqualTo(new double[] { 1.0, 2.0, 3.0 });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testDeserialize1dArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerialize2dArray() {\r\n    TypeAdapter\u003cdouble[][]\u003e arrayAdapter \u003d miniGson.getAdapter(new TypeToken\u003cdouble[][]\u003e() {\r\n    });\r\n    double[][] array \u003d { { 1.0, 2.0 }, { 3.0 } };\r\n    assertThat(arrayAdapter.toJson(array)).isEqualTo(\"[[1.0,2.0],[3.0]]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testSerialize2dArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserialize2dArray() throws IOException {\r\n    TypeAdapter\u003cdouble[][]\u003e arrayAdapter \u003d miniGson.getAdapter(new TypeToken\u003cdouble[][]\u003e() {\r\n    });\r\n    double[][] array \u003d arrayAdapter.fromJson(\"[[1.0,2.0],[3.0]]\");\r\n    double[][] expected \u003d { { 1.0, 2.0 }, { 3.0 } };\r\n    assertThat(array).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testDeserialize2dArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Person read(JsonReader in) throws IOException {\r\n    List\u003cString\u003e values \u003d Splitter.on(\u0027,\u0027).splitToList(in.nextString());\r\n    return new Person(values.get(0), Integer.parseInt(values.get(1)));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Person"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Person person) throws IOException {\r\n    out.value(person.name + \",\" + person.age);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Person"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullSafe() {\r\n    TypeAdapter\u003cPerson\u003e typeAdapter \u003d new TypeAdapter\u003cPerson\u003e() {\r\n\r\n        @Override\r\n        public Person read(JsonReader in) throws IOException {\r\n            List\u003cString\u003e values \u003d Splitter.on(\u0027,\u0027).splitToList(in.nextString());\r\n            return new Person(values.get(0), Integer.parseInt(values.get(1)));\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Person person) throws IOException {\r\n            out.value(person.name + \",\" + person.age);\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Person.class, typeAdapter).create();\r\n    Truck truck \u003d new Truck();\r\n    truck.horsePower \u003d 1.0D;\r\n    truck.passengers \u003d new ArrayList\u003c\u003e();\r\n    truck.passengers.add(null);\r\n    truck.passengers.add(new Person(\"jesse\", 30));\r\n    try {\r\n        gson.toJson(truck, Truck.class);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n    String json \u003d \"{horsePower:1.0,passengers:[null,\u0027jesse,30\u0027]}\";\r\n    try {\r\n        gson.fromJson(json, Truck.class);\r\n        fail();\r\n    } catch (JsonSyntaxException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"java.lang.IllegalStateException: Expected a string but was NULL at line 1 column 33 path $.passengers[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#adapter-not-null-safe\");\r\n    }\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(Person.class, typeAdapter.nullSafe()).create();\r\n    assertThat(gson.toJson(truck, Truck.class)).isEqualTo(\"{\\\"horsePower\\\":1.0,\\\"passengers\\\":[null,\\\"jesse,30\\\"]}\");\r\n    truck \u003d gson.fromJson(json, Truck.class);\r\n    assertThat(truck.horsePower).isEqualTo(1.0D);\r\n    assertThat(truck.passengers.get(0)).isNull();\r\n    assertThat(truck.passengers.get(1).name).isEqualTo(\"jesse\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testNullSafe",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeRecursive() {\r\n    TypeAdapter\u003cNode\u003e nodeAdapter \u003d miniGson.getAdapter(Node.class);\r\n    Node root \u003d new Node(\"root\");\r\n    root.left \u003d new Node(\"left\");\r\n    root.right \u003d new Node(\"right\");\r\n    assertThat(nodeAdapter.toJson(root).replace(\u0027\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027label\u0027:\u0027root\u0027,\" + \"\u0027left\u0027:{\u0027label\u0027:\u0027left\u0027,\u0027left\u0027:null,\u0027right\u0027:null},\" + \"\u0027right\u0027:{\u0027label\u0027:\u0027right\u0027,\u0027left\u0027:null,\u0027right\u0027:null}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testSerializeRecursive",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFromJsonTree() {\r\n    JsonObject truckObject \u003d new JsonObject();\r\n    truckObject.add(\"horsePower\", new JsonPrimitive(300));\r\n    JsonArray passengersArray \u003d new JsonArray();\r\n    JsonObject jesseObject \u003d new JsonObject();\r\n    jesseObject.add(\"age\", new JsonPrimitive(30));\r\n    jesseObject.add(\"name\", new JsonPrimitive(\"Jesse\"));\r\n    passengersArray.add(jesseObject);\r\n    truckObject.add(\"passengers\", passengersArray);\r\n    Truck truck \u003d truckAdapter.fromJsonTree(truckObject);\r\n    assertThat(truck.horsePower).isEqualTo(300.0);\r\n    assertThat(truck.passengers).isEqualTo(Arrays.asList(new Person(\"Jesse\", 30)));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest",
      "methodName": "testFromJsonTree",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    return o instanceof Person \u0026\u0026 ((Person) o).name.equals(name) \u0026\u0026 ((Person) o).age \u003d\u003d age;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest.Person",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return name.hashCode() ^ age;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StreamingTypeAdaptersTest.Person",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringValueSerialization() {\r\n    String value \u003d \"someRandomStringValue\";\r\n    assertThat(gson.toJson(value)).isEqualTo(\u0027\"\u0027 + value + \u0027\"\u0027);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testStringValueSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringValueDeserialization() {\r\n    String value \u003d \"someRandomStringValue\";\r\n    String actual \u003d gson.fromJson(\"\\\"\" + value + \"\\\"\", String.class);\r\n    assertThat(actual).isEqualTo(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testStringValueDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSingleQuoteInStringSerialization() {\r\n    String valueWithQuotes \u003d \"beforeQuote\u0027afterQuote\";\r\n    String jsonRepresentation \u003d gson.toJson(valueWithQuotes);\r\n    assertThat(gson.fromJson(jsonRepresentation, String.class)).isEqualTo(valueWithQuotes);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testSingleQuoteInStringSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapedCtrlNInStringSerialization() {\r\n    String value \u003d \"a\\nb\";\r\n    String json \u003d gson.toJson(value);\r\n    assertThat(json).isEqualTo(\"\\\"a\\\\nb\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testEscapedCtrlNInStringSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapedCtrlNInStringDeserialization() {\r\n    String json \u003d \"\u0027a\\\\nb\u0027\";\r\n    String actual \u003d gson.fromJson(json, String.class);\r\n    assertThat(actual).isEqualTo(\"a\\nb\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testEscapedCtrlNInStringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapedCtrlRInStringSerialization() {\r\n    String value \u003d \"a\\rb\";\r\n    String json \u003d gson.toJson(value);\r\n    assertThat(json).isEqualTo(\"\\\"a\\\\rb\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testEscapedCtrlRInStringSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapedCtrlRInStringDeserialization() {\r\n    String json \u003d \"\u0027a\\\\rb\u0027\";\r\n    String actual \u003d gson.fromJson(json, String.class);\r\n    assertThat(actual).isEqualTo(\"a\\rb\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testEscapedCtrlRInStringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapedBackslashInStringSerialization() {\r\n    String value \u003d \"a\\\\b\";\r\n    String json \u003d gson.toJson(value);\r\n    assertThat(json).isEqualTo(\"\\\"a\\\\\\\\b\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testEscapedBackslashInStringSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapedBackslashInStringDeserialization() {\r\n    String actual \u003d gson.fromJson(\"\u0027a\\\\\\\\b\u0027\", String.class);\r\n    assertThat(actual).isEqualTo(\"a\\\\b\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testEscapedBackslashInStringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSingleQuoteInStringDeserialization() {\r\n    String value \u003d \"beforeQuote\u0027afterQuote\";\r\n    String actual \u003d gson.fromJson(\"\\\"\" + value + \"\\\"\", String.class);\r\n    assertThat(actual).isEqualTo(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testSingleQuoteInStringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapingQuotesInStringSerialization() {\r\n    String valueWithQuotes \u003d \"beforeQuote\\\"afterQuote\";\r\n    String jsonRepresentation \u003d gson.toJson(valueWithQuotes);\r\n    String target \u003d gson.fromJson(jsonRepresentation, String.class);\r\n    assertThat(target).isEqualTo(valueWithQuotes);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testEscapingQuotesInStringSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapingQuotesInStringDeserialization() {\r\n    String value \u003d \"beforeQuote\\\\\\\"afterQuote\";\r\n    String actual \u003d gson.fromJson(\"\\\"\" + value + \"\\\"\", String.class);\r\n    String expected \u003d \"beforeQuote\\\"afterQuote\";\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testEscapingQuotesInStringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringValueAsSingleElementArraySerialization() {\r\n    String[] target \u003d { \"abc\" };\r\n    assertThat(gson.toJson(target)).isEqualTo(\"[\\\"abc\\\"]\");\r\n    assertThat(gson.toJson(target, String[].class)).isEqualTo(\"[\\\"abc\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testStringValueAsSingleElementArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringWithEscapedSlashDeserialization() {\r\n    String value \u003d \"/\";\r\n    String json \u003d \"\u0027\\\\/\u0027\";\r\n    String actual \u003d gson.fromJson(json, String.class);\r\n    assertThat(actual).isEqualTo(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testStringWithEscapedSlashDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to http://groups.google.com/group/google-gson/browse_thread/thread/2431d4a3d0d6cb23\r\n */\r\n@Test\r\npublic void testAssignmentCharSerialization() {\r\n    String value \u003d \"abc\u003d\";\r\n    String json \u003d gson.toJson(value);\r\n    assertThat(json).isEqualTo(\"\\\"abc\\\\u003d\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testAssignmentCharSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to http://groups.google.com/group/google-gson/browse_thread/thread/2431d4a3d0d6cb23\r\n */\r\n@Test\r\npublic void testAssignmentCharDeserialization() {\r\n    String json \u003d \"\\\"abc\u003d\\\"\";\r\n    String value \u003d gson.fromJson(json, String.class);\r\n    assertThat(value).isEqualTo(\"abc\u003d\");\r\n    json \u003d \"\u0027abc\\\\u003d\u0027\";\r\n    value \u003d gson.fromJson(json, String.class);\r\n    assertThat(value).isEqualTo(\"abc\u003d\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testAssignmentCharDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJavascriptKeywordsInStringSerialization() {\r\n    String value \u003d \"null true false function\";\r\n    String json \u003d gson.toJson(value);\r\n    assertThat(json).isEqualTo(\"\\\"\" + value + \"\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testJavascriptKeywordsInStringSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJavascriptKeywordsInStringDeserialization() {\r\n    String json \u003d \"\u0027null true false function\u0027\";\r\n    String value \u003d gson.fromJson(json, String.class);\r\n    assertThat(json.substring(1, json.length() - 1)).isEqualTo(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.StringTest",
      "methodName": "testJavascriptKeywordsInStringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefault() {\r\n    Gson gson \u003d new Gson();\r\n    assertThat(gson.fromJson(\"null\", Object.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Object.class)).isEqualTo(10D);\r\n    assertThat(gson.fromJson(\"null\", Number.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Number.class)).isEqualTo(new LazilyParsedNumber(\"10\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ToNumberPolicyFunctionalTest",
      "methodName": "testDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAsDoubles() {\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(ToNumberPolicy.DOUBLE).setNumberToNumberStrategy(ToNumberPolicy.DOUBLE).create();\r\n    assertThat(gson.fromJson(\"null\", Object.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Object.class)).isEqualTo(10.0);\r\n    assertThat(gson.fromJson(\"null\", Number.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Number.class)).isEqualTo(10.0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ToNumberPolicyFunctionalTest",
      "methodName": "testAsDoubles",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAsLazilyParsedNumbers() {\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(ToNumberPolicy.LAZILY_PARSED_NUMBER).setNumberToNumberStrategy(ToNumberPolicy.LAZILY_PARSED_NUMBER).create();\r\n    assertThat(gson.fromJson(\"null\", Object.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Object.class)).isEqualTo(new LazilyParsedNumber(\"10\"));\r\n    assertThat(gson.fromJson(\"null\", Number.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Number.class)).isEqualTo(new LazilyParsedNumber(\"10\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ToNumberPolicyFunctionalTest",
      "methodName": "testAsLazilyParsedNumbers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAsLongsOrDoubles() {\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(ToNumberPolicy.LONG_OR_DOUBLE).setNumberToNumberStrategy(ToNumberPolicy.LONG_OR_DOUBLE).create();\r\n    assertThat(gson.fromJson(\"null\", Object.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Object.class)).isEqualTo(10L);\r\n    assertThat(gson.fromJson(\"10.0\", Object.class)).isEqualTo(10.0);\r\n    assertThat(gson.fromJson(\"null\", Number.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Number.class)).isEqualTo(10L);\r\n    assertThat(gson.fromJson(\"10.0\", Number.class)).isEqualTo(10.0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ToNumberPolicyFunctionalTest",
      "methodName": "testAsLongsOrDoubles",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAsBigDecimals() {\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(ToNumberPolicy.BIG_DECIMAL).setNumberToNumberStrategy(ToNumberPolicy.BIG_DECIMAL).create();\r\n    assertThat(gson.fromJson(\"null\", Object.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Object.class)).isEqualTo(new BigDecimal(\"10\"));\r\n    assertThat(gson.fromJson(\"10.0\", Object.class)).isEqualTo(new BigDecimal(\"10.0\"));\r\n    assertThat(gson.fromJson(\"null\", Number.class)).isEqualTo(null);\r\n    assertThat(gson.fromJson(\"10\", Number.class)).isEqualTo(new BigDecimal(\"10\"));\r\n    assertThat(gson.fromJson(\"10.0\", Number.class)).isEqualTo(new BigDecimal(\"10.0\"));\r\n    assertThat(gson.fromJson(\"3.141592653589793238462643383279\", BigDecimal.class)).isEqualTo(new BigDecimal(\"3.141592653589793238462643383279\"));\r\n    assertThat(gson.fromJson(\"1e400\", BigDecimal.class)).isEqualTo(new BigDecimal(\"1e400\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ToNumberPolicyFunctionalTest",
      "methodName": "testAsBigDecimals",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAsListOfLongsOrDoubles() {\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(ToNumberPolicy.LONG_OR_DOUBLE).setNumberToNumberStrategy(ToNumberPolicy.LONG_OR_DOUBLE).create();\r\n    Type objectCollectionType \u003d new TypeToken\u003cCollection\u003cObject\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cObject\u003e objects \u003d gson.fromJson(\"[null,10,10.0]\", objectCollectionType);\r\n    assertThat(objects).containsExactly(null, 10L, 10.0).inOrder();\r\n    Type numberCollectionType \u003d new TypeToken\u003cCollection\u003cNumber\u003e\u003e() {\r\n    }.getType();\r\n    Collection\u003cObject\u003e numbers \u003d gson.fromJson(\"[null,10,10.0]\", numberCollectionType);\r\n    assertThat(numbers).containsExactly(null, 10L, 10.0).inOrder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ToNumberPolicyFunctionalTest",
      "methodName": "testAsListOfLongsOrDoubles",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Byte readNumber(JsonReader in) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ToNumberPolicyFunctionalTest",
      "methodName": "readNumber",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Byte"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomStrategiesCannotAffectConcreteDeclaredNumbers() {\r\n    ToNumberStrategy fail \u003d new ToNumberStrategy() {\r\n\r\n        @Override\r\n        public Byte readNumber(JsonReader in) {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n    Gson gson \u003d new GsonBuilder().setObjectToNumberStrategy(fail).setNumberToNumberStrategy(fail).create();\r\n    List\u003cObject\u003e numbers \u003d gson.fromJson(\"[null, 10, 20, 30]\", new TypeToken\u003cList\u003cByte\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(numbers).containsExactly(null, (byte) 10, (byte) 20, (byte) 30).inOrder();\r\n    try {\r\n        gson.fromJson(\"[null, 10, 20, 30]\", new TypeToken\u003cList\u003cObject\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (UnsupportedOperationException ex) {\r\n    }\r\n    try {\r\n        gson.fromJson(\"[null, 10, 20, 30]\", new TypeToken\u003cList\u003cNumber\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (UnsupportedOperationException ex) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.ToNumberPolicyFunctionalTest",
      "methodName": "testCustomStrategiesCannotAffectConcreteDeclaredNumbers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() {\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(Id.class, new IdTreeTypeAdapter()).create();\r\n    course \u003d new Course\u003c\u003e(COURSE_ID, 4, new Assignment\u003cHistoryCourse\u003e(null, null), Arrays.asList(STUDENT1, STUDENT2));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TreeTypeAdaptersTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeId() {\r\n    String json \u003d gson.toJson(course, TYPE_COURSE_HISTORY);\r\n    assertThat(json).contains(String.valueOf(COURSE_ID.getValue()));\r\n    assertThat(json).contains(String.valueOf(STUDENT1_ID.getValue()));\r\n    assertThat(json).contains(String.valueOf(STUDENT2_ID.getValue()));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TreeTypeAdaptersTest",
      "methodName": "testSerializeId",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeId() {\r\n    String json \u003d \"{courseId:1,students:[{id:1,name:\u0027first\u0027},{id:6,name:\u0027second\u0027}],\" + \"numAssignments:4,assignment:{}}\";\r\n    Course\u003cHistoryCourse\u003e target \u003d gson.fromJson(json, TYPE_COURSE_HISTORY);\r\n    assertThat(target.getStudents().get(0).id.getValue()).isEqualTo(\"1\");\r\n    assertThat(target.getStudents().get(1).id.getValue()).isEqualTo(\"6\");\r\n    assertThat(target.getId().getValue()).isEqualTo(\"1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TreeTypeAdaptersTest",
      "methodName": "testDeserializeId",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public String getValue() {\r\n    return value;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TreeTypeAdaptersTest.Id",
      "methodName": "getValue",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Id\u003c?\u003e deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    if (!(typeOfT instanceof ParameterizedType)) {\r\n        throw new JsonParseException(\"Id of unknown type: \" + typeOfT);\r\n    }\r\n    ParameterizedType parameterizedType \u003d (ParameterizedType) typeOfT;\r\n    // Since Id takes only one TypeVariable, the actual type corresponding to the first\r\n    // TypeVariable is the Type we are looking for\r\n    Type typeOfId \u003d parameterizedType.getActualTypeArguments()[0];\r\n    return new Id\u003c\u003e(json.getAsString(), typeOfId);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TreeTypeAdaptersTest.IdTreeTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Id\u003c?\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Id\u003c?\u003e src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(src.getValue());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TreeTypeAdaptersTest.IdTreeTypeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "Id\u003c?\u003e",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "public Id\u003cCourse\u003cT\u003e\u003e getId() {\r\n    return courseId;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TreeTypeAdaptersTest.Course",
      "methodName": "getId",
      "parameterTypes": [],
      "returnType": "Id\u003cCourse\u003cT\u003e\u003e"
    }
  },
  {
    "sourceCode": "List\u003cStudent\u003e getStudents() {\r\n    return students;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TreeTypeAdaptersTest.Course",
      "methodName": "getStudents",
      "parameterTypes": [],
      "returnType": "List\u003cStudent\u003e"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonstreamingFollowedByNonstreaming() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, newSerializer(\"serializer 1\")).registerTypeAdapter(Foo.class, newSerializer(\"serializer 2\")).registerTypeAdapter(Foo.class, newDeserializer(\"deserializer 1\")).registerTypeAdapter(Foo.class, newDeserializer(\"deserializer 2\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via serializer 2\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via deserializer 2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "testNonstreamingFollowedByNonstreaming",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStreamingFollowedByStreaming() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, newTypeAdapter(\"type adapter 1\")).registerTypeAdapter(Foo.class, newTypeAdapter(\"type adapter 2\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via type adapter 2\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via type adapter 2\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "testStreamingFollowedByStreaming",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeNonstreamingTypeAdapterFollowedByStreamingTypeAdapter() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, newSerializer(\"serializer\")).registerTypeAdapter(Foo.class, newDeserializer(\"deserializer\")).registerTypeAdapter(Foo.class, newTypeAdapter(\"type adapter\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via type adapter\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via type adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "testSerializeNonstreamingTypeAdapterFollowedByStreamingTypeAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStreamingFollowedByNonstreaming() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, newTypeAdapter(\"type adapter\")).registerTypeAdapter(Foo.class, newSerializer(\"serializer\")).registerTypeAdapter(Foo.class, newDeserializer(\"deserializer\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via serializer\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via deserializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "testStreamingFollowedByNonstreaming",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStreamingHierarchicalFollowedByNonstreaming() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Foo.class, newTypeAdapter(\"type adapter\")).registerTypeAdapter(Foo.class, newSerializer(\"serializer\")).registerTypeAdapter(Foo.class, newDeserializer(\"deserializer\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via serializer\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via deserializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "testStreamingHierarchicalFollowedByNonstreaming",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStreamingFollowedByNonstreamingHierarchical() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, newTypeAdapter(\"type adapter\")).registerTypeHierarchyAdapter(Foo.class, newSerializer(\"serializer\")).registerTypeHierarchyAdapter(Foo.class, newDeserializer(\"deserializer\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via type adapter\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via type adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "testStreamingFollowedByNonstreamingHierarchical",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStreamingHierarchicalFollowedByNonstreamingHierarchical() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Foo.class, newSerializer(\"serializer\")).registerTypeHierarchyAdapter(Foo.class, newDeserializer(\"deserializer\")).registerTypeHierarchyAdapter(Foo.class, newTypeAdapter(\"type adapter\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via type adapter\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via type adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "testStreamingHierarchicalFollowedByNonstreamingHierarchical",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonstreamingHierarchicalFollowedByNonstreaming() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Foo.class, newSerializer(\"hierarchical\")).registerTypeHierarchyAdapter(Foo.class, newDeserializer(\"hierarchical\")).registerTypeAdapter(Foo.class, newSerializer(\"non hierarchical\")).registerTypeAdapter(Foo.class, newDeserializer(\"non hierarchical\")).create();\r\n    assertThat(gson.toJson(new Foo(\"foo\"))).isEqualTo(\"\\\"foo via non hierarchical\\\"\");\r\n    assertThat(gson.fromJson(\"foo\", Foo.class).name).isEqualTo(\"foo via non hierarchical\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "testNonstreamingHierarchicalFollowedByNonstreaming",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(src.name + \" via \" + name);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "serialize",
      "parameterTypes": [
        "Foo",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "private JsonSerializer\u003cFoo\u003e newSerializer(final String name) {\r\n    return new JsonSerializer\u003cFoo\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(src.name + \" via \" + name);\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "newSerializer",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonSerializer\u003cFoo\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n    return new Foo(json.getAsString() + \" via \" + name);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Foo"
    }
  },
  {
    "sourceCode": "private JsonDeserializer\u003cFoo\u003e newDeserializer(final String name) {\r\n    return new JsonDeserializer\u003cFoo\u003e() {\r\n\r\n        @Override\r\n        public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n            return new Foo(json.getAsString() + \" via \" + name);\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "newDeserializer",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonDeserializer\u003cFoo\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Foo read(JsonReader in) throws IOException {\r\n    return new Foo(in.nextString() + \" via \" + name);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Foo"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Foo value) throws IOException {\r\n    out.value(value.name + \" via \" + name);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Foo"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private TypeAdapter\u003cFoo\u003e newTypeAdapter(final String name) {\r\n    return new TypeAdapter\u003cFoo\u003e() {\r\n\r\n        @Override\r\n        public Foo read(JsonReader in) throws IOException {\r\n            return new Foo(in.nextString() + \" via \" + name);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Foo value) throws IOException {\r\n            out.value(value.name + \" via \" + name);\r\n        }\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterPrecedenceTest",
      "methodName": "newTypeAdapter",
      "parameterTypes": [
        "String"
      ],
      "returnType": "TypeAdapter\u003cFoo\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n    throw new AssertionError(\"not needed for this test\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest.Deserializer",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Base"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"serializer\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "serialize",
      "parameterTypes": [
        "Base",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * When custom {@link JsonSerializer} is registered for Base should\r\n * prefer that over reflective adapter for Subclass for serialization.\r\n */\r\n@Test\r\npublic void testJsonSerializer() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"serializer\");\r\n        }\r\n    }).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":\\\"serializer\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "testJsonSerializer",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * When only {@link JsonDeserializer} is registered for Base, then on\r\n * serialization should prefer reflective adapter for Subclass since\r\n * Base would use reflective adapter as delegate.\r\n */\r\n@Test\r\npublic void testJsonDeserializer_ReflectiveSerializerDelegate() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new Deserializer()).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":{\\\"f\\\":\\\"test\\\"}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "testJsonDeserializer_ReflectiveSerializerDelegate",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Base read(JsonReader in) throws IOException {\r\n    throw new UnsupportedOperationException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Base"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Base value) throws IOException {\r\n    out.value(\"custom delegate\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Base"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * When {@link JsonDeserializer} with custom adapter as delegate is\r\n * registered for Base, then on serialization should prefer custom adapter\r\n * delegate for Base over reflective adapter for Subclass.\r\n */\r\n@Test\r\npublic void testJsonDeserializer_CustomSerializerDelegate() {\r\n    Gson gson \u003d new GsonBuilder().// Register custom delegate\r\n    registerTypeAdapter(Base.class, new TypeAdapter\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public Base read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Base value) throws IOException {\r\n            out.value(\"custom delegate\");\r\n        }\r\n    }).registerTypeAdapter(Base.class, new Deserializer()).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":\\\"custom delegate\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "testJsonDeserializer_CustomSerializerDelegate",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * When two (or more) {@link JsonDeserializer}s are registered for Base\r\n * which eventually fall back to reflective adapter as delegate, then on\r\n * serialization should prefer reflective adapter for Subclass.\r\n */\r\n@Test\r\npublic void testJsonDeserializer_ReflectiveTreeSerializerDelegate() {\r\n    Gson gson \u003d new GsonBuilder().// Register delegate which itself falls back to reflective serialization\r\n    registerTypeAdapter(Base.class, new Deserializer()).registerTypeAdapter(Base.class, new Deserializer()).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":{\\\"f\\\":\\\"test\\\"}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "testJsonDeserializer_ReflectiveTreeSerializerDelegate",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"custom delegate\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "serialize",
      "parameterTypes": [
        "Base",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "/**\r\n * When {@link JsonDeserializer} with {@link JsonSerializer} as delegate\r\n * is registered for Base, then on serialization should prefer\r\n * {@code JsonSerializer} over reflective adapter for Subclass.\r\n */\r\n@Test\r\npublic void testJsonDeserializer_JsonSerializerDelegate() {\r\n    Gson gson \u003d new GsonBuilder().// Register JsonSerializer as delegate\r\n    registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"custom delegate\");\r\n        }\r\n    }).registerTypeAdapter(Base.class, new Deserializer()).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":\\\"custom delegate\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "testJsonDeserializer_JsonSerializerDelegate",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"base\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "serialize",
      "parameterTypes": [
        "Base",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Subclass deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n    throw new AssertionError(\"not needed for this test\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Subclass"
    }
  },
  {
    "sourceCode": "/**\r\n * When a {@link JsonDeserializer} is registered for Subclass, and a custom\r\n * {@link JsonSerializer} is registered for Base, then Gson should prefer\r\n * the reflective adapter for Subclass for backward compatibility (see\r\n * https://github.com/google/gson/pull/1787#issuecomment-1222175189) even\r\n * though normally TypeAdapterRuntimeTypeWrapper should prefer the custom\r\n * serializer for Base.\r\n */\r\n@Test\r\npublic void testJsonDeserializer_SubclassBackwardCompatibility() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Subclass.class, new JsonDeserializer\u003cSubclass\u003e() {\r\n\r\n        @Override\r\n        public Subclass deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n    }).registerTypeAdapter(Base.class, new JsonSerializer\u003cBase\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"base\");\r\n        }\r\n    }).create();\r\n    String json \u003d gson.toJson(new Container());\r\n    assertThat(json).isEqualTo(\"{\\\"b\\\":{\\\"f\\\":\\\"test\\\"}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "testJsonDeserializer_SubclassBackwardCompatibility",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior when the type of a field refers to a type whose adapter is\r\n * currently in the process of being created. For these cases {@link Gson}\r\n * uses a future adapter for the type. That adapter later uses the actual\r\n * adapter as delegate.\r\n */\r\n@Test\r\npublic void testGsonFutureAdapter() {\r\n    CyclicBase b \u003d new CyclicBase();\r\n    b.f \u003d new CyclicSub(2);\r\n    String json \u003d new Gson().toJson(b);\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":{\\\"i\\\":2}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest",
      "methodName": "testGsonFutureAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTypeHierarchy() {\r\n    Manager andy \u003d new Manager();\r\n    andy.userid \u003d \"andy\";\r\n    andy.startDate \u003d 2005;\r\n    andy.minions \u003d new Employee[] { new Employee(\"inder\", 2007), new Employee(\"joel\", 2006), new Employee(\"jesse\", 2006) };\r\n    CEO eric \u003d new CEO();\r\n    eric.userid \u003d \"eric\";\r\n    eric.startDate \u003d 2001;\r\n    eric.assistant \u003d new Employee(\"jerome\", 2006);\r\n    eric.minions \u003d new Employee[] { new Employee(\"larry\", 1998), new Employee(\"sergey\", 1998), andy };\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter()).setPrettyPrinting().create();\r\n    Company company \u003d new Company();\r\n    company.ceo \u003d eric;\r\n    String json \u003d gson.toJson(company, Company.class);\r\n    assertThat(json).isEqualTo(\"{\\n\" + \"  \\\"ceo\\\": {\\n\" + \"    \\\"userid\\\": \\\"eric\\\",\\n\" + \"    \\\"startDate\\\": 2001,\\n\" + \"    \\\"minions\\\": [\\n\" + \"      {\\n\" + \"        \\\"userid\\\": \\\"larry\\\",\\n\" + \"        \\\"startDate\\\": 1998\\n\" + \"      },\\n\" + \"      {\\n\" + \"        \\\"userid\\\": \\\"sergey\\\",\\n\" + \"        \\\"startDate\\\": 1998\\n\" + \"      },\\n\" + \"      {\\n\" + \"        \\\"userid\\\": \\\"andy\\\",\\n\" + \"        \\\"startDate\\\": 2005,\\n\" + \"        \\\"minions\\\": [\\n\" + \"          {\\n\" + \"            \\\"userid\\\": \\\"inder\\\",\\n\" + \"            \\\"startDate\\\": 2007\\n\" + \"          },\\n\" + \"          {\\n\" + \"            \\\"userid\\\": \\\"joel\\\",\\n\" + \"            \\\"startDate\\\": 2006\\n\" + \"          },\\n\" + \"          {\\n\" + \"            \\\"userid\\\": \\\"jesse\\\",\\n\" + \"            \\\"startDate\\\": 2006\\n\" + \"          }\\n\" + \"        ]\\n\" + \"      }\\n\" + \"    ],\\n\" + \"    \\\"assistant\\\": {\\n\" + \"      \\\"userid\\\": \\\"jerome\\\",\\n\" + \"      \\\"startDate\\\": 2006\\n\" + \"    }\\n\" + \"  }\\n\" + \"}\");\r\n    Company copied \u003d gson.fromJson(json, Company.class);\r\n    assertThat(gson.toJson(copied, Company.class)).isEqualTo(json);\r\n    assertThat(company.ceo.userid).isEqualTo(copied.ceo.userid);\r\n    assertThat(company.ceo.assistant.userid).isEqualTo(copied.ceo.assistant.userid);\r\n    assertThat(company.ceo.minions[0].userid).isEqualTo(copied.ceo.minions[0].userid);\r\n    assertThat(company.ceo.minions[1].userid).isEqualTo(copied.ceo.minions[1].userid);\r\n    assertThat(company.ceo.minions[2].userid).isEqualTo(copied.ceo.minions[2].userid);\r\n    assertThat(((Manager) company.ceo.minions[2]).minions[0].userid).isEqualTo(((Manager) copied.ceo.minions[2]).minions[0].userid);\r\n    assertThat(((Manager) company.ceo.minions[2]).minions[1].userid).isEqualTo(((Manager) copied.ceo.minions[2]).minions[1].userid);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeHierarchyAdapterTest",
      "methodName": "testTypeHierarchy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRegisterSuperTypeFirst() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter()).registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter()).create();\r\n    Manager manager \u003d new Manager();\r\n    manager.userid \u003d \"inder\";\r\n    String json \u003d gson.toJson(manager, Manager.class);\r\n    assertThat(json).isEqualTo(\"\\\"inder\\\"\");\r\n    Manager copied \u003d gson.fromJson(json, Manager.class);\r\n    assertThat(copied.userid).isEqualTo(manager.userid);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeHierarchyAdapterTest",
      "methodName": "testRegisterSuperTypeFirst",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This behaviour changed in Gson 2.1; it used to throw.\r\n */\r\n@Test\r\npublic void testRegisterSubTypeFirstAllowed() {\r\n    Gson unused \u003d new GsonBuilder().registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter()).registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter()).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeHierarchyAdapterTest",
      "methodName": "testRegisterSubTypeFirstAllowed",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Manager deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n    Manager result \u003d new Manager();\r\n    result.userid \u003d json.getAsString();\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeHierarchyAdapterTest.ManagerAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Manager"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Manager src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(src.userid);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeHierarchyAdapterTest.ManagerAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "Manager",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Employee employee, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonObject result \u003d new JsonObject();\r\n    result.add(\"userid\", context.serialize(employee.userid, String.class));\r\n    result.add(\"startDate\", context.serialize(employee.startDate, long.class));\r\n    if (employee instanceof Manager) {\r\n        result.add(\"minions\", context.serialize(((Manager) employee).minions, Employee[].class));\r\n        if (employee instanceof CEO) {\r\n            result.add(\"assistant\", context.serialize(((CEO) employee).assistant, Employee.class));\r\n        }\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeHierarchyAdapterTest.EmployeeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "Employee",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Employee deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    JsonObject object \u003d json.getAsJsonObject();\r\n    Employee result \u003d null;\r\n    // if the employee has an assistant, she must be the CEO\r\n    JsonElement assistant \u003d object.get(\"assistant\");\r\n    if (assistant !\u003d null) {\r\n        result \u003d new CEO();\r\n        ((CEO) result).assistant \u003d context.deserialize(assistant, Employee.class);\r\n    }\r\n    // only managers have minions\r\n    JsonElement minons \u003d object.get(\"minions\");\r\n    if (minons !\u003d null) {\r\n        if (result \u003d\u003d null) {\r\n            result \u003d new Manager();\r\n        }\r\n        ((Manager) result).minions \u003d context.deserialize(minons, Employee[].class);\r\n    }\r\n    if (result \u003d\u003d null) {\r\n        result \u003d new Employee();\r\n    }\r\n    result.userid \u003d context.deserialize(object.get(\"userid\"), String.class);\r\n    result.startDate \u003d context.\u003cLong\u003edeserialize(object.get(\"startDate\"), long.class);\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeHierarchyAdapterTest.EmployeeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Employee"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAdvancedTypeVariables() {\r\n    Gson gson \u003d new Gson();\r\n    Bar bar1 \u003d new Bar(\"someString\", 1, true);\r\n    ArrayList\u003cInteger\u003e arrayList \u003d new ArrayList\u003c\u003e();\r\n    arrayList.add(1);\r\n    arrayList.add(2);\r\n    arrayList.add(3);\r\n    bar1.map.put(\"key1\", arrayList);\r\n    bar1.map.put(\"key2\", new ArrayList\u003cInteger\u003e());\r\n    String json \u003d gson.toJson(bar1);\r\n    Bar bar2 \u003d gson.fromJson(json, Bar.class);\r\n    assertThat(bar2).isEqualTo(bar1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeVariableTest",
      "methodName": "testAdvancedTypeVariables",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTypeVariablesViaTypeParameter() {\r\n    Gson gson \u003d new Gson();\r\n    Foo\u003cString, Integer\u003e original \u003d new Foo\u003c\u003e(\"e\", 5, false);\r\n    original.map.put(\"f\", Arrays.asList(6, 7));\r\n    Type type \u003d new TypeToken\u003cFoo\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    String json \u003d gson.toJson(original, type);\r\n    assertThat(json).isEqualTo(\"{\\\"someSField\\\":\\\"e\\\",\\\"someTField\\\":5,\\\"map\\\":{\\\"f\\\":[6,7]},\\\"redField\\\":false}\");\r\n    assertThat(gson.\u003cFoo\u003cString, Integer\u003e\u003efromJson(json, type)).isEqualTo(original);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeVariableTest",
      "methodName": "testTypeVariablesViaTypeParameter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBasicTypeVariables() {\r\n    Gson gson \u003d new Gson();\r\n    Blue blue1 \u003d new Blue(true);\r\n    String json \u003d gson.toJson(blue1);\r\n    Blue blue2 \u003d gson.fromJson(json, Blue.class);\r\n    assertThat(blue2).isEqualTo(blue1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeVariableTest",
      "methodName": "testBasicTypeVariables",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    if (!(o instanceof Blue)) {\r\n        return false;\r\n    }\r\n    Blue blue \u003d (Blue) o;\r\n    return redField.equals(blue.redField);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeVariableTest.Blue",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic boolean equals(Object o) {\r\n    if (!(o instanceof Foo\u003c?, ?\u003e)) {\r\n        return false;\r\n    }\r\n    Foo\u003cS, T\u003e realFoo \u003d (Foo\u003cS, T\u003e) o;\r\n    return redField.equals(realFoo.redField) \u0026\u0026 someTField.equals(realFoo.someTField) \u0026\u0026 someSField.equals(realFoo.someSField) \u0026\u0026 map.equals(realFoo.map);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.TypeVariableTest.Foo",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.UncategorizedTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInvalidJsonDeserializationFails() throws Exception {\r\n    try {\r\n        gson.fromJson(\"adfasdf1112,,,\\\":\", BagOfPrimitives.class);\r\n        fail(\"Bad JSON should throw a ParseException\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n    try {\r\n        gson.fromJson(\"{adfasdf1112,,,\\\":}\", BagOfPrimitives.class);\r\n        fail(\"Bad JSON should throw a ParseException\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.UncategorizedTest",
      "methodName": "testInvalidJsonDeserializationFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testObjectEqualButNotSameSerialization() {\r\n    ClassOverridingEquals objA \u003d new ClassOverridingEquals();\r\n    ClassOverridingEquals objB \u003d new ClassOverridingEquals();\r\n    objB.ref \u003d objA;\r\n    String json \u003d gson.toJson(objB);\r\n    assertThat(json).isEqualTo(objB.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.UncategorizedTest",
      "methodName": "testObjectEqualButNotSameSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStaticFieldsAreNotSerialized() {\r\n    BagOfPrimitives target \u003d new BagOfPrimitives();\r\n    assertThat(gson.toJson(target)).doesNotContain(\"DEFAULT_VALUE\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.UncategorizedTest",
      "methodName": "testStaticFieldsAreNotSerialized",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGsonInstanceReusableForSerializationAndDeserialization() {\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n    String json \u003d gson.toJson(bag);\r\n    BagOfPrimitives deserialized \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(deserialized).isEqualTo(bag);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.UncategorizedTest",
      "methodName": "testGsonInstanceReusableForSerializationAndDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This test ensures that a custom deserializer is able to return a derived class instance for a\r\n * base class object. For a motivation for this test, see Issue 37 and\r\n * http://groups.google.com/group/google-gson/browse_thread/thread/677d56e9976d7761\r\n */\r\n@Test\r\npublic void testReturningDerivedClassesDuringDeserialization() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Base.class, new BaseTypeAdapter()).create();\r\n    String json \u003d \"{\\\"opType\\\":\\\"OP1\\\"}\";\r\n    Base base \u003d gson.fromJson(json, Base.class);\r\n    assertThat(base).isInstanceOf(Derived1.class);\r\n    assertThat(base.opType).isEqualTo(OperationType.OP1);\r\n    json \u003d \"{\\\"opType\\\":\\\"OP2\\\"}\";\r\n    base \u003d gson.fromJson(json, Base.class);\r\n    assertThat(base).isInstanceOf(Derived2.class);\r\n    assertThat(base.opType).isEqualTo(OperationType.OP2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.UncategorizedTest",
      "methodName": "testReturningDerivedClassesDuringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Test that trailing whitespace is ignored.\r\n * http://code.google.com/p/google-gson/issues/detail?id\u003d302\r\n */\r\n@Test\r\npublic void testTrailingWhitespace() throws Exception {\r\n    List\u003cInteger\u003e integers \u003d gson.fromJson(\"[1,2,3]  \\n\\n  \", new TypeToken\u003cList\u003cInteger\u003e\u003e() {\r\n    }.getType());\r\n    assertThat(integers).containsExactly(1, 2, 3).inOrder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.UncategorizedTest",
      "methodName": "testTrailingWhitespace",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    String opTypeStr \u003d json.getAsJsonObject().get(\"opType\").getAsString();\r\n    OperationType opType \u003d OperationType.valueOf(opTypeStr);\r\n    switch(opType) {\r\n        case OP1:\r\n            return new Derived1();\r\n        case OP2:\r\n            return new Derived2();\r\n    }\r\n    throw new JsonParseException(\"unknown type: \" + json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.UncategorizedTest.BaseTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Base"
    }
  },
  {
    "sourceCode": "private static Gson gsonWithVersion(double version) {\r\n    return new GsonBuilder().setVersion(version).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "gsonWithVersion",
      "parameterTypes": [
        "double"
      ],
      "returnType": "Gson"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVersionedUntilSerialization() {\r\n    Version1 target \u003d new Version1();\r\n    Gson gson \u003d gsonWithVersion(1.29);\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"a\\\":\" + A);\r\n    gson \u003d gsonWithVersion(1.3);\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"\\\"a\\\":\" + A);\r\n    gson \u003d gsonWithVersion(1.31);\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"\\\"a\\\":\" + A);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "testVersionedUntilSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVersionedUntilDeserialization() {\r\n    String json \u003d \"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5}\";\r\n    Gson gson \u003d gsonWithVersion(1.29);\r\n    Version1 version1 \u003d gson.fromJson(json, Version1.class);\r\n    assertThat(version1.a).isEqualTo(3);\r\n    gson \u003d gsonWithVersion(1.3);\r\n    version1 \u003d gson.fromJson(json, Version1.class);\r\n    assertThat(version1.a).isEqualTo(A);\r\n    gson \u003d gsonWithVersion(1.31);\r\n    version1 \u003d gson.fromJson(json, Version1.class);\r\n    assertThat(version1.a).isEqualTo(A);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "testVersionedUntilDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVersionedClassesSerialization() {\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    String json1 \u003d gson.toJson(new Version1());\r\n    String json2 \u003d gson.toJson(new Version1_1());\r\n    assertThat(json2).isEqualTo(json1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "testVersionedClassesSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVersionedClassesDeserialization() {\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    String json \u003d \"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5}\";\r\n    Version1 version1 \u003d gson.fromJson(json, Version1.class);\r\n    assertThat(version1.a).isEqualTo(3);\r\n    assertThat(version1.b).isEqualTo(4);\r\n    Version1_1 version1_1 \u003d gson.fromJson(json, Version1_1.class);\r\n    assertThat(version1_1.a).isEqualTo(3);\r\n    assertThat(version1_1.b).isEqualTo(4);\r\n    assertThat(version1_1.c).isEqualTo(C);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "testVersionedClassesDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIgnoreLaterVersionClassSerialization() {\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    assertThat(gson.toJson(new Version1_2())).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "testIgnoreLaterVersionClassSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIgnoreLaterVersionClassDeserialization() {\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    String json \u003d \"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5,\\\"d\\\":6}\";\r\n    Version1_2 version1_2 \u003d gson.fromJson(json, Version1_2.class);\r\n    // Since the class is versioned to be after 1.0, we expect null\r\n    // This is the new behavior in Gson 2.0\r\n    assertThat(version1_2).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "testIgnoreLaterVersionClassDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVersionedGsonWithUnversionedClassesSerialization() {\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    BagOfPrimitives target \u003d new BagOfPrimitives(10, 20, false, \"stringValue\");\r\n    assertThat(gson.toJson(target)).isEqualTo(target.getExpectedJson());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "testVersionedGsonWithUnversionedClassesSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVersionedGsonWithUnversionedClassesDeserialization() {\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    String json \u003d \"{\\\"longValue\\\":10,\\\"intValue\\\":20,\\\"booleanValue\\\":false}\";\r\n    BagOfPrimitives expected \u003d new BagOfPrimitives();\r\n    expected.longValue \u003d 10;\r\n    expected.intValue \u003d 20;\r\n    expected.booleanValue \u003d false;\r\n    BagOfPrimitives actual \u003d gson.fromJson(json, BagOfPrimitives.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "testVersionedGsonWithUnversionedClassesDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVersionedGsonMixingSinceAndUntilSerialization() {\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    SinceUntilMixing target \u003d new SinceUntilMixing();\r\n    String json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"\\\"b\\\":\" + B);\r\n    gson \u003d gsonWithVersion(1.2);\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).contains(\"\\\"b\\\":\" + B);\r\n    gson \u003d gsonWithVersion(1.3);\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"\\\"b\\\":\" + B);\r\n    gson \u003d gsonWithVersion(1.4);\r\n    json \u003d gson.toJson(target);\r\n    assertThat(json).doesNotContain(\"\\\"b\\\":\" + B);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "testVersionedGsonMixingSinceAndUntilSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVersionedGsonMixingSinceAndUntilDeserialization() {\r\n    String json \u003d \"{\\\"a\\\":5,\\\"b\\\":6}\";\r\n    Gson gson \u003d gsonWithVersion(1.0);\r\n    SinceUntilMixing result \u003d gson.fromJson(json, SinceUntilMixing.class);\r\n    assertThat(result.a).isEqualTo(5);\r\n    assertThat(result.b).isEqualTo(B);\r\n    gson \u003d gsonWithVersion(1.2);\r\n    result \u003d gson.fromJson(json, SinceUntilMixing.class);\r\n    assertThat(result.a).isEqualTo(5);\r\n    assertThat(result.b).isEqualTo(6);\r\n    gson \u003d gsonWithVersion(1.3);\r\n    result \u003d gson.fromJson(json, SinceUntilMixing.class);\r\n    assertThat(result.a).isEqualTo(5);\r\n    assertThat(result.b).isEqualTo(B);\r\n    gson \u003d gsonWithVersion(1.4);\r\n    result \u003d gson.fromJson(json, SinceUntilMixing.class);\r\n    assertThat(result.a).isEqualTo(5);\r\n    assertThat(result.b).isEqualTo(B);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.functional.VersioningTest",
      "methodName": "testVersionedGsonMixingSinceAndUntilDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    ourType \u003d $Gson$Types.arrayOf($Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GenericArrayTypeTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testOurTypeFunctionality() throws Exception {\r\n    Type parameterizedType \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    Type genericArrayType \u003d new TypeToken\u003cList\u003cString\u003e[]\u003e() {\r\n    }.getType();\r\n    assertThat(ourType.getGenericComponentType()).isEqualTo(parameterizedType);\r\n    assertThat(ourType).isEqualTo(genericArrayType);\r\n    assertThat(ourType.hashCode()).isEqualTo(genericArrayType.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GenericArrayTypeTest",
      "methodName": "testOurTypeFunctionality",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNotEquals() throws Exception {\r\n    Type differentGenericArrayType \u003d new TypeToken\u003cList\u003cString\u003e[][]\u003e() {\r\n    }.getType();\r\n    assertThat(differentGenericArrayType.equals(ourType)).isFalse();\r\n    assertThat(ourType.equals(differentGenericArrayType)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GenericArrayTypeTest",
      "methodName": "testNotEquals",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Object value) {\r\n    throw new AssertionError();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Object read(JsonReader in) {\r\n    throw new AssertionError();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return \"test\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCreatingMoreThanOnce() {\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    Gson gson \u003d builder.create();\r\n    assertThat(gson).isNotNull();\r\n    assertThat(builder.create()).isNotNull();\r\n    builder.setFieldNamingStrategy(new FieldNamingStrategy() {\r\n\r\n        @Override\r\n        public String translateName(Field f) {\r\n            return \"test\";\r\n        }\r\n    });\r\n    Gson otherGson \u003d builder.create();\r\n    assertThat(otherGson).isNotNull();\r\n    // Should be different instances because builder has been modified in the meantime\r\n    assertThat(gson).isNotSameInstanceAs(otherGson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testCreatingMoreThanOnce",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic CustomClass1 read(JsonReader in) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "CustomClass1"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n    out.value(\"custom-adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "CustomClass1"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"custom-hierarchy-adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "serialize",
      "parameterTypes": [
        "CustomClass2",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic CustomClass3 createInstance(Type type) {\r\n    return new CustomClass3(\"custom-instance\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "CustomClass3"
    }
  },
  {
    "sourceCode": "/**\r\n * Gson instances should not be affected by subsequent modification of GsonBuilder\r\n * which created them.\r\n */\r\n@Test\r\npublic void testModificationAfterCreate() {\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    Gson gson \u003d gsonBuilder.create();\r\n    // Modifications of `gsonBuilder` should not affect `gson` object\r\n    gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter\u003cCustomClass1\u003e() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"custom-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, new JsonSerializer\u003cCustomClass2\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"custom-hierarchy-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeAdapter(CustomClass3.class, new InstanceCreator\u003cCustomClass3\u003e() {\r\n\r\n        @Override\r\n        public CustomClass3 createInstance(Type type) {\r\n            return new CustomClass3(\"custom-instance\");\r\n        }\r\n    });\r\n    assertDefaultGson(gson);\r\n    // New GsonBuilder created from `gson` should not have been affected by changes\r\n    // to `gsonBuilder` either\r\n    assertDefaultGson(gson.newBuilder().create());\r\n    // New Gson instance from modified GsonBuilder should be affected by changes\r\n    assertCustomGson(gsonBuilder.create());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testModificationAfterCreate",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void assertDefaultGson(Gson gson) {\r\n    // Should use default reflective adapter\r\n    String json1 \u003d gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"{}\");\r\n    // Should use default reflective adapter\r\n    String json2 \u003d gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"{}\");\r\n    // Should use default instance creator\r\n    CustomClass3 customClass3 \u003d gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(CustomClass3.NO_ARG_CONSTRUCTOR_VALUE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "assertDefaultGson",
      "parameterTypes": [
        "Gson"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void assertCustomGson(Gson gson) {\r\n    String json1 \u003d gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"\\\"custom-adapter\\\"\");\r\n    String json2 \u003d gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"\\\"custom-hierarchy-adapter\\\"\");\r\n    CustomClass3 customClass3 \u003d gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(\"custom-instance\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "assertCustomGson",
      "parameterTypes": [
        "Gson"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExcludeFieldsWithModifiers() {\r\n    Gson gson \u003d new GsonBuilder().excludeFieldsWithModifiers(Modifier.VOLATILE, Modifier.PRIVATE).create();\r\n    assertThat(gson.toJson(new HasModifiers())).isEqualTo(\"{\\\"d\\\":\\\"d\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testExcludeFieldsWithModifiers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTransientFieldExclusion() {\r\n    Gson gson \u003d new GsonBuilder().excludeFieldsWithModifiers().create();\r\n    assertThat(gson.toJson(new HasTransients())).isEqualTo(\"{\\\"a\\\":\\\"a\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testTransientFieldExclusion",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRegisterTypeAdapterForCoreType() {\r\n    Type[] types \u003d { byte.class, int.class, double.class, Short.class, Long.class, String.class };\r\n    for (Type type : types) {\r\n        new GsonBuilder().registerTypeAdapter(type, NULL_TYPE_ADAPTER);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testRegisterTypeAdapterForCoreType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDisableJdkUnsafe() {\r\n    Gson gson \u003d new GsonBuilder().disableJdkUnsafe().create();\r\n    try {\r\n        gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n        fail(\"Expected exception\");\r\n    } catch (JsonIOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unable to create instance of class com.google.gson.GsonBuilderTest$ClassWithoutNoArgsConstructor; \" + \"usage of JDK Unsafe is disabled. Registering an InstanceCreator or a TypeAdapter for this type, \" + \"adding a no-args constructor, or enabling usage of JDK Unsafe may fix this problem.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testDisableJdkUnsafe",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSetVersionInvalid() {\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    try {\r\n        builder.setVersion(Double.NaN);\r\n        fail();\r\n    } catch (IllegalArgumentException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid version: NaN\");\r\n    }\r\n    try {\r\n        builder.setVersion(-0.1);\r\n        fail();\r\n    } catch (IllegalArgumentException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid version: -0.1\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testSetVersionInvalid",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultStrictness() throws IOException {\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    Gson gson \u003d builder.create();\r\n    assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n    assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testDefaultStrictness",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// for GsonBuilder.setLenient\r\n@SuppressWarnings({ \"deprecation\", \"InlineMeInliner\" })\r\n@Test\r\npublic void testSetLenient() throws IOException {\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    builder.setLenient();\r\n    Gson gson \u003d builder.create();\r\n    assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(Strictness.LENIENT);\r\n    assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(Strictness.LENIENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testSetLenient",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSetStrictness() throws IOException {\r\n    final Strictness STRICTNESS \u003d Strictness.STRICT;\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    builder.setStrictness(STRICTNESS);\r\n    Gson gson \u003d builder.create();\r\n    assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(STRICTNESS);\r\n    assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(STRICTNESS);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testSetStrictness",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRegisterTypeAdapterForObjectAndJsonElements() {\r\n    final String ERROR_MESSAGE \u003d \"Cannot override built-in adapter for \";\r\n    Type[] types \u003d { Object.class, JsonElement.class, JsonArray.class };\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    for (Type type : types) {\r\n        IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e gsonBuilder.registerTypeAdapter(type, NULL_TYPE_ADAPTER));\r\n        assertThat(e).hasMessageThat().isEqualTo(ERROR_MESSAGE + type);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testRegisterTypeAdapterForObjectAndJsonElements",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRegisterTypeHierarchyAdapterJsonElements() {\r\n    final String ERROR_MESSAGE \u003d \"Cannot override built-in adapter for \";\r\n    Class\u003c?\u003e[] types \u003d { JsonElement.class, JsonArray.class };\r\n    GsonBuilder gsonBuilder \u003d new GsonBuilder();\r\n    for (Class\u003c?\u003e type : types) {\r\n        IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e gsonBuilder.registerTypeHierarchyAdapter(type, NULL_TYPE_ADAPTER));\r\n        assertThat(e).hasMessageThat().isEqualTo(ERROR_MESSAGE + type);\r\n    }\r\n    // But registering type hierarchy adapter for Object should be allowed\r\n    gsonBuilder.registerTypeHierarchyAdapter(Object.class, NULL_TYPE_ADAPTER);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonBuilderTest",
      "methodName": "testRegisterTypeHierarchyAdapterJsonElements",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String translateName(Field f) {\r\n    return \"foo\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "translateName",
      "parameterTypes": [
        "Field"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictnessDefault() {\r\n    assertThat(new Gson().strictness).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testStrictnessDefault",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testOverridesDefaultExcluder() {\r\n    Gson gson \u003d new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY, new HashMap\u003cType, InstanceCreator\u003c?\u003e\u003e(), true, false, true, false, FormattingStyle.PRETTY, Strictness.LENIENT, false, true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT, new ArrayList\u003cTypeAdapterFactory\u003e(), new ArrayList\u003cTypeAdapterFactory\u003e(), new ArrayList\u003cTypeAdapterFactory\u003e(), CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY, Collections.\u003cReflectionAccessFilter\u003eemptyList());\r\n    assertThat(gson.excluder).isEqualTo(CUSTOM_EXCLUDER);\r\n    assertThat(gson.fieldNamingStrategy()).isEqualTo(CUSTOM_FIELD_NAMING_STRATEGY);\r\n    assertThat(gson.serializeNulls()).isTrue();\r\n    assertThat(gson.htmlSafe()).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testOverridesDefaultExcluder",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClonedTypeAdapterFactoryListsAreIndependent() {\r\n    Gson original \u003d new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY, new HashMap\u003cType, InstanceCreator\u003c?\u003e\u003e(), true, false, true, false, FormattingStyle.PRETTY, Strictness.LENIENT, false, true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT, new ArrayList\u003cTypeAdapterFactory\u003e(), new ArrayList\u003cTypeAdapterFactory\u003e(), new ArrayList\u003cTypeAdapterFactory\u003e(), CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY, Collections.\u003cReflectionAccessFilter\u003eemptyList());\r\n    Gson clone \u003d original.newBuilder().registerTypeAdapter(int.class, new TestTypeAdapter()).create();\r\n    assertThat(clone.factories).hasSize(original.factories.size() + 1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testClonedTypeAdapterFactoryListsAreIndependent",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Object value) {\r\n    // Test stub.\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest.TestTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Object read(JsonReader in) {\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest.TestTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGetAdapter_Null() {\r\n    Gson gson \u003d new Gson();\r\n    NullPointerException e \u003d assertThrows(NullPointerException.class, () -\u003e gson.getAdapter((TypeToken\u003c?\u003e) null));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"type must not be null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testGetAdapter_Null",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    throw new AssertionError(\"not needed for this test\");\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    throw new AssertionError(\"not needed for this test\");\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void run() {\r\n    threadAdapter.set(gson.getAdapter(requestedType));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "run",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, TypeToken\u003cT\u003e type) {\r\n    if (isFirstCall) {\r\n        isFirstCall \u003d false;\r\n        // Create a separate thread which requests an adapter for the same type\r\n        // This will cause this factory to return a different adapter instance than\r\n        // the one it is currently creating\r\n        Thread thread \u003d new Thread() {\r\n\r\n            @Override\r\n            public void run() {\r\n                threadAdapter.set(gson.getAdapter(requestedType));\r\n            }\r\n        };\r\n        thread.start();\r\n        try {\r\n            thread.join();\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n    // Create a new dummy adapter instance\r\n    adapterInstancesCreated.incrementAndGet();\r\n    return new DummyAdapter\u003c\u003e();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGetAdapter_Concurrency() {\r\n    class DummyAdapter\u003cT\u003e extends TypeAdapter\u003cT\u003e {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n    }\r\n    final AtomicInteger adapterInstancesCreated \u003d new AtomicInteger(0);\r\n    final AtomicReference\u003cTypeAdapter\u003c?\u003e\u003e threadAdapter \u003d new AtomicReference\u003c\u003e();\r\n    final Class\u003c?\u003e requestedType \u003d Number.class;\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(new TypeAdapterFactory() {\r\n\r\n        private volatile boolean isFirstCall \u003d true;\r\n\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(final Gson gson, TypeToken\u003cT\u003e type) {\r\n            if (isFirstCall) {\r\n                isFirstCall \u003d false;\r\n                // Create a separate thread which requests an adapter for the same type\r\n                // This will cause this factory to return a different adapter instance than\r\n                // the one it is currently creating\r\n                Thread thread \u003d new Thread() {\r\n\r\n                    @Override\r\n                    public void run() {\r\n                        threadAdapter.set(gson.getAdapter(requestedType));\r\n                    }\r\n                };\r\n                thread.start();\r\n                try {\r\n                    thread.join();\r\n                } catch (InterruptedException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n            // Create a new dummy adapter instance\r\n            adapterInstancesCreated.incrementAndGet();\r\n            return new DummyAdapter\u003c\u003e();\r\n        }\r\n    }).create();\r\n    TypeAdapter\u003c?\u003e adapter \u003d gson.getAdapter(requestedType);\r\n    assertThat(adapterInstancesCreated.get()).isEqualTo(2);\r\n    assertThat(adapter).isInstanceOf(DummyAdapter.class);\r\n    assertThat(threadAdapter.get()).isInstanceOf(DummyAdapter.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testGetAdapter_Concurrency",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T value) throws IOException {\r\n    // Due to how this test is set up there is infinite recursion, therefore\r\n    // need to track how deeply nested this call is\r\n    if (isFirstCall) {\r\n        isFirstCall \u003d false;\r\n        out.beginArray();\r\n        wrapped.write(out, null);\r\n        out.endArray();\r\n        isFirstCall \u003d true;\r\n    } else {\r\n        out.value(\"wrapped-nested\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    throw new AssertionError(\"not needed for this test\");\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    Class\u003c?\u003e raw \u003d type.getRawType();\r\n    if (raw \u003d\u003d CustomClass1.class) {\r\n        // Retrieves a WrappingAdapter containing a nested FutureAdapter for CustomClass1\r\n        TypeAdapter\u003c?\u003e adapter \u003d gson.getAdapter(CustomClass2.class);\r\n        // Let thread wait so the FutureAdapter for CustomClass1 nested in the adapter\r\n        // for CustomClass2 is not resolved yet\r\n        if (isFirstCaller) {\r\n            isFirstCaller \u003d false;\r\n            isThreadWaiting.countDown();\r\n            try {\r\n                canThreadProceed.await();\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n        return new WrappingAdapter\u003c\u003e(adapter);\r\n    } else if (raw \u003d\u003d CustomClass2.class) {\r\n        TypeAdapter\u003c?\u003e adapter \u003d gson.getAdapter(CustomClass1.class);\r\n        assertThat(adapter).isInstanceOf(FutureTypeAdapter.class);\r\n        return new WrappingAdapter\u003c\u003e(adapter);\r\n    } else {\r\n        throw new AssertionError(\"Adapter for unexpected type requested: \" + raw);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void run() {\r\n    otherThreadAdapter.set(gson.getAdapter(CustomClass1.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "run",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Verifies that two threads calling {@link Gson#getAdapter(TypeToken)} do not see the\r\n * same unresolved {@link FutureTypeAdapter} instance, since that would not be thread-safe.\r\n *\r\n * This test constructs the cyclic dependency {@literal CustomClass1 -\u003e CustomClass2 -\u003e CustomClass1}\r\n * and lets one thread wait after the adapter for CustomClass2 has been obtained (which still\r\n * refers to the nested unresolved FutureTypeAdapter for CustomClass1).\r\n */\r\n@Test\r\npublic void testGetAdapter_FutureAdapterConcurrency() throws Exception {\r\n    /**\r\n     * Adapter which wraps another adapter. Can be imagined as a simplified version of the\r\n     * {@code ReflectiveTypeAdapterFactory$Adapter}.\r\n     */\r\n    class WrappingAdapter\u003cT\u003e extends TypeAdapter\u003cT\u003e {\r\n\r\n        final TypeAdapter\u003c?\u003e wrapped;\r\n\r\n        boolean isFirstCall \u003d true;\r\n\r\n        WrappingAdapter(TypeAdapter\u003c?\u003e wrapped) {\r\n            this.wrapped \u003d wrapped;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            // Due to how this test is set up there is infinite recursion, therefore\r\n            // need to track how deeply nested this call is\r\n            if (isFirstCall) {\r\n                isFirstCall \u003d false;\r\n                out.beginArray();\r\n                wrapped.write(out, null);\r\n                out.endArray();\r\n                isFirstCall \u003d true;\r\n            } else {\r\n                out.value(\"wrapped-nested\");\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n    }\r\n    final CountDownLatch isThreadWaiting \u003d new CountDownLatch(1);\r\n    final CountDownLatch canThreadProceed \u003d new CountDownLatch(1);\r\n    final Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(new TypeAdapterFactory() {\r\n\r\n        // volatile instead of AtomicBoolean is safe here because CountDownLatch prevents\r\n        // \"true\" concurrency\r\n        volatile boolean isFirstCaller \u003d true;\r\n\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            Class\u003c?\u003e raw \u003d type.getRawType();\r\n            if (raw \u003d\u003d CustomClass1.class) {\r\n                // Retrieves a WrappingAdapter containing a nested FutureAdapter for CustomClass1\r\n                TypeAdapter\u003c?\u003e adapter \u003d gson.getAdapter(CustomClass2.class);\r\n                // Let thread wait so the FutureAdapter for CustomClass1 nested in the adapter\r\n                // for CustomClass2 is not resolved yet\r\n                if (isFirstCaller) {\r\n                    isFirstCaller \u003d false;\r\n                    isThreadWaiting.countDown();\r\n                    try {\r\n                        canThreadProceed.await();\r\n                    } catch (InterruptedException e) {\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                }\r\n                return new WrappingAdapter\u003c\u003e(adapter);\r\n            } else if (raw \u003d\u003d CustomClass2.class) {\r\n                TypeAdapter\u003c?\u003e adapter \u003d gson.getAdapter(CustomClass1.class);\r\n                assertThat(adapter).isInstanceOf(FutureTypeAdapter.class);\r\n                return new WrappingAdapter\u003c\u003e(adapter);\r\n            } else {\r\n                throw new AssertionError(\"Adapter for unexpected type requested: \" + raw);\r\n            }\r\n        }\r\n    }).create();\r\n    final AtomicReference\u003cTypeAdapter\u003c?\u003e\u003e otherThreadAdapter \u003d new AtomicReference\u003c\u003e();\r\n    Thread thread \u003d new Thread() {\r\n\r\n        @Override\r\n        public void run() {\r\n            otherThreadAdapter.set(gson.getAdapter(CustomClass1.class));\r\n        }\r\n    };\r\n    thread.start();\r\n    // Wait until other thread has obtained FutureAdapter\r\n    isThreadWaiting.await();\r\n    TypeAdapter\u003c?\u003e adapter \u003d gson.getAdapter(CustomClass1.class);\r\n    // Should not fail due to referring to unresolved FutureTypeAdapter\r\n    assertThat(adapter.toJson(null)).isEqualTo(\"[[\\\"wrapped-nested\\\"]]\");\r\n    // Let other thread proceed and have it resolve its FutureTypeAdapter\r\n    canThreadProceed.countDown();\r\n    thread.join();\r\n    assertThat(otherThreadAdapter.get().toJson(null)).isEqualTo(\"[[\\\"wrapped-nested\\\"]]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testGetAdapter_FutureAdapterConcurrency",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Number read(JsonReader in) throws IOException {\r\n    throw new AssertionError(\"not needed for test\");\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Number"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Number value) throws IOException {\r\n    throw new AssertionError(\"not needed for test\");\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Number"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Override toString() for better assertion error messages\r\n@Override\r\npublic String toString() {\r\n    return \"adapter-\" + number;\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    return (TypeAdapter\u003cT\u003e) adapter;\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "// Override equals to verify that reference equality check is performed by Gson,\r\n// and this method is ignored\r\n@Override\r\npublic boolean equals(Object obj) {\r\n    return obj instanceof DummyFactory \u0026\u0026 ((DummyFactory) obj).adapter.equals(adapter);\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return adapter.hashCode();\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGetDelegateAdapter() {\r\n    class DummyAdapter extends TypeAdapter\u003cNumber\u003e {\r\n\r\n        private final int number;\r\n\r\n        DummyAdapter(int number) {\r\n            this.number \u003d number;\r\n        }\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            throw new AssertionError(\"not needed for test\");\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            throw new AssertionError(\"not needed for test\");\r\n        }\r\n\r\n        // Override toString() for better assertion error messages\r\n        @Override\r\n        public String toString() {\r\n            return \"adapter-\" + number;\r\n        }\r\n    }\r\n    class DummyFactory implements TypeAdapterFactory {\r\n\r\n        private final DummyAdapter adapter;\r\n\r\n        DummyFactory(DummyAdapter adapter) {\r\n            this.adapter \u003d adapter;\r\n        }\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            return (TypeAdapter\u003cT\u003e) adapter;\r\n        }\r\n\r\n        // Override equals to verify that reference equality check is performed by Gson,\r\n        // and this method is ignored\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            return obj instanceof DummyFactory \u0026\u0026 ((DummyFactory) obj).adapter.equals(adapter);\r\n        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n            return adapter.hashCode();\r\n        }\r\n    }\r\n    DummyAdapter adapter1 \u003d new DummyAdapter(1);\r\n    DummyFactory factory1 \u003d new DummyFactory(adapter1);\r\n    DummyAdapter adapter2 \u003d new DummyAdapter(2);\r\n    DummyFactory factory2 \u003d new DummyFactory(adapter2);\r\n    Gson gson \u003d new GsonBuilder().// Note: This is \u0027last in, first out\u0027 order; Gson will first use factory2, then factory1\r\n    registerTypeAdapterFactory(factory1).registerTypeAdapterFactory(factory2).create();\r\n    TypeToken\u003c?\u003e type \u003d TypeToken.get(Number.class);\r\n    assertThrows(NullPointerException.class, () -\u003e gson.getDelegateAdapter(null, type));\r\n    assertThrows(NullPointerException.class, () -\u003e gson.getDelegateAdapter(factory1, null));\r\n    // For unknown factory the first adapter for that type should be returned\r\n    assertThat(gson.getDelegateAdapter(new DummyFactory(new DummyAdapter(0)), type)).isEqualTo(adapter2);\r\n    assertThat(gson.getDelegateAdapter(factory2, type)).isEqualTo(adapter1);\r\n    // Default Gson adapter should be returned\r\n    assertThat(gson.getDelegateAdapter(factory1, type)).isNotInstanceOf(DummyAdapter.class);\r\n    DummyFactory factory1Eq \u003d new DummyFactory(adapter1);\r\n    // Verify that test setup is correct\r\n    assertThat(factory1.equals(factory1Eq)).isTrue();\r\n    // Should only consider reference equality and ignore that custom `equals` method considers\r\n    // factories to be equal, therefore returning `adapter2` which came from `factory2` instead\r\n    // of skipping past `factory1`\r\n    assertThat(gson.getDelegateAdapter(factory1Eq, type)).isEqualTo(adapter2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testGetDelegateAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNewJsonWriter_Default() throws IOException {\r\n    StringWriter writer \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new Gson().newJsonWriter(writer);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"test\");\r\n    jsonWriter.nullValue();\r\n    jsonWriter.name(\"\u003ctest2\");\r\n    jsonWriter.value(true);\r\n    jsonWriter.endObject();\r\n    // Additional top-level value\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e jsonWriter.value(1));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"JSON must have only one top-level value.\");\r\n    jsonWriter.close();\r\n    assertThat(writer.toString()).isEqualTo(\"{\\\"\\\\u003ctest2\\\":true}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testNewJsonWriter_Default",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// for GsonBuilder.setLenient\r\n@SuppressWarnings({ \"deprecation\", \"InlineMeInliner\" })\r\n@Test\r\npublic void testNewJsonWriter_Custom() throws IOException {\r\n    StringWriter writer \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new GsonBuilder().disableHtmlEscaping().generateNonExecutableJson().setPrettyPrinting().serializeNulls().setLenient().create().newJsonWriter(writer);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"test\");\r\n    jsonWriter.nullValue();\r\n    jsonWriter.name(\"\u003ctest2\");\r\n    jsonWriter.value(true);\r\n    jsonWriter.endObject();\r\n    // Additional top-level value\r\n    jsonWriter.value(1);\r\n    jsonWriter.close();\r\n    assertThat(writer.toString()).isEqualTo(\")]}\u0027\\n{\\n  \\\"test\\\": null,\\n  \\\"\u003ctest2\\\": true\\n}1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testNewJsonWriter_Custom",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNewJsonReader_Default() throws IOException {\r\n    // String without quotes\r\n    String json \u003d \"test\";\r\n    JsonReader jsonReader \u003d new Gson().newJsonReader(new StringReader(json));\r\n    assertThrows(MalformedJsonException.class, jsonReader::nextString);\r\n    jsonReader.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testNewJsonReader_Default",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// for GsonBuilder.setLenient\r\n@SuppressWarnings({ \"deprecation\", \"InlineMeInliner\" })\r\n@Test\r\npublic void testNewJsonReader_Custom() throws IOException {\r\n    // String without quotes\r\n    String json \u003d \"test\";\r\n    JsonReader jsonReader \u003d new GsonBuilder().setLenient().create().newJsonReader(new StringReader(json));\r\n    assertThat(jsonReader.nextString()).isEqualTo(\"test\");\r\n    jsonReader.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testNewJsonReader_Custom",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic CustomClass1 read(JsonReader in) throws IOException {\r\n    throw new UnsupportedOperationException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "CustomClass1"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n    out.value(\"custom-adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "CustomClass1"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"custom-hierarchy-adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "serialize",
      "parameterTypes": [
        "CustomClass2",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic CustomClass3 createInstance(Type type) {\r\n    return new CustomClass3(\"custom-instance\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "CustomClass3"
    }
  },
  {
    "sourceCode": "/**\r\n * Modifying a GsonBuilder obtained from {@link Gson#newBuilder()} of a\r\n * {@code new Gson()} should not affect the Gson instance it came from.\r\n */\r\n@Test\r\npublic void testDefaultGsonNewBuilderModification() {\r\n    Gson gson \u003d new Gson();\r\n    GsonBuilder gsonBuilder \u003d gson.newBuilder();\r\n    // Modifications of `gsonBuilder` should not affect `gson` object\r\n    gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter\u003cCustomClass1\u003e() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"custom-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, new JsonSerializer\u003cCustomClass2\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"custom-hierarchy-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeAdapter(CustomClass3.class, new InstanceCreator\u003cCustomClass3\u003e() {\r\n\r\n        @Override\r\n        public CustomClass3 createInstance(Type type) {\r\n            return new CustomClass3(\"custom-instance\");\r\n        }\r\n    });\r\n    assertDefaultGson(gson);\r\n    // New GsonBuilder created from `gson` should not have been affected by changes either\r\n    assertDefaultGson(gson.newBuilder().create());\r\n    // But new Gson instance from `gsonBuilder` should use custom adapters\r\n    assertCustomGson(gsonBuilder.create());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testDefaultGsonNewBuilderModification",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void assertDefaultGson(Gson gson) {\r\n    // Should use default reflective adapter\r\n    String json1 \u003d gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"{}\");\r\n    // Should use default reflective adapter\r\n    String json2 \u003d gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"{}\");\r\n    // Should use default instance creator\r\n    CustomClass3 customClass3 \u003d gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(CustomClass3.NO_ARG_CONSTRUCTOR_VALUE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "assertDefaultGson",
      "parameterTypes": [
        "Gson"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic CustomClass3 createInstance(Type type) {\r\n    return new CustomClass3(\"custom-instance\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "CustomClass3"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"custom-hierarchy-adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "serialize",
      "parameterTypes": [
        "CustomClass2",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic CustomClass1 read(JsonReader in) throws IOException {\r\n    throw new UnsupportedOperationException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "CustomClass1"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n    out.value(\"custom-adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "CustomClass1"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic CustomClass1 read(JsonReader in) throws IOException {\r\n    throw new UnsupportedOperationException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "CustomClass1"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n    out.value(\"overwritten custom-adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "CustomClass1"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"overwritten custom-hierarchy-adapter\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "serialize",
      "parameterTypes": [
        "CustomClass2",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic CustomClass3 createInstance(Type type) {\r\n    return new CustomClass3(\"overwritten custom-instance\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "CustomClass3"
    }
  },
  {
    "sourceCode": "/**\r\n * Modifying a GsonBuilder obtained from {@link Gson#newBuilder()} of a custom\r\n * Gson instance (created using a GsonBuilder) should not affect the Gson instance\r\n * it came from.\r\n */\r\n@Test\r\npublic void testNewBuilderModification() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(CustomClass1.class, new TypeAdapter\u003cCustomClass1\u003e() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"custom-adapter\");\r\n        }\r\n    }).registerTypeHierarchyAdapter(CustomClass2.class, new JsonSerializer\u003cCustomClass2\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"custom-hierarchy-adapter\");\r\n        }\r\n    }).registerTypeAdapter(CustomClass3.class, new InstanceCreator\u003cCustomClass3\u003e() {\r\n\r\n        @Override\r\n        public CustomClass3 createInstance(Type type) {\r\n            return new CustomClass3(\"custom-instance\");\r\n        }\r\n    }).create();\r\n    assertCustomGson(gson);\r\n    // Modify `gson.newBuilder()`\r\n    GsonBuilder gsonBuilder \u003d gson.newBuilder();\r\n    gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter\u003cCustomClass1\u003e() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"overwritten custom-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, new JsonSerializer\u003cCustomClass2\u003e() {\r\n\r\n        @Override\r\n        public JsonElement serialize(CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"overwritten custom-hierarchy-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeAdapter(CustomClass3.class, new InstanceCreator\u003cCustomClass3\u003e() {\r\n\r\n        @Override\r\n        public CustomClass3 createInstance(Type type) {\r\n            return new CustomClass3(\"overwritten custom-instance\");\r\n        }\r\n    });\r\n    // `gson` object should not have been affected by changes to new GsonBuilder\r\n    assertCustomGson(gson);\r\n    // New GsonBuilder based on `gson` should not have been affected either\r\n    assertCustomGson(gson.newBuilder().create());\r\n    // But new Gson instance from `gsonBuilder` should be affected by changes\r\n    Gson otherGson \u003d gsonBuilder.create();\r\n    String json1 \u003d otherGson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"\\\"overwritten custom-adapter\\\"\");\r\n    String json2 \u003d otherGson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"\\\"overwritten custom-hierarchy-adapter\\\"\");\r\n    CustomClass3 customClass3 \u003d otherGson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(\"overwritten custom-instance\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "testNewBuilderModification",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void assertCustomGson(Gson gson) {\r\n    String json1 \u003d gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"\\\"custom-adapter\\\"\");\r\n    String json2 \u003d gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"\\\"custom-hierarchy-adapter\\\"\");\r\n    CustomClass3 customClass3 \u003d gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(\"custom-instance\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTest",
      "methodName": "assertCustomGson",
      "parameterTypes": [
        "Gson"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new GsonBuilder().registerTypeAdapter(AtomicLong.class, new ExceptionTypeAdapter()).registerTypeAdapter(AtomicInteger.class, new AtomicIntegerTypeAdapter()).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultTypeAdapterThrowsParseException() throws Exception {\r\n    try {\r\n        gson.fromJson(\"{\\\"abc\\\":123}\", BigInteger.class);\r\n        fail(\"Should have thrown a JsonParseException\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest",
      "methodName": "testDefaultTypeAdapterThrowsParseException",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTypeAdapterThrowsException() throws Exception {\r\n    try {\r\n        gson.toJson(new AtomicLong(0));\r\n        fail(\"Type Adapter should have thrown an exception\");\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    // Verify that serializer is made null-safe, i.e. it is not called for null\r\n    assertThat(gson.toJson(null, AtomicLong.class)).isEqualTo(\"null\");\r\n    try {\r\n        gson.fromJson(\"123\", AtomicLong.class);\r\n        fail(\"Type Adapter should have thrown an exception\");\r\n    } catch (JsonParseException expected) {\r\n    }\r\n    // Verify that deserializer is made null-safe, i.e. it is not called for null\r\n    assertThat(gson.fromJson(JsonNull.INSTANCE, AtomicLong.class)).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest",
      "methodName": "testTypeAdapterThrowsException",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTypeAdapterProperlyConvertsTypes() {\r\n    int intialValue \u003d 1;\r\n    AtomicInteger atomicInt \u003d new AtomicInteger(intialValue);\r\n    String json \u003d gson.toJson(atomicInt);\r\n    assertThat(Integer.parseInt(json)).isEqualTo(intialValue + 1);\r\n    atomicInt \u003d gson.fromJson(json, AtomicInteger.class);\r\n    assertThat(atomicInt.get()).isEqualTo(intialValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest",
      "methodName": "testTypeAdapterProperlyConvertsTypes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTypeAdapterDoesNotAffectNonAdaptedTypes() {\r\n    String expected \u003d \"blah\";\r\n    String actual \u003d gson.toJson(expected);\r\n    assertThat(actual).isEqualTo(\"\\\"\" + expected + \"\\\"\");\r\n    actual \u003d gson.fromJson(actual, String.class);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest",
      "methodName": "testTypeAdapterDoesNotAffectNonAdaptedTypes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(AtomicLong src, Type typeOfSrc, JsonSerializationContext context) {\r\n    throw new IllegalStateException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest.ExceptionTypeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "AtomicLong",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic AtomicLong deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    throw new IllegalStateException();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest.ExceptionTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "AtomicLong"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(AtomicInteger src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(src.incrementAndGet());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest.AtomicIntegerTypeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "AtomicInteger",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic AtomicInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    int intValue \u003d json.getAsInt();\r\n    return new AtomicInteger(--intValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest.AtomicIntegerTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "AtomicInteger"
    }
  },
  {
    "sourceCode": "// https://groups.google.com/d/topic/google-gson/EBmOCa8kJPE/discussion\r\n@Test\r\npublic void testDeserializerForAbstractClass() {\r\n    Concrete instance \u003d new Concrete();\r\n    instance.a \u003d \"android\";\r\n    instance.b \u003d \"beep\";\r\n    assertSerialized(\"{\\\"a\\\":\\\"android\\\"}\", Abstract.class, true, true, instance);\r\n    assertSerialized(\"{\\\"a\\\":\\\"android\\\"}\", Abstract.class, true, false, instance);\r\n    assertSerialized(\"{\\\"a\\\":\\\"android\\\"}\", Abstract.class, false, true, instance);\r\n    assertSerialized(\"{\\\"a\\\":\\\"android\\\"}\", Abstract.class, false, false, instance);\r\n    assertSerialized(\"{\\\"b\\\":\\\"beep\\\",\\\"a\\\":\\\"android\\\"}\", Concrete.class, true, true, instance);\r\n    assertSerialized(\"{\\\"b\\\":\\\"beep\\\",\\\"a\\\":\\\"android\\\"}\", Concrete.class, true, false, instance);\r\n    assertSerialized(\"{\\\"b\\\":\\\"beep\\\",\\\"a\\\":\\\"android\\\"}\", Concrete.class, false, true, instance);\r\n    assertSerialized(\"{\\\"b\\\":\\\"beep\\\",\\\"a\\\":\\\"android\\\"}\", Concrete.class, false, false, instance);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest",
      "methodName": "testDeserializerForAbstractClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Abstract deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    throw new AssertionError();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Abstract"
    }
  },
  {
    "sourceCode": "private void assertSerialized(String expected, Class\u003c?\u003e instanceType, boolean registerAbstractDeserializer, boolean registerAbstractHierarchyDeserializer, Object instance) {\r\n    JsonDeserializer\u003cAbstract\u003e deserializer \u003d new JsonDeserializer\u003cAbstract\u003e() {\r\n\r\n        @Override\r\n        public Abstract deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            throw new AssertionError();\r\n        }\r\n    };\r\n    GsonBuilder builder \u003d new GsonBuilder();\r\n    if (registerAbstractDeserializer) {\r\n        builder.registerTypeAdapter(Abstract.class, deserializer);\r\n    }\r\n    if (registerAbstractHierarchyDeserializer) {\r\n        builder.registerTypeHierarchyAdapter(Abstract.class, deserializer);\r\n    }\r\n    Gson gson \u003d builder.create();\r\n    assertThat(gson.toJson(instance, instanceType)).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.GsonTypeAdapterTest",
      "methodName": "assertSerialized",
      "parameterTypes": [
        "String",
        "Class\u003c?\u003e",
        "boolean",
        "boolean",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExcludeInnerClassObject() {\r\n    Class\u003c?\u003e clazz \u003d innerClass.getClass();\r\n    assertThat(excluder.excludeClass(clazz, true)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.InnerClassExclusionStrategyTest",
      "methodName": "testExcludeInnerClassObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExcludeInnerClassField() throws Exception {\r\n    Field f \u003d getClass().getField(\"innerClass\");\r\n    assertThat(excluder.excludeField(f, true)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.InnerClassExclusionStrategyTest",
      "methodName": "testExcludeInnerClassField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIncludeStaticNestedClassObject() {\r\n    Class\u003c?\u003e clazz \u003d staticNestedClass.getClass();\r\n    assertThat(excluder.excludeClass(clazz, true)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.InnerClassExclusionStrategyTest",
      "methodName": "testIncludeStaticNestedClassObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIncludeStaticNestedClassField() throws Exception {\r\n    Field f \u003d getClass().getField(\"staticNestedClass\");\r\n    assertThat(excluder.excludeField(f, true)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.InnerClassExclusionStrategyTest",
      "methodName": "testIncludeStaticNestedClassField",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFormattingInEnUs() {\r\n    assertFormattingAlwaysEmitsUsLocale(Locale.US);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testFormattingInEnUs",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFormattingInFr() {\r\n    assertFormattingAlwaysEmitsUsLocale(Locale.FRANCE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testFormattingInFr",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(locale);\r\n    try {\r\n        // The patterns here attempt to accommodate minor date-time formatting differences between JDK\r\n        // versions. Ideally Gson would serialize in a way that is independent of the JDK version.\r\n        // Note: \\h means \"horizontal space\", because some JDK versions use Narrow No Break Space\r\n        // (U+202F) before the AM or PM indication.\r\n        String utcFull \u003d \"(Coordinated Universal Time|UTC)\";\r\n        assertFormatted(\"Jan 1, 1970,? 12:00:00\\\\hAM\", DateType.DATE.createDefaultsAdapterFactory());\r\n        assertFormatted(\"1/1/70\", DateType.DATE.createAdapterFactory(DateFormat.SHORT));\r\n        assertFormatted(\"Jan 1, 1970\", DateType.DATE.createAdapterFactory(DateFormat.MEDIUM));\r\n        assertFormatted(\"January 1, 1970\", DateType.DATE.createAdapterFactory(DateFormat.LONG));\r\n        assertFormatted(\"1/1/70,? 12:00\\\\hAM\", DateType.DATE.createAdapterFactory(DateFormat.SHORT, DateFormat.SHORT));\r\n        assertFormatted(\"Jan 1, 1970,? 12:00:00\\\\hAM\", DateType.DATE.createAdapterFactory(DateFormat.MEDIUM, DateFormat.MEDIUM));\r\n        assertFormatted(\"January 1, 1970(,| at)? 12:00:00\\\\hAM UTC\", DateType.DATE.createAdapterFactory(DateFormat.LONG, DateFormat.LONG));\r\n        assertFormatted(\"Thursday, January 1, 1970(,| at)? 12:00:00\\\\hAM \" + utcFull, DateType.DATE.createAdapterFactory(DateFormat.FULL, DateFormat.FULL));\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "assertFormattingAlwaysEmitsUsLocale",
      "parameterTypes": [
        "Locale"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParsingDatesFormattedWithSystemLocale() throws Exception {\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.FRANCE);\r\n    try {\r\n        Date date \u003d new Date(0);\r\n        assertParsed(DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM).format(date), DateType.DATE.createDefaultsAdapterFactory());\r\n        assertParsed(DateFormat.getDateInstance(DateFormat.SHORT).format(date), DateType.DATE.createAdapterFactory(DateFormat.SHORT));\r\n        assertParsed(DateFormat.getDateInstance(DateFormat.MEDIUM).format(date), DateType.DATE.createAdapterFactory(DateFormat.MEDIUM));\r\n        assertParsed(DateFormat.getDateInstance(DateFormat.LONG).format(date), DateType.DATE.createAdapterFactory(DateFormat.LONG));\r\n        assertParsed(DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT).format(date), DateType.DATE.createAdapterFactory(DateFormat.SHORT, DateFormat.SHORT));\r\n        assertParsed(DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM).format(date), DateType.DATE.createAdapterFactory(DateFormat.MEDIUM, DateFormat.MEDIUM));\r\n        assertParsed(DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG).format(date), DateType.DATE.createAdapterFactory(DateFormat.LONG, DateFormat.LONG));\r\n        assertParsed(DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(date), DateType.DATE.createAdapterFactory(DateFormat.FULL, DateFormat.FULL));\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testParsingDatesFormattedWithSystemLocale",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParsingDatesFormattedWithUsLocale() throws Exception {\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    try {\r\n        assertParsed(\"Jan 1, 1970 0:00:00 AM\", DateType.DATE.createDefaultsAdapterFactory());\r\n        assertParsed(\"1/1/70\", DateType.DATE.createAdapterFactory(DateFormat.SHORT));\r\n        assertParsed(\"Jan 1, 1970\", DateType.DATE.createAdapterFactory(DateFormat.MEDIUM));\r\n        assertParsed(\"January 1, 1970\", DateType.DATE.createAdapterFactory(DateFormat.LONG));\r\n        assertParsed(\"1/1/70 0:00 AM\", DateType.DATE.createAdapterFactory(DateFormat.SHORT, DateFormat.SHORT));\r\n        assertParsed(\"Jan 1, 1970 0:00:00 AM\", DateType.DATE.createAdapterFactory(DateFormat.MEDIUM, DateFormat.MEDIUM));\r\n        assertParsed(\"January 1, 1970 0:00:00 AM UTC\", DateType.DATE.createAdapterFactory(DateFormat.LONG, DateFormat.LONG));\r\n        assertParsed(\"Thursday, January 1, 1970 0:00:00 AM UTC\", DateType.DATE.createAdapterFactory(DateFormat.FULL, DateFormat.FULL));\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testParsingDatesFormattedWithUsLocale",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFormatUsesDefaultTimezone() throws Exception {\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    try {\r\n        assertFormatted(\"Dec 31, 1969,? 4:00:00\\\\hPM\", DateType.DATE.createDefaultsAdapterFactory());\r\n        assertParsed(\"Dec 31, 1969 4:00:00 PM\", DateType.DATE.createDefaultsAdapterFactory());\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testFormatUsesDefaultTimezone",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDateDeserializationISO8601() throws Exception {\r\n    TypeAdapterFactory adapterFactory \u003d DateType.DATE.createDefaultsAdapterFactory();\r\n    assertParsed(\"1970-01-01T00:00:00.000Z\", adapterFactory);\r\n    assertParsed(\"1970-01-01T00:00Z\", adapterFactory);\r\n    assertParsed(\"1970-01-01T00:00:00+00:00\", adapterFactory);\r\n    assertParsed(\"1970-01-01T01:00:00+01:00\", adapterFactory);\r\n    assertParsed(\"1970-01-01T01:00:00+01\", adapterFactory);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testDateDeserializationISO8601",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDateSerialization() {\r\n    int dateStyle \u003d DateFormat.LONG;\r\n    TypeAdapter\u003cDate\u003e dateTypeAdapter \u003d dateAdapter(DateType.DATE.createAdapterFactory(dateStyle));\r\n    DateFormat formatter \u003d DateFormat.getDateInstance(dateStyle, Locale.US);\r\n    Date currentDate \u003d new Date();\r\n    String dateString \u003d dateTypeAdapter.toJson(currentDate);\r\n    assertThat(dateString).isEqualTo(toLiteral(formatter.format(currentDate)));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testDateSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDatePattern() {\r\n    String pattern \u003d \"yyyy-MM-dd\";\r\n    TypeAdapter\u003cDate\u003e dateTypeAdapter \u003d dateAdapter(DateType.DATE.createAdapterFactory(pattern));\r\n    DateFormat formatter \u003d new SimpleDateFormat(pattern);\r\n    Date currentDate \u003d new Date();\r\n    String dateString \u003d dateTypeAdapter.toJson(currentDate);\r\n    assertThat(dateString).isEqualTo(toLiteral(formatter.format(currentDate)));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testDatePattern",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInvalidDatePattern() {\r\n    try {\r\n        DateType.DATE.createAdapterFactory(\"I am a bad Date pattern....\");\r\n        fail(\"Invalid date pattern should fail.\");\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testInvalidDatePattern",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullValue() throws Exception {\r\n    TypeAdapter\u003cDate\u003e adapter \u003d dateAdapter(DateType.DATE.createDefaultsAdapterFactory());\r\n    assertThat(adapter.fromJson(\"null\")).isNull();\r\n    assertThat(adapter.toJson(null)).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testNullValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUnexpectedToken() throws Exception {\r\n    try {\r\n        TypeAdapter\u003cDate\u003e adapter \u003d dateAdapter(DateType.DATE.createDefaultsAdapterFactory());\r\n        adapter.fromJson(\"{}\");\r\n        fail(\"Unexpected token should fail.\");\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "testUnexpectedToken",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static TypeAdapter\u003cDate\u003e dateAdapter(TypeAdapterFactory adapterFactory) {\r\n    TypeAdapter\u003cDate\u003e adapter \u003d adapterFactory.create(new Gson(), TypeToken.get(Date.class));\r\n    assertThat(adapter).isNotNull();\r\n    return adapter;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "dateAdapter",
      "parameterTypes": [
        "TypeAdapterFactory"
      ],
      "returnType": "TypeAdapter\u003cDate\u003e"
    }
  },
  {
    "sourceCode": "private static void assertFormatted(String formattedPattern, TypeAdapterFactory adapterFactory) {\r\n    TypeAdapter\u003cDate\u003e adapter \u003d dateAdapter(adapterFactory);\r\n    String json \u003d adapter.toJson(new Date(0));\r\n    assertThat(json).matches(toLiteral(formattedPattern));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "assertFormatted",
      "parameterTypes": [
        "String",
        "TypeAdapterFactory"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"UndefinedEquals\")\r\nprivate static void assertParsed(String date, TypeAdapterFactory adapterFactory) throws IOException {\r\n    TypeAdapter\u003cDate\u003e adapter \u003d dateAdapter(adapterFactory);\r\n    assertWithMessage(date).that(adapter.fromJson(toLiteral(date))).isEqualTo(new Date(0));\r\n    assertWithMessage(\"ISO 8601\").that(adapter.fromJson(toLiteral(\"1970-01-01T00:00:00Z\"))).isEqualTo(new Date(0));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "assertParsed",
      "parameterTypes": [
        "String",
        "TypeAdapterFactory"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static String toLiteral(String s) {\r\n    return \u0027\"\u0027 + s + \u0027\"\u0027;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.DefaultDateTypeAdapterTest",
      "methodName": "toLiteral",
      "parameterTypes": [
        "String"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    unixDomainPrincipalClass \u003d Class.forName(\"jdk.net.UnixDomainPrincipal\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.Java17ReflectiveTypeAdapterFactoryTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomAdapterForRecords() {\r\n    Gson gson \u003d new Gson();\r\n    TypeAdapter\u003c?\u003e recordAdapter \u003d gson.getAdapter(unixDomainPrincipalClass);\r\n    TypeAdapter\u003c?\u003e defaultReflectionAdapter \u003d gson.getAdapter(DummyClass.class);\r\n    assertThat(defaultReflectionAdapter.getClass()).isNotEqualTo(recordAdapter.getClass());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.Java17ReflectiveTypeAdapterFactoryTest",
      "methodName": "testCustomAdapterForRecords",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeRecords() throws ReflectiveOperationException {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(UserPrincipal.class, new PrincipalTypeAdapter\u003c\u003e()).registerTypeAdapter(GroupPrincipal.class, new PrincipalTypeAdapter\u003c\u003e()).create();\r\n    UserPrincipal userPrincipal \u003d gson.fromJson(\"\\\"user\\\"\", UserPrincipal.class);\r\n    GroupPrincipal groupPrincipal \u003d gson.fromJson(\"\\\"group\\\"\", GroupPrincipal.class);\r\n    Object recordInstance \u003d unixDomainPrincipalClass.getDeclaredConstructor(UserPrincipal.class, GroupPrincipal.class).newInstance(userPrincipal, groupPrincipal);\r\n    String serialized \u003d gson.toJson(recordInstance);\r\n    Object deserializedRecordInstance \u003d gson.fromJson(serialized, unixDomainPrincipalClass);\r\n    assertThat(deserializedRecordInstance).isEqualTo(recordInstance);\r\n    assertThat(serialized).isEqualTo(\"{\\\"user\\\":\\\"user\\\",\\\"group\\\":\\\"group\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.Java17ReflectiveTypeAdapterFactoryTest",
      "methodName": "testSerializeRecords",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, T principal) throws IOException {\r\n    out.value(principal.getName());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.Java17ReflectiveTypeAdapterFactoryTest.PrincipalTypeAdapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic T read(JsonReader in) throws IOException {\r\n    final String name \u003d in.nextString();\r\n    // This type adapter is only used for Group and User Principal, both of which are implemented by PrincipalImpl.\r\n    @SuppressWarnings(\"unchecked\")\r\n    T principal \u003d (T) new Java17ReflectionHelperTest.PrincipalImpl(name);\r\n    return principal;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.Java17ReflectiveTypeAdapterFactoryTest.PrincipalTypeAdapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNumbers() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[1, 2, 3]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.nextLong()).isEqualTo(2L);\r\n    assertThat(reader.nextDouble()).isEqualTo(3.0);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testNumbers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientNansAndInfinities() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[NaN, -Infinity, Infinity]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(Double.isNaN(reader.nextDouble())).isTrue();\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.NEGATIVE_INFINITY);\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.POSITIVE_INFINITY);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testLenientNansAndInfinities",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictNansAndInfinities() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[NaN, -Infinity, Infinity]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.setStrictness(Strictness.LEGACY_STRICT);\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: NaN\");\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"NaN\");\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: -Infinity\");\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"-Infinity\");\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: Infinity\");\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"Infinity\");\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testStrictNansAndInfinities",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNumbersFromStrings() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[\\\"1\\\", \\\"2\\\", \\\"3\\\"]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.nextLong()).isEqualTo(2L);\r\n    assertThat(reader.nextDouble()).isEqualTo(3.0);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testNumbersFromStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringsFromNumbers() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[1]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"1\");\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testStringsFromNumbers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBooleans() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[true, false]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isEqualTo(true);\r\n    assertThat(reader.nextBoolean()).isEqualTo(false);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testBooleans",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNulls() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[null,null]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    reader.nextNull();\r\n    reader.nextNull();\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrings() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[\\\"A\\\",\\\"B\\\"]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"A\");\r\n    assertThat(reader.nextString()).isEqualTo(\"B\");\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArray() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[1, 2, 3]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.BEGIN_ARRAY);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextInt()).isEqualTo(2);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextInt()).isEqualTo(3);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_ARRAY);\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testObject() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"{\\\"A\\\": 1, \\\"B\\\": 2}\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.BEGIN_OBJECT);\r\n    reader.beginObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NAME);\r\n    assertThat(reader.nextName()).isEqualTo(\"A\");\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NAME);\r\n    assertThat(reader.nextName()).isEqualTo(\"B\");\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.nextInt()).isEqualTo(2);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_OBJECT);\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyArray() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testEmptyArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNestedArrays() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[[],[[]]]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    reader.beginArray();\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    reader.endArray();\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testNestedArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNestedObjects() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"{\\\"A\\\":{},\\\"B\\\":{\\\"C\\\":{}}}\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"A\");\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"B\");\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"C\");\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    reader.endObject();\r\n    reader.endObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testNestedObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyObject() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"{}\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginObject();\r\n    reader.endObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testEmptyObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipValue() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[\\\"A\\\",{\\\"B\\\":[[]]},\\\"C\\\",[[]],\\\"D\\\",null]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"A\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextString()).isEqualTo(\"C\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextString()).isEqualTo(\"D\");\r\n    reader.skipValue();\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWrongType() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[[],\\\"A\\\"]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.beginObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.endArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.endObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"A\");\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testWrongType",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNextJsonElement() throws IOException {\r\n    final JsonElement element \u003d JsonParser.parseString(\"{\\\"A\\\": 1, \\\"B\\\" : {}, \\\"C\\\" : []}\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginObject();\r\n    try {\r\n        reader.nextJsonElement();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    String unused1 \u003d reader.nextName();\r\n    assertThat(new JsonPrimitive(1)).isEqualTo(reader.nextJsonElement());\r\n    String unused2 \u003d reader.nextName();\r\n    reader.beginObject();\r\n    try {\r\n        reader.nextJsonElement();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    reader.endObject();\r\n    String unused3 \u003d reader.nextName();\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextJsonElement();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    reader.endArray();\r\n    reader.endObject();\r\n    try {\r\n        reader.nextJsonElement();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testNextJsonElement",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEarlyClose() throws IOException {\r\n    JsonElement element \u003d JsonParser.parseString(\"[1, 2, 3]\");\r\n    JsonTreeReader reader \u003d new JsonTreeReader(element);\r\n    reader.beginArray();\r\n    reader.close();\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonElementReaderTest",
      "methodName": "testEarlyClose",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipValue_emptyJsonObject() throws IOException {\r\n    JsonTreeReader in \u003d new JsonTreeReader(new JsonObject());\r\n    in.skipValue();\r\n    assertThat(in.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(in.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReaderTest",
      "methodName": "testSkipValue_emptyJsonObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipValue_filledJsonObject() throws IOException {\r\n    JsonObject jsonObject \u003d new JsonObject();\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(\u0027c\u0027);\r\n    jsonArray.add(\"text\");\r\n    jsonObject.add(\"a\", jsonArray);\r\n    jsonObject.addProperty(\"b\", true);\r\n    jsonObject.addProperty(\"i\", 1);\r\n    jsonObject.add(\"n\", JsonNull.INSTANCE);\r\n    JsonObject jsonObject2 \u003d new JsonObject();\r\n    jsonObject2.addProperty(\"n\", 2L);\r\n    jsonObject.add(\"o\", jsonObject2);\r\n    jsonObject.addProperty(\"s\", \"text\");\r\n    JsonTreeReader in \u003d new JsonTreeReader(jsonObject);\r\n    in.skipValue();\r\n    assertThat(in.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(in.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReaderTest",
      "methodName": "testSkipValue_filledJsonObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipValue_name() throws IOException {\r\n    JsonObject jsonObject \u003d new JsonObject();\r\n    jsonObject.addProperty(\"a\", \"value\");\r\n    JsonTreeReader in \u003d new JsonTreeReader(jsonObject);\r\n    in.beginObject();\r\n    in.skipValue();\r\n    assertThat(in.peek()).isEqualTo(JsonToken.STRING);\r\n    assertThat(in.getPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    assertThat(in.nextString()).isEqualTo(\"value\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReaderTest",
      "methodName": "testSkipValue_name",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipValue_afterEndOfDocument() throws IOException {\r\n    JsonTreeReader reader \u003d new JsonTreeReader(new JsonObject());\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReaderTest",
      "methodName": "testSkipValue_afterEndOfDocument",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipValue_atArrayEnd() throws IOException {\r\n    JsonTreeReader reader \u003d new JsonTreeReader(new JsonArray());\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReaderTest",
      "methodName": "testSkipValue_atArrayEnd",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipValue_atObjectEnd() throws IOException {\r\n    JsonTreeReader reader \u003d new JsonTreeReader(new JsonObject());\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReaderTest",
      "methodName": "testSkipValue_atObjectEnd",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testHasNext_endOfDocument() throws IOException {\r\n    JsonTreeReader reader \u003d new JsonTreeReader(new JsonObject());\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.hasNext()).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReaderTest",
      "methodName": "testHasNext_endOfDocument",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement deepCopy() {\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "deepCopy",
      "parameterTypes": [],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCustomJsonElementSubclass() throws IOException {\r\n    // superclass constructor\r\n    @SuppressWarnings(\"deprecation\")\r\n    class CustomSubclass extends JsonElement {\r\n\r\n        @Override\r\n        public JsonElement deepCopy() {\r\n            return this;\r\n        }\r\n    }\r\n    JsonArray array \u003d new JsonArray();\r\n    array.add(new CustomSubclass());\r\n    JsonTreeReader reader \u003d new JsonTreeReader(array);\r\n    reader.beginArray();\r\n    try {\r\n        // Should fail due to custom JsonElement subclass\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Custom JsonElement subclass \" + CustomSubclass.class.getName() + \" is not supported\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReaderTest",
      "methodName": "testCustomJsonElementSubclass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * {@link JsonTreeReader} effectively replaces the complete reading logic of {@link JsonReader} to\r\n * read from a {@link JsonElement} instead of a {@link Reader}. Therefore all relevant methods of\r\n * {@code JsonReader} must be overridden.\r\n */\r\n@Test\r\npublic void testOverrides() {\r\n    List\u003cString\u003e ignoredMethods \u003d Arrays.asList(\"setLenient(boolean)\", \"isLenient()\", \"setStrictness(com.google.gson.Strictness)\", \"getStrictness()\");\r\n    MoreAsserts.assertOverridesMethods(JsonReader.class, JsonTreeReader.class, ignoredMethods);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeReaderTest",
      "methodName": "testOverrides",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArray() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginArray();\r\n    writer.value(1);\r\n    writer.value(2);\r\n    writer.value(3);\r\n    writer.endArray();\r\n    assertThat(writer.get().toString()).isEqualTo(\"[1,2,3]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNestedArray() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginArray();\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.beginArray();\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.endArray();\r\n    writer.endArray();\r\n    assertThat(writer.get().toString()).isEqualTo(\"[[],[[]]]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testNestedArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testObject() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginObject();\r\n    writer.name(\"A\").value(1);\r\n    writer.name(\"B\").value(2);\r\n    writer.endObject();\r\n    assertThat(writer.get().toString()).isEqualTo(\"{\\\"A\\\":1,\\\"B\\\":2}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNestedObject() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginObject();\r\n    writer.name(\"A\");\r\n    writer.beginObject();\r\n    writer.name(\"B\");\r\n    writer.beginObject();\r\n    writer.endObject();\r\n    writer.endObject();\r\n    writer.name(\"C\");\r\n    writer.beginObject();\r\n    writer.endObject();\r\n    writer.endObject();\r\n    assertThat(writer.get().toString()).isEqualTo(\"{\\\"A\\\":{\\\"B\\\":{}},\\\"C\\\":{}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testNestedObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWriteAfterClose() throws Exception {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setStrictness(Strictness.LENIENT);\r\n    writer.beginArray();\r\n    writer.value(\"A\");\r\n    writer.endArray();\r\n    writer.close();\r\n    try {\r\n        writer.beginArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testWriteAfterClose",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrematureClose() throws Exception {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setStrictness(Strictness.LENIENT);\r\n    writer.beginArray();\r\n    try {\r\n        writer.close();\r\n        fail();\r\n    } catch (IOException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Incomplete document\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testPrematureClose",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNameAsTopLevelValue() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e writer.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Did not expect a name\");\r\n    writer.value(12);\r\n    writer.close();\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e writer.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testNameAsTopLevelValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNameInArray() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginArray();\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e writer.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n    writer.value(12);\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e writer.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n    writer.endArray();\r\n    assertThat(writer.get().toString()).isEqualTo(\"[12]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testNameInArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTwoNames() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginObject();\r\n    writer.name(\"a\");\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e writer.name(\"a\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Did not expect a name\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testTwoNames",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeNullsFalse() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setSerializeNulls(false);\r\n    writer.beginObject();\r\n    writer.name(\"A\");\r\n    writer.nullValue();\r\n    writer.endObject();\r\n    assertThat(writer.get().toString()).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testSerializeNullsFalse",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeNullsTrue() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setSerializeNulls(true);\r\n    writer.beginObject();\r\n    writer.name(\"A\");\r\n    writer.nullValue();\r\n    writer.endObject();\r\n    assertThat(writer.get().toString()).isEqualTo(\"{\\\"A\\\":null}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testSerializeNullsTrue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyWriter() {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    assertThat(writer.get()).isEqualTo(JsonNull.INSTANCE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testEmptyWriter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBeginArray() throws Exception {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    assertThat(writer.beginArray()).isEqualTo(writer);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testBeginArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBeginObject() throws Exception {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    assertThat(writer.beginObject()).isEqualTo(writer);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testBeginObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testValueString() throws Exception {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    String n \u003d \"as\";\r\n    assertThat(writer.value(n)).isEqualTo(writer);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testValueString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBoolValue() throws Exception {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    boolean bool \u003d true;\r\n    assertThat(writer.value(bool)).isEqualTo(writer);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testBoolValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBoolMaisValue() throws Exception {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    Boolean bool \u003d true;\r\n    assertThat(writer.value(bool)).isEqualTo(writer);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testBoolMaisValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientNansAndInfinities() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setStrictness(Strictness.LENIENT);\r\n    writer.beginArray();\r\n    writer.value(Float.NaN);\r\n    writer.value(Float.NEGATIVE_INFINITY);\r\n    writer.value(Float.POSITIVE_INFINITY);\r\n    writer.value(Double.NaN);\r\n    writer.value(Double.NEGATIVE_INFINITY);\r\n    writer.value(Double.POSITIVE_INFINITY);\r\n    writer.endArray();\r\n    assertThat(writer.get().toString()).isEqualTo(\"[NaN,-Infinity,Infinity,NaN,-Infinity,Infinity]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testLenientNansAndInfinities",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictNansAndInfinities() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setStrictness(Strictness.LEGACY_STRICT);\r\n    writer.beginArray();\r\n    try {\r\n        writer.value(Float.NaN);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Float.NEGATIVE_INFINITY);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Float.POSITIVE_INFINITY);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.NaN);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.NEGATIVE_INFINITY);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.POSITIVE_INFINITY);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testStrictNansAndInfinities",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictBoxedNansAndInfinities() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.setStrictness(Strictness.LEGACY_STRICT);\r\n    writer.beginArray();\r\n    try {\r\n        writer.value(Float.valueOf(Float.NaN));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Float.valueOf(Float.NEGATIVE_INFINITY));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Float.valueOf(Float.POSITIVE_INFINITY));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.valueOf(Double.NaN));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.valueOf(Double.NEGATIVE_INFINITY));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n    try {\r\n        writer.value(Double.valueOf(Double.POSITIVE_INFINITY));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testStrictBoxedNansAndInfinities",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonValue() throws IOException {\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    writer.beginArray();\r\n    try {\r\n        writer.jsonValue(\"test\");\r\n        fail();\r\n    } catch (UnsupportedOperationException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testJsonValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * {@link JsonTreeWriter} effectively replaces the complete writing logic of {@link JsonWriter} to\r\n * create a {@link JsonElement} tree instead of writing to a {@link Writer}. Therefore all relevant\r\n * methods of {@code JsonWriter} must be overridden.\r\n */\r\n@Test\r\npublic void testOverrides() {\r\n    List\u003cString\u003e ignoredMethods \u003d Arrays.asList(\"setLenient(boolean)\", \"isLenient()\", \"setStrictness(com.google.gson.Strictness)\", \"getStrictness()\", \"setIndent(java.lang.String)\", \"setHtmlSafe(boolean)\", \"isHtmlSafe()\", \"setFormattingStyle(com.google.gson.FormattingStyle)\", \"getFormattingStyle()\", \"setSerializeNulls(boolean)\", \"getSerializeNulls()\");\r\n    MoreAsserts.assertOverridesMethods(JsonWriter.class, JsonTreeWriter.class, ignoredMethods);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.JsonTreeWriterTest",
      "methodName": "testOverrides",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Test simplest case of recursion.\r\n */\r\n@Test\r\npublic void testRecursiveResolveSimple() {\r\n    @SuppressWarnings(\"rawtypes\")\r\n    TypeAdapter\u003cFoo1\u003e adapter \u003d new Gson().getAdapter(Foo1.class);\r\n    assertThat(adapter).isNotNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.RecursiveTypesResolveTest",
      "methodName": "testRecursiveResolveSimple",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests belows check the behaviour of the methods changed for the fix.\r\n */\r\n@Test\r\npublic void testDoubleSupertype() {\r\n    assertThat($Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class))).isEqualTo($Gson$Types.supertypeOf(Number.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.RecursiveTypesResolveTest",
      "methodName": "testDoubleSupertype",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleSubtype() {\r\n    assertThat($Gson$Types.subtypeOf($Gson$Types.subtypeOf(Number.class))).isEqualTo($Gson$Types.subtypeOf(Number.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.RecursiveTypesResolveTest",
      "methodName": "testDoubleSubtype",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSuperSubtype() {\r\n    assertThat($Gson$Types.supertypeOf($Gson$Types.subtypeOf(Number.class))).isEqualTo($Gson$Types.subtypeOf(Object.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.RecursiveTypesResolveTest",
      "methodName": "testSuperSubtype",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSubSupertype() {\r\n    assertThat($Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class))).isEqualTo($Gson$Types.subtypeOf(Object.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.RecursiveTypesResolveTest",
      "methodName": "testSubSupertype",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRecursiveTypeVariablesResolve1() {\r\n    @SuppressWarnings(\"rawtypes\")\r\n    TypeAdapter\u003cTestType\u003e adapter \u003d new Gson().getAdapter(TestType.class);\r\n    assertThat(adapter).isNotNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.RecursiveTypesResolveTest",
      "methodName": "testRecursiveTypeVariablesResolve1",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRecursiveTypeVariablesResolve12() {\r\n    @SuppressWarnings(\"rawtypes\")\r\n    TypeAdapter\u003cTestType2\u003e adapter \u003d new Gson().getAdapter(TestType2.class);\r\n    assertThat(adapter).isNotNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.RecursiveTypesResolveTest",
      "methodName": "testRecursiveTypeVariablesResolve12",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static TimeZone utcTimeZone() {\r\n    return TimeZone.getTimeZone(\"UTC\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "utcTimeZone",
      "parameterTypes": [],
      "returnType": "TimeZone"
    }
  },
  {
    "sourceCode": "private static GregorianCalendar createUtcCalendar() {\r\n    TimeZone utc \u003d utcTimeZone();\r\n    GregorianCalendar calendar \u003d new GregorianCalendar(utc);\r\n    // Calendar was created with current time, must clear it\r\n    calendar.clear();\r\n    return calendar;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "createUtcCalendar",
      "parameterTypes": [],
      "returnType": "GregorianCalendar"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDateFormatString() {\r\n    GregorianCalendar calendar \u003d new GregorianCalendar(utcTimeZone(), Locale.US);\r\n    // Calendar was created with current time, must clear it\r\n    calendar.clear();\r\n    calendar.set(2018, Calendar.JUNE, 25);\r\n    Date date \u003d calendar.getTime();\r\n    String dateStr \u003d ISO8601Utils.format(date);\r\n    String expectedDate \u003d \"2018-06-25\";\r\n    assertThat(dateStr.substring(0, expectedDate.length())).isEqualTo(expectedDate);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "testDateFormatString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"JavaUtilDate\")\r\npublic void testDateFormatWithMilliseconds() {\r\n    long time \u003d 1530209176870L;\r\n    Date date \u003d new Date(time);\r\n    String dateStr \u003d ISO8601Utils.format(date, true);\r\n    String expectedDate \u003d \"2018-06-28T18:06:16.870Z\";\r\n    assertThat(dateStr).isEqualTo(expectedDate);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "testDateFormatWithMilliseconds",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"JavaUtilDate\")\r\npublic void testDateFormatWithTimezone() {\r\n    long time \u003d 1530209176870L;\r\n    Date date \u003d new Date(time);\r\n    String dateStr \u003d ISO8601Utils.format(date, true, TimeZone.getTimeZone(\"Brazil/East\"));\r\n    String expectedDate \u003d \"2018-06-28T15:06:16.870-03:00\";\r\n    assertThat(dateStr).isEqualTo(expectedDate);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "testDateFormatWithTimezone",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"UndefinedEquals\")\r\npublic void testDateParseWithDefaultTimezone() throws ParseException {\r\n    String dateStr \u003d \"2018-06-25\";\r\n    Date date \u003d ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n    Date expectedDate \u003d new GregorianCalendar(2018, Calendar.JUNE, 25).getTime();\r\n    assertThat(date).isEqualTo(expectedDate);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "testDateParseWithDefaultTimezone",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDateParseInvalidDay() {\r\n    String dateStr \u003d \"2022-12-33\";\r\n    try {\r\n        ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n        fail(\"Expected parsing to fail\");\r\n    } catch (ParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "testDateParseInvalidDay",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDateParseInvalidMonth() {\r\n    String dateStr \u003d \"2022-14-30\";\r\n    try {\r\n        ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n        fail(\"Expected parsing to fail\");\r\n    } catch (ParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "testDateParseInvalidMonth",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"UndefinedEquals\")\r\npublic void testDateParseWithTimezone() throws ParseException {\r\n    String dateStr \u003d \"2018-06-25T00:00:00-03:00\";\r\n    Date date \u003d ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n    GregorianCalendar calendar \u003d createUtcCalendar();\r\n    calendar.set(2018, Calendar.JUNE, 25, 3, 0);\r\n    Date expectedDate \u003d calendar.getTime();\r\n    assertThat(date).isEqualTo(expectedDate);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "testDateParseWithTimezone",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"UndefinedEquals\")\r\npublic void testDateParseSpecialTimezone() throws ParseException {\r\n    String dateStr \u003d \"2018-06-25T00:02:00-02:58\";\r\n    Date date \u003d ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n    GregorianCalendar calendar \u003d createUtcCalendar();\r\n    calendar.set(2018, Calendar.JUNE, 25, 3, 0);\r\n    Date expectedDate \u003d calendar.getTime();\r\n    assertThat(date).isEqualTo(expectedDate);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "testDateParseSpecialTimezone",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void run() throws Throwable {\r\n    ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "run",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDateParseInvalidTime() {\r\n    final String dateStr \u003d \"2018-06-25T61:60:62-03:00\";\r\n    assertThrows(ParseException.class, new ThrowingRunnable() {\r\n\r\n        @Override\r\n        public void run() throws Throwable {\r\n            ISO8601Utils.parse(dateStr, new ParsePosition(0));\r\n        }\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.bind.util.ISO8601UtilsTest",
      "methodName": "testDateParseInvalidTime",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Verify that ConstructorConstructor does not try to invoke no-args constructor\r\n * of abstract class.\r\n */\r\n@Test\r\npublic void testGet_AbstractClassNoArgConstructor() {\r\n    ObjectConstructor\u003cAbstractClass\u003e constructor \u003d constructorConstructor.get(TypeToken.get(AbstractClass.class));\r\n    try {\r\n        constructor.construct();\r\n        fail(\"Expected exception\");\r\n    } catch (RuntimeException exception) {\r\n        assertThat(exception).hasMessageThat().isEqualTo(\"Abstract classes can\u0027t be instantiated!\" + \" Adjust the R8 configuration or register an InstanceCreator or a TypeAdapter for this type.\" + \" Class name: com.google.gson.internal.ConstructorConstructorTest$AbstractClass\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#r8-abstract-class\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructorTest",
      "methodName": "testGet_AbstractClassNoArgConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGet_Interface() {\r\n    ObjectConstructor\u003cInterface\u003e constructor \u003d constructorConstructor.get(TypeToken.get(Interface.class));\r\n    try {\r\n        constructor.construct();\r\n        fail(\"Expected exception\");\r\n    } catch (RuntimeException exception) {\r\n        assertThat(exception).hasMessageThat().isEqualTo(\"Interfaces can\u0027t be instantiated!\" + \" Register an InstanceCreator or a TypeAdapter for this type.\" + \" Interface name: com.google.gson.internal.ConstructorConstructorTest$Interface\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.ConstructorConstructorTest",
      "methodName": "testGet_Interface",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEnsureGsonBuildConfigGetsUpdatedToMavenVersion() {\r\n    assertThat(\"${project.version}\").isNotEqualTo(GsonBuildConfig.VERSION);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.GsonBuildConfigTest",
      "methodName": "testEnsureGsonBuildConfigGetsUpdatedToMavenVersion",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNewParameterizedTypeWithoutOwner() throws Exception {\r\n    // List\u003cA\u003e. List is a top-level class\r\n    ParameterizedType type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, List.class, A.class);\r\n    assertThat(type.getOwnerType()).isNull();\r\n    assertThat(type.getRawType()).isEqualTo(List.class);\r\n    assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);\r\n    // A\u003cB\u003e. A is a static inner class.\r\n    type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, A.class, B.class);\r\n    assertThat(getFirstTypeArgument(type)).isEqualTo(B.class);\r\n    IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, // NonStaticInner\u003cA\u003e is not allowed without owner\r\n    () -\u003e $Gson$Types.newParameterizedTypeWithOwner(null, NonStaticInner.class, A.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must specify owner type for \" + NonStaticInner.class);\r\n    type \u003d $Gson$Types.newParameterizedTypeWithOwner(GsonTypesTest.class, NonStaticInner.class, A.class);\r\n    assertThat(type.getOwnerType()).isEqualTo(GsonTypesTest.class);\r\n    assertThat(type.getRawType()).isEqualTo(NonStaticInner.class);\r\n    assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);\r\n    final class D {\r\n    }\r\n    // D\u003cA\u003e is allowed since D has no owner type\r\n    type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, D.class, A.class);\r\n    assertThat(type.getOwnerType()).isNull();\r\n    assertThat(type.getRawType()).isEqualTo(D.class);\r\n    assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);\r\n    // A\u003cD\u003e is allowed.\r\n    type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, A.class, D.class);\r\n    assertThat(getFirstTypeArgument(type)).isEqualTo(D.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.GsonTypesTest",
      "methodName": "testNewParameterizedTypeWithoutOwner",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGetFirstTypeArgument() throws Exception {\r\n    assertThat(getFirstTypeArgument(A.class)).isNull();\r\n    Type type \u003d $Gson$Types.newParameterizedTypeWithOwner(null, A.class, B.class, C.class);\r\n    assertThat(getFirstTypeArgument(type)).isEqualTo(B.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.GsonTypesTest",
      "methodName": "testGetFirstTypeArgument",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Given a parameterized type A\u0026lt;B,C\u0026gt;, returns B. If the specified type is not\r\n * a generic type, returns null.\r\n */\r\npublic static Type getFirstTypeArgument(Type type) throws Exception {\r\n    if (!(type instanceof ParameterizedType))\r\n        return null;\r\n    ParameterizedType ptype \u003d (ParameterizedType) type;\r\n    Type[] actualTypeArguments \u003d ptype.getActualTypeArguments();\r\n    if (actualTypeArguments.length \u003d\u003d 0)\r\n        return null;\r\n    return $Gson$Types.canonicalize(actualTypeArguments[0]);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.GsonTypesTest",
      "methodName": "getFirstTypeArgument",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "// Borrowed some of test strings from https://github.com/prestodb/presto/blob/master/presto-main/src/test/java/com/facebook/presto/server/TestJavaVersion.java\r\n@Test\r\npublic void testGetMajorJavaVersion() {\r\n    // Gson currently requires at least Java 7\r\n    assertThat(JavaVersion.getMajorJavaVersion() \u003e\u003d 7).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersionTest",
      "methodName": "testGetMajorJavaVersion",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJava6() {\r\n    // http://www.oracle.com/technetwork/java/javase/version-6-141920.html\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.6.0\")).isEqualTo(6);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersionTest",
      "methodName": "testJava6",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJava7() {\r\n    // http://www.oracle.com/technetwork/java/javase/jdk7-naming-418744.html\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.7.0\")).isEqualTo(7);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersionTest",
      "methodName": "testJava7",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJava8() {\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8\")).isEqualTo(8);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0\")).isEqualTo(8);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0_131\")).isEqualTo(8);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0_60-ea\")).isEqualTo(8);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0_111-internal\")).isEqualTo(8);\r\n    // openjdk8 per https://github.com/AdoptOpenJDK/openjdk-build/issues/93\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0-internal\")).isEqualTo(8);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"1.8.0_131-adoptopenjdk\")).isEqualTo(8);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersionTest",
      "methodName": "testJava8",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJava9() {\r\n    // Legacy style\r\n    // Oracle JDK 9\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9.0.4\")).isEqualTo(9);\r\n    // Debian as reported in https://github.com/google/gson/issues/1310\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9-Debian\")).isEqualTo(9);\r\n    // New style\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9-ea+19\")).isEqualTo(9);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9+100\")).isEqualTo(9);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9.0.1+20\")).isEqualTo(9);\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"9.1.1+20\")).isEqualTo(9);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersionTest",
      "methodName": "testJava9",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJava10() {\r\n    // Oracle JDK 10.0.1\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"10.0.1\")).isEqualTo(10);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersionTest",
      "methodName": "testJava10",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUnknownVersionFormat() {\r\n    // unknown format\r\n    assertThat(JavaVersion.getMajorJavaVersion(\"Java9\")).isEqualTo(6);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.JavaVersionTest",
      "methodName": "testUnknownVersionFormat",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testHashCode() {\r\n    LazilyParsedNumber n1 \u003d new LazilyParsedNumber(\"1\");\r\n    LazilyParsedNumber n1Another \u003d new LazilyParsedNumber(\"1\");\r\n    assertThat(n1Another.hashCode()).isEqualTo(n1.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumberTest",
      "methodName": "testHashCode",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEquals() {\r\n    LazilyParsedNumber n1 \u003d new LazilyParsedNumber(\"1\");\r\n    LazilyParsedNumber n1Another \u003d new LazilyParsedNumber(\"1\");\r\n    assertThat(n1.equals(n1Another)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumberTest",
      "methodName": "testEquals",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJavaSerialization() throws IOException, ClassNotFoundException {\r\n    ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\r\n    ObjectOutputStream objOut \u003d new ObjectOutputStream(out);\r\n    objOut.writeObject(new LazilyParsedNumber(\"123\"));\r\n    objOut.close();\r\n    ObjectInputStream objIn \u003d new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\r\n    Number deserialized \u003d (Number) objIn.readObject();\r\n    assertThat(deserialized).isEqualTo(new BigDecimal(\"123\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LazilyParsedNumberTest",
      "methodName": "testJavaSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIterationOrder() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"android\");\r\n    map.put(\"c\", \"cola\");\r\n    map.put(\"b\", \"bbq\");\r\n    assertIterationOrder(map.keySet(), \"a\", \"c\", \"b\");\r\n    assertIterationOrder(map.values(), \"android\", \"cola\", \"bbq\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testIterationOrder",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRemoveRootDoesNotDoubleUnlink() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"android\");\r\n    map.put(\"c\", \"cola\");\r\n    map.put(\"b\", \"bbq\");\r\n    Iterator\u003cMap.Entry\u003cString, String\u003e\u003e it \u003d map.entrySet().iterator();\r\n    it.next();\r\n    it.next();\r\n    it.next();\r\n    it.remove();\r\n    assertIterationOrder(map.keySet(), \"a\", \"c\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testRemoveRootDoesNotDoubleUnlink",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"ModifiedButNotUsed\")\r\npublic void testPutNullKeyFails() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    try {\r\n        map.put(null, \"android\");\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testPutNullKeyFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@SuppressWarnings(\"ModifiedButNotUsed\")\r\npublic void testPutNonComparableKeyFails() {\r\n    LinkedTreeMap\u003cObject, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    try {\r\n        map.put(new Object(), \"android\");\r\n        fail();\r\n    } catch (ClassCastException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testPutNonComparableKeyFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPutNullValue() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", null);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.containsKey(\"a\")).isTrue();\r\n    assertThat(map.containsValue(null)).isTrue();\r\n    assertThat(map.get(\"a\")).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testPutNullValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPutNullValue_Forbidden() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e(false);\r\n    try {\r\n        map.put(\"a\", null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n    assertThat(map).hasSize(0);\r\n    assertThat(map).doesNotContainKey(\"a\");\r\n    assertThat(map.containsValue(null)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testPutNullValue_Forbidden",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEntrySetValueNull() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"1\");\r\n    assertThat(map.get(\"a\")).isEqualTo(\"1\");\r\n    Entry\u003cString, String\u003e entry \u003d map.entrySet().iterator().next();\r\n    assertThat(entry.getKey()).isEqualTo(\"a\");\r\n    assertThat(entry.getValue()).isEqualTo(\"1\");\r\n    entry.setValue(null);\r\n    assertThat(entry.getValue()).isNull();\r\n    assertThat(map.containsKey(\"a\")).isTrue();\r\n    assertThat(map.containsValue(null)).isTrue();\r\n    assertThat(map.get(\"a\")).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testEntrySetValueNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEntrySetValueNull_Forbidden() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e(false);\r\n    map.put(\"a\", \"1\");\r\n    Entry\u003cString, String\u003e entry \u003d map.entrySet().iterator().next();\r\n    try {\r\n        entry.setValue(null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n    assertThat(entry.getValue()).isEqualTo(\"1\");\r\n    assertThat(map.get(\"a\")).isEqualTo(\"1\");\r\n    assertThat(map.containsValue(null)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testEntrySetValueNull_Forbidden",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testContainsNonComparableKeyReturnsFalse() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"android\");\r\n    assertThat(map).doesNotContainKey(new Object());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testContainsNonComparableKeyReturnsFalse",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testContainsNullKeyIsAlwaysFalse() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    assertThat(map.containsKey(null)).isFalse();\r\n    map.put(\"a\", \"android\");\r\n    assertThat(map.containsKey(null)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testContainsNullKeyIsAlwaysFalse",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPutOverrides() throws Exception {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    assertThat(map.put(\"d\", \"donut\")).isNull();\r\n    assertThat(map.put(\"e\", \"eclair\")).isNull();\r\n    assertThat(map.put(\"f\", \"froyo\")).isNull();\r\n    assertThat(map).hasSize(3);\r\n    assertThat(map.get(\"d\")).isEqualTo(\"donut\");\r\n    assertThat(map.put(\"d\", \"done\")).isEqualTo(\"donut\");\r\n    assertThat(map).hasSize(3);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testPutOverrides",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyStringValues() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"\");\r\n    assertThat(map.containsKey(\"a\")).isTrue();\r\n    assertThat(map.get(\"a\")).isEqualTo(\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testEmptyStringValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLargeSetOfRandomKeys() {\r\n    Random random \u003d new Random(1367593214724L);\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    String[] keys \u003d new String[1000];\r\n    for (int i \u003d 0; i \u003c keys.length; i++) {\r\n        keys[i] \u003d Integer.toString(random.nextInt(), 36) + \"-\" + i;\r\n        map.put(keys[i], \"\" + i);\r\n    }\r\n    for (int i \u003d 0; i \u003c keys.length; i++) {\r\n        String key \u003d keys[i];\r\n        assertThat(map.containsKey(key)).isTrue();\r\n        assertThat(map.get(key)).isEqualTo(\"\" + i);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testLargeSetOfRandomKeys",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClear() {\r\n    LinkedTreeMap\u003cString, String\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", \"android\");\r\n    map.put(\"c\", \"cola\");\r\n    map.put(\"b\", \"bbq\");\r\n    map.clear();\r\n    assertIterationOrder(map.keySet());\r\n    assertThat(map).hasSize(0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testClear",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsAndHashCode() throws Exception {\r\n    LinkedTreeMap\u003cString, Integer\u003e map1 \u003d new LinkedTreeMap\u003c\u003e();\r\n    map1.put(\"A\", 1);\r\n    map1.put(\"B\", 2);\r\n    map1.put(\"C\", 3);\r\n    map1.put(\"D\", 4);\r\n    LinkedTreeMap\u003cString, Integer\u003e map2 \u003d new LinkedTreeMap\u003c\u003e();\r\n    map2.put(\"C\", 3);\r\n    map2.put(\"B\", 2);\r\n    map2.put(\"D\", 4);\r\n    map2.put(\"A\", 1);\r\n    MoreAsserts.assertEqualsAndHashCode(map1, map2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testEqualsAndHashCode",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJavaSerialization() throws IOException, ClassNotFoundException {\r\n    ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\r\n    ObjectOutputStream objOut \u003d new ObjectOutputStream(out);\r\n    Map\u003cString, Integer\u003e map \u003d new LinkedTreeMap\u003c\u003e();\r\n    map.put(\"a\", 1);\r\n    objOut.writeObject(map);\r\n    objOut.close();\r\n    ObjectInputStream objIn \u003d new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map\u003cString, Integer\u003e deserialized \u003d (Map\u003cString, Integer\u003e) objIn.readObject();\r\n    assertThat(deserialized).isEqualTo(Collections.singletonMap(\"a\", 1));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "testJavaSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"varargs\")\r\n@SafeVarargs\r\nprivate final \u003cT\u003e void assertIterationOrder(Iterable\u003cT\u003e actual, T... expected) {\r\n    ArrayList\u003cT\u003e actualList \u003d new ArrayList\u003c\u003e();\r\n    for (T t : actual) {\r\n        actualList.add(t);\r\n    }\r\n    assertThat(actualList).isEqualTo(Arrays.asList(expected));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.LinkedTreeMapTest",
      "methodName": "assertIterationOrder",
      "parameterTypes": [
        "Iterable\u003cT\u003e",
        "T"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJava17Record() throws ClassNotFoundException {\r\n    Class\u003c?\u003e unixDomainPrincipalClass \u003d Class.forName(\"jdk.net.UnixDomainPrincipal\");\r\n    // UnixDomainPrincipal is a record\r\n    assertThat(ReflectionHelper.isRecord(unixDomainPrincipalClass)).isTrue();\r\n    // with 2 components\r\n    assertThat(ReflectionHelper.getRecordComponentNames(unixDomainPrincipalClass)).isEqualTo(new String[] { \"user\", \"group\" });\r\n    // Check canonical constructor\r\n    Constructor\u003c?\u003e constructor \u003d ReflectionHelper.getCanonicalRecordConstructor(unixDomainPrincipalClass);\r\n    assertThat(constructor).isNotNull();\r\n    assertThat(constructor.getParameterTypes()).isEqualTo(new Class\u003c?\u003e[] { UserPrincipal.class, GroupPrincipal.class });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.Java17ReflectionHelperTest",
      "methodName": "testJava17Record",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJava17RecordAccessors() throws ReflectiveOperationException {\r\n    // Create an instance of UnixDomainPrincipal, using our custom implementation of UserPrincipal,\r\n    // and GroupPrincipal. Then attempt to access each component of the record using our accessor\r\n    // methods.\r\n    Class\u003c?\u003e unixDomainPrincipalClass \u003d Class.forName(\"jdk.net.UnixDomainPrincipal\");\r\n    Object unixDomainPrincipal \u003d ReflectionHelper.getCanonicalRecordConstructor(unixDomainPrincipalClass).newInstance(new PrincipalImpl(\"user\"), new PrincipalImpl(\"group\"));\r\n    String[] componentNames \u003d ReflectionHelper.getRecordComponentNames(unixDomainPrincipalClass);\r\n    assertThat(componentNames.length \u003e 0).isTrue();\r\n    for (String componentName : componentNames) {\r\n        Field componentField \u003d unixDomainPrincipalClass.getDeclaredField(componentName);\r\n        Method accessor \u003d ReflectionHelper.getAccessor(unixDomainPrincipalClass, componentField);\r\n        Object principal \u003d accessor.invoke(unixDomainPrincipal);\r\n        assertThat(principal).isEqualTo(new PrincipalImpl(componentName));\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.Java17ReflectionHelperTest",
      "methodName": "testJava17RecordAccessors",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String getName() {\r\n    return name;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.Java17ReflectionHelperTest.PrincipalImpl",
      "methodName": "getName",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    if (o instanceof PrincipalImpl) {\r\n        return Objects.equals(name, ((PrincipalImpl) o).name);\r\n    }\r\n    return false;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.Java17ReflectionHelperTest.PrincipalImpl",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return Objects.hash(name);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.reflect.Java17ReflectionHelperTest.PrincipalImpl",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    this.oldTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"));\r\n    this.oldLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@After\r\npublic void tearDown() throws Exception {\r\n    TimeZone.setDefault(oldTimeZone);\r\n    Locale.setDefault(oldLocale);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "tearDown",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullSerializationAndDeserialization() {\r\n    testNullSerializationAndDeserialization(Date.class);\r\n    testNullSerializationAndDeserialization(Time.class);\r\n    testNullSerializationAndDeserialization(Timestamp.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "testNullSerializationAndDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void testNullSerializationAndDeserialization(Class\u003c?\u003e c) {\r\n    DefaultTypeAdaptersTest.testNullSerializationAndDeserialization(gson, c);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "testNullSerializationAndDeserialization",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultSqlDateSerialization() {\r\n    java.sql.Date instant \u003d new java.sql.Date(1259875082000L);\r\n    String json \u003d gson.toJson(instant);\r\n    assertThat(json).isEqualTo(\"\\\"Dec 3, 2009\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "testDefaultSqlDateSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultSqlDateDeserialization() {\r\n    String json \u003d \"\u0027Dec 3, 2009\u0027\";\r\n    java.sql.Date extracted \u003d gson.fromJson(json, java.sql.Date.class);\r\n    DefaultTypeAdaptersTest.assertEqualsDate(extracted, 2009, 11, 3);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "testDefaultSqlDateDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// http://code.google.com/p/google-gson/issues/detail?id\u003d230\r\n@Test\r\npublic void testSqlDateSerialization() throws Exception {\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    try {\r\n        java.sql.Date sqlDate \u003d new java.sql.Date(0L);\r\n        Gson gson \u003d new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create();\r\n        String json \u003d gson.toJson(sqlDate, Timestamp.class);\r\n        assertThat(json).isEqualTo(\"\\\"1970-01-01\\\"\");\r\n        assertThat(gson.fromJson(\"\\\"1970-01-01\\\"\", java.sql.Date.class).getTime()).isEqualTo(0);\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "testSqlDateSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultSqlTimeSerialization() {\r\n    Time now \u003d new Time(1259875082000L);\r\n    String json \u003d gson.toJson(now);\r\n    assertThat(json).isEqualTo(\"\\\"01:18:02 PM\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "testDefaultSqlTimeSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultSqlTimeDeserialization() {\r\n    String json \u003d \"\u00271:18:02 PM\u0027\";\r\n    Time extracted \u003d gson.fromJson(json, Time.class);\r\n    DefaultTypeAdaptersTest.assertEqualsTime(extracted, 13, 18, 2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "testDefaultSqlTimeDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultSqlTimestampSerialization() {\r\n    Timestamp now \u003d new java.sql.Timestamp(1259875082000L);\r\n    String json \u003d gson.toJson(now);\r\n    // The exact format of the serialized date-time string depends on the JDK version. The pattern\r\n    // here allows for an optional comma after the date, and what might be U+202F (Narrow No-Break\r\n    // Space) before \"PM\".\r\n    assertThat(json).matches(\"\\\"Dec 3, 2009,? 1:18:02\\\\hPM\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "testDefaultSqlTimestampSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultSqlTimestampDeserialization() {\r\n    String json \u003d \"\u0027Dec 3, 2009 1:18:02 PM\u0027\";\r\n    Timestamp extracted \u003d gson.fromJson(json, Timestamp.class);\r\n    DefaultTypeAdaptersTest.assertEqualsDate(extracted, 2009, 11, 3);\r\n    DefaultTypeAdaptersTest.assertEqualsTime(extracted, 13, 18, 2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "testDefaultSqlTimestampDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// http://code.google.com/p/google-gson/issues/detail?id\u003d230\r\n@Test\r\npublic void testTimestampSerialization() throws Exception {\r\n    TimeZone defaultTimeZone \u003d TimeZone.getDefault();\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\r\n    Locale defaultLocale \u003d Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    try {\r\n        Timestamp timestamp \u003d new Timestamp(0L);\r\n        Gson gson \u003d new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create();\r\n        String json \u003d gson.toJson(timestamp, Timestamp.class);\r\n        assertThat(json).isEqualTo(\"\\\"1970-01-01\\\"\");\r\n        assertThat(gson.fromJson(\"\\\"1970-01-01\\\"\", Timestamp.class).getTime()).isEqualTo(0);\r\n    } finally {\r\n        TimeZone.setDefault(defaultTimeZone);\r\n        Locale.setDefault(defaultLocale);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesGsonTest",
      "methodName": "testTimestampSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSupported() {\r\n    assertThat(SqlTypesSupport.SUPPORTS_SQL_TYPES).isTrue();\r\n    assertThat(SqlTypesSupport.DATE_DATE_TYPE).isNotNull();\r\n    assertThat(SqlTypesSupport.TIMESTAMP_DATE_TYPE).isNotNull();\r\n    assertThat(SqlTypesSupport.DATE_FACTORY).isNotNull();\r\n    assertThat(SqlTypesSupport.TIME_FACTORY).isNotNull();\r\n    assertThat(SqlTypesSupport.TIMESTAMP_FACTORY).isNotNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.sql.SqlTypesSupportTest",
      "methodName": "testSupported",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWriterForAppendable() throws IOException {\r\n    StringBuilder stringBuilder \u003d new StringBuilder();\r\n    Writer writer \u003d Streams.writerForAppendable(stringBuilder);\r\n    writer.append(\u0027a\u0027);\r\n    writer.append(\u0027\\u1234\u0027);\r\n    writer.append(\"test\");\r\n    // test custom null handling mandated by `append`\r\n    writer.append(null);\r\n    writer.append(\"abcdef\", 2, 4);\r\n    // test custom null handling mandated by `append`\r\n    writer.append(null, 1, 3);\r\n    writer.append(\u0027,\u0027);\r\n    writer.write(\u0027a\u0027);\r\n    writer.write(\u0027\\u1234\u0027);\r\n    // Should only consider the 16 low-order bits\r\n    writer.write(0x4321_1234);\r\n    writer.append(\u0027,\u0027);\r\n    writer.write(\"chars\".toCharArray());\r\n    try {\r\n        writer.write((char[]) null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n    }\r\n    writer.write(\"chars\".toCharArray(), 1, 2);\r\n    try {\r\n        writer.write((char[]) null, 1, 2);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n    }\r\n    writer.append(\u0027,\u0027);\r\n    writer.write(\"string\");\r\n    try {\r\n        writer.write((String) null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n    }\r\n    writer.write(\"string\", 1, 2);\r\n    try {\r\n        writer.write((String) null, 1, 2);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n    }\r\n    String actualOutput \u003d stringBuilder.toString();\r\n    assertThat(actualOutput).isEqualTo(\"a\\u1234testnullcdul,a\\u1234\\u1234,charsha,stringtr\");\r\n    writer.flush();\r\n    writer.close();\r\n    // flush() and close() calls should have had no effect\r\n    assertThat(stringBuilder.toString()).isEqualTo(actualOutput);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.StreamsTest",
      "methodName": "testWriterForAppendable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Ensure that an {@link AssertionError} is thrown when trying\r\n * to instantiate an interface\r\n */\r\n@Test\r\npublic void testInterfaceInstantiation() {\r\n    AssertionError e \u003d assertThrows(AssertionError.class, () -\u003e UnsafeAllocator.INSTANCE.newInstance(Interface.class));\r\n    assertThat(e).hasMessageThat().startsWith(\"UnsafeAllocator is used for non-instantiable type\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.UnsafeAllocatorInstantiationTest",
      "methodName": "testInterfaceInstantiation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Ensure that an {@link AssertionError} is thrown when trying\r\n * to instantiate an abstract class\r\n */\r\n@Test\r\npublic void testAbstractClassInstantiation() {\r\n    AssertionError e \u003d assertThrows(AssertionError.class, () -\u003e UnsafeAllocator.INSTANCE.newInstance(AbstractClass.class));\r\n    assertThat(e).hasMessageThat().startsWith(\"UnsafeAllocator is used for non-instantiable type\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.UnsafeAllocatorInstantiationTest",
      "methodName": "testAbstractClassInstantiation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Ensure that no exception is thrown when trying to instantiate a concrete class\r\n */\r\n@Test\r\npublic void testConcreteClassInstantiation() throws Exception {\r\n    ConcreteClass instance \u003d UnsafeAllocator.INSTANCE.newInstance(ConcreteClass.class);\r\n    assertThat(instance).isNotNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.internal.UnsafeAllocatorInstantiationTest",
      "methodName": "testConcreteClassInstantiation",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMapIsSerializable() throws Exception {\r\n    Type type \u003d new TypeToken\u003cMap\u003cString, Integer\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cString, Integer\u003e map \u003d gson.fromJson(\"{\\\"b\\\":1,\\\"c\\\":2,\\\"a\\\":3}\", type);\r\n    Map\u003cString, Integer\u003e serialized \u003d serializedCopy(map);\r\n    assertThat(serialized).isEqualTo(map);\r\n    // Also check that the iteration order is retained.\r\n    assertThat(serialized.keySet()).containsExactly(\"b\", \"c\", \"a\").inOrder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JavaSerializationTest",
      "methodName": "testMapIsSerializable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testListIsSerializable() throws Exception {\r\n    Type type \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cString\u003e list \u003d gson.fromJson(\"[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\", type);\r\n    List\u003cString\u003e serialized \u003d serializedCopy(list);\r\n    assertThat(serialized).isEqualTo(list);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JavaSerializationTest",
      "methodName": "testListIsSerializable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNumberIsSerializable() throws Exception {\r\n    Type type \u003d new TypeToken\u003cList\u003cNumber\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cNumber\u003e list \u003d gson.fromJson(\"[1,3.14,6.673e-11]\", type);\r\n    List\u003cNumber\u003e serialized \u003d serializedCopy(list);\r\n    assertThat(serialized.get(0).doubleValue()).isEqualTo(1.0);\r\n    assertThat(serialized.get(1).doubleValue()).isEqualTo(3.14);\r\n    assertThat(serialized.get(2).doubleValue()).isEqualTo(6.673e-11);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JavaSerializationTest",
      "methodName": "testNumberIsSerializable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Serialization promises to return the same type.\r\n@SuppressWarnings(\"unchecked\")\r\nprivate \u003cT\u003e T serializedCopy(T object) throws IOException, ClassNotFoundException {\r\n    ByteArrayOutputStream bytesOut \u003d new ByteArrayOutputStream();\r\n    ObjectOutputStream out \u003d new ObjectOutputStream(bytesOut);\r\n    out.writeObject(object);\r\n    out.close();\r\n    ByteArrayInputStream bytesIn \u003d new ByteArrayInputStream(bytesOut.toByteArray());\r\n    ObjectInputStream in \u003d new ObjectInputStream(bytesIn);\r\n    return (T) in.readObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JavaSerializationTest",
      "methodName": "serializedCopy",
      "parameterTypes": [
        "T"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGet() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list.get(0)).isEqualTo(new JsonPrimitive(1));\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.get(-1));\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.get(2));\r\n    a.add((JsonElement) null);\r\n    assertThat(list.get(1)).isEqualTo(JsonNull.INSTANCE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testGet",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSize() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list).hasSize(1);\r\n    list.add(new JsonPrimitive(2));\r\n    assertThat(list).hasSize(2);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testSize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSet() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    JsonElement old \u003d list.set(0, new JsonPrimitive(2));\r\n    assertThat(old).isEqualTo(new JsonPrimitive(1));\r\n    assertThat(list.get(0)).isEqualTo(new JsonPrimitive(2));\r\n    assertThat(a.get(0)).isEqualTo(new JsonPrimitive(2));\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.set(-1, new JsonPrimitive(1)));\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.set(2, new JsonPrimitive(1)));\r\n    NullPointerException e \u003d assertThrows(NullPointerException.class, () -\u003e list.set(0, null));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Element must be non-null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testSet",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAdd() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    list.add(0, new JsonPrimitive(2));\r\n    list.add(1, new JsonPrimitive(3));\r\n    assertThat(list.add(new JsonPrimitive(4))).isTrue();\r\n    assertThat(list.add(JsonNull.INSTANCE)).isTrue();\r\n    List\u003cJsonElement\u003e expectedList \u003d Arrays.\u003cJsonElement\u003easList(new JsonPrimitive(2), new JsonPrimitive(3), new JsonPrimitive(1), new JsonPrimitive(4), JsonNull.INSTANCE);\r\n    assertThat(list).isEqualTo(expectedList);\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.set(-1, new JsonPrimitive(1)));\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.set(list.size(), new JsonPrimitive(1)));\r\n    NullPointerException e \u003d assertThrows(NullPointerException.class, () -\u003e list.add(0, null));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Element must be non-null\");\r\n    e \u003d assertThrows(NullPointerException.class, () -\u003e list.add(null));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Element must be non-null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testAdd",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAddAll() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    list.addAll(Arrays.asList(new JsonPrimitive(2), new JsonPrimitive(3)));\r\n    List\u003cJsonElement\u003e expectedList \u003d Arrays.\u003cJsonElement\u003easList(new JsonPrimitive(1), new JsonPrimitive(2), new JsonPrimitive(3));\r\n    assertThat(list).isEqualTo(expectedList);\r\n    assertThat(list).isEqualTo(expectedList);\r\n    NullPointerException e \u003d assertThrows(NullPointerException.class, () -\u003e list.addAll(0, Collections.\u003cJsonElement\u003esingletonList(null)));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Element must be non-null\");\r\n    e \u003d assertThrows(NullPointerException.class, () -\u003e list.addAll(Collections.\u003cJsonElement\u003esingletonList(null)));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Element must be non-null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testAddAll",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRemoveIndex() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list.remove(0)).isEqualTo(new JsonPrimitive(1));\r\n    assertThat(list).hasSize(0);\r\n    assertThat(a).hasSize(0);\r\n    assertThrows(IndexOutOfBoundsException.class, () -\u003e list.remove(0));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testRemoveIndex",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRemoveElement() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list.remove(new JsonPrimitive(1))).isTrue();\r\n    assertThat(list).hasSize(0);\r\n    assertThat(a).hasSize(0);\r\n    assertThat(list.remove(new JsonPrimitive(1))).isFalse();\r\n    assertThat(list.remove(null)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testRemoveElement",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClear() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    list.clear();\r\n    assertThat(list).hasSize(0);\r\n    assertThat(a).hasSize(0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testClear",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testContains() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list).contains(new JsonPrimitive(1));\r\n    assertThat(list).doesNotContain(new JsonPrimitive(2));\r\n    assertThat(list).doesNotContain(null);\r\n    @SuppressWarnings({ \"unlikely-arg-type\", \"CollectionIncompatibleType\" })\r\n    boolean // should only contain JsonPrimitive(1)\r\n    containsInt \u003d list.contains(1);\r\n    assertThat(containsInt).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testContains",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIndexOf() {\r\n    JsonArray a \u003d new JsonArray();\r\n    // Add the same value twice to test indexOf vs. lastIndexOf\r\n    a.add(1);\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list.indexOf(new JsonPrimitive(1))).isEqualTo(0);\r\n    assertThat(list.indexOf(new JsonPrimitive(2))).isEqualTo(-1);\r\n    assertThat(list.indexOf(null)).isEqualTo(-1);\r\n    @SuppressWarnings({ \"unlikely-arg-type\", \"CollectionIncompatibleType\" })\r\n    int // should only contain JsonPrimitive(1)\r\n    indexOfInt \u003d list.indexOf(1);\r\n    assertThat(indexOfInt).isEqualTo(-1);\r\n    assertThat(list.lastIndexOf(new JsonPrimitive(1))).isEqualTo(1);\r\n    assertThat(list.lastIndexOf(new JsonPrimitive(2))).isEqualTo(-1);\r\n    assertThat(list.lastIndexOf(null)).isEqualTo(-1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testIndexOf",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testToArray() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    assertThat(list.toArray()).isEqualTo(new Object[] { new JsonPrimitive(1) });\r\n    JsonElement[] array \u003d list.toArray(new JsonElement[0]);\r\n    assertThat(array).isEqualTo(new Object[] { new JsonPrimitive(1) });\r\n    array \u003d new JsonElement[1];\r\n    assertThat(list.toArray(array)).isEqualTo(array);\r\n    assertThat(array).isEqualTo(new Object[] { new JsonPrimitive(1) });\r\n    array \u003d new JsonElement[] { null, new JsonPrimitive(2) };\r\n    assertThat(list.toArray(array)).isEqualTo(array);\r\n    // Should have set existing array element to null\r\n    assertThat(array).isEqualTo(new Object[] { new JsonPrimitive(1), null });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testToArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsHashCode() {\r\n    JsonArray a \u003d new JsonArray();\r\n    a.add(1);\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    MoreAsserts.assertEqualsAndHashCode(list, Collections.singletonList(new JsonPrimitive(1)));\r\n    assertThat(list.equals(Collections.emptyList())).isFalse();\r\n    assertThat(list.equals(Collections.singletonList(new JsonPrimitive(2)))).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testEqualsHashCode",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Verify that {@code JsonArray} updates are visible to view and vice versa\r\n */\r\n@Test\r\npublic void testViewUpdates() {\r\n    JsonArray a \u003d new JsonArray();\r\n    List\u003cJsonElement\u003e list \u003d a.asList();\r\n    a.add(1);\r\n    assertThat(list).hasSize(1);\r\n    assertThat(list.get(0)).isEqualTo(new JsonPrimitive(1));\r\n    list.add(new JsonPrimitive(2));\r\n    assertThat(a).hasSize(2);\r\n    assertThat(a.get(1)).isEqualTo(new JsonPrimitive(2));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayAsListTest",
      "methodName": "testViewUpdates",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsOnEmptyArray() {\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonArray(), new JsonArray());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testEqualsOnEmptyArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsNonEmptyArray() {\r\n    JsonArray a \u003d new JsonArray();\r\n    JsonArray b \u003d new JsonArray();\r\n    new EqualsTester().addEqualityGroup(a).testEquals();\r\n    a.add(new JsonObject());\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n    b.add(new JsonObject());\r\n    MoreAsserts.assertEqualsAndHashCode(a, b);\r\n    a.add(new JsonObject());\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n    b.add(JsonNull.INSTANCE);\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testEqualsNonEmptyArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRemove() {\r\n    JsonArray array \u003d new JsonArray();\r\n    try {\r\n        array.remove(0);\r\n        fail();\r\n    } catch (IndexOutOfBoundsException expected) {\r\n    }\r\n    JsonPrimitive a \u003d new JsonPrimitive(\"a\");\r\n    array.add(a);\r\n    assertThat(array.remove(a)).isTrue();\r\n    assertThat(array).doesNotContain(a);\r\n    array.add(a);\r\n    array.add(new JsonPrimitive(\"b\"));\r\n    assertThat(array.remove(1).getAsString()).isEqualTo(\"b\");\r\n    assertThat(array).hasSize(1);\r\n    assertThat(array).contains(a);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testRemove",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSet() {\r\n    JsonArray array \u003d new JsonArray();\r\n    try {\r\n        array.set(0, new JsonPrimitive(1));\r\n        fail();\r\n    } catch (IndexOutOfBoundsException expected) {\r\n    }\r\n    JsonPrimitive a \u003d new JsonPrimitive(\"a\");\r\n    array.add(a);\r\n    JsonPrimitive b \u003d new JsonPrimitive(\"b\");\r\n    JsonElement oldValue \u003d array.set(0, b);\r\n    assertThat(oldValue).isEqualTo(a);\r\n    assertThat(array.get(0).getAsString()).isEqualTo(\"b\");\r\n    oldValue \u003d array.set(0, null);\r\n    assertThat(oldValue).isEqualTo(b);\r\n    assertThat(array.get(0)).isEqualTo(JsonNull.INSTANCE);\r\n    oldValue \u003d array.set(0, new JsonPrimitive(\"c\"));\r\n    assertThat(oldValue).isEqualTo(JsonNull.INSTANCE);\r\n    assertThat(array.get(0).getAsString()).isEqualTo(\"c\");\r\n    assertThat(array).hasSize(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testSet",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeepCopy() {\r\n    JsonArray original \u003d new JsonArray();\r\n    JsonArray firstEntry \u003d new JsonArray();\r\n    original.add(firstEntry);\r\n    JsonArray copy \u003d original.deepCopy();\r\n    original.add(new JsonPrimitive(\"y\"));\r\n    assertThat(copy).hasSize(1);\r\n    firstEntry.add(new JsonPrimitive(\"z\"));\r\n    assertThat(original.get(0).getAsJsonArray()).hasSize(1);\r\n    assertThat(copy.get(0).getAsJsonArray()).hasSize(0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testDeepCopy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIsEmpty() {\r\n    JsonArray array \u003d new JsonArray();\r\n    assertThat(array).isEmpty();\r\n    JsonPrimitive a \u003d new JsonPrimitive(\"a\");\r\n    array.add(a);\r\n    assertThat(array).isNotEmpty();\r\n    array.remove(0);\r\n    assertThat(array).isEmpty();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testIsEmpty",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailedGetArrayValues() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(JsonParser.parseString(\"{\" + \"\\\"key1\\\":\\\"value1\\\",\" + \"\\\"key2\\\":\\\"value2\\\",\" + \"\\\"key3\\\":\\\"value3\\\",\" + \"\\\"key4\\\":\\\"value4\\\"\" + \"}\"));\r\n    try {\r\n        jsonArray.getAsBoolean();\r\n        fail(\"expected getBoolean to fail\");\r\n    } catch (UnsupportedOperationException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JsonObject\");\r\n    }\r\n    try {\r\n        jsonArray.get(-1);\r\n        fail(\"expected get to fail\");\r\n    } catch (IndexOutOfBoundsException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Index -1 out of bounds for length 1\");\r\n    }\r\n    try {\r\n        jsonArray.getAsString();\r\n        fail(\"expected getString to fail\");\r\n    } catch (UnsupportedOperationException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JsonObject\");\r\n    }\r\n    jsonArray.remove(0);\r\n    jsonArray.add(\"hello\");\r\n    try {\r\n        jsonArray.getAsDouble();\r\n        fail(\"expected getDouble to fail\");\r\n    } catch (NumberFormatException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"For input string: \\\"hello\\\"\");\r\n    }\r\n    try {\r\n        jsonArray.getAsInt();\r\n        fail(\"expected getInt to fail\");\r\n    } catch (NumberFormatException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"For input string: \\\"hello\\\"\");\r\n    }\r\n    try {\r\n        jsonArray.get(0).getAsJsonArray();\r\n        fail(\"expected getJSONArray to fail\");\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Not a JSON Array: \\\"hello\\\"\");\r\n    }\r\n    try {\r\n        jsonArray.getAsJsonObject();\r\n        fail(\"expected getJSONObject to fail\");\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Not a JSON Object: [\\\"hello\\\"]\");\r\n    }\r\n    try {\r\n        jsonArray.getAsLong();\r\n        fail(\"expected getLong to fail\");\r\n    } catch (NumberFormatException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"For input string: \\\"hello\\\"\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testFailedGetArrayValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGetAs_WrongArraySize() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    try {\r\n        jsonArray.getAsByte();\r\n        fail();\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Array must have size 1, but has size 0\");\r\n    }\r\n    jsonArray.add(true);\r\n    jsonArray.add(false);\r\n    try {\r\n        jsonArray.getAsByte();\r\n        fail();\r\n    } catch (IllegalStateException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Array must have size 1, but has size 2\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testGetAs_WrongArraySize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringPrimitiveAddition() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(\"Hello\");\r\n    jsonArray.add(\"Goodbye\");\r\n    jsonArray.add(\"Thank you\");\r\n    jsonArray.add((String) null);\r\n    jsonArray.add(\"Yes\");\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[\\\"Hello\\\",\\\"Goodbye\\\",\\\"Thank you\\\",null,\\\"Yes\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testStringPrimitiveAddition",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIntegerPrimitiveAddition() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    int x \u003d 1;\r\n    jsonArray.add(x);\r\n    x \u003d 2;\r\n    jsonArray.add(x);\r\n    x \u003d -3;\r\n    jsonArray.add(x);\r\n    jsonArray.add((Integer) null);\r\n    x \u003d 4;\r\n    jsonArray.add(x);\r\n    x \u003d 0;\r\n    jsonArray.add(x);\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[1,2,-3,null,4,0]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testIntegerPrimitiveAddition",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoublePrimitiveAddition() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    double x \u003d 1.0;\r\n    jsonArray.add(x);\r\n    x \u003d 2.13232;\r\n    jsonArray.add(x);\r\n    x \u003d 0.121;\r\n    jsonArray.add(x);\r\n    jsonArray.add((Double) null);\r\n    x \u003d -0.00234;\r\n    jsonArray.add(x);\r\n    jsonArray.add((Double) null);\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[1.0,2.13232,0.121,null,-0.00234,null]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testDoublePrimitiveAddition",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBooleanPrimitiveAddition() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(true);\r\n    jsonArray.add(true);\r\n    jsonArray.add(false);\r\n    jsonArray.add(false);\r\n    jsonArray.add((Boolean) null);\r\n    jsonArray.add(true);\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[true,true,false,false,null,true]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testBooleanPrimitiveAddition",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCharPrimitiveAddition() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(\u0027a\u0027);\r\n    jsonArray.add(\u0027e\u0027);\r\n    jsonArray.add(\u0027i\u0027);\r\n    jsonArray.add((char) 111);\r\n    jsonArray.add((Character) null);\r\n    jsonArray.add(\u0027u\u0027);\r\n    jsonArray.add(\"and sometimes Y\");\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[\\\"a\\\",\\\"e\\\",\\\"i\\\",\\\"o\\\",null,\\\"u\\\",\\\"and sometimes Y\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testCharPrimitiveAddition",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMixedPrimitiveAddition() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(\u0027a\u0027);\r\n    jsonArray.add(\"apple\");\r\n    jsonArray.add(12121);\r\n    jsonArray.add((char) 111);\r\n    jsonArray.add((Boolean) null);\r\n    assertThat(jsonArray.get(jsonArray.size() - 1)).isEqualTo(JsonNull.INSTANCE);\r\n    jsonArray.add((Character) null);\r\n    assertThat(jsonArray.get(jsonArray.size() - 1)).isEqualTo(JsonNull.INSTANCE);\r\n    jsonArray.add(12.232);\r\n    jsonArray.add(BigInteger.valueOf(2323));\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[\\\"a\\\",\\\"apple\\\",12121,\\\"o\\\",null,null,12.232,2323]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testMixedPrimitiveAddition",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullPrimitiveAddition() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add((Character) null);\r\n    jsonArray.add((Boolean) null);\r\n    jsonArray.add((Integer) null);\r\n    jsonArray.add((Double) null);\r\n    jsonArray.add((Float) null);\r\n    jsonArray.add((BigInteger) null);\r\n    jsonArray.add((String) null);\r\n    jsonArray.add((Boolean) null);\r\n    jsonArray.add((Number) null);\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[null,null,null,null,null,null,null,null,null]\");\r\n    for (int i \u003d 0; i \u003c jsonArray.size(); i++) {\r\n        // Verify that they are actually a JsonNull and not a Java null\r\n        assertThat(jsonArray.get(i)).isEqualTo(JsonNull.INSTANCE);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testNullPrimitiveAddition",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullJsonElementAddition() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add((JsonElement) null);\r\n    assertThat(jsonArray.get(0)).isEqualTo(JsonNull.INSTANCE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testNullJsonElementAddition",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSameAddition() {\r\n    JsonArray jsonArray \u003d new JsonArray();\r\n    jsonArray.add(\u0027a\u0027);\r\n    jsonArray.add(\u0027a\u0027);\r\n    jsonArray.add(true);\r\n    jsonArray.add(true);\r\n    jsonArray.add(1212);\r\n    jsonArray.add(1212);\r\n    jsonArray.add(34.34);\r\n    jsonArray.add(34.34);\r\n    jsonArray.add((Boolean) null);\r\n    jsonArray.add((Boolean) null);\r\n    assertThat(jsonArray.toString()).isEqualTo(\"[\\\"a\\\",\\\"a\\\",true,true,1212,1212,34.34,34.34,null,null]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonArrayTest",
      "methodName": "testSameAddition",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testEqualsAndHashcode() {\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonNull(), new JsonNull());\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonNull(), JsonNull.INSTANCE);\r\n    MoreAsserts.assertEqualsAndHashCode(JsonNull.INSTANCE, JsonNull.INSTANCE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonNullTest",
      "methodName": "testEqualsAndHashcode",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeepCopy() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    JsonNull a \u003d new JsonNull();\r\n    assertThat(a.deepCopy()).isSameInstanceAs(JsonNull.INSTANCE);\r\n    assertThat(JsonNull.INSTANCE.deepCopy()).isSameInstanceAs(JsonNull.INSTANCE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonNullTest",
      "methodName": "testDeepCopy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSize() {\r\n    JsonObject o \u003d new JsonObject();\r\n    assertThat(o.asMap().size()).isEqualTo(0);\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map).hasSize(1);\r\n    map.clear();\r\n    assertThat(map).hasSize(0);\r\n    assertThat(o.size()).isEqualTo(0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testSize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testContainsKey() {\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map.containsKey(\"a\")).isTrue();\r\n    assertThat(map.containsKey(\"b\")).isFalse();\r\n    assertThat(map.containsKey(null)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testContainsKey",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testContainsValue() {\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    o.add(\"b\", JsonNull.INSTANCE);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map.containsValue(new JsonPrimitive(1))).isTrue();\r\n    assertThat(map.containsValue(new JsonPrimitive(2))).isFalse();\r\n    assertThat(map.containsValue(null)).isFalse();\r\n    @SuppressWarnings({ \"unlikely-arg-type\", \"CollectionIncompatibleType\" })\r\n    boolean // should only contain JsonPrimitive(1)\r\n    containsInt \u003d map.containsValue(1);\r\n    assertThat(containsInt).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testContainsValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testGet() {\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map.get(\"a\")).isEqualTo(new JsonPrimitive(1));\r\n    assertThat(map.get(\"b\")).isNull();\r\n    assertThat(map.get(null)).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testGet",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPut() {\r\n    JsonObject o \u003d new JsonObject();\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map.put(\"a\", new JsonPrimitive(1))).isNull();\r\n    assertThat(map.get(\"a\")).isEqualTo(new JsonPrimitive(1));\r\n    JsonElement old \u003d map.put(\"a\", new JsonPrimitive(2));\r\n    assertThat(old).isEqualTo(new JsonPrimitive(1));\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"a\")).isEqualTo(new JsonPrimitive(2));\r\n    assertThat(o.get(\"a\")).isEqualTo(new JsonPrimitive(2));\r\n    assertThat(map.put(\"b\", JsonNull.INSTANCE)).isNull();\r\n    assertThat(map.get(\"b\")).isEqualTo(JsonNull.INSTANCE);\r\n    try {\r\n        map.put(null, new JsonPrimitive(1));\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"key \u003d\u003d null\");\r\n    }\r\n    try {\r\n        map.put(\"a\", null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testPut",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRemove() {\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    assertThat(map.remove(\"b\")).isNull();\r\n    assertThat(map).hasSize(1);\r\n    JsonElement old \u003d map.remove(\"a\");\r\n    assertThat(old).isEqualTo(new JsonPrimitive(1));\r\n    assertThat(map).hasSize(0);\r\n    assertThat(map.remove(\"a\")).isNull();\r\n    assertThat(map).hasSize(0);\r\n    assertThat(o.size()).isEqualTo(0);\r\n    assertThat(map.remove(null)).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testRemove",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPutAll() {\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e otherMap \u003d new HashMap\u003c\u003e();\r\n    otherMap.put(\"a\", new JsonPrimitive(2));\r\n    otherMap.put(\"b\", new JsonPrimitive(3));\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    map.putAll(otherMap);\r\n    assertThat(map).hasSize(2);\r\n    assertThat(map.get(\"a\")).isEqualTo(new JsonPrimitive(2));\r\n    assertThat(map.get(\"b\")).isEqualTo(new JsonPrimitive(3));\r\n    try {\r\n        map.putAll(Collections.\u003cString, JsonElement\u003esingletonMap(null, new JsonPrimitive(1)));\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"key \u003d\u003d null\");\r\n    }\r\n    try {\r\n        map.putAll(Collections.\u003cString, JsonElement\u003esingletonMap(\"a\", null));\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testPutAll",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClear() {\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    map.clear();\r\n    assertThat(map).hasSize(0);\r\n    assertThat(o.size()).isEqualTo(0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testClear",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testKeySet() {\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"b\", 1);\r\n    o.addProperty(\"a\", 2);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    Set\u003cString\u003e keySet \u003d map.keySet();\r\n    // Should contain keys in same order\r\n    assertThat(keySet).containsExactly(\"b\", \"a\").inOrder();\r\n    // Key set doesn\u0027t support insertions\r\n    try {\r\n        keySet.add(\"c\");\r\n        fail();\r\n    } catch (UnsupportedOperationException e) {\r\n    }\r\n    assertThat(keySet.remove(\"a\")).isTrue();\r\n    assertThat(map.keySet()).isEqualTo(Collections.singleton(\"b\"));\r\n    assertThat(o.keySet()).isEqualTo(Collections.singleton(\"b\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testKeySet",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testValues() {\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 2);\r\n    o.addProperty(\"b\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    Collection\u003cJsonElement\u003e values \u003d map.values();\r\n    // Should contain values in same order\r\n    assertThat(values).containsExactly(new JsonPrimitive(2), new JsonPrimitive(1)).inOrder();\r\n    // Values collection doesn\u0027t support insertions\r\n    try {\r\n        values.add(new JsonPrimitive(3));\r\n        fail();\r\n    } catch (UnsupportedOperationException e) {\r\n    }\r\n    assertThat(values.remove(new JsonPrimitive(2))).isTrue();\r\n    assertThat(new ArrayList\u003c\u003e(map.values())).isEqualTo(Collections.singletonList(new JsonPrimitive(1)));\r\n    assertThat(o.size()).isEqualTo(1);\r\n    assertThat(o.get(\"b\")).isEqualTo(new JsonPrimitive(1));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEntrySet() {\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"b\", 2);\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    Set\u003cEntry\u003cString, JsonElement\u003e\u003e entrySet \u003d map.entrySet();\r\n    List\u003cEntry\u003c?, ?\u003e\u003e expectedEntrySet \u003d Arrays.\u003cEntry\u003c?, ?\u003e\u003easList(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(2)), new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(1)));\r\n    // Should contain entries in same order\r\n    assertThat(new ArrayList\u003c\u003e(entrySet)).isEqualTo(expectedEntrySet);\r\n    try {\r\n        entrySet.add(new SimpleEntry\u003cString, JsonElement\u003e(\"c\", new JsonPrimitive(3)));\r\n        fail();\r\n    } catch (UnsupportedOperationException e) {\r\n    }\r\n    assertThat(entrySet.remove(new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(1)))).isTrue();\r\n    assertThat(map.entrySet()).isEqualTo(Collections.singleton(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(2))));\r\n    assertThat(o.entrySet()).isEqualTo(Collections.singleton(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(2))));\r\n    // Should return false because entry has already been removed\r\n    assertThat(entrySet.remove(new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(1)))).isFalse();\r\n    Entry\u003cString, JsonElement\u003e entry \u003d entrySet.iterator().next();\r\n    JsonElement old \u003d entry.setValue(new JsonPrimitive(3));\r\n    assertThat(old).isEqualTo(new JsonPrimitive(2));\r\n    assertThat(map.entrySet()).isEqualTo(Collections.singleton(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(3))));\r\n    assertThat(o.entrySet()).isEqualTo(Collections.singleton(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(3))));\r\n    try {\r\n        entry.setValue(null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testEntrySet",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsHashCode() {\r\n    JsonObject o \u003d new JsonObject();\r\n    o.addProperty(\"a\", 1);\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    MoreAsserts.assertEqualsAndHashCode(map, Collections.singletonMap(\"a\", new JsonPrimitive(1)));\r\n    assertThat(map.equals(Collections.emptyMap())).isFalse();\r\n    assertThat(map.equals(Collections.singletonMap(\"a\", new JsonPrimitive(2)))).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testEqualsHashCode",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Verify that {@code JsonObject} updates are visible to view and vice versa\r\n */\r\n@Test\r\npublic void testViewUpdates() {\r\n    JsonObject o \u003d new JsonObject();\r\n    Map\u003cString, JsonElement\u003e map \u003d o.asMap();\r\n    o.addProperty(\"a\", 1);\r\n    assertThat(map).hasSize(1);\r\n    assertThat(map.get(\"a\")).isEqualTo(new JsonPrimitive(1));\r\n    map.put(\"b\", new JsonPrimitive(2));\r\n    assertThat(o.size()).isEqualTo(2);\r\n    assertThat(map.get(\"b\")).isEqualTo(new JsonPrimitive(2));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectAsMapTest",
      "methodName": "testViewUpdates",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAddingAndRemovingObjectProperties() {\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    String propertyName \u003d \"property\";\r\n    assertThat(jsonObj.has(propertyName)).isFalse();\r\n    assertThat(jsonObj.get(propertyName)).isNull();\r\n    JsonPrimitive value \u003d new JsonPrimitive(\"blah\");\r\n    jsonObj.add(propertyName, value);\r\n    assertThat(jsonObj.get(propertyName)).isEqualTo(value);\r\n    JsonElement removedElement \u003d jsonObj.remove(propertyName);\r\n    assertThat(removedElement).isEqualTo(value);\r\n    assertThat(jsonObj.has(propertyName)).isFalse();\r\n    assertThat(jsonObj.get(propertyName)).isNull();\r\n    assertThat(jsonObj.remove(propertyName)).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testAddingAndRemovingObjectProperties",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAddingNullPropertyValue() {\r\n    String propertyName \u003d \"property\";\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.add(propertyName, null);\r\n    assertThat(jsonObj.has(propertyName)).isTrue();\r\n    JsonElement jsonElement \u003d jsonObj.get(propertyName);\r\n    assertThat(jsonElement).isNotNull();\r\n    assertThat(jsonElement.isJsonNull()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testAddingNullPropertyValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAddingNullOrEmptyPropertyName() {\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    try {\r\n        jsonObj.add(null, JsonNull.INSTANCE);\r\n        fail(\"Should not allow null property names.\");\r\n    } catch (NullPointerException expected) {\r\n    }\r\n    jsonObj.add(\"\", JsonNull.INSTANCE);\r\n    jsonObj.add(\"   \\t\", JsonNull.INSTANCE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testAddingNullOrEmptyPropertyName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAddingBooleanProperties() {\r\n    String propertyName \u003d \"property\";\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.addProperty(propertyName, true);\r\n    assertThat(jsonObj.has(propertyName)).isTrue();\r\n    JsonElement jsonElement \u003d jsonObj.get(propertyName);\r\n    assertThat(jsonElement).isNotNull();\r\n    assertThat(jsonElement.getAsBoolean()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testAddingBooleanProperties",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAddingStringProperties() {\r\n    String propertyName \u003d \"property\";\r\n    String value \u003d \"blah\";\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.addProperty(propertyName, value);\r\n    assertThat(jsonObj.has(propertyName)).isTrue();\r\n    JsonElement jsonElement \u003d jsonObj.get(propertyName);\r\n    assertThat(jsonElement).isNotNull();\r\n    assertThat(jsonElement.getAsString()).isEqualTo(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testAddingStringProperties",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAddingCharacterProperties() {\r\n    String propertyName \u003d \"property\";\r\n    char value \u003d \u0027a\u0027;\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.addProperty(propertyName, value);\r\n    assertThat(jsonObj.has(propertyName)).isTrue();\r\n    JsonElement jsonElement \u003d jsonObj.get(propertyName);\r\n    assertThat(jsonElement).isNotNull();\r\n    assertThat(jsonElement.getAsString()).isEqualTo(String.valueOf(value));\r\n    @SuppressWarnings(\"deprecation\")\r\n    char character \u003d jsonElement.getAsCharacter();\r\n    assertThat(character).isEqualTo(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testAddingCharacterProperties",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * From bug report http://code.google.com/p/google-gson/issues/detail?id\u003d182\r\n */\r\n@Test\r\npublic void testPropertyWithQuotes() {\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.add(\"a\\\"b\", new JsonPrimitive(\"c\\\"d\"));\r\n    String json \u003d new Gson().toJson(jsonObj);\r\n    assertThat(json).isEqualTo(\"{\\\"a\\\\\\\"b\\\":\\\"c\\\\\\\"d\\\"}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testPropertyWithQuotes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * From issue 227.\r\n */\r\n@Test\r\npublic void testWritePropertyWithEmptyStringName() {\r\n    JsonObject jsonObj \u003d new JsonObject();\r\n    jsonObj.add(\"\", new JsonPrimitive(true));\r\n    assertThat(new Gson().toJson(jsonObj)).isEqualTo(\"{\\\"\\\":true}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testWritePropertyWithEmptyStringName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadPropertyWithEmptyStringName() {\r\n    JsonObject jsonObj \u003d JsonParser.parseString(\"{\\\"\\\":true}\").getAsJsonObject();\r\n    assertThat(jsonObj.get(\"\").getAsBoolean()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testReadPropertyWithEmptyStringName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsOnEmptyObject() {\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonObject(), new JsonObject());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testEqualsOnEmptyObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsNonEmptyObject() {\r\n    JsonObject a \u003d new JsonObject();\r\n    JsonObject b \u003d new JsonObject();\r\n    new EqualsTester().addEqualityGroup(a).testEquals();\r\n    a.add(\"foo\", new JsonObject());\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n    b.add(\"foo\", new JsonObject());\r\n    MoreAsserts.assertEqualsAndHashCode(a, b);\r\n    a.add(\"bar\", new JsonObject());\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n    b.add(\"bar\", JsonNull.INSTANCE);\r\n    assertThat(a.equals(b)).isFalse();\r\n    assertThat(b.equals(a)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testEqualsNonEmptyObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsHashCodeIgnoringOrder() {\r\n    JsonObject a \u003d new JsonObject();\r\n    JsonObject b \u003d new JsonObject();\r\n    a.addProperty(\"1\", true);\r\n    b.addProperty(\"2\", false);\r\n    a.addProperty(\"2\", false);\r\n    b.addProperty(\"1\", true);\r\n    assertThat(new ArrayList\u003c\u003e(a.keySet())).containsExactly(\"1\", \"2\").inOrder();\r\n    assertThat(new ArrayList\u003c\u003e(b.keySet())).containsExactly(\"2\", \"1\").inOrder();\r\n    MoreAsserts.assertEqualsAndHashCode(a, b);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testEqualsHashCodeIgnoringOrder",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSize() {\r\n    JsonObject o \u003d new JsonObject();\r\n    assertThat(o.size()).isEqualTo(0);\r\n    o.add(\"Hello\", new JsonPrimitive(1));\r\n    assertThat(o.size()).isEqualTo(1);\r\n    o.add(\"Hi\", new JsonPrimitive(1));\r\n    assertThat(o.size()).isEqualTo(2);\r\n    o.remove(\"Hello\");\r\n    assertThat(o.size()).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testSize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIsEmpty() {\r\n    JsonObject o \u003d new JsonObject();\r\n    assertThat(o.isEmpty()).isTrue();\r\n    o.add(\"Hello\", new JsonPrimitive(1));\r\n    assertThat(o.isEmpty()).isFalse();\r\n    o.remove(\"Hello\");\r\n    assertThat(o.isEmpty()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testIsEmpty",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeepCopy() {\r\n    JsonObject original \u003d new JsonObject();\r\n    JsonArray firstEntry \u003d new JsonArray();\r\n    original.add(\"key\", firstEntry);\r\n    JsonObject copy \u003d original.deepCopy();\r\n    firstEntry.add(new JsonPrimitive(\"z\"));\r\n    assertThat(original.get(\"key\").getAsJsonArray()).hasSize(1);\r\n    assertThat(copy.get(\"key\").getAsJsonArray()).hasSize(0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testDeepCopy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * From issue 941\r\n */\r\n@Test\r\npublic void testKeySet() {\r\n    JsonObject a \u003d new JsonObject();\r\n    assertThat(a.keySet()).hasSize(0);\r\n    a.add(\"foo\", new JsonArray());\r\n    a.add(\"bar\", new JsonObject());\r\n    assertThat(a.size()).isEqualTo(2);\r\n    assertThat(a.keySet()).hasSize(2);\r\n    assertThat(a.keySet()).containsExactly(\"foo\", \"bar\").inOrder();\r\n    a.addProperty(\"1\", true);\r\n    a.addProperty(\"2\", false);\r\n    // Insertion order should be preserved by keySet()\r\n    Deque\u003cString\u003e expectedKeys \u003d new ArrayDeque\u003c\u003e(Arrays.asList(\"foo\", \"bar\", \"1\", \"2\"));\r\n    // Note: Must wrap in ArrayList because Deque implementations do not implement `equals`\r\n    assertThat(new ArrayList\u003c\u003e(a.keySet())).isEqualTo(new ArrayList\u003c\u003e(expectedKeys));\r\n    Iterator\u003cString\u003e iterator \u003d a.keySet().iterator();\r\n    // Remove keys one by one\r\n    for (int i \u003d a.size(); i \u003e\u003d 1; i--) {\r\n        assertThat(iterator.hasNext()).isTrue();\r\n        assertThat(iterator.next()).isEqualTo(expectedKeys.getFirst());\r\n        iterator.remove();\r\n        expectedKeys.removeFirst();\r\n        assertThat(a.size()).isEqualTo(i - 1);\r\n        assertThat(new ArrayList\u003c\u003e(a.keySet())).isEqualTo(new ArrayList\u003c\u003e(expectedKeys));\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testKeySet",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEntrySet() {\r\n    JsonObject o \u003d new JsonObject();\r\n    assertThat(o.entrySet()).hasSize(0);\r\n    o.addProperty(\"b\", true);\r\n    Set\u003c?\u003e expectedEntries \u003d Collections.singleton(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(true)));\r\n    assertThat(o.entrySet()).isEqualTo(expectedEntries);\r\n    assertThat(o.entrySet()).hasSize(1);\r\n    o.addProperty(\"a\", false);\r\n    // Insertion order should be preserved by entrySet()\r\n    List\u003c?\u003e expectedEntriesList \u003d Arrays.asList(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(true)), new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(false)));\r\n    assertThat(new ArrayList\u003c\u003e(o.entrySet())).isEqualTo(expectedEntriesList);\r\n    Iterator\u003cEntry\u003cString, JsonElement\u003e\u003e iterator \u003d o.entrySet().iterator();\r\n    // Test behavior of Entry.setValue\r\n    for (int i \u003d 0; i \u003c o.size(); i++) {\r\n        Entry\u003cString, JsonElement\u003e entry \u003d iterator.next();\r\n        entry.setValue(new JsonPrimitive(i));\r\n        assertThat(entry.getValue()).isEqualTo(new JsonPrimitive(i));\r\n    }\r\n    expectedEntriesList \u003d Arrays.asList(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(0)), new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(1)));\r\n    assertThat(new ArrayList\u003c\u003e(o.entrySet())).isEqualTo(expectedEntriesList);\r\n    Entry\u003cString, JsonElement\u003e entry \u003d o.entrySet().iterator().next();\r\n    try {\r\n        // null value is not permitted, only JsonNull is supported\r\n        // This intentionally deviates from the behavior of the other JsonObject methods which\r\n        // implicitly convert null -\u003e JsonNull, to match more closely the contract of Map.Entry\r\n        entry.setValue(null);\r\n        fail();\r\n    } catch (NullPointerException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"value \u003d\u003d null\");\r\n    }\r\n    assertThat(entry.getValue()).isNotNull();\r\n    o.addProperty(\"key1\", 1);\r\n    o.addProperty(\"key2\", 2);\r\n    Deque\u003c?\u003e expectedEntriesQueue \u003d new ArrayDeque\u003c\u003e(Arrays.asList(new SimpleEntry\u003c\u003e(\"b\", new JsonPrimitive(0)), new SimpleEntry\u003c\u003e(\"a\", new JsonPrimitive(1)), new SimpleEntry\u003c\u003e(\"key1\", new JsonPrimitive(1)), new SimpleEntry\u003c\u003e(\"key2\", new JsonPrimitive(2))));\r\n    // Note: Must wrap in ArrayList because Deque implementations do not implement `equals`\r\n    assertThat(new ArrayList\u003c\u003e(o.entrySet())).isEqualTo(new ArrayList\u003c\u003e(expectedEntriesQueue));\r\n    iterator \u003d o.entrySet().iterator();\r\n    // Remove entries one by one\r\n    for (int i \u003d o.size(); i \u003e\u003d 1; i--) {\r\n        assertThat(iterator.hasNext()).isTrue();\r\n        assertThat(iterator.next()).isEqualTo(expectedEntriesQueue.getFirst());\r\n        iterator.remove();\r\n        expectedEntriesQueue.removeFirst();\r\n        assertThat(o.size()).isEqualTo(i - 1);\r\n        assertThat(new ArrayList\u003c\u003e(o.entrySet())).isEqualTo(new ArrayList\u003c\u003e(expectedEntriesQueue));\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonObjectTest",
      "methodName": "testEntrySet",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Parameters\r\npublic static Iterable\u003cString\u003e data() {\r\n    return Arrays.asList(\"[]\", \"{}\", \"null\", \"1.0\", \"true\", \"\\\"string\\\"\", \"[true,1.0,null,{},2.0,{\\\"a\\\":[false]},[3.0,\\\"test\\\"],4.0]\", \"{\\\"\\\":1.0,\\\"a\\\":true,\\\"b\\\":null,\\\"c\\\":[],\\\"d\\\":{\\\"a1\\\":2.0,\\\"b2\\\":[true,{\\\"a3\\\":3.0}]},\\\"e\\\":[{\\\"f\\\":4.0},\\\"test\\\"]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserParameterizedTest",
      "methodName": "data",
      "parameterTypes": [],
      "returnType": "Iterable\u003cString\u003e"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParse() {\r\n    JsonElement deserialized \u003d JsonParser.parseString(json);\r\n    String actualSerialized \u003d adapter.toJson(deserialized);\r\n    // Serialized JsonElement should be the same as original JSON\r\n    assertThat(actualSerialized).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserParameterizedTest",
      "methodName": "testParse",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseInvalidJson() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e JsonParser.parseString(\"[[]\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseInvalidJson",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseUnquotedStringArrayFails() {\r\n    JsonElement element \u003d JsonParser.parseString(\"[a,b,c]\");\r\n    assertThat(element.getAsJsonArray().get(0).getAsString()).isEqualTo(\"a\");\r\n    assertThat(element.getAsJsonArray().get(1).getAsString()).isEqualTo(\"b\");\r\n    assertThat(element.getAsJsonArray().get(2).getAsString()).isEqualTo(\"c\");\r\n    assertThat(element.getAsJsonArray()).hasSize(3);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseUnquotedStringArrayFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseString() {\r\n    String json \u003d \"{a:10,b:\u0027c\u0027}\";\r\n    JsonElement e \u003d JsonParser.parseString(json);\r\n    assertThat(e.isJsonObject()).isTrue();\r\n    assertThat(e.getAsJsonObject().get(\"a\").getAsInt()).isEqualTo(10);\r\n    assertThat(e.getAsJsonObject().get(\"b\").getAsString()).isEqualTo(\"c\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseEmptyString() {\r\n    JsonElement e \u003d JsonParser.parseString(\"\\\"   \\\"\");\r\n    assertThat(e.isJsonPrimitive()).isTrue();\r\n    assertThat(e.getAsString()).isEqualTo(\"   \");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseEmptyString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseEmptyWhitespaceInput() {\r\n    JsonElement e \u003d JsonParser.parseString(\"     \");\r\n    assertThat(e.isJsonNull()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseEmptyWhitespaceInput",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseUnquotedSingleWordStringFails() {\r\n    assertThat(JsonParser.parseString(\"Test\").getAsString()).isEqualTo(\"Test\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseUnquotedSingleWordStringFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseUnquotedMultiWordStringFails() {\r\n    assertThrows(JsonSyntaxException.class, () -\u003e JsonParser.parseString(\"Test is a test..blah blah\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseUnquotedMultiWordStringFails",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseMixedArray() {\r\n    String json \u003d \"[{},13,\\\"stringValue\\\"]\";\r\n    JsonElement e \u003d JsonParser.parseString(json);\r\n    assertThat(e.isJsonArray()).isTrue();\r\n    JsonArray array \u003d e.getAsJsonArray();\r\n    assertThat(array.get(0).toString()).isEqualTo(\"{}\");\r\n    assertThat(array.get(1).getAsInt()).isEqualTo(13);\r\n    assertThat(array.get(2).getAsString()).isEqualTo(\"stringValue\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseMixedArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static String repeat(String s, int times) {\r\n    StringBuilder stringBuilder \u003d new StringBuilder(s.length() * times);\r\n    for (int i \u003d 0; i \u003c times; i++) {\r\n        stringBuilder.append(s);\r\n    }\r\n    return stringBuilder.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "repeat",
      "parameterTypes": [
        "String",
        "int"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Deeply nested JSON arrays should not cause {@link StackOverflowError}\r\n */\r\n@Test\r\npublic void testParseDeeplyNestedArrays() throws IOException {\r\n    int times \u003d 10000;\r\n    // [[[ ... ]]]\r\n    String json \u003d repeat(\"[\", times) + repeat(\"]\", times);\r\n    int actualTimes \u003d 0;\r\n    JsonArray current \u003d JsonParser.parseString(json).getAsJsonArray();\r\n    while (true) {\r\n        actualTimes++;\r\n        if (current.isEmpty()) {\r\n            break;\r\n        }\r\n        assertThat(current.size()).isEqualTo(1);\r\n        current \u003d current.get(0).getAsJsonArray();\r\n    }\r\n    assertThat(actualTimes).isEqualTo(times);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseDeeplyNestedArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Deeply nested JSON objects should not cause {@link StackOverflowError}\r\n */\r\n@Test\r\npublic void testParseDeeplyNestedObjects() throws IOException {\r\n    int times \u003d 10000;\r\n    // {\"a\":{\"a\": ... {\"a\":null} ... }}\r\n    String json \u003d repeat(\"{\\\"a\\\":\", times) + \"null\" + repeat(\"}\", times);\r\n    int actualTimes \u003d 0;\r\n    JsonObject current \u003d JsonParser.parseString(json).getAsJsonObject();\r\n    while (true) {\r\n        assertThat(current.size()).isEqualTo(1);\r\n        actualTimes++;\r\n        JsonElement next \u003d current.get(\"a\");\r\n        if (next.isJsonNull()) {\r\n            break;\r\n        } else {\r\n            current \u003d next.getAsJsonObject();\r\n        }\r\n    }\r\n    assertThat(actualTimes).isEqualTo(times);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseDeeplyNestedObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseReader() {\r\n    StringReader reader \u003d new StringReader(\"{a:10,b:\u0027c\u0027}\");\r\n    JsonElement e \u003d JsonParser.parseReader(reader);\r\n    assertThat(e.isJsonObject()).isTrue();\r\n    assertThat(e.getAsJsonObject().get(\"a\").getAsInt()).isEqualTo(10);\r\n    assertThat(e.getAsJsonObject().get(\"b\").getAsString()).isEqualTo(\"c\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testParseReader",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadWriteTwoObjects() throws Exception {\r\n    Gson gson \u003d new Gson();\r\n    CharArrayWriter writer \u003d new CharArrayWriter();\r\n    BagOfPrimitives expectedOne \u003d new BagOfPrimitives(1, 1, true, \"one\");\r\n    writer.write(gson.toJson(expectedOne).toCharArray());\r\n    BagOfPrimitives expectedTwo \u003d new BagOfPrimitives(2, 2, false, \"two\");\r\n    writer.write(gson.toJson(expectedTwo).toCharArray());\r\n    CharArrayReader reader \u003d new CharArrayReader(writer.toCharArray());\r\n    JsonReader parser \u003d new JsonReader(reader);\r\n    parser.setStrictness(Strictness.LENIENT);\r\n    JsonElement element1 \u003d Streams.parse(parser);\r\n    JsonElement element2 \u003d Streams.parse(parser);\r\n    BagOfPrimitives actualOne \u003d gson.fromJson(element1, BagOfPrimitives.class);\r\n    assertThat(actualOne.stringValue).isEqualTo(\"one\");\r\n    BagOfPrimitives actualTwo \u003d gson.fromJson(element2, BagOfPrimitives.class);\r\n    assertThat(actualTwo.stringValue).isEqualTo(\"two\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testReadWriteTwoObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrict() {\r\n    JsonReader reader \u003d new JsonReader(new StringReader(\"faLsE\"));\r\n    Strictness strictness \u003d Strictness.STRICT;\r\n    // Strictness is ignored by JsonParser later; always parses in lenient mode\r\n    reader.setStrictness(strictness);\r\n    assertThat(JsonParser.parseReader(reader)).isEqualTo(new JsonPrimitive(false));\r\n    // Original strictness was restored\r\n    assertThat(reader.getStrictness()).isEqualTo(strictness);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonParserTest",
      "methodName": "testStrict",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unused\")\r\n@Test\r\npublic void testNulls() {\r\n    try {\r\n        new JsonPrimitive((Boolean) null);\r\n        fail();\r\n    } catch (NullPointerException ignored) {\r\n    }\r\n    try {\r\n        new JsonPrimitive((Number) null);\r\n        fail();\r\n    } catch (NullPointerException ignored) {\r\n    }\r\n    try {\r\n        new JsonPrimitive((String) null);\r\n        fail();\r\n    } catch (NullPointerException ignored) {\r\n    }\r\n    try {\r\n        new JsonPrimitive((Character) null);\r\n        fail();\r\n    } catch (NullPointerException ignored) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBoolean() {\r\n    JsonPrimitive json \u003d new JsonPrimitive(Boolean.TRUE);\r\n    assertThat(json.isBoolean()).isTrue();\r\n    assertThat(json.getAsBoolean()).isTrue();\r\n    // Extra support for booleans\r\n    json \u003d new JsonPrimitive(1);\r\n    assertThat(json.getAsBoolean()).isFalse();\r\n    json \u003d new JsonPrimitive(\"1\");\r\n    assertThat(json.getAsBoolean()).isFalse();\r\n    json \u003d new JsonPrimitive(\"true\");\r\n    assertThat(json.getAsBoolean()).isTrue();\r\n    json \u003d new JsonPrimitive(\"TrUe\");\r\n    assertThat(json.getAsBoolean()).isTrue();\r\n    json \u003d new JsonPrimitive(\"1.3\");\r\n    assertThat(json.getAsBoolean()).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testBoolean",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParsingStringAsBoolean() {\r\n    JsonPrimitive json \u003d new JsonPrimitive(\"true\");\r\n    assertThat(json.isBoolean()).isFalse();\r\n    assertThat(json.getAsBoolean()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testParsingStringAsBoolean",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParsingStringAsNumber() {\r\n    JsonPrimitive json \u003d new JsonPrimitive(\"1\");\r\n    assertThat(json.isNumber()).isFalse();\r\n    assertThat(json.getAsDouble()).isEqualTo(1.0);\r\n    assertThat(json.getAsFloat()).isEqualTo(1F);\r\n    assertThat(json.getAsInt()).isEqualTo(1);\r\n    assertThat(json.getAsLong()).isEqualTo(1L);\r\n    assertThat(json.getAsShort()).isEqualTo((short) 1);\r\n    assertThat(json.getAsByte()).isEqualTo((byte) 1);\r\n    assertThat(json.getAsBigInteger()).isEqualTo(new BigInteger(\"1\"));\r\n    assertThat(json.getAsBigDecimal()).isEqualTo(new BigDecimal(\"1\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testParsingStringAsNumber",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testAsNumber_Boolean() {\r\n    JsonPrimitive json \u003d new JsonPrimitive(true);\r\n    try {\r\n        json.getAsNumber();\r\n        fail();\r\n    } catch (UnsupportedOperationException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Primitive is neither a number nor a string\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testAsNumber_Boolean",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testStringsAndChar() {\r\n    JsonPrimitive json \u003d new JsonPrimitive(\"abc\");\r\n    assertThat(json.isString()).isTrue();\r\n    assertThat(json.getAsCharacter()).isEqualTo(\u0027a\u0027);\r\n    assertThat(json.getAsString()).isEqualTo(\"abc\");\r\n    json \u003d new JsonPrimitive(\u0027z\u0027);\r\n    assertThat(json.isString()).isTrue();\r\n    assertThat(json.getAsCharacter()).isEqualTo(\u0027z\u0027);\r\n    assertThat(json.getAsString()).isEqualTo(\"z\");\r\n    json \u003d new JsonPrimitive(true);\r\n    assertThat(json.getAsString()).isEqualTo(\"true\");\r\n    json \u003d new JsonPrimitive(\"\");\r\n    assertThat(json.getAsString()).isEqualTo(\"\");\r\n    try {\r\n        json.getAsCharacter();\r\n        fail();\r\n    } catch (UnsupportedOperationException e) {\r\n        assertThat(e).hasMessageThat().isEqualTo(\"String value is empty\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testStringsAndChar",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testExponential() {\r\n    JsonPrimitive json \u003d new JsonPrimitive(\"1E+7\");\r\n    assertThat(json.getAsBigDecimal()).isEqualTo(new BigDecimal(\"1E+7\"));\r\n    assertThat(json.getAsDouble()).isEqualTo(1E+7);\r\n    try {\r\n        json.getAsInt();\r\n        fail(\"Integers can not handle exponents like this.\");\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testExponential",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testByteEqualsShort() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((byte) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive((short) 10);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testByteEqualsShort",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testByteEqualsInteger() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((byte) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testByteEqualsInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testByteEqualsLong() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((byte) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10L);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testByteEqualsLong",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testByteEqualsBigInteger() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((byte) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigInteger(\"10\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testByteEqualsBigInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testShortEqualsInteger() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((short) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testShortEqualsInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testShortEqualsLong() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((short) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10L);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testShortEqualsLong",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testShortEqualsBigInteger() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive((short) 10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigInteger(\"10\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testShortEqualsBigInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIntegerEqualsLong() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10L);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testIntegerEqualsLong",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIntegerEqualsBigInteger() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigInteger(\"10\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testIntegerEqualsBigInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLongEqualsBigInteger() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10L);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigInteger(\"10\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testLongEqualsBigInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFloatEqualsDouble() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10.25F);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(10.25D);\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testFloatEqualsDouble",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFloatEqualsBigDecimal() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10.25F);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigDecimal(\"10.25\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testFloatEqualsBigDecimal",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubleEqualsBigDecimal() {\r\n    JsonPrimitive p1 \u003d new JsonPrimitive(10.25D);\r\n    JsonPrimitive p2 \u003d new JsonPrimitive(new BigDecimal(\"10.25\"));\r\n    assertThat(p1).isEqualTo(p2);\r\n    assertThat(p1.hashCode()).isEqualTo(p2.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testDoubleEqualsBigDecimal",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testValidJsonOnToString() {\r\n    JsonPrimitive json \u003d new JsonPrimitive(\"Some\\nEscaped\\nValue\");\r\n    assertThat(json.toString()).isEqualTo(\"\\\"Some\\\\nEscaped\\\\nValue\\\"\");\r\n    json \u003d new JsonPrimitive(new BigDecimal(\"1.333\"));\r\n    assertThat(json.toString()).isEqualTo(\"1.333\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testValidJsonOnToString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEquals() {\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(\"A\"), new JsonPrimitive(\"A\"));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(true), new JsonPrimitive(true));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(5L), new JsonPrimitive(5L));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(\u0027a\u0027), new JsonPrimitive(\u0027a\u0027));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.NaN), new JsonPrimitive(Float.NaN));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.NEGATIVE_INFINITY), new JsonPrimitive(Float.NEGATIVE_INFINITY));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.POSITIVE_INFINITY), new JsonPrimitive(Float.POSITIVE_INFINITY));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Double.NaN), new JsonPrimitive(Double.NaN));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Double.NEGATIVE_INFINITY), new JsonPrimitive(Double.NEGATIVE_INFINITY));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Double.POSITIVE_INFINITY), new JsonPrimitive(Double.POSITIVE_INFINITY));\r\n    assertThat(new JsonPrimitive(\"a\").equals(new JsonPrimitive(\"b\"))).isFalse();\r\n    assertThat(new JsonPrimitive(true).equals(new JsonPrimitive(false))).isFalse();\r\n    assertThat(new JsonPrimitive(0).equals(new JsonPrimitive(1))).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testEquals",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsAcrossTypes() {\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(\"a\"), new JsonPrimitive(\u0027a\u0027));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(new BigInteger(\"0\")), new JsonPrimitive(0));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(0), new JsonPrimitive(0L));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(new BigInteger(\"0\")), new JsonPrimitive(0));\r\n    MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(Float.NaN), new JsonPrimitive(Double.NaN));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testEqualsAcrossTypes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsIntegerAndBigInteger() {\r\n    JsonPrimitive a \u003d new JsonPrimitive(5L);\r\n    JsonPrimitive b \u003d new JsonPrimitive(new BigInteger(\"18446744073709551621\"));\r\n    assertWithMessage(\"%s not equals %s\", a, b).that(a.equals(b)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testEqualsIntegerAndBigInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEqualsDoesNotEquateStringAndNonStringTypes() {\r\n    assertThat(new JsonPrimitive(\"true\").equals(new JsonPrimitive(true))).isFalse();\r\n    assertThat(new JsonPrimitive(\"0\").equals(new JsonPrimitive(0))).isFalse();\r\n    assertThat(new JsonPrimitive(\"NaN\").equals(new JsonPrimitive(Float.NaN))).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testEqualsDoesNotEquateStringAndNonStringTypes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeepCopy() {\r\n    JsonPrimitive a \u003d new JsonPrimitive(\"a\");\r\n    // Primitives are immutable!\r\n    assertThat(a).isSameInstanceAs(a.deepCopy());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonPrimitiveTest",
      "methodName": "testDeepCopy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    parser \u003d new JsonStreamParser(\"\u0027one\u0027 \u0027two\u0027\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParserTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParseTwoStrings() {\r\n    String actualOne \u003d parser.next().getAsString();\r\n    assertThat(actualOne).isEqualTo(\"one\");\r\n    String actualTwo \u003d parser.next().getAsString();\r\n    assertThat(actualTwo).isEqualTo(\"two\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParserTest",
      "methodName": "testParseTwoStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIterator() {\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.next().getAsString()).isEqualTo(\"one\");\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.next().getAsString()).isEqualTo(\"two\");\r\n    assertThat(parser.hasNext()).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParserTest",
      "methodName": "testIterator",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNoSideEffectForHasNext() {\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.next().getAsString()).isEqualTo(\"one\");\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThat(parser.next().getAsString()).isEqualTo(\"two\");\r\n    assertThat(parser.hasNext()).isFalse();\r\n    assertThat(parser.hasNext()).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParserTest",
      "methodName": "testNoSideEffectForHasNext",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCallingNextBeyondAvailableInput() {\r\n    JsonElement unused1 \u003d parser.next();\r\n    JsonElement unused2 \u003d parser.next();\r\n    // Parser should not go beyond available input\r\n    assertThrows(NoSuchElementException.class, parser::next);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParserTest",
      "methodName": "testCallingNextBeyondAvailableInput",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyInput() {\r\n    JsonStreamParser parser \u003d new JsonStreamParser(\"\");\r\n    JsonIOException e \u003d assertThrows(JsonIOException.class, parser::next);\r\n    assertThat(e).hasCauseThat().isInstanceOf(EOFException.class);\r\n    parser \u003d new JsonStreamParser(\"\");\r\n    e \u003d assertThrows(JsonIOException.class, parser::hasNext);\r\n    assertThat(e).hasCauseThat().isInstanceOf(EOFException.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParserTest",
      "methodName": "testEmptyInput",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIncompleteInput() {\r\n    JsonStreamParser parser \u003d new JsonStreamParser(\"[\");\r\n    assertThat(parser.hasNext()).isTrue();\r\n    assertThrows(JsonSyntaxException.class, parser::next);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParserTest",
      "methodName": "testIncompleteInput",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMalformedInput() {\r\n    JsonStreamParser parser \u003d new JsonStreamParser(\":\");\r\n    assertThrows(JsonSyntaxException.class, parser::hasNext);\r\n    parser \u003d new JsonStreamParser(\":\");\r\n    assertThrows(JsonSyntaxException.class, parser::next);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.JsonStreamParserTest",
      "methodName": "testMalformedInput",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultLongSerialization() throws Exception {\r\n    JsonElement element \u003d LongSerializationPolicy.DEFAULT.serialize(1556L);\r\n    assertThat(element.isJsonPrimitive()).isTrue();\r\n    JsonPrimitive jsonPrimitive \u003d element.getAsJsonPrimitive();\r\n    assertThat(jsonPrimitive.isString()).isFalse();\r\n    assertThat(jsonPrimitive.isNumber()).isTrue();\r\n    assertThat(element.getAsLong()).isEqualTo(1556L);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.LongSerializationPolicyTest",
      "methodName": "testDefaultLongSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultLongSerializationIntegration() {\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.DEFAULT).create();\r\n    assertThat(gson.toJson(new long[] { 1L }, long[].class)).isEqualTo(\"[1]\");\r\n    assertThat(gson.toJson(new Long[] { 1L }, Long[].class)).isEqualTo(\"[1]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.LongSerializationPolicyTest",
      "methodName": "testDefaultLongSerializationIntegration",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultLongSerializationNull() {\r\n    LongSerializationPolicy policy \u003d LongSerializationPolicy.DEFAULT;\r\n    assertThat(policy.serialize(null).isJsonNull()).isTrue();\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(policy).create();\r\n    assertThat(gson.toJson(null, Long.class)).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.LongSerializationPolicyTest",
      "methodName": "testDefaultLongSerializationNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringLongSerialization() throws Exception {\r\n    JsonElement element \u003d LongSerializationPolicy.STRING.serialize(1556L);\r\n    assertThat(element.isJsonPrimitive()).isTrue();\r\n    JsonPrimitive jsonPrimitive \u003d element.getAsJsonPrimitive();\r\n    assertThat(jsonPrimitive.isNumber()).isFalse();\r\n    assertThat(jsonPrimitive.isString()).isTrue();\r\n    assertThat(element.getAsString()).isEqualTo(\"1556\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.LongSerializationPolicyTest",
      "methodName": "testStringLongSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringLongSerializationIntegration() {\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\r\n    assertThat(gson.toJson(new long[] { 1L }, long[].class)).isEqualTo(\"[\\\"1\\\"]\");\r\n    assertThat(gson.toJson(new Long[] { 1L }, long[].class)).isEqualTo(\"[\\\"1\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.LongSerializationPolicyTest",
      "methodName": "testStringLongSerializationIntegration",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringLongSerializationNull() {\r\n    LongSerializationPolicy policy \u003d LongSerializationPolicy.STRING;\r\n    assertThat(policy.serialize(null).isJsonNull()).isTrue();\r\n    Gson gson \u003d new GsonBuilder().setLongSerializationPolicy(policy).create();\r\n    assertThat(gson.toJson(null, Long.class)).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.LongSerializationPolicyTest",
      "methodName": "testStringLongSerializationNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new Gson();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDummy() {\r\n    // This is here to prevent Junit for complaining when we disable all tests.\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testDummy",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@Ignore\r\npublic void testStringDeserialization() {\r\n    StringBuilder sb \u003d new StringBuilder(8096);\r\n    sb.append(\"Error Yippie\");\r\n    while (true) {\r\n        try {\r\n            String stackTrace \u003d sb.toString();\r\n            sb.append(stackTrace);\r\n            String json \u003d \"{\\\"message\\\":\\\"Error message.\\\",\" + \"\\\"stackTrace\\\":\\\"\" + stackTrace + \"\\\"}\";\r\n            parseLongJson(json);\r\n            System.out.println(\"Gson could handle a string of size: \" + stackTrace.length());\r\n        } catch (JsonParseException expected) {\r\n            break;\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testStringDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void parseLongJson(String json) throws JsonParseException {\r\n    ExceptionHolder target \u003d gson.fromJson(json, ExceptionHolder.class);\r\n    assertThat(target.message).contains(\"Error\");\r\n    assertThat(target.stackTrace).contains(\"Yippie\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "parseLongJson",
      "parameterTypes": [
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to http://code.google.com/p/google-gson/issues/detail?id\u003d96\r\n */\r\n@Test\r\n@Ignore\r\npublic void testLargeCollectionSerialization() {\r\n    int count \u003d 1400000;\r\n    List\u003cCollectionEntry\u003e list \u003d new ArrayList\u003c\u003e(count);\r\n    for (int i \u003d 0; i \u003c count; ++i) {\r\n        list.add(new CollectionEntry(\"name\" + i, \"value\" + i));\r\n    }\r\n    String unused \u003d gson.toJson(list);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testLargeCollectionSerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to http://code.google.com/p/google-gson/issues/detail?id\u003d96\r\n */\r\n@Test\r\n@Ignore\r\npublic void testLargeCollectionDeserialization() {\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    int count \u003d 87000;\r\n    boolean first \u003d true;\r\n    sb.append(\u0027[\u0027);\r\n    for (int i \u003d 0; i \u003c count; ++i) {\r\n        if (first) {\r\n            first \u003d false;\r\n        } else {\r\n            sb.append(\u0027,\u0027);\r\n        }\r\n        sb.append(\"{name:\u0027name\").append(i).append(\"\u0027,value:\u0027value\").append(i).append(\"\u0027}\");\r\n    }\r\n    sb.append(\u0027]\u0027);\r\n    String json \u003d sb.toString();\r\n    Type collectionType \u003d new TypeToken\u003cArrayList\u003cCollectionEntry\u003e\u003e() {\r\n    }.getType();\r\n    List\u003cCollectionEntry\u003e list \u003d gson.fromJson(json, collectionType);\r\n    assertThat(list).hasSize(count);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testLargeCollectionDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to http://code.google.com/p/google-gson/issues/detail?id\u003d96\r\n */\r\n// Last I tested, Gson was able to serialize upto 14MB byte array\r\n@Test\r\n@Ignore\r\npublic void testByteArraySerialization() {\r\n    for (int size \u003d 4145152; true; size +\u003d 1036288) {\r\n        byte[] ba \u003d new byte[size];\r\n        for (int i \u003d 0; i \u003c size; ++i) {\r\n            ba[i] \u003d 0x05;\r\n        }\r\n        String unused \u003d gson.toJson(ba);\r\n        System.out.printf(\"Gson could serialize a byte array of size: %d\\n\", size);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testByteArraySerialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Created in response to http://code.google.com/p/google-gson/issues/detail?id\u003d96\r\n */\r\n// Last I tested, Gson was able to deserialize a byte array of 11MB\r\n@Test\r\n@Ignore\r\npublic void testByteArrayDeserialization() {\r\n    for (int numElements \u003d 10639296; true; numElements +\u003d 16384) {\r\n        StringBuilder sb \u003d new StringBuilder(numElements * 2);\r\n        sb.append(\"[\");\r\n        boolean first \u003d true;\r\n        for (int i \u003d 0; i \u003c numElements; ++i) {\r\n            if (first) {\r\n                first \u003d false;\r\n            } else {\r\n                sb.append(\",\");\r\n            }\r\n            sb.append(\"5\");\r\n        }\r\n        sb.append(\"]\");\r\n        String json \u003d sb.toString();\r\n        byte[] ba \u003d gson.fromJson(json, byte[].class);\r\n        System.out.printf(\"Gson could deserialize a byte array of size: %d\\n\", ba.length);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testByteArrayDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// The tests to measure serialization and deserialization performance of Gson\r\n// Based on the discussion at\r\n// http://groups.google.com/group/google-gson/browse_thread/thread/7a50b17a390dfaeb\r\n// Test results: 10/19/2009\r\n// Serialize classes avg time: 60 ms\r\n// Deserialized classes avg time: 70 ms\r\n// Serialize exposed classes avg time: 159 ms\r\n// Deserialized exposed classes avg time: 173 ms\r\n@Test\r\n@Ignore\r\npublic void testSerializeClasses() {\r\n    ClassWithList c \u003d new ClassWithList(\"str\");\r\n    for (int i \u003d 0; i \u003c COLLECTION_SIZE; ++i) {\r\n        c.list.add(new ClassWithField(\"element-\" + i));\r\n    }\r\n    StringWriter w \u003d new StringWriter();\r\n    long t1 \u003d System.currentTimeMillis();\r\n    for (int i \u003d 0; i \u003c NUM_ITERATIONS; ++i) {\r\n        gson.toJson(c, w);\r\n    }\r\n    long t2 \u003d System.currentTimeMillis();\r\n    long avg \u003d (t2 - t1) / NUM_ITERATIONS;\r\n    System.out.printf(\"Serialize classes avg time: %d ms\\n\", avg);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testSerializeClasses",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@Ignore\r\npublic void testDeserializeClasses() {\r\n    String json \u003d buildJsonForClassWithList();\r\n    ClassWithList[] target \u003d new ClassWithList[NUM_ITERATIONS];\r\n    long t1 \u003d System.currentTimeMillis();\r\n    for (int i \u003d 0; i \u003c NUM_ITERATIONS; ++i) {\r\n        target[i] \u003d gson.fromJson(json, ClassWithList.class);\r\n    }\r\n    long t2 \u003d System.currentTimeMillis();\r\n    long avg \u003d (t2 - t1) / NUM_ITERATIONS;\r\n    System.out.printf(\"Deserialize classes avg time: %d ms\\n\", avg);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testDeserializeClasses",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@Ignore\r\npublic void testLargeObjectSerializationAndDeserialization() {\r\n    Map\u003cString, Long\u003e largeObject \u003d new HashMap\u003c\u003e();\r\n    for (long l \u003d 0; l \u003c 100000; l++) {\r\n        largeObject.put(\"field\" + l, l);\r\n    }\r\n    long t1 \u003d System.currentTimeMillis();\r\n    String json \u003d gson.toJson(largeObject);\r\n    long t2 \u003d System.currentTimeMillis();\r\n    System.out.printf(\"Large object serialized in: %d ms\\n\", (t2 - t1));\r\n    t1 \u003d System.currentTimeMillis();\r\n    Map\u003cString, Long\u003e unused \u003d gson.fromJson(json, new TypeToken\u003cMap\u003cString, Long\u003e\u003e() {\r\n    }.getType());\r\n    t2 \u003d System.currentTimeMillis();\r\n    System.out.printf(\"Large object deserialized in: %d ms\\n\", (t2 - t1));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testLargeObjectSerializationAndDeserialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@Ignore\r\npublic void testSerializeExposedClasses() {\r\n    ClassWithListOfObjects c1 \u003d new ClassWithListOfObjects(\"str\");\r\n    for (int i1 \u003d 0; i1 \u003c COLLECTION_SIZE; ++i1) {\r\n        c1.list.add(new ClassWithExposedField(\"element-\" + i1));\r\n    }\r\n    ClassWithListOfObjects c \u003d c1;\r\n    StringWriter w \u003d new StringWriter();\r\n    long t1 \u003d System.currentTimeMillis();\r\n    for (int i \u003d 0; i \u003c NUM_ITERATIONS; ++i) {\r\n        gson.toJson(c, w);\r\n    }\r\n    long t2 \u003d System.currentTimeMillis();\r\n    long avg \u003d (t2 - t1) / NUM_ITERATIONS;\r\n    System.out.printf(\"Serialize exposed classes avg time: %d ms\\n\", avg);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testSerializeExposedClasses",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@Ignore\r\npublic void testDeserializeExposedClasses() {\r\n    String json \u003d buildJsonForClassWithList();\r\n    ClassWithListOfObjects[] target \u003d new ClassWithListOfObjects[NUM_ITERATIONS];\r\n    long t1 \u003d System.currentTimeMillis();\r\n    for (int i \u003d 0; i \u003c NUM_ITERATIONS; ++i) {\r\n        target[i] \u003d gson.fromJson(json, ClassWithListOfObjects.class);\r\n    }\r\n    long t2 \u003d System.currentTimeMillis();\r\n    long avg \u003d (t2 - t1) / NUM_ITERATIONS;\r\n    System.out.printf(\"Deserialize exposed classes avg time: %d ms\\n\", avg);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testDeserializeExposedClasses",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@Ignore\r\npublic void testLargeGsonMapRoundTrip() throws Exception {\r\n    Map\u003cLong, Long\u003e original \u003d new HashMap\u003c\u003e();\r\n    for (long i \u003d 0; i \u003c 1000000; i++) {\r\n        original.put(i, i + 1);\r\n    }\r\n    Gson gson \u003d new Gson();\r\n    String json \u003d gson.toJson(original);\r\n    Type longToLong \u003d new TypeToken\u003cMap\u003cLong, Long\u003e\u003e() {\r\n    }.getType();\r\n    Map\u003cLong, Long\u003e unused \u003d gson.fromJson(json, longToLong);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "testLargeGsonMapRoundTrip",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private String buildJsonForClassWithList() {\r\n    StringBuilder sb \u003d new StringBuilder(\"{\");\r\n    sb.append(\"field:\").append(\"\u0027str\u0027,\");\r\n    sb.append(\"list:[\");\r\n    boolean first \u003d true;\r\n    for (int i \u003d 0; i \u003c COLLECTION_SIZE; ++i) {\r\n        if (first) {\r\n            first \u003d false;\r\n        } else {\r\n            sb.append(\",\");\r\n        }\r\n        sb.append(\"{field:\u0027element-\" + i + \"\u0027}\");\r\n    }\r\n    sb.append(\"]\");\r\n    sb.append(\"}\");\r\n    String json \u003d sb.toString();\r\n    return json;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.PerformanceTest",
      "methodName": "buildJsonForClassWithList",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWriteMixedStreamed() throws IOException {\r\n    Gson gson \u003d new Gson();\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.setIndent(\"  \");\r\n    gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\r\n    gson.toJson(BLACK_BMW, Car.class, jsonWriter);\r\n    gson.toJson(RED_MIATA, Car.class, jsonWriter);\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(CARS_JSON);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testWriteMixedStreamed",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadMixedStreamed() throws IOException {\r\n    Gson gson \u003d new Gson();\r\n    StringReader stringReader \u003d new StringReader(CARS_JSON);\r\n    JsonReader jsonReader \u003d new JsonReader(stringReader);\r\n    jsonReader.beginArray();\r\n    // actual and expected object are inverted in the test.\r\n    // gson.fromJson(jsonReader, Car.class) as arg of assertThat() cause an ambiguous method call\r\n    assertThat(BLUE_MUSTANG).isEqualTo(gson.fromJson(jsonReader, Car.class));\r\n    assertThat(BLACK_BMW).isEqualTo(gson.fromJson(jsonReader, Car.class));\r\n    assertThat(RED_MIATA).isEqualTo(gson.fromJson(jsonReader, Car.class));\r\n    jsonReader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testReadMixedStreamed",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// for JsonReader.setLenient\r\n@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testReaderDoesNotMutateState() throws IOException {\r\n    Gson gson \u003d new Gson();\r\n    JsonReader jsonReader \u003d new JsonReader(new StringReader(CARS_JSON));\r\n    jsonReader.beginArray();\r\n    jsonReader.setLenient(false);\r\n    Car unused1 \u003d gson.fromJson(jsonReader, Car.class);\r\n    assertThat(jsonReader.isLenient()).isFalse();\r\n    jsonReader.setLenient(true);\r\n    Car unused2 \u003d gson.fromJson(jsonReader, Car.class);\r\n    assertThat(jsonReader.isLenient()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testReaderDoesNotMutateState",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// for JsonWriter.setLenient\r\n@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testWriteDoesNotMutateState() throws IOException {\r\n    Gson gson \u003d new Gson();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.beginArray();\r\n    jsonWriter.setHtmlSafe(true);\r\n    jsonWriter.setLenient(true);\r\n    gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\r\n    assertThat(jsonWriter.isHtmlSafe()).isTrue();\r\n    assertThat(jsonWriter.isLenient()).isTrue();\r\n    jsonWriter.setHtmlSafe(false);\r\n    jsonWriter.setLenient(false);\r\n    gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\r\n    assertThat(jsonWriter.isHtmlSafe()).isFalse();\r\n    assertThat(jsonWriter.isLenient()).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testWriteDoesNotMutateState",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadInvalidState() throws IOException {\r\n    Gson gson \u003d new Gson();\r\n    JsonReader jsonReader \u003d new JsonReader(new StringReader(CARS_JSON));\r\n    jsonReader.beginArray();\r\n    jsonReader.beginObject();\r\n    try {\r\n        gson.fromJson(jsonReader, String.class);\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testReadInvalidState",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadClosed() throws IOException {\r\n    Gson gson \u003d new Gson();\r\n    JsonReader jsonReader \u003d new JsonReader(new StringReader(CARS_JSON));\r\n    jsonReader.close();\r\n    try {\r\n        gson.fromJson(jsonReader, new TypeToken\u003cList\u003cCar\u003e\u003e() {\r\n        }.getType());\r\n        fail();\r\n    } catch (JsonParseException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testReadClosed",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWriteInvalidState() throws IOException {\r\n    Gson gson \u003d new Gson();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.beginObject();\r\n    try {\r\n        gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testWriteInvalidState",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWriteClosed() throws IOException {\r\n    Gson gson \u003d new Gson();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.beginArray();\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    try {\r\n        gson.toJson(BLUE_MUSTANG, Car.class, jsonWriter);\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testWriteClosed",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWriteNulls() {\r\n    Gson gson \u003d new Gson();\r\n    try {\r\n        gson.toJson(new JsonPrimitive(\"hello\"), (JsonWriter) null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    gson.toJson(null, new JsonWriter(stringWriter));\r\n    assertThat(stringWriter.toString()).isEqualTo(\"null\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testWriteNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadNulls() {\r\n    Gson gson \u003d new Gson();\r\n    try {\r\n        gson.fromJson((JsonReader) null, Integer.class);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n    try {\r\n        gson.fromJson(new JsonReader(new StringReader(\"true\")), (Type) null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testReadNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWriteHtmlSafe() {\r\n    List\u003cString\u003e contents \u003d Arrays.asList(\"\u003c\", \"\u003e\", \"\u0026\", \"\u003d\", \"\u0027\");\r\n    Type type \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    StringWriter writer \u003d new StringWriter();\r\n    new Gson().toJson(contents, type, new JsonWriter(writer));\r\n    assertThat(writer.toString()).isEqualTo(\"[\\\"\\\\u003c\\\",\\\"\\\\u003e\\\",\\\"\\\\u0026\\\",\\\"\\\\u003d\\\",\\\"\\\\u0027\\\"]\");\r\n    writer \u003d new StringWriter();\r\n    new GsonBuilder().disableHtmlEscaping().create().toJson(contents, type, new JsonWriter(writer));\r\n    assertThat(writer.toString()).isEqualTo(\"[\\\"\u003c\\\",\\\"\u003e\\\",\\\"\u0026\\\",\\\"\u003d\\\",\\\"\u0027\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testWriteHtmlSafe",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWriteLenient() {\r\n    List\u003cDouble\u003e doubles \u003d Arrays.asList(Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, -0.0d, 0.5d, 0.0d);\r\n    Type type \u003d new TypeToken\u003cList\u003cDouble\u003e\u003e() {\r\n    }.getType();\r\n    StringWriter writer \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(writer);\r\n    new GsonBuilder().serializeSpecialFloatingPointValues().create().toJson(doubles, type, jsonWriter);\r\n    assertThat(writer.toString()).isEqualTo(\"[NaN,-Infinity,Infinity,-0.0,0.5,0.0]\");\r\n    try {\r\n        new Gson().toJson(doubles, type, new JsonWriter(new StringWriter()));\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest",
      "methodName": "testWriteLenient",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return name.hashCode() ^ color;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest.Car",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    return o instanceof Car \u0026\u0026 ((Car) o).name.equals(name) \u0026\u0026 ((Car) o).color \u003d\u003d color;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MixedStreamTest.Car",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipField(FieldAttributes f) {\r\n    return skipField;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MockExclusionStrategy",
      "methodName": "shouldSkipField",
      "parameterTypes": [
        "FieldAttributes"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean shouldSkipClass(Class\u003c?\u003e clazz) {\r\n    return skipClass;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.MockExclusionStrategy",
      "methodName": "shouldSkipClass",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Parameters\r\npublic static Iterable\u003cString\u003e data() {\r\n    return Arrays.asList(\"[]\", \"{}\", \"null\", \"1.0\", \"true\", \"\\\"string\\\"\", \"[true,1.0,null,{},2.0,{\\\"a\\\":[false]},[3.0,\\\"test\\\"],4.0]\", \"{\\\"\\\":1.0,\\\"a\\\":true,\\\"b\\\":null,\\\"c\\\":[],\\\"d\\\":{\\\"a1\\\":2.0,\\\"b2\\\":[true,{\\\"a3\\\":3.0}]},\\\"e\\\":[{\\\"f\\\":4.0},\\\"test\\\"]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ObjectTypeAdapterParameterizedTest",
      "methodName": "data",
      "parameterTypes": [],
      "returnType": "Iterable\u003cString\u003e"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadWrite() throws IOException {\r\n    Object deserialized \u003d adapter.fromJson(json);\r\n    String actualSerialized \u003d adapter.toJson(deserialized);\r\n    // Serialized Object should be the same as original JSON\r\n    assertThat(actualSerialized).isEqualTo(json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ObjectTypeAdapterParameterizedTest",
      "methodName": "testReadWrite",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserialize() throws Exception {\r\n    Map\u003c?, ?\u003e map \u003d (Map\u003c?, ?\u003e) adapter.fromJson(\"{\\\"a\\\":5,\\\"b\\\":[1,2,null],\\\"c\\\":{\\\"x\\\":\\\"y\\\"}}\");\r\n    assertThat(map.get(\"a\")).isEqualTo(5.0);\r\n    assertThat(map.get(\"b\")).isEqualTo(Arrays.asList(1.0, 2.0, null));\r\n    assertThat(map.get(\"c\")).isEqualTo(Collections.singletonMap(\"x\", \"y\"));\r\n    assertThat(map).hasSize(3);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ObjectTypeAdapterTest",
      "methodName": "testDeserialize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerialize() {\r\n    Object object \u003d new RuntimeType();\r\n    assertThat(adapter.toJson(object).replace(\"\\\"\", \"\u0027\")).isEqualTo(\"{\u0027a\u0027:5,\u0027b\u0027:[1,2,null]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ObjectTypeAdapterTest",
      "methodName": "testSerialize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeNullValue() {\r\n    Map\u003cString, Object\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", null);\r\n    assertThat(adapter.toJson(map).replace(\u0027\"\u0027, \u0027\\\u0027\u0027)).isEqualTo(\"{\u0027a\u0027:null}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ObjectTypeAdapterTest",
      "methodName": "testSerializeNullValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeNullValue() throws Exception {\r\n    Map\u003cString, Object\u003e map \u003d new LinkedHashMap\u003c\u003e();\r\n    map.put(\"a\", null);\r\n    assertThat(adapter.fromJson(\"{\\\"a\\\":null}\")).isEqualTo(map);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ObjectTypeAdapterTest",
      "methodName": "testDeserializeNullValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeObject() {\r\n    assertThat(adapter.toJson(new Object())).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ObjectTypeAdapterTest",
      "methodName": "testSerializeObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static String repeat(String s, int times) {\r\n    StringBuilder stringBuilder \u003d new StringBuilder(s.length() * times);\r\n    for (int i \u003d 0; i \u003c times; i++) {\r\n        stringBuilder.append(s);\r\n    }\r\n    return stringBuilder.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ObjectTypeAdapterTest",
      "methodName": "repeat",
      "parameterTypes": [
        "String",
        "int"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Deeply nested JSON arrays should not cause {@link StackOverflowError}\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Test\r\npublic void testDeserializeDeeplyNestedArrays() throws IOException {\r\n    int times \u003d 10000;\r\n    // [[[ ... ]]]\r\n    String json \u003d repeat(\"[\", times) + repeat(\"]\", times);\r\n    int actualTimes \u003d 0;\r\n    List\u003cList\u003c?\u003e\u003e current \u003d (List\u003cList\u003c?\u003e\u003e) adapter.fromJson(json);\r\n    while (true) {\r\n        actualTimes++;\r\n        if (current.isEmpty()) {\r\n            break;\r\n        }\r\n        assertThat(current).hasSize(1);\r\n        current \u003d (List\u003cList\u003c?\u003e\u003e) current.get(0);\r\n    }\r\n    assertThat(actualTimes).isEqualTo(times);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ObjectTypeAdapterTest",
      "methodName": "testDeserializeDeeplyNestedArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Deeply nested JSON objects should not cause {@link StackOverflowError}\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Test\r\npublic void testDeserializeDeeplyNestedObjects() throws IOException {\r\n    int times \u003d 10000;\r\n    // {\"a\":{\"a\": ... {\"a\":null} ... }}\r\n    String json \u003d repeat(\"{\\\"a\\\":\", times) + \"null\" + repeat(\"}\", times);\r\n    int actualTimes \u003d 0;\r\n    Map\u003cString, Map\u003c?, ?\u003e\u003e current \u003d (Map\u003cString, Map\u003c?, ?\u003e\u003e) adapter.fromJson(json);\r\n    while (current !\u003d null) {\r\n        assertThat(current).hasSize(1);\r\n        actualTimes++;\r\n        current \u003d (Map\u003cString, Map\u003c?, ?\u003e\u003e) current.get(\"a\");\r\n    }\r\n    assertThat(actualTimes).isEqualTo(times);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ObjectTypeAdapterTest",
      "methodName": "testDeserializeDeeplyNestedObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Boolean value) throws IOException {\r\n    out.value(value ? 1 : 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.OverrideCoreTypeAdaptersTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Boolean"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Boolean read(JsonReader in) throws IOException {\r\n    int value \u003d in.nextInt();\r\n    return value !\u003d 0;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.OverrideCoreTypeAdaptersTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, String value) throws IOException {\r\n    out.value(value.toUpperCase(Locale.US));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.OverrideCoreTypeAdaptersTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String read(JsonReader in) throws IOException {\r\n    return in.nextString().toLowerCase(Locale.US);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.OverrideCoreTypeAdaptersTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testOverrideWrapperBooleanAdapter() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(Boolean.class, booleanAsIntAdapter).create();\r\n    assertThat(gson.toJson(true, boolean.class)).isEqualTo(\"true\");\r\n    assertThat(gson.toJson(true, Boolean.class)).isEqualTo(\"1\");\r\n    assertThat(gson.fromJson(\"true\", boolean.class)).isEqualTo(Boolean.TRUE);\r\n    assertThat(gson.fromJson(\"1\", Boolean.class)).isEqualTo(Boolean.TRUE);\r\n    assertThat(gson.fromJson(\"0\", Boolean.class)).isEqualTo(Boolean.FALSE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.OverrideCoreTypeAdaptersTest",
      "methodName": "testOverrideWrapperBooleanAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testOverridePrimitiveBooleanAdapter() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(boolean.class, booleanAsIntAdapter).create();\r\n    assertThat(gson.toJson(true, boolean.class)).isEqualTo(\"1\");\r\n    assertThat(gson.toJson(true, Boolean.class)).isEqualTo(\"true\");\r\n    assertThat(gson.fromJson(\"1\", boolean.class)).isEqualTo(Boolean.TRUE);\r\n    assertThat(gson.fromJson(\"true\", Boolean.class)).isEqualTo(Boolean.TRUE);\r\n    assertThat(gson.toJson(false, boolean.class)).isEqualTo(\"0\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.OverrideCoreTypeAdaptersTest",
      "methodName": "testOverridePrimitiveBooleanAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testOverrideStringAdapter() {\r\n    Gson gson \u003d new GsonBuilder().registerTypeAdapter(String.class, swapCaseStringAdapter).create();\r\n    assertThat(gson.toJson(\"Hello\", String.class)).isEqualTo(\"\\\"HELLO\\\"\");\r\n    assertThat(gson.fromJson(\"\\\"Hello\\\"\", String.class)).isEqualTo(\"hello\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.OverrideCoreTypeAdaptersTest",
      "methodName": "testOverrideStringAdapter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public T getValue() {\r\n    return value;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeFixtures.MyParameterizedType",
      "methodName": "getValue",
      "parameterTypes": [],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    String valueAsJson \u003d getExpectedJson(value);\r\n    return String.format(\"{\\\"value\\\":%s}\", valueAsJson);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeFixtures.MyParameterizedType",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "private String getExpectedJson(Object obj) {\r\n    Class\u003c?\u003e clazz \u003d obj.getClass();\r\n    if (Primitives.isWrapperType(Primitives.wrap(clazz))) {\r\n        return obj.toString();\r\n    } else if (obj.getClass().equals(String.class)) {\r\n        return \"\\\"\" + obj.toString() + \"\\\"\";\r\n    } else {\r\n        // Try invoking a getExpectedJson() method if it exists\r\n        try {\r\n            Method method \u003d clazz.getMethod(\"getExpectedJson\");\r\n            Object results \u003d method.invoke(obj);\r\n            return (String) results;\r\n        } catch (SecurityException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (NoSuchMethodException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (IllegalArgumentException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeFixtures.MyParameterizedType",
      "methodName": "getExpectedJson",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    return value \u003d\u003d null ? 0 : value.hashCode();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeFixtures.MyParameterizedType",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object obj) {\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof MyParameterizedType\u003c?\u003e)) {\r\n        return false;\r\n    }\r\n    MyParameterizedType\u003c?\u003e that \u003d (MyParameterizedType\u003c?\u003e) obj;\r\n    return Objects.equal(getValue(), that.getValue());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeFixtures.MyParameterizedType",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic MyParameterizedType\u003cT\u003e createInstance(Type type) {\r\n    return new MyParameterizedType\u003c\u003e(instanceOfT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeFixtures.MyParameterizedTypeInstanceCreator",
      "methodName": "createInstance",
      "parameterTypes": [
        "Type"
      ],
      "returnType": "MyParameterizedType\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\npublic static \u003cT\u003e String getExpectedJson(MyParameterizedType\u003cT\u003e obj) {\r\n    Class\u003cT\u003e clazz \u003d (Class\u003cT\u003e) obj.value.getClass();\r\n    boolean addQuotes \u003d !clazz.isArray() \u0026\u0026 !Primitives.unwrap(clazz).isPrimitive();\r\n    StringBuilder sb \u003d new StringBuilder(\"{\\\"\");\r\n    sb.append(obj.value.getClass().getSimpleName()).append(\"\\\":\");\r\n    if (addQuotes) {\r\n        sb.append(\"\\\"\");\r\n    }\r\n    sb.append(obj.value.toString());\r\n    if (addQuotes) {\r\n        sb.append(\"\\\"\");\r\n    }\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeFixtures.MyParameterizedTypeAdapter",
      "methodName": "getExpectedJson",
      "parameterTypes": [
        "MyParameterizedType\u003cT\u003e"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(MyParameterizedType\u003cT\u003e src, Type classOfSrc, JsonSerializationContext context) {\r\n    JsonObject json \u003d new JsonObject();\r\n    T value \u003d src.getValue();\r\n    json.add(value.getClass().getSimpleName(), context.serialize(value));\r\n    return json;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeFixtures.MyParameterizedTypeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "MyParameterizedType\u003cT\u003e",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic MyParameterizedType\u003cT\u003e deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    Type genericClass \u003d ((ParameterizedType) typeOfT).getActualTypeArguments()[0];\r\n    Class\u003c?\u003e rawType \u003d $Gson$Types.getRawType(genericClass);\r\n    String className \u003d rawType.getSimpleName();\r\n    JsonElement jsonElement \u003d json.getAsJsonObject().get(className);\r\n    T value;\r\n    if (genericClass \u003d\u003d Integer.class) {\r\n        value \u003d (T) Integer.valueOf(jsonElement.getAsInt());\r\n    } else if (genericClass \u003d\u003d String.class) {\r\n        value \u003d (T) jsonElement.getAsString();\r\n    } else {\r\n        value \u003d (T) jsonElement;\r\n    }\r\n    if (Primitives.isPrimitive(genericClass)) {\r\n        PrimitiveTypeAdapter typeAdapter \u003d new PrimitiveTypeAdapter();\r\n        value \u003d (T) typeAdapter.adaptType(value, rawType);\r\n    }\r\n    return new MyParameterizedType\u003c\u003e(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeFixtures.MyParameterizedTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "MyParameterizedType\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    ourType \u003d $Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testOurTypeFunctionality() {\r\n    Type parameterizedType \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(ourType.getOwnerType()).isNull();\r\n    assertThat(ourType.getActualTypeArguments()[0]).isSameInstanceAs(String.class);\r\n    assertThat(ourType.getRawType()).isSameInstanceAs(List.class);\r\n    assertThat(ourType).isEqualTo(parameterizedType);\r\n    assertThat(ourType.hashCode()).isEqualTo(parameterizedType.hashCode());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeTest",
      "methodName": "testOurTypeFunctionality",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNotEquals() {\r\n    Type differentParameterizedType \u003d new TypeToken\u003cList\u003cInteger\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(differentParameterizedType.equals(ourType)).isFalse();\r\n    assertThat(ourType.equals(differentParameterizedType)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ParameterizedTypeTest",
      "methodName": "testNotEquals",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unchecked\")\r\npublic \u003cT\u003e T adaptType(Object from, Class\u003cT\u003e to) {\r\n    Class\u003c?\u003e aClass \u003d Primitives.wrap(to);\r\n    if (Primitives.isWrapperType(aClass)) {\r\n        if (aClass \u003d\u003d Character.class) {\r\n            String value \u003d from.toString();\r\n            if (value.length() \u003d\u003d 1) {\r\n                return (T) (Character) from.toString().charAt(0);\r\n            }\r\n            throw new JsonParseException(\"The value: \" + value + \" contains more than a character.\");\r\n        }\r\n        try {\r\n            Constructor\u003c?\u003e constructor \u003d aClass.getConstructor(String.class);\r\n            return (T) constructor.newInstance(from.toString());\r\n        } catch (NoSuchMethodException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (InstantiationException e) {\r\n            throw new JsonParseException(e);\r\n        }\r\n    } else if (Enum.class.isAssignableFrom(to)) {\r\n        // Case where the type being adapted to is an Enum\r\n        // We will try to convert from.toString() to the enum\r\n        try {\r\n            Method valuesMethod \u003d to.getMethod(\"valueOf\", String.class);\r\n            return (T) valuesMethod.invoke(null, from.toString());\r\n        } catch (NoSuchMethodException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    } else {\r\n        throw new JsonParseException(\"Can not adapt type \" + from.getClass() + \" to \" + to);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.PrimitiveTypeAdapter",
      "methodName": "adaptType",
      "parameterTypes": [
        "Object",
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@SuppressWarnings({ \"deprecation\" })\r\n@Test\r\npublic void testIsAssignableFromRawTypes() {\r\n    assertThat(TypeToken.get(Object.class).isAssignableFrom(String.class)).isTrue();\r\n    assertThat(TypeToken.get(String.class).isAssignableFrom(Object.class)).isFalse();\r\n    assertThat(TypeToken.get(RandomAccess.class).isAssignableFrom(ArrayList.class)).isTrue();\r\n    assertThat(TypeToken.get(ArrayList.class).isAssignableFrom(RandomAccess.class)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testIsAssignableFromRawTypes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings({ \"deprecation\" })\r\n@Test\r\npublic void testIsAssignableFromWithTypeParameters() throws Exception {\r\n    Type a \u003d getClass().getDeclaredField(\"listOfInteger\").getGenericType();\r\n    Type b \u003d getClass().getDeclaredField(\"listOfNumber\").getGenericType();\r\n    assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n    assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n    // listOfInteger \u003d listOfNumber; // doesn\u0027t compile; must be false\r\n    assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n    // listOfNumber \u003d listOfInteger; // doesn\u0027t compile; must be false\r\n    assertThat(TypeToken.get(b).isAssignableFrom(a)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testIsAssignableFromWithTypeParameters",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings({ \"deprecation\" })\r\n@Test\r\npublic void testIsAssignableFromWithBasicWildcards() throws Exception {\r\n    Type a \u003d getClass().getDeclaredField(\"listOfString\").getGenericType();\r\n    Type b \u003d getClass().getDeclaredField(\"listOfUnknown\").getGenericType();\r\n    assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n    assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n    // listOfString \u003d listOfUnknown  // doesn\u0027t compile; must be false\r\n    assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n    // compiles; must be true\r\n    listOfUnknown \u003d listOfString;\r\n    // The following assertion is too difficult to support reliably, so disabling\r\n    // assertThat(TypeToken.get(b).isAssignableFrom(a)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testIsAssignableFromWithBasicWildcards",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings({ \"deprecation\" })\r\n@Test\r\npublic void testIsAssignableFromWithNestedWildcards() throws Exception {\r\n    Type a \u003d getClass().getDeclaredField(\"listOfSetOfString\").getGenericType();\r\n    Type b \u003d getClass().getDeclaredField(\"listOfSetOfUnknown\").getGenericType();\r\n    assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n    assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n    // listOfSetOfString \u003d listOfSetOfUnknown; // doesn\u0027t compile; must be false\r\n    assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n    // listOfSetOfUnknown \u003d listOfSetOfString; // doesn\u0027t compile; must be false\r\n    assertThat(TypeToken.get(b).isAssignableFrom(a)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testIsAssignableFromWithNestedWildcards",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArrayFactory() {\r\n    TypeToken\u003c?\u003e expectedStringArray \u003d new TypeToken\u003cString[]\u003e() {\r\n    };\r\n    assertThat(TypeToken.getArray(String.class)).isEqualTo(expectedStringArray);\r\n    TypeToken\u003c?\u003e expectedListOfStringArray \u003d new TypeToken\u003cList\u003cString\u003e[]\u003e() {\r\n    };\r\n    Type listOfString \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    }.getType();\r\n    assertThat(TypeToken.getArray(listOfString)).isEqualTo(expectedListOfStringArray);\r\n    TypeToken\u003c?\u003e expectedIntArray \u003d new TypeToken\u003cint[]\u003e() {\r\n    };\r\n    assertThat(TypeToken.getArray(int.class)).isEqualTo(expectedIntArray);\r\n    assertThrows(NullPointerException.class, () -\u003e TypeToken.getArray(null));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testArrayFactory",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedFactory() {\r\n    TypeToken\u003c?\u003e expectedListOfString \u003d new TypeToken\u003cList\u003cString\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(List.class, String.class)).isEqualTo(expectedListOfString);\r\n    TypeToken\u003c?\u003e expectedMapOfStringToString \u003d new TypeToken\u003cMap\u003cString, String\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(Map.class, String.class, String.class)).isEqualTo(expectedMapOfStringToString);\r\n    TypeToken\u003c?\u003e expectedListOfListOfListOfString \u003d new TypeToken\u003cList\u003cList\u003cList\u003cString\u003e\u003e\u003e\u003e() {\r\n    };\r\n    Type listOfString \u003d TypeToken.getParameterized(List.class, String.class).getType();\r\n    Type listOfListOfString \u003d TypeToken.getParameterized(List.class, listOfString).getType();\r\n    assertThat(TypeToken.getParameterized(List.class, listOfListOfString)).isEqualTo(expectedListOfListOfListOfString);\r\n    TypeToken\u003c?\u003e expectedWithExactArg \u003d new TypeToken\u003cGenericWithBound\u003cNumber\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(GenericWithBound.class, Number.class)).isEqualTo(expectedWithExactArg);\r\n    TypeToken\u003c?\u003e expectedWithSubclassArg \u003d new TypeToken\u003cGenericWithBound\u003cInteger\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(GenericWithBound.class, Integer.class)).isEqualTo(expectedWithSubclassArg);\r\n    TypeToken\u003c?\u003e expectedSatisfyingTwoBounds \u003d new TypeToken\u003cGenericWithMultiBound\u003cClassSatisfyingBounds\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(GenericWithMultiBound.class, ClassSatisfyingBounds.class)).isEqualTo(expectedSatisfyingTwoBounds);\r\n    TypeToken\u003c?\u003e nestedTypeToken \u003d TypeToken.getParameterized(NestedGeneric.class, Integer.class);\r\n    ParameterizedType nestedParameterizedType \u003d (ParameterizedType) nestedTypeToken.getType();\r\n    // TODO: This seems to differ from how Java reflection behaves; when using TypeToken\u003cNestedGeneric\u003cInteger\u003e\u003e,\r\n    // then NestedGeneric\u003cInteger\u003e does have an owner type\r\n    assertThat(nestedParameterizedType.getOwnerType()).isNull();\r\n    assertThat(nestedParameterizedType.getRawType()).isEqualTo(NestedGeneric.class);\r\n    assertThat(nestedParameterizedType.getActualTypeArguments()).asList().containsExactly(Integer.class);\r\n    class LocalGenericClass\u003cT\u003e {\r\n    }\r\n    TypeToken\u003c?\u003e expectedLocalType \u003d new TypeToken\u003cLocalGenericClass\u003cInteger\u003e\u003e() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(LocalGenericClass.class, Integer.class)).isEqualTo(expectedLocalType);\r\n    // For legacy reasons, if requesting parameterized type for non-generic class, create a `TypeToken(Class)`\r\n    assertThat(TypeToken.getParameterized(String.class)).isEqualTo(TypeToken.get(String.class));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testParameterizedFactory",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testParameterizedFactory_Invalid() {\r\n    assertThrows(NullPointerException.class, () -\u003e TypeToken.getParameterized(null, new Type[0]));\r\n    assertThrows(NullPointerException.class, () -\u003e TypeToken.getParameterized(List.class, new Type[] { null }));\r\n    GenericArrayType arrayType \u003d (GenericArrayType) TypeToken.getArray(String.class).getType();\r\n    IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(arrayType, new Type[0]));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"rawType must be of type Class, but was java.lang.String[]\");\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(String.class, Number.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.lang.String requires 0 type arguments, but got 1\");\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(List.class, new Type[0]));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.util.List requires 1 type arguments, but got 0\");\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(List.class, String.class, String.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.util.List requires 1 type arguments, but got 2\");\r\n    // Primitive types must not be used as type argument\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(List.class, int.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument int does not satisfy bounds\" + \" for type variable E declared by \" + List.class);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(GenericWithBound.class, String.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.String does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithBound.class);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(GenericWithBound.class, Object.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Object does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithBound.class);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(GenericWithMultiBound.class, Number.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Number does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(GenericWithMultiBound.class, CharSequence.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument interface java.lang.CharSequence does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(GenericWithMultiBound.class, Object.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Object does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n    class Outer {\r\n\r\n        class NonStaticInner\u003cT\u003e {\r\n        }\r\n    }\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e TypeToken.getParameterized(Outer.NonStaticInner.class, Object.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Raw type \" + Outer.NonStaticInner.class.getName() + \" is not supported because it requires specifying an owner type\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testParameterizedFactory_Invalid",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTypeTokenNonAnonymousSubclass() {\r\n    TypeToken\u003c?\u003e typeToken \u003d new CustomTypeToken();\r\n    assertThat(typeToken.getRawType()).isEqualTo(String.class);\r\n    assertThat(typeToken.getType()).isEqualTo(String.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testTypeTokenNonAnonymousSubclass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * User must only create direct subclasses of TypeToken, but not subclasses\r\n * of subclasses (...) of TypeToken.\r\n */\r\n@Test\r\npublic void testTypeTokenSubSubClass() {\r\n    class SubTypeToken\u003cT\u003e extends TypeToken\u003cString\u003e {\r\n    }\r\n    class SubSubTypeToken1\u003cT\u003e extends SubTypeToken\u003cT\u003e {\r\n    }\r\n    class SubSubTypeToken2 extends SubTypeToken\u003cInteger\u003e {\r\n    }\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e new SubTypeToken\u003cInteger\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e new SubSubTypeToken1\u003cInteger\u003e());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e new SubSubTypeToken2());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testTypeTokenSubSubClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static \u003cM\u003e void createTypeTokenTypeVariable() {\r\n    new TypeToken\u003cM\u003e() {\r\n    };\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "createTypeTokenTypeVariable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "void test() {\r\n    String expectedMessage \u003d \"TypeToken type argument must not contain a type variable;\" + \" captured type variable T declared by \" + Enclosing.class + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\";\r\n    IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cT\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003cList\u003cT\u003e\u003e\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003c? extends List\u003cT\u003e\u003e\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003c? super List\u003cT\u003e\u003e\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003cT\u003e[]\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cEnclosing\u003cT\u003e.Inner\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    String systemProperty \u003d \"gson.allowCapturingTypeVariables\";\r\n    try {\r\n        // Any value other than \u0027true\u0027 should be ignored\r\n        System.setProperty(systemProperty, \"some-value\");\r\n        e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cT\u003e() {\r\n        });\r\n        assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n    } finally {\r\n        System.clearProperty(systemProperty);\r\n    }\r\n    try {\r\n        System.setProperty(systemProperty, \"true\");\r\n        TypeToken\u003c?\u003e typeToken \u003d new TypeToken\u003cT\u003e() {\r\n        };\r\n        assertThat(typeToken.getType()).isEqualTo(Enclosing.class.getTypeParameters()[0]);\r\n    } finally {\r\n        System.clearProperty(systemProperty);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "test",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "\u003cM\u003e void testMethodTypeVariable() throws Exception {\r\n    Method testMethod \u003d Enclosing.class.getDeclaredMethod(\"testMethodTypeVariable\");\r\n    IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cM\u003e() {\r\n    });\r\n    assertThat(e).hasMessageThat().isAnyOf(\"TypeToken type argument must not contain a type variable;\" + \" captured type variable M declared by \" + testMethod + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\", // Note: When running this test in Eclipse IDE or with certain Java versions it seems to capture `null`\r\n    // instead of the type variable, see https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n    \"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n}",
    "methodIdentifier": {
      "className": "",
      "methodName": "testMethodTypeVariable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * TypeToken type argument must not contain a type variable because, due to\r\n * type erasure, at runtime only the bound of the type variable is available\r\n * which is likely not what the user wanted.\r\n *\r\n * \u003cp\u003eNote that type variables are allowed for the {@code TypeToken} factory\r\n * methods calling {@code TypeToken(Type)} because for them the return type is\r\n * {@code TypeToken\u003c?\u003e} which does not give a false sense of type-safety.\r\n */\r\n@Test\r\npublic void testTypeTokenTypeVariable() throws Exception {\r\n    // Put the test code inside generic class to be able to access `T`\r\n    class Enclosing\u003cT\u003e {\r\n\r\n        class Inner {\r\n        }\r\n\r\n        void test() {\r\n            String expectedMessage \u003d \"TypeToken type argument must not contain a type variable;\" + \" captured type variable T declared by \" + Enclosing.class + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\";\r\n            IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cT\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003cList\u003cT\u003e\u003e\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003c? extends List\u003cT\u003e\u003e\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003c? super List\u003cT\u003e\u003e\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cList\u003cT\u003e[]\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cEnclosing\u003cT\u003e.Inner\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            String systemProperty \u003d \"gson.allowCapturingTypeVariables\";\r\n            try {\r\n                // Any value other than \u0027true\u0027 should be ignored\r\n                System.setProperty(systemProperty, \"some-value\");\r\n                e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cT\u003e() {\r\n                });\r\n                assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            } finally {\r\n                System.clearProperty(systemProperty);\r\n            }\r\n            try {\r\n                System.setProperty(systemProperty, \"true\");\r\n                TypeToken\u003c?\u003e typeToken \u003d new TypeToken\u003cT\u003e() {\r\n                };\r\n                assertThat(typeToken.getType()).isEqualTo(Enclosing.class.getTypeParameters()[0]);\r\n            } finally {\r\n                System.clearProperty(systemProperty);\r\n            }\r\n        }\r\n\r\n        \u003cM\u003e void testMethodTypeVariable() throws Exception {\r\n            Method testMethod \u003d Enclosing.class.getDeclaredMethod(\"testMethodTypeVariable\");\r\n            IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e new TypeToken\u003cM\u003e() {\r\n            });\r\n            assertThat(e).hasMessageThat().isAnyOf(\"TypeToken type argument must not contain a type variable;\" + \" captured type variable M declared by \" + testMethod + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\", // Note: When running this test in Eclipse IDE or with certain Java versions it seems to capture `null`\r\n            // instead of the type variable, see https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n            \"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n        }\r\n    }\r\n    new Enclosing\u003c\u003e().test();\r\n    new Enclosing\u003c\u003e().testMethodTypeVariable();\r\n    Method testMethod \u003d TypeTokenTest.class.getDeclaredMethod(\"createTypeTokenTypeVariable\");\r\n    IllegalArgumentException e \u003d assertThrows(IllegalArgumentException.class, () -\u003e createTypeTokenTypeVariable());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"TypeToken type argument must not contain a type variable;\" + \" captured type variable M declared by \" + testMethod + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\");\r\n    // Using type variable as argument for factory methods should be allowed; this is not a type-safety\r\n    // problem because the user would have to perform unsafe casts\r\n    TypeVariable\u003c?\u003e typeVar \u003d Enclosing.class.getTypeParameters()[0];\r\n    TypeToken\u003c?\u003e typeToken \u003d TypeToken.get(typeVar);\r\n    assertThat(typeToken.getType()).isEqualTo(typeVar);\r\n    TypeToken\u003c?\u003e parameterizedTypeToken \u003d TypeToken.getParameterized(List.class, typeVar);\r\n    ParameterizedType parameterizedType \u003d (ParameterizedType) parameterizedTypeToken.getType();\r\n    assertThat(parameterizedType.getRawType()).isEqualTo(List.class);\r\n    assertThat(parameterizedType.getActualTypeArguments()).asList().containsExactly(typeVar);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testTypeTokenTypeVariable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"rawtypes\")\r\n@Test\r\npublic void testTypeTokenRaw() {\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e new TypeToken() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(\"TypeToken must be created with a type argument: new TypeToken\u003c...\u003e() {};\" + \" When using code shrinkers (ProGuard, R8, ...) make sure that generic signatures are preserved.\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#type-token-raw\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.reflect.TypeTokenTest",
      "methodName": "testTypeTokenRaw",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testComGoogleGsonAnnotationsPackage() throws Exception {\r\n    Manifest mf \u003d findManifest(\"com.google.gson\");\r\n    String importPkg \u003d mf.getMainAttributes().getValue(\"Import-Package\");\r\n    assertWithMessage(\"Import-Package statement is there\").that(importPkg).isNotNull();\r\n    assertSubstring(\"There should be com.google.gson.annotations dependency\", importPkg, \"com.google.gson.annotations\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.regression.OSGiTest",
      "methodName": "testComGoogleGsonAnnotationsPackage",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSunMiscImportPackage() throws Exception {\r\n    Manifest mf \u003d findManifest(\"com.google.gson\");\r\n    String importPkg \u003d mf.getMainAttributes().getValue(\"Import-Package\");\r\n    assertWithMessage(\"Import-Package statement is there\").that(importPkg).isNotNull();\r\n    for (String dep : Splitter.on(\u0027,\u0027).split(importPkg)) {\r\n        if (dep.contains(\"sun.misc\")) {\r\n            assertSubstring(\"sun.misc import is optional\", dep, \"resolution:\u003doptional\");\r\n            return;\r\n        }\r\n    }\r\n    fail(\"There should be sun.misc dependency, but was: \" + importPkg);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.regression.OSGiTest",
      "methodName": "testSunMiscImportPackage",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private Manifest findManifest(String pkg) throws IOException {\r\n    List\u003cURL\u003e urls \u003d new ArrayList\u003c\u003e();\r\n    for (URL u : Collections.list(getClass().getClassLoader().getResources(\"META-INF/MANIFEST.MF\"))) {\r\n        InputStream is \u003d u.openStream();\r\n        Manifest mf \u003d new Manifest(is);\r\n        is.close();\r\n        if (pkg.equals(mf.getMainAttributes().getValue(\"Bundle-SymbolicName\"))) {\r\n            return mf;\r\n        }\r\n        urls.add(u);\r\n    }\r\n    fail(\"Cannot find \" + pkg + \" OSGi bundle manifest among: \" + urls);\r\n    return null;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.regression.OSGiTest",
      "methodName": "findManifest",
      "parameterTypes": [
        "String"
      ],
      "returnType": "Manifest"
    }
  },
  {
    "sourceCode": "private static void assertSubstring(String msg, String wholeText, String subString) {\r\n    if (wholeText.contains(subString)) {\r\n        return;\r\n    }\r\n    fail(msg + \". Expecting \" + subString + \" but was: \" + wholeText);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.regression.OSGiTest",
      "methodName": "assertSubstring",
      "parameterTypes": [
        "String",
        "String",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Parameterized.Parameters(name \u003d \"{0}\")\r\npublic static List\u003cObject[]\u003e parameters() {\r\n    return Arrays.asList(new Object[] { Factory.STRING_READER }, new Object[] { Factory.OBJECT_READER });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "parameters",
      "parameterTypes": [],
      "returnType": "List\u003cObject[]\u003e"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void path() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":[2,true,false,null,\\\"b\\\",{\\\"c\\\":\\\"d\\\"},[3]]}\");\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\");\r\n    String unused1 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[0]\");\r\n    int unused2 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[1]\");\r\n    boolean unused3 \u003d reader.nextBoolean();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[2]\");\r\n    boolean unused4 \u003d reader.nextBoolean();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[2]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[3]\");\r\n    reader.nextNull();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[3]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[4]\");\r\n    String unused5 \u003d reader.nextString();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[4]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[5]\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[5].\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[5].\");\r\n    String unused6 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[5].c\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[5].c\");\r\n    String unused7 \u003d reader.nextString();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[5].c\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[5].c\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[5]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[6]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[6][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[6][0]\");\r\n    int unused8 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[6][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[6][1]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a[6]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a[7]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "path",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void objectPath() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":1,\\\"b\\\":2}\");\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    JsonToken unused1 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\");\r\n    JsonToken unused2 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\");\r\n    String unused3 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    JsonToken unused4 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    int unused5 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    JsonToken unused6 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    String unused7 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    JsonToken unused8 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    int unused9 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    JsonToken unused10 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    JsonToken unused11 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.close();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "objectPath",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void arrayPath() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"[1,2]\");\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    JsonToken unused1 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0]\");\r\n    JsonToken unused2 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0]\");\r\n    int unused3 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n    JsonToken unused4 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n    int unused5 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2]\");\r\n    JsonToken unused6 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    JsonToken unused7 \u003d reader.peek();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.close();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "arrayPath",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void multipleTopLevelValuesInOneDocument() throws IOException {\r\n    assumeTrue(factory \u003d\u003d Factory.STRING_READER);\r\n    JsonReader reader \u003d factory.create(\"[][]\");\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "multipleTopLevelValuesInOneDocument",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void skipArrayElements() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"[1,2,3]\");\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "skipArrayElements",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void skipArrayEnd() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"[[],1]\");\r\n    reader.beginArray();\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0][0]\");\r\n    // skip end of array\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "skipArrayEnd",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void skipObjectNames() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":[]}\");\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\u003cskipped\u003e[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\u003cskipped\u003e[0]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "skipObjectNames",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void skipObjectValues() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":1,\\\"b\\\":2}\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\");\r\n    String unused1 \u003d reader.nextName();\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    String unused2 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "skipObjectValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void skipObjectEnd() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":{},\\\"b\\\":2}\");\r\n    reader.beginObject();\r\n    String unused \u003d reader.nextName();\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.\");\r\n    // skip end of object\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "skipObjectEnd",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void skipNestedStructures() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"[[1,2,3],4]\");\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "skipNestedStructures",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void skipEndOfDocument() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"[]\");\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.skipValue();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "skipEndOfDocument",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void arrayOfObjects() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"[{},{},{}]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0]\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0].\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0].\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1].\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1].\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2]\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[2].\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2].\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[2]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[3]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "arrayOfObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void arrayOfArrays() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"[[],[],[]]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0][0]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[1][0]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[1]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2]\");\r\n    reader.beginArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[2][0]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[2][0]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$[2]\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$[3]\");\r\n    reader.endArray();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "arrayOfArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void objectOfObjects() throws IOException {\r\n    JsonReader reader \u003d factory.create(\"{\\\"a\\\":{\\\"a1\\\":1,\\\"a2\\\":2},\\\"b\\\":{\\\"b1\\\":1}}\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\");\r\n    String unused1 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.\");\r\n    String unused2 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.a1\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.a1\");\r\n    int unused3 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.a1\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.a1\");\r\n    String unused4 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.a2\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.a2\");\r\n    int unused5 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a.a2\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.a2\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.a\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a\");\r\n    String unused6 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    reader.beginObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b.\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b.\");\r\n    String unused7 \u003d reader.nextName();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b.b1\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b.b1\");\r\n    int unused8 \u003d reader.nextInt();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b.b1\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b.b1\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$.b\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$.b\");\r\n    reader.endObject();\r\n    assertThat(reader.getPreviousPath()).isEqualTo(\"$\");\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "objectOfObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonReader create(String data) {\r\n    return new JsonReader(new StringReader(data));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "create",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonReader"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonReader create(String data) {\r\n    JsonElement element \u003d Streams.parse(new JsonReader(new StringReader(data)));\r\n    return new JsonTreeReader(element);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "create",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonReader"
    }
  },
  {
    "sourceCode": "abstract JsonReader create(String data);",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderPathTest",
      "methodName": "create",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonReader"
    }
  },
  {
    "sourceCode": "// for JsonReader.setLenient\r\n@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testSetLenientTrue() {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.setLenient(true);\r\n    assertThat(reader.getStrictness()).isEqualTo(Strictness.LENIENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSetLenientTrue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// for JsonReader.setLenient\r\n@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testSetLenientFalse() {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.setLenient(false);\r\n    assertThat(reader.getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSetLenientFalse",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSetStrictness() {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    assertThat(reader.getStrictness()).isEqualTo(Strictness.STRICT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSetStrictness",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSetStrictnessNull() {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    assertThrows(NullPointerException.class, () -\u003e reader.setStrictness(null));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSetStrictnessNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapedNewlineNotAllowedInStrictMode() throws IOException {\r\n    String json \u003d \"\\\"\\\\\\n\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextString);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Cannot escape a newline character in strict mode\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testEscapedNewlineNotAllowedInStrictMode",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapedNewlineAllowedInDefaultMode() throws IOException {\r\n    String json \u003d \"\\\"\\\\\\n\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    assertThat(reader.nextString()).isEqualTo(\"\\n\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testEscapedNewlineAllowedInDefaultMode",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictModeFailsToParseUnescapedControlCharacter() {\r\n    String json \u003d \"\\\"\\0\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextString);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n    json \u003d \"\\\"\\t\\\"\";\r\n    reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    expected \u003d assertThrows(IOException.class, reader::nextString);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n    json \u003d \"\\\"\\u001F\\\"\";\r\n    reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    expected \u003d assertThrows(IOException.class, reader::nextString);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictModeFailsToParseUnescapedControlCharacter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictModeAllowsOtherControlCharacters() throws IOException {\r\n    // JSON specification only forbids control characters U+0000 - U+001F, other control characters should be allowed\r\n    String json \u003d \"\\\"\\u007F\\u009F\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    assertThat(reader.nextString()).isEqualTo(\"\\u007F\\u009F\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictModeAllowsOtherControlCharacters",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonStrictModeParsesUnescapedControlCharacter() throws IOException {\r\n    String json \u003d \"\\\"\\t\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    assertThat(reader.nextString()).isEqualTo(\"\\t\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testNonStrictModeParsesUnescapedControlCharacter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCapitalizedTrueFailWhenStrict() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"TRUE\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextBoolean);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n    reader \u003d new JsonReader(reader(\"True\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    expected \u003d assertThrows(IOException.class, reader::nextBoolean);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testCapitalizedTrueFailWhenStrict",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCapitalizedFalseFailWhenStrict() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"FALSE\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextBoolean);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n    reader \u003d new JsonReader(reader(\"FaLse\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    expected \u003d assertThrows(IOException.class, reader::nextBoolean);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testCapitalizedFalseFailWhenStrict",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCapitalizedNullFailWhenStrict() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"NULL\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextNull);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n    reader \u003d new JsonReader(reader(\"nulL\"));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    expected \u003d assertThrows(IOException.class, reader::nextNull);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed\" + \" JSON at line 1 column 1 path $\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testCapitalizedNullFailWhenStrict",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadArray() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true, true]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testReadArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadEmptyArray() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.hasNext()).isFalse();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testReadEmptyArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadObject() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": \\\"android\\\", \\\"b\\\": \\\"banana\\\"}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"android\");\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    assertThat(reader.nextString()).isEqualTo(\"banana\");\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testReadObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReadEmptyObject() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.hasNext()).isFalse();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testReadEmptyObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testHasNextEndOfDocument() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.hasNext()).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testHasNextEndOfDocument",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipArray() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": [\\\"one\\\", \\\"two\\\", \\\"three\\\"], \\\"b\\\": 123}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    assertThat(reader.nextInt()).isEqualTo(123);\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipArrayAfterPeek() throws Exception {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": [\\\"one\\\", \\\"two\\\", \\\"three\\\"], \\\"b\\\": 123}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.peek()).isEqualTo(BEGIN_ARRAY);\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    assertThat(reader.nextInt()).isEqualTo(123);\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipArrayAfterPeek",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipTopLevelObject() throws Exception {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": [\\\"one\\\", \\\"two\\\", \\\"three\\\"], \\\"b\\\": 123}\"));\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipTopLevelObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipObject() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": { \\\"c\\\": [], \\\"d\\\": [true, true, {}] }, \\\"b\\\": \\\"banana\\\"}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    reader.skipValue();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipObjectAfterPeek() throws Exception {\r\n    String json \u003d \"{\" + \"  \\\"one\\\": { \\\"num\\\": 1 }\" + \", \\\"two\\\": { \\\"num\\\": 2 }\" + \", \\\"three\\\": { \\\"num\\\": 3 }\" + \"}\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"one\");\r\n    assertThat(reader.peek()).isEqualTo(BEGIN_OBJECT);\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"two\");\r\n    assertThat(reader.peek()).isEqualTo(BEGIN_OBJECT);\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"three\");\r\n    reader.skipValue();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipObjectAfterPeek",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipObjectName() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\": 1}\"));\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipObjectName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipObjectNameSingleQuoted() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\u0027a\u0027: 1}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipObjectNameSingleQuoted",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipObjectNameUnquoted() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{a: 1}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.NUMBER);\r\n    assertThat(reader.getPath()).isEqualTo(\"$.\u003cskipped\u003e\");\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipObjectNameUnquoted",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipInteger() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":123456789,\\\"b\\\":-123456789}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    reader.skipValue();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipInteger",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipDouble() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":-123.456e-789,\\\"b\\\":123456789.0}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    reader.skipValue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n    reader.skipValue();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipDouble",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipValueAfterEndOfDocument() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipValueAfterEndOfDocument",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipValueAtArrayEnd() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[]\"));\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipValueAtArrayEnd",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipValueAtObjectEnd() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{}\"));\r\n    reader.beginObject();\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    assertThat(reader.getPath()).isEqualTo(\"$\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipValueAtObjectEnd",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testHelloWorld() throws IOException {\r\n    String json \u003d \"{\\n\" + \"   \\\"hello\\\": true,\\n\" + \"   \\\"foo\\\": [\\\"world\\\"]\\n\" + \"}\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"hello\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextName()).isEqualTo(\"foo\");\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"world\");\r\n    reader.endArray();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testHelloWorld",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testInvalidJsonInput() throws IOException {\r\n    String json \u003d \"{\\n\" + \"   \\\"h\\\\ello\\\": true,\\n\" + \"   \\\"foo\\\": [\\\"world\\\"]\\n\" + \"}\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginObject();\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Invalid escape sequence at line 2 column 8 path $.\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testInvalidJsonInput",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@SuppressWarnings(\"unused\")\r\n@Test\r\npublic void testNulls() {\r\n    try {\r\n        new JsonReader(null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyString() throws IOException {\r\n    try {\r\n        new JsonReader(reader(\"\")).beginArray();\r\n        fail();\r\n    } catch (EOFException expected) {\r\n    }\r\n    try {\r\n        new JsonReader(reader(\"\")).beginObject();\r\n        fail();\r\n    } catch (EOFException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testEmptyString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCharacterUnescaping() throws IOException {\r\n    String json \u003d \"[\\\"a\\\",\" + \"\\\"a\\\\\\\"\\\",\" + \"\\\"\\\\\\\"\\\",\" + \"\\\":\\\",\" + \"\\\",\\\",\" + \"\\\"\\\\b\\\",\" + \"\\\"\\\\f\\\",\" + \"\\\"\\\\n\\\",\" + \"\\\"\\\\r\\\",\" + \"\\\"\\\\t\\\",\" + \"\\\" \\\",\" + \"\\\"\\\\\\\\\\\",\" + \"\\\"{\\\",\" + \"\\\"}\\\",\" + \"\\\"[\\\",\" + \"\\\"]\\\",\" + \"\\\"\\\\u0000\\\",\" + \"\\\"\\\\u0019\\\",\" + \"\\\"\\\\u20AC\\\"\" + \"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"a\\\"\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\\"\");\r\n    assertThat(reader.nextString()).isEqualTo(\":\");\r\n    assertThat(reader.nextString()).isEqualTo(\",\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\b\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\f\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\n\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\r\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\t\");\r\n    assertThat(reader.nextString()).isEqualTo(\" \");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\\\\");\r\n    assertThat(reader.nextString()).isEqualTo(\"{\");\r\n    assertThat(reader.nextString()).isEqualTo(\"}\");\r\n    assertThat(reader.nextString()).isEqualTo(\"[\");\r\n    assertThat(reader.nextString()).isEqualTo(\"]\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\0\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\u0019\");\r\n    assertThat(reader.nextString()).isEqualTo(\"\\u20AC\");\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testCharacterUnescaping",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testReaderDoesNotTreatU2028U2029AsNewline() throws IOException {\r\n    // This test shows that the JSON string [\\n\"whatever\"] is seen as valid\r\n    // And the JSON string [\\u2028\"whatever\"] is not.\r\n    String jsonInvalid2028 \u003d \"[\\u2028\\\"whatever\\\"]\";\r\n    JsonReader readerInvalid2028 \u003d new JsonReader(reader(jsonInvalid2028));\r\n    readerInvalid2028.beginArray();\r\n    assertThrows(IOException.class, readerInvalid2028::nextString);\r\n    String jsonInvalid2029 \u003d \"[\\u2029\\\"whatever\\\"]\";\r\n    JsonReader readerInvalid2029 \u003d new JsonReader(reader(jsonInvalid2029));\r\n    readerInvalid2029.beginArray();\r\n    assertThrows(IOException.class, readerInvalid2029::nextString);\r\n    String jsonValid \u003d \"[\\n\\\"whatever\\\"]\";\r\n    JsonReader readerValid \u003d new JsonReader(reader(jsonValid));\r\n    readerValid.beginArray();\r\n    assertThat(readerValid.nextString()).isEqualTo(\"whatever\");\r\n    // And even in STRICT mode U+2028 and U+2029 are not considered control characters\r\n    // and can appear unescaped in JSON string\r\n    String jsonValid2028And2029 \u003d \"\\\"whatever\\u2028\\u2029\\\"\";\r\n    JsonReader readerValid2028And2029 \u003d new JsonReader(reader(jsonValid2028And2029));\r\n    readerValid2028And2029.setStrictness(Strictness.STRICT);\r\n    assertThat(readerValid2028And2029.nextString()).isEqualTo(\"whatever\\u2028\\u2029\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testReaderDoesNotTreatU2028U2029AsNewline",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapeCharacterQuoteInStrictMode() throws IOException {\r\n    String json \u003d \"\\\"\\\\\u0027\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.STRICT);\r\n    IOException expected \u003d assertThrows(IOException.class, reader::nextString);\r\n    assertThat(expected).hasMessageThat().startsWith(\"Invalid escaped character \\\"\u0027\\\" in strict mode\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testEscapeCharacterQuoteInStrictMode",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEscapeCharacterQuoteWithoutStrictMode() throws IOException {\r\n    String json \u003d \"\\\"\\\\\u0027\\\"\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    assertThat(reader.nextString()).isEqualTo(\"\u0027\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testEscapeCharacterQuoteWithoutStrictMode",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUnescapingInvalidCharacters() throws IOException {\r\n    String json \u003d \"[\\\"\\\\u000g\\\"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Malformed Unicode escape \\\\u000g at line 1 column 5 path $[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testUnescapingInvalidCharacters",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUnescapingTruncatedCharacters() throws IOException {\r\n    String json \u003d \"[\\\"\\\\u000\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unterminated escape sequence at line 1 column 5 path $[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testUnescapingTruncatedCharacters",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUnescapingTruncatedSequence() throws IOException {\r\n    String json \u003d \"[\\\"\\\\\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unterminated escape sequence at line 1 column 4 path $[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testUnescapingTruncatedSequence",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIntegersWithFractionalPartSpecified() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[1.0,1.0,1.0]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.nextLong()).isEqualTo(1L);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testIntegersWithFractionalPartSpecified",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubles() throws IOException {\r\n    String json \u003d \"[-0.0,\" + \"1.0,\" + \"1.7976931348623157E308,\" + \"4.9E-324,\" + \"0.0,\" + \"0.00,\" + \"-0.5,\" + \"2.2250738585072014E-308,\" + \"3.141592653589793,\" + \"2.718281828459045,\" + \"0,\" + \"0.01,\" + \"0e0,\" + \"1e+0,\" + \"1e-0,\" + // leading 0 is allowed for exponent\r\n    \"1e0000,\" + \"1e00001,\" + \"1e+1]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    assertThat(reader.nextDouble()).isEqualTo(-0.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.7976931348623157E308);\r\n    assertThat(reader.nextDouble()).isEqualTo(4.9E-324);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(-0.5);\r\n    assertThat(reader.nextDouble()).isEqualTo(2.2250738585072014E-308);\r\n    assertThat(reader.nextDouble()).isEqualTo(3.141592653589793);\r\n    assertThat(reader.nextDouble()).isEqualTo(2.718281828459045);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.01);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(10.0);\r\n    assertThat(reader.nextDouble()).isEqualTo(10.0);\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testDoubles",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictNonFiniteDoubles() throws IOException {\r\n    String json \u003d \"[NaN]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictNonFiniteDoubles",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictQuotedNonFiniteDoubles() throws IOException {\r\n    String json \u003d \"[\\\"NaN\\\"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: NaN at line 1 column 7 path $[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictQuotedNonFiniteDoubles",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientNonFiniteDoubles() throws IOException {\r\n    String json \u003d \"[NaN, -Infinity, Infinity]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(Double.isNaN(reader.nextDouble())).isTrue();\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.NEGATIVE_INFINITY);\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.POSITIVE_INFINITY);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientNonFiniteDoubles",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientQuotedNonFiniteDoubles() throws IOException {\r\n    String json \u003d \"[\\\"NaN\\\", \\\"-Infinity\\\", \\\"Infinity\\\"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(Double.isNaN(reader.nextDouble())).isTrue();\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.NEGATIVE_INFINITY);\r\n    assertThat(reader.nextDouble()).isEqualTo(Double.POSITIVE_INFINITY);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientQuotedNonFiniteDoubles",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictNonFiniteDoublesWithSkipValue() throws IOException {\r\n    String json \u003d \"[NaN]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictNonFiniteDoublesWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLongs() throws IOException {\r\n    String json \u003d \"[0,0,0,\" + \"1,1,1,\" + \"-1,-1,-1,\" + \"-9223372036854775808,\" + \"9223372036854775807]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    assertThat(reader.nextLong()).isEqualTo(0L);\r\n    assertThat(reader.nextInt()).isEqualTo(0);\r\n    assertThat(reader.nextDouble()).isEqualTo(0.0);\r\n    assertThat(reader.nextLong()).isEqualTo(1L);\r\n    assertThat(reader.nextInt()).isEqualTo(1);\r\n    assertThat(reader.nextDouble()).isEqualTo(1.0);\r\n    assertThat(reader.nextLong()).isEqualTo(-1L);\r\n    assertThat(reader.nextInt()).isEqualTo(-1);\r\n    assertThat(reader.nextDouble()).isEqualTo(-1.0);\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextLong()).isEqualTo(Long.MIN_VALUE);\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextLong()).isEqualTo(Long.MAX_VALUE);\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLongs",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\n@Ignore(\"JsonReader advances after exception for invalid number was thrown; to be decided if that is acceptable\")\r\npublic void testNumberWithOctalPrefix() throws IOException {\r\n    String json \u003d \"[01]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"TODO\");\r\n    }\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"TODO\");\r\n    }\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"TODO\");\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"01\");\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testNumberWithOctalPrefix",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBooleans() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true,false]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextBoolean()).isFalse();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testBooleans",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPeekingUnquotedStringsPrefixedWithBooleans() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[truey]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a boolean\", \"STRING\", \"line 1 column 2 path $[0]\");\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"truey\");\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testPeekingUnquotedStringsPrefixedWithBooleans",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMalformedNumbers() throws IOException {\r\n    assertNotANumber(\"-\");\r\n    assertNotANumber(\".\");\r\n    // plus sign is not allowed for integer part\r\n    assertNotANumber(\"+1\");\r\n    // leading 0 is not allowed for integer part\r\n    assertNotANumber(\"00\");\r\n    assertNotANumber(\"01\");\r\n    // exponent lacks digit\r\n    assertNotANumber(\"e\");\r\n    assertNotANumber(\"0e\");\r\n    assertNotANumber(\".e\");\r\n    assertNotANumber(\"0.e\");\r\n    assertNotANumber(\"-.0e\");\r\n    // no integer\r\n    assertNotANumber(\"e1\");\r\n    assertNotANumber(\".e1\");\r\n    assertNotANumber(\"-e1\");\r\n    // trailing characters\r\n    assertNotANumber(\"1x\");\r\n    assertNotANumber(\"1.1x\");\r\n    assertNotANumber(\"1e1x\");\r\n    assertNotANumber(\"1ex\");\r\n    assertNotANumber(\"1.1ex\");\r\n    assertNotANumber(\"1.1e1x\");\r\n    // fraction has no digit\r\n    assertNotANumber(\"0.\");\r\n    assertNotANumber(\"-0.\");\r\n    assertNotANumber(\"0.e1\");\r\n    assertNotANumber(\"-0.e1\");\r\n    // no leading digit\r\n    assertNotANumber(\".0\");\r\n    assertNotANumber(\"-.0\");\r\n    assertNotANumber(\".0e1\");\r\n    assertNotANumber(\"-.0e1\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testMalformedNumbers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void assertNotANumber(String s) throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(s));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.STRING);\r\n    assertThat(reader.nextString()).isEqualTo(s);\r\n    JsonReader strictReader \u003d new JsonReader(reader(s));\r\n    try {\r\n        strictReader.nextDouble();\r\n        fail(\"Should have failed reading \" + s + \" as double\");\r\n    } catch (MalformedJsonException e) {\r\n        assertThat(e).hasMessageThat().startsWith(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "assertNotANumber",
      "parameterTypes": [
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[12.34e5x]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextString()).isEqualTo(\"12.34e5x\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testPeekingUnquotedStringsPrefixedWithIntegers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPeekLongMinValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[-9223372036854775808]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    assertThat(reader.nextLong()).isEqualTo(-9223372036854775808L);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testPeekLongMinValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPeekLongMaxValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[9223372036854775807]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    assertThat(reader.nextLong()).isEqualTo(9223372036854775807L);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testPeekLongMaxValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLongLargerThanMaxLongThatWrapsAround() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[22233720368547758070]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLongLargerThanMaxLongThatWrapsAround",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLongLargerThanMinLongThatWrapsAround() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[-22233720368547758070]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLongLargerThanMinLongThatWrapsAround",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Issue 1053, negative zero.\r\n */\r\n@Test\r\npublic void testNegativeZero() throws Exception {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[-0]\"));\r\n    reader.setStrictness(Strictness.LEGACY_STRICT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    assertThat(reader.nextString()).isEqualTo(\"-0\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testNegativeZero",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This test fails because there\u0027s no double for 9223372036854775808, and our\r\n * long parsing uses Double.parseDouble() for fractional values.\r\n */\r\n@Test\r\n@Ignore\r\npublic void testPeekLargerThanLongMaxValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[9223372036854775808]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException e) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testPeekLargerThanLongMaxValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This test fails because there\u0027s no double for -9223372036854775809, and our\r\n * long parsing uses Double.parseDouble() for fractional values.\r\n */\r\n@Test\r\n@Ignore\r\npublic void testPeekLargerThanLongMinValue() throws IOException {\r\n    @SuppressWarnings(\"FloatingPointLiteralPrecision\")\r\n    double d \u003d -9223372036854775809d;\r\n    JsonReader reader \u003d new JsonReader(reader(\"[-9223372036854775809]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextDouble()).isEqualTo(d);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testPeekLargerThanLongMinValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This test fails because there\u0027s no double for 9223372036854775806, and\r\n * our long parsing uses Double.parseDouble() for fractional values.\r\n */\r\n@Test\r\n@Ignore\r\npublic void testHighPrecisionLong() throws IOException {\r\n    String json \u003d \"[9223372036854775806.000]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    assertThat(reader.nextLong()).isEqualTo(9223372036854775806L);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testHighPrecisionLong",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPeekMuchLargerThanLongMinValue() throws IOException {\r\n    @SuppressWarnings(\"FloatingPointLiteralPrecision\")\r\n    double d \u003d -92233720368547758080d;\r\n    JsonReader reader \u003d new JsonReader(reader(\"[-92233720368547758080]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(NUMBER);\r\n    try {\r\n        reader.nextLong();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextDouble()).isEqualTo(d);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testPeekMuchLargerThanLongMinValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testQuotedNumberWithEscape() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\\"12\\\\u00334\\\"]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n    assertThat(reader.nextInt()).isEqualTo(1234);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testQuotedNumberWithEscape",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMixedCaseLiterals() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[True,TruE,False,FALSE,NULL,nulL]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextBoolean()).isFalse();\r\n    assertThat(reader.nextBoolean()).isFalse();\r\n    reader.nextNull();\r\n    reader.nextNull();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testMixedCaseLiterals",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMissingValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected value at line 1 column 6 path $.a\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testMissingValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrematureEndOfInput() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":true,\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (EOFException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testPrematureEndOfInput",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrematurelyClosed() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":[]}\"));\r\n    reader.beginObject();\r\n    reader.close();\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"JsonReader is closed\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\":[]}\"));\r\n    reader.close();\r\n    try {\r\n        reader.beginObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"JsonReader is closed\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\":true}\"));\r\n    reader.beginObject();\r\n    String unused1 \u003d reader.nextName();\r\n    JsonToken unused2 \u003d reader.peek();\r\n    reader.close();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"JsonReader is closed\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testPrematurelyClosed",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNextFailuresDoNotAdvance() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":true}\"));\r\n    reader.beginObject();\r\n    try {\r\n        String unused \u003d reader.nextString();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a string\", \"NAME\", \"line 1 column 3 path $.\");\r\n    }\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        String unused \u003d reader.nextName();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a name\", \"BOOLEAN\", \"line 1 column 10 path $.a\");\r\n    }\r\n    try {\r\n        reader.beginArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"BEGIN_ARRAY\", \"BOOLEAN\", \"line 1 column 10 path $.a\");\r\n    }\r\n    try {\r\n        reader.endArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"END_ARRAY\", \"BOOLEAN\", \"line 1 column 10 path $.a\");\r\n    }\r\n    try {\r\n        reader.beginObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"BEGIN_OBJECT\", \"BOOLEAN\", \"line 1 column 10 path $.a\");\r\n    }\r\n    try {\r\n        reader.endObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"END_OBJECT\", \"BOOLEAN\", \"line 1 column 10 path $.a\");\r\n    }\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a string\", \"END_OBJECT\", \"line 1 column 11 path $.a\");\r\n    }\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a name\", \"END_OBJECT\", \"line 1 column 11 path $.a\");\r\n    }\r\n    try {\r\n        reader.beginArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"BEGIN_ARRAY\", \"END_OBJECT\", \"line 1 column 11 path $.a\");\r\n    }\r\n    try {\r\n        reader.endArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"END_ARRAY\", \"END_OBJECT\", \"line 1 column 11 path $.a\");\r\n    }\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    reader.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testNextFailuresDoNotAdvance",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIntegerMismatchFailuresDoNotAdvance() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[1.5]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextInt();\r\n        fail();\r\n    } catch (NumberFormatException expected) {\r\n    }\r\n    assertThat(reader.nextDouble()).isEqualTo(1.5d);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testIntegerMismatchFailuresDoNotAdvance",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringNullIsNotNull() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\\"null\\\"]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"null\", \"STRING\", \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStringNullIsNotNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullLiteralIsNotAString() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[null]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertUnexpectedStructureError(expected, \"a string\", \"NULL\", \"line 1 column 6 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testNullLiteralIsNotAString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictNameValueSeparator() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003dtrue}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003d\u003etrue}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictNameValueSeparator",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientNameValueSeparator() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003dtrue}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003d\u003etrue}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientNameValueSeparator",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictNameValueSeparatorWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003dtrue}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\"\u003d\u003etrue}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictNameValueSeparatorWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testCommentsInStringValue() throws Exception {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\\"// comment\\\"]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"// comment\");\r\n    reader.endArray();\r\n    reader \u003d new JsonReader(reader(\"{\\\"a\\\":\\\"#someComment\\\"}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"#someComment\");\r\n    reader.endObject();\r\n    reader \u003d new JsonReader(reader(\"{\\\"#//a\\\":\\\"#some //Comment\\\"}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"#//a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"#some //Comment\");\r\n    reader.endObject();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testCommentsInStringValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictComments() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[// comment \\n true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[# comment \\n true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[/* comment */ true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictComments",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientComments() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[// comment \\n true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader \u003d new JsonReader(reader(\"[# comment \\n true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader \u003d new JsonReader(reader(\"[/* comment */ true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientComments",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictCommentsWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[// comment \\n true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[# comment \\n true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[/* comment */ true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictCommentsWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictUnquotedNames() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{a:true}\"));\r\n    reader.beginObject();\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictUnquotedNames",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientUnquotedNames() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{a:true}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientUnquotedNames",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictUnquotedNamesWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{a:true}\"));\r\n    reader.beginObject();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictUnquotedNamesWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictSingleQuotedNames() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\u0027a\u0027:true}\"));\r\n    reader.beginObject();\r\n    try {\r\n        reader.nextName();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictSingleQuotedNames",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientSingleQuotedNames() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\u0027a\u0027:true}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientSingleQuotedNames",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictSingleQuotedNamesWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\u0027a\u0027:true}\"));\r\n    reader.beginObject();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictSingleQuotedNamesWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictUnquotedStrings() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[a]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictUnquotedStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictUnquotedStringsWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[a]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictUnquotedStringsWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientUnquotedStrings() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[a]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"a\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientUnquotedStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictSingleQuotedStrings() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\u0027a\u0027]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictSingleQuotedStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientSingleQuotedStrings() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\u0027a\u0027]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(\"a\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientSingleQuotedStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictSingleQuotedStringsWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\u0027a\u0027]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictSingleQuotedStringsWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictSemicolonDelimitedArray() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true;true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        boolean unused \u003d reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictSemicolonDelimitedArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientSemicolonDelimitedArray() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true;true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientSemicolonDelimitedArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictSemicolonDelimitedArrayWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true;true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictSemicolonDelimitedArrayWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictSemicolonDelimitedNameValuePair() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":true;\\\"b\\\":true}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        boolean unused \u003d reader.nextBoolean();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictSemicolonDelimitedNameValuePair",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientSemicolonDelimitedNameValuePair() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":true;\\\"b\\\":true}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.nextName()).isEqualTo(\"b\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientSemicolonDelimitedNameValuePair",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictSemicolonDelimitedNameValuePairWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":true;\\\"b\\\":true}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 6 path $.a\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictSemicolonDelimitedNameValuePairWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictUnnecessaryArraySeparators() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true,,true]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 8 path $[1]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[,true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[true,]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 8 path $[1]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[,]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextNull();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictUnnecessaryArraySeparators",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientUnnecessaryArraySeparators() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true,,true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.nextNull();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.endArray();\r\n    reader \u003d new JsonReader(reader(\"[,true]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.nextNull();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.endArray();\r\n    reader \u003d new JsonReader(reader(\"[true,]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.nextNull();\r\n    reader.endArray();\r\n    reader \u003d new JsonReader(reader(\"[,]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.nextNull();\r\n    reader.nextNull();\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientUnnecessaryArraySeparators",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictUnnecessaryArraySeparatorsWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[true,,true]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 8 path $[1]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[,true]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[true,]\"));\r\n    reader.beginArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 8 path $[1]\");\r\n    }\r\n    reader \u003d new JsonReader(reader(\"[,]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 3 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictUnnecessaryArraySeparatorsWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictMultipleTopLevelValues() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[] []\"));\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 5 path $\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictMultipleTopLevelValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientMultipleTopLevelValues() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[] true {}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    reader.beginObject();\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientMultipleTopLevelValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictMultipleTopLevelValuesWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[] []\"));\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 5 path $\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictMultipleTopLevelValuesWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelValueTypes() throws IOException {\r\n    JsonReader reader1 \u003d new JsonReader(reader(\"true\"));\r\n    assertThat(reader1.nextBoolean()).isTrue();\r\n    assertThat(reader1.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    JsonReader reader2 \u003d new JsonReader(reader(\"false\"));\r\n    assertThat(reader2.nextBoolean()).isFalse();\r\n    assertThat(reader2.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    JsonReader reader3 \u003d new JsonReader(reader(\"null\"));\r\n    assertThat(reader3.peek()).isEqualTo(JsonToken.NULL);\r\n    reader3.nextNull();\r\n    assertThat(reader3.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    JsonReader reader4 \u003d new JsonReader(reader(\"123\"));\r\n    assertThat(reader4.nextInt()).isEqualTo(123);\r\n    assertThat(reader4.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    JsonReader reader5 \u003d new JsonReader(reader(\"123.4\"));\r\n    assertThat(reader5.nextDouble()).isEqualTo(123.4);\r\n    assertThat(reader5.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n    JsonReader reader6 \u003d new JsonReader(reader(\"\\\"a\\\"\"));\r\n    assertThat(reader6.nextString()).isEqualTo(\"a\");\r\n    assertThat(reader6.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testTopLevelValueTypes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelValueTypeWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"true\"));\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testTopLevelValueTypeWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictNonExecutePrefix() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\")]}\u0027\\n []\"));\r\n    try {\r\n        reader.beginArray();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 1 path $\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictNonExecutePrefix",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictNonExecutePrefixWithSkipValue() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\")]}\u0027\\n []\"));\r\n    try {\r\n        reader.skipValue();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 1 path $\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictNonExecutePrefixWithSkipValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientNonExecutePrefix() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\")]}\u0027\\n []\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientNonExecutePrefix",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientNonExecutePrefixWithLeadingWhitespace() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"\\r\\n \\t)]}\u0027\\n []\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientNonExecutePrefixWithLeadingWhitespace",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientPartialNonExecutePrefix() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\")]}\u0027 []\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    assertThat(reader.nextString()).isEqualTo(\")\");\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unexpected value at line 1 column 3 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientPartialNonExecutePrefix",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBomIgnoredAsFirstCharacterOfDocument() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"\\ufeff[]\"));\r\n    reader.beginArray();\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testBomIgnoredAsFirstCharacterOfDocument",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBomForbiddenAsOtherCharacterInDocument() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\ufeff]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.endArray();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testBomForbiddenAsOtherCharacterInDocument",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailWithPosition() throws IOException {\r\n    testFailWithPosition(\"Expected value at line 6 column 5 path $[1]\", \"[\\n\\n\\n\\n\\n\\\"a\\\",}]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithPosition",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailWithPositionGreaterThanBufferSize() throws IOException {\r\n    String spaces \u003d repeat(\u0027 \u0027, 8192);\r\n    testFailWithPosition(\"Expected value at line 6 column 5 path $[1]\", \"[\\n\\n\" + spaces + \"\\n\\n\\n\\\"a\\\",}]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithPositionGreaterThanBufferSize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailWithPositionOverSlashSlashEndOfLineComment() throws IOException {\r\n    testFailWithPosition(\"Expected value at line 5 column 6 path $[1]\", \"\\n// foo\\n\\n//bar\\r\\n[\\\"a\\\",}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithPositionOverSlashSlashEndOfLineComment",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailWithPositionOverHashEndOfLineComment() throws IOException {\r\n    testFailWithPosition(\"Expected value at line 5 column 6 path $[1]\", \"\\n# foo\\n\\n#bar\\r\\n[\\\"a\\\",}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithPositionOverHashEndOfLineComment",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailWithPositionOverCStyleComment() throws IOException {\r\n    testFailWithPosition(\"Expected value at line 6 column 12 path $[1]\", \"\\n\\n/* foo\\n*\\n*\\r\\nbar */[\\\"a\\\",}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithPositionOverCStyleComment",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailWithPositionOverQuotedString() throws IOException {\r\n    testFailWithPosition(\"Expected value at line 5 column 3 path $[1]\", \"[\\\"foo\\nbar\\r\\nbaz\\n\\\",\\n  }\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithPositionOverQuotedString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailWithPositionOverUnquotedString() throws IOException {\r\n    testFailWithPosition(\"Expected value at line 5 column 2 path $[1]\", \"[\\n\\nabcd\\n\\n,}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithPositionOverUnquotedString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailWithEscapedNewlineCharacter() throws IOException {\r\n    testFailWithPosition(\"Expected value at line 5 column 3 path $[1]\", \"[\\n\\n\\\"\\\\\\n\\n\\\",}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithEscapedNewlineCharacter",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailWithPositionIsOffsetByBom() throws IOException {\r\n    testFailWithPosition(\"Expected value at line 1 column 6 path $[1]\", \"\\ufeff[\\\"a\\\",}]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithPositionIsOffsetByBom",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void testFailWithPosition(String message, String json) throws IOException {\r\n    // Validate that it works reading the string normally.\r\n    JsonReader reader1 \u003d new JsonReader(reader(json));\r\n    reader1.setStrictness(Strictness.LENIENT);\r\n    reader1.beginArray();\r\n    String unused1 \u003d reader1.nextString();\r\n    try {\r\n        JsonToken unused2 \u003d reader1.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(message + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n    // Also validate that it works when skipping.\r\n    JsonReader reader2 \u003d new JsonReader(reader(json));\r\n    reader2.setStrictness(Strictness.LENIENT);\r\n    reader2.beginArray();\r\n    reader2.skipValue();\r\n    try {\r\n        JsonToken unused3 \u003d reader2.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(message + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithPosition",
      "parameterTypes": [
        "String",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFailWithPositionDeepPath() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[1,{\\\"a\\\":[2,3,}\"));\r\n    reader.beginArray();\r\n    int unused1 \u003d reader.nextInt();\r\n    reader.beginObject();\r\n    String unused2 \u003d reader.nextName();\r\n    reader.beginArray();\r\n    int unused3 \u003d reader.nextInt();\r\n    int unused4 \u003d reader.nextInt();\r\n    try {\r\n        JsonToken unused5 \u003d reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected value at line 1 column 14 path $[1].a[2]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testFailWithPositionDeepPath",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictVeryLongNumber() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[0.\" + repeat(\u00279\u0027, 8192) + \"]\"));\r\n    reader.beginArray();\r\n    try {\r\n        reader.nextDouble();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertStrictError(expected, \"line 1 column 2 path $[0]\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictVeryLongNumber",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientVeryLongNumber() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[0.\" + repeat(\u00279\u0027, 8192) + \"]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.STRING);\r\n    assertThat(reader.nextDouble()).isEqualTo(1d);\r\n    reader.endArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientVeryLongNumber",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVeryLongUnquotedLiteral() throws IOException {\r\n    String literal \u003d \"a\" + repeat(\u0027b\u0027, 8192) + \"c\";\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\" + literal + \"]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(literal);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testVeryLongUnquotedLiteral",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeeplyNestedArrays() throws IOException {\r\n    // this is nested 40 levels deep; Gson is tuned for nesting is 30 levels deep or fewer\r\n    JsonReader reader \u003d new JsonReader(reader(\"[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\"));\r\n    for (int i \u003d 0; i \u003c 40; i++) {\r\n        reader.beginArray();\r\n    }\r\n    assertThat(reader.getPath()).isEqualTo(\"$[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]\" + \"[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]\");\r\n    for (int i \u003d 0; i \u003c 40; i++) {\r\n        reader.endArray();\r\n    }\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testDeeplyNestedArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeeplyNestedObjects() throws IOException {\r\n    // Build a JSON document structured like {\"a\":{\"a\":{\"a\":{\"a\":true}}}}, but 40 levels deep\r\n    String array \u003d \"{\\\"a\\\":%s}\";\r\n    String json \u003d \"true\";\r\n    for (int i \u003d 0; i \u003c 40; i++) {\r\n        json \u003d String.format(array, json);\r\n    }\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    for (int i \u003d 0; i \u003c 40; i++) {\r\n        reader.beginObject();\r\n        assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    }\r\n    assertThat(reader.getPath()).isEqualTo(\"$.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a\" + \".a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a\");\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    for (int i \u003d 0; i \u003c 40; i++) {\r\n        reader.endObject();\r\n    }\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testDeeplyNestedObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// http://code.google.com/p/google-gson/issues/detail?id\u003d409\r\n@Test\r\npublic void testStringEndingInSlash() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"/\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected value at line 1 column 1 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStringEndingInSlash",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDocumentWithCommentEndingInSlash() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"/* foo *//\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected value at line 1 column 10 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testDocumentWithCommentEndingInSlash",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringWithLeadingSlash() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"/x\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected value at line 1 column 1 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStringWithLeadingSlash",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUnterminatedObject() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":\\\"android\\\"x\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"android\");\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unterminated object at line 1 column 16 path $.a\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testUnterminatedObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVeryLongQuotedString() throws IOException {\r\n    char[] stringChars \u003d new char[1024 * 16];\r\n    Arrays.fill(stringChars, \u0027x\u0027);\r\n    String string \u003d new String(stringChars);\r\n    String json \u003d \"[\\\"\" + string + \"\\\"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(string);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testVeryLongQuotedString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVeryLongUnquotedString() throws IOException {\r\n    char[] stringChars \u003d new char[1024 * 16];\r\n    Arrays.fill(stringChars, \u0027x\u0027);\r\n    String string \u003d new String(stringChars);\r\n    String json \u003d \"[\" + string + \"]\";\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(string);\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testVeryLongUnquotedString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testVeryLongUnterminatedString() throws IOException {\r\n    char[] stringChars \u003d new char[1024 * 16];\r\n    Arrays.fill(stringChars, \u0027x\u0027);\r\n    String string \u003d new String(stringChars);\r\n    String json \u003d \"[\" + string;\r\n    JsonReader reader \u003d new JsonReader(reader(json));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.nextString()).isEqualTo(string);\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (EOFException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testVeryLongUnterminatedString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipVeryLongUnquotedString() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\" + repeat(\u0027x\u0027, 8192) + \"]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipVeryLongUnquotedString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipTopLevelUnquotedString() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(repeat(\u0027x\u0027, 8192)));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipTopLevelUnquotedString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipVeryLongQuotedString() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\\"\" + repeat(\u0027x\u0027, 8192) + \"\\\"]\"));\r\n    reader.beginArray();\r\n    reader.skipValue();\r\n    reader.endArray();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipVeryLongQuotedString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSkipTopLevelQuotedString() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"\\\"\" + repeat(\u0027x\u0027, 8192) + \"\\\"\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.skipValue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testSkipTopLevelQuotedString",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringAsNumberWithTruncatedExponent() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[123e]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStringAsNumberWithTruncatedExponent",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringAsNumberWithDigitAndNonDigitExponent() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[123e4b]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStringAsNumberWithDigitAndNonDigitExponent",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStringAsNumberWithNonDigitExponent() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[123eb]\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(STRING);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStringAsNumberWithNonDigitExponent",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyStringName() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"\\\":true}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    assertThat(reader.peek()).isEqualTo(BEGIN_OBJECT);\r\n    reader.beginObject();\r\n    assertThat(reader.peek()).isEqualTo(NAME);\r\n    assertThat(reader.nextName()).isEqualTo(\"\");\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.BOOLEAN);\r\n    assertThat(reader.nextBoolean()).isTrue();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_OBJECT);\r\n    reader.endObject();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.END_DOCUMENT);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testEmptyStringName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrictExtraCommasInMaps() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":\\\"b\\\",}\"));\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"b\");\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected name at line 1 column 11 path $.a\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testStrictExtraCommasInMaps",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLenientExtraCommasInMaps() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"{\\\"a\\\":\\\"b\\\",}\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginObject();\r\n    assertThat(reader.nextName()).isEqualTo(\"a\");\r\n    assertThat(reader.nextString()).isEqualTo(\"b\");\r\n    try {\r\n        reader.peek();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Expected name at line 1 column 11 path $.a\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testLenientExtraCommasInMaps",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private String repeat(char c, int count) {\r\n    char[] array \u003d new char[count];\r\n    Arrays.fill(array, c);\r\n    return new String(array);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "repeat",
      "parameterTypes": [
        "char",
        "int"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMalformedDocuments() throws IOException {\r\n    assertDocument(\"{]\", BEGIN_OBJECT, MalformedJsonException.class);\r\n    assertDocument(\"{,\", BEGIN_OBJECT, MalformedJsonException.class);\r\n    assertDocument(\"{{\", BEGIN_OBJECT, MalformedJsonException.class);\r\n    assertDocument(\"{[\", BEGIN_OBJECT, MalformedJsonException.class);\r\n    assertDocument(\"{:\", BEGIN_OBJECT, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\",\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\",\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\":}\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"::\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\":,\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d}\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e}\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e\\\"string\\\":\", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e\\\"string\\\"\u003d\", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e\\\"string\\\"\u003d\u003e\", BEGIN_OBJECT, NAME, STRING, MalformedJsonException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e\\\"string\\\",\", BEGIN_OBJECT, NAME, STRING, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\"\u003d\u003e\\\"string\\\",\\\"name\\\"\", BEGIN_OBJECT, NAME, STRING, NAME);\r\n    assertDocument(\"[}\", BEGIN_ARRAY, MalformedJsonException.class);\r\n    assertDocument(\"[,]\", BEGIN_ARRAY, NULL, NULL, END_ARRAY);\r\n    assertDocument(\"{\", BEGIN_OBJECT, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\"\", BEGIN_OBJECT, NAME, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\",\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{\u0027name\u0027\", BEGIN_OBJECT, NAME, EOFException.class);\r\n    assertDocument(\"{\u0027name\u0027,\", BEGIN_OBJECT, NAME, MalformedJsonException.class);\r\n    assertDocument(\"{name\", BEGIN_OBJECT, NAME, EOFException.class);\r\n    assertDocument(\"[\", BEGIN_ARRAY, EOFException.class);\r\n    assertDocument(\"[string\", BEGIN_ARRAY, STRING, EOFException.class);\r\n    assertDocument(\"[\\\"string\\\"\", BEGIN_ARRAY, STRING, EOFException.class);\r\n    assertDocument(\"[\u0027string\u0027\", BEGIN_ARRAY, STRING, EOFException.class);\r\n    assertDocument(\"[123\", BEGIN_ARRAY, NUMBER, EOFException.class);\r\n    assertDocument(\"[123,\", BEGIN_ARRAY, NUMBER, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":123\", BEGIN_OBJECT, NAME, NUMBER, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":123,\", BEGIN_OBJECT, NAME, NUMBER, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":\\\"string\\\"\", BEGIN_OBJECT, NAME, STRING, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":\\\"string\\\",\", BEGIN_OBJECT, NAME, STRING, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":\u0027string\u0027\", BEGIN_OBJECT, NAME, STRING, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":\u0027string\u0027,\", BEGIN_OBJECT, NAME, STRING, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":false\", BEGIN_OBJECT, NAME, BOOLEAN, EOFException.class);\r\n    assertDocument(\"{\\\"name\\\":false,,\", BEGIN_OBJECT, NAME, BOOLEAN, MalformedJsonException.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testMalformedDocuments",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This test behave slightly differently in Gson 2.2 and earlier. It fails\r\n * during peek rather than during nextString().\r\n */\r\n@Test\r\npublic void testUnterminatedStringFailure() throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(\"[\\\"string\"));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    reader.beginArray();\r\n    assertThat(reader.peek()).isEqualTo(JsonToken.STRING);\r\n    try {\r\n        reader.nextString();\r\n        fail();\r\n    } catch (MalformedJsonException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Unterminated string at line 1 column 9 path $[0]\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testUnterminatedStringFailure",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Regression test for an issue with buffer filling and consumeNonExecutePrefix.\r\n */\r\n@Test\r\npublic void testReadAcrossBuffers() throws IOException {\r\n    StringBuilder sb \u003d new StringBuilder(\"#\");\r\n    for (int i \u003d 0; i \u003c JsonReader.BUFFER_SIZE - 3; i++) {\r\n        sb.append(\u0027 \u0027);\r\n    }\r\n    sb.append(\"\\n)]}\u0027\\n3\");\r\n    JsonReader reader \u003d new JsonReader(reader(sb.toString()));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    JsonToken token \u003d reader.peek();\r\n    assertThat(token).isEqualTo(JsonToken.NUMBER);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "testReadAcrossBuffers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void assertStrictError(MalformedJsonException exception, String expectedLocation) {\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON at \" + expectedLocation + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "assertStrictError",
      "parameterTypes": [
        "MalformedJsonException",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void assertUnexpectedStructureError(IllegalStateException exception, String expectedToken, String actualToken, String expectedLocation) {\r\n    String troubleshootingId \u003d actualToken.equals(\"NULL\") ? \"adapter-not-null-safe\" : \"unexpected-json-structure\";\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"Expected \" + expectedToken + \" but was \" + actualToken + \" at \" + expectedLocation + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#\" + troubleshootingId);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "assertUnexpectedStructureError",
      "parameterTypes": [
        "IllegalStateException",
        "String",
        "String",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void assertDocument(String document, Object... expectations) throws IOException {\r\n    JsonReader reader \u003d new JsonReader(reader(document));\r\n    reader.setStrictness(Strictness.LENIENT);\r\n    for (Object expectation : expectations) {\r\n        if (expectation \u003d\u003d BEGIN_OBJECT) {\r\n            reader.beginObject();\r\n        } else if (expectation \u003d\u003d BEGIN_ARRAY) {\r\n            reader.beginArray();\r\n        } else if (expectation \u003d\u003d END_OBJECT) {\r\n            reader.endObject();\r\n        } else if (expectation \u003d\u003d END_ARRAY) {\r\n            reader.endArray();\r\n        } else if (expectation \u003d\u003d NAME) {\r\n            assertThat(reader.nextName()).isEqualTo(\"name\");\r\n        } else if (expectation \u003d\u003d BOOLEAN) {\r\n            assertThat(reader.nextBoolean()).isFalse();\r\n        } else if (expectation \u003d\u003d STRING) {\r\n            assertThat(reader.nextString()).isEqualTo(\"string\");\r\n        } else if (expectation \u003d\u003d NUMBER) {\r\n            assertThat(reader.nextInt()).isEqualTo(123);\r\n        } else if (expectation \u003d\u003d NULL) {\r\n            reader.nextNull();\r\n        } else if (expectation instanceof Class \u0026\u0026 Exception.class.isAssignableFrom((Class\u003c?\u003e) expectation)) {\r\n            try {\r\n                reader.peek();\r\n                fail();\r\n            } catch (Exception expected) {\r\n                assertThat(expected.getClass()).isEqualTo((Class\u003c?\u003e) expectation);\r\n            }\r\n        } else {\r\n            throw new AssertionError(\"Unsupported expectation value: \" + expectation);\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "assertDocument",
      "parameterTypes": [
        "String",
        "Object"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns a reader that returns one character at a time.\r\n */\r\nprivate Reader reader(final String s) {\r\n    /* if (true) */\r\n    return new StringReader(s);\r\n    /* return new Reader() {\r\n      int position \u003d 0;\r\n      @Override public int read(char[] buffer, int offset, int count) throws IOException {\r\n        if (position \u003d\u003d s.length()) {\r\n          return -1;\r\n        } else if (count \u003e 0) {\r\n          buffer[offset] \u003d s.charAt(position++);\r\n          return 1;\r\n        } else {\r\n          throw new IllegalArgumentException();\r\n        }\r\n      }\r\n      @Override public void close() throws IOException {\r\n      }\r\n    }; */\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonReaderTest",
      "methodName": "reader",
      "parameterTypes": [
        "String"
      ],
      "returnType": "Reader"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDefaultStrictness() throws IOException {\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    assertThat(jsonWriter.getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n    jsonWriter.value(false);\r\n    jsonWriter.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testDefaultStrictness",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// for JsonWriter.setLenient\r\n@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testSetLenientTrue() throws IOException {\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.setLenient(true);\r\n    assertThat(jsonWriter.getStrictness()).isEqualTo(Strictness.LENIENT);\r\n    jsonWriter.value(false);\r\n    jsonWriter.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testSetLenientTrue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// for JsonWriter.setLenient\r\n@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testSetLenientFalse() throws IOException {\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.setLenient(false);\r\n    assertThat(jsonWriter.getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n    jsonWriter.value(false);\r\n    jsonWriter.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testSetLenientFalse",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSetStrictness() throws IOException {\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    jsonWriter.setStrictness(Strictness.STRICT);\r\n    assertThat(jsonWriter.getStrictness()).isEqualTo(Strictness.STRICT);\r\n    jsonWriter.value(false);\r\n    jsonWriter.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testSetStrictness",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSetStrictnessNull() throws IOException {\r\n    JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n    assertThrows(NullPointerException.class, () -\u003e jsonWriter.setStrictness(null));\r\n    jsonWriter.value(false);\r\n    jsonWriter.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testSetStrictnessNull",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTopLevelValueTypes() throws IOException {\r\n    StringWriter string1 \u003d new StringWriter();\r\n    JsonWriter writer1 \u003d new JsonWriter(string1);\r\n    writer1.value(true);\r\n    writer1.close();\r\n    assertThat(string1.toString()).isEqualTo(\"true\");\r\n    StringWriter string2 \u003d new StringWriter();\r\n    JsonWriter writer2 \u003d new JsonWriter(string2);\r\n    writer2.nullValue();\r\n    writer2.close();\r\n    assertThat(string2.toString()).isEqualTo(\"null\");\r\n    StringWriter string3 \u003d new StringWriter();\r\n    JsonWriter writer3 \u003d new JsonWriter(string3);\r\n    writer3.value(123);\r\n    writer3.close();\r\n    assertThat(string3.toString()).isEqualTo(\"123\");\r\n    StringWriter string4 \u003d new StringWriter();\r\n    JsonWriter writer4 \u003d new JsonWriter(string4);\r\n    writer4.value(123.4);\r\n    writer4.close();\r\n    assertThat(string4.toString()).isEqualTo(\"123.4\");\r\n    StringWriter string5 \u003d new StringWriter();\r\n    JsonWriter writert \u003d new JsonWriter(string5);\r\n    writert.value(\"a\");\r\n    writert.close();\r\n    assertThat(string5.toString()).isEqualTo(\"\\\"a\\\"\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testTopLevelValueTypes",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNameAsTopLevelValue() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e jsonWriter.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n    jsonWriter.value(12);\r\n    jsonWriter.close();\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e jsonWriter.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"JsonWriter is closed.\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNameAsTopLevelValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNameInArray() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e jsonWriter.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n    jsonWriter.value(12);\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e jsonWriter.name(\"hello\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Please begin an object before writing a name.\");\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[12]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNameInArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testTwoNames() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    try {\r\n        jsonWriter.name(\"a\");\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Already wrote a name, expecting a value.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testTwoNames",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNameWithoutValue() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    try {\r\n        jsonWriter.endObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Dangling name: a\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNameWithoutValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testValueWithoutName() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    try {\r\n        jsonWriter.value(true);\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Nesting problem.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testValueWithoutName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultipleTopLevelValues() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray().endArray();\r\n    IllegalStateException expected \u003d assertThrows(IllegalStateException.class, jsonWriter::beginArray);\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"JSON must have only one top-level value.\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testMultipleTopLevelValues",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultipleTopLevelValuesStrict() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.STRICT);\r\n    jsonWriter.beginArray().endArray();\r\n    IllegalStateException expected \u003d assertThrows(IllegalStateException.class, jsonWriter::beginArray);\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"JSON must have only one top-level value.\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testMultipleTopLevelValuesStrict",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMultipleTopLevelValuesLenient() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.setStrictness(Strictness.LENIENT);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[][]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testMultipleTopLevelValuesLenient",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBadNestingObject() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.beginObject();\r\n    try {\r\n        jsonWriter.endArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Nesting problem.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testBadNestingObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBadNestingArray() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.beginArray();\r\n    try {\r\n        jsonWriter.endObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected).hasMessageThat().isEqualTo(\"Nesting problem.\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testBadNestingArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullName() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    try {\r\n        jsonWriter.name(null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNullName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullStringValue() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    jsonWriter.value((String) null);\r\n    jsonWriter.endObject();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{\\\"a\\\":null}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNullStringValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testJsonValue() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    jsonWriter.jsonValue(\"{\\\"b\\\":true}\");\r\n    jsonWriter.name(\"c\");\r\n    jsonWriter.value(1);\r\n    jsonWriter.endObject();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{\\\"a\\\":{\\\"b\\\":true},\\\"c\\\":1}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testJsonValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonFiniteFloats() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.NaN));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.NEGATIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.POSITIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNonFiniteFloats",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonFiniteFloatsWhenStrict() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.STRICT);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.NaN));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.NEGATIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Float.POSITIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNonFiniteFloatsWhenStrict",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonFiniteDoubles() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.NaN));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.NEGATIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.POSITIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNonFiniteDoubles",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonFiniteDoublesWhenStrict() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.STRICT);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.NaN));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.NEGATIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.POSITIVE_INFINITY));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNonFiniteDoublesWhenStrict",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonFiniteNumbers() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.NaN)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNonFiniteNumbers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonFiniteNumbersWhenStrict() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.STRICT);\r\n    jsonWriter.beginArray();\r\n    IllegalArgumentException expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.NaN)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was -Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n    expected \u003d assertThrows(IllegalArgumentException.class, () -\u003e jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\r\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was Infinity\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNonFiniteNumbersWhenStrict",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonFiniteFloatsWhenLenient() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.LENIENT);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(Float.NaN);\r\n    jsonWriter.value(Float.NEGATIVE_INFINITY);\r\n    jsonWriter.value(Float.POSITIVE_INFINITY);\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[NaN,-Infinity,Infinity]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNonFiniteFloatsWhenLenient",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonFiniteDoublesWhenLenient() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.LENIENT);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(Double.NaN);\r\n    jsonWriter.value(Double.NEGATIVE_INFINITY);\r\n    jsonWriter.value(Double.POSITIVE_INFINITY);\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[NaN,-Infinity,Infinity]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNonFiniteDoublesWhenLenient",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNonFiniteNumbersWhenLenient() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setStrictness(Strictness.LENIENT);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(Double.valueOf(Double.NaN));\r\n    jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY));\r\n    jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY));\r\n    jsonWriter.value(new LazilyParsedNumber(\"Infinity\"));\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[NaN,-Infinity,Infinity,Infinity]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNonFiniteNumbersWhenLenient",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testFloats() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(-0.0f);\r\n    jsonWriter.value(1.0f);\r\n    jsonWriter.value(Float.MAX_VALUE);\r\n    jsonWriter.value(Float.MIN_VALUE);\r\n    jsonWriter.value(0.0f);\r\n    jsonWriter.value(-0.5f);\r\n    jsonWriter.value(2.2250739E-38f);\r\n    jsonWriter.value(3.723379f);\r\n    jsonWriter.value((float) Math.PI);\r\n    jsonWriter.value((float) Math.E);\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[-0.0,\" + \"1.0,\" + \"3.4028235E38,\" + \"1.4E-45,\" + \"0.0,\" + \"-0.5,\" + \"2.2250739E-38,\" + \"3.723379,\" + \"3.1415927,\" + \"2.7182817]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testFloats",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDoubles() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(-0.0);\r\n    jsonWriter.value(1.0);\r\n    jsonWriter.value(Double.MAX_VALUE);\r\n    jsonWriter.value(Double.MIN_VALUE);\r\n    jsonWriter.value(0.0);\r\n    jsonWriter.value(-0.5);\r\n    jsonWriter.value(2.2250738585072014E-308);\r\n    jsonWriter.value(Math.PI);\r\n    jsonWriter.value(Math.E);\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[-0.0,\" + \"1.0,\" + \"1.7976931348623157E308,\" + \"4.9E-324,\" + \"0.0,\" + \"-0.5,\" + \"2.2250738585072014E-308,\" + \"3.141592653589793,\" + \"2.718281828459045]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testDoubles",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLongs() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(0);\r\n    jsonWriter.value(1);\r\n    jsonWriter.value(-1);\r\n    jsonWriter.value(Long.MIN_VALUE);\r\n    jsonWriter.value(Long.MAX_VALUE);\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[0,\" + \"1,\" + \"-1,\" + \"-9223372036854775808,\" + \"9223372036854775807]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testLongs",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNumbers() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(new BigInteger(\"0\"));\r\n    jsonWriter.value(new BigInteger(\"9223372036854775808\"));\r\n    jsonWriter.value(new BigInteger(\"-9223372036854775809\"));\r\n    jsonWriter.value(new BigDecimal(\"3.141592653589793238462643383\"));\r\n    jsonWriter.endArray();\r\n    jsonWriter.close();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[0,\" + \"9223372036854775808,\" + \"-9223372036854775809,\" + \"3.141592653589793238462643383]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNumbers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests writing {@code Number} instances which are not one of the standard JDK ones.\r\n */\r\n@Test\r\npublic void testNumbersCustomClass() throws IOException {\r\n    String[] validNumbers \u003d { \"-0.0\", \"1.0\", \"1.7976931348623157E308\", \"4.9E-324\", \"0.0\", \"0.00\", \"-0.5\", \"2.2250738585072014E-308\", \"3.141592653589793\", \"2.718281828459045\", \"0\", \"0.01\", \"0e0\", \"1e+0\", \"1e-0\", // leading 0 is allowed for exponent\r\n    \"1e0000\", \"1e00001\", \"1e+1\" };\r\n    for (String validNumber : validNumbers) {\r\n        StringWriter stringWriter \u003d new StringWriter();\r\n        JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n        jsonWriter.value(new LazilyParsedNumber(validNumber));\r\n        jsonWriter.close();\r\n        assertThat(stringWriter.toString()).isEqualTo(validNumber);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNumbersCustomClass",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testMalformedNumbers() throws IOException {\r\n    String[] malformedNumbers \u003d { \"some text\", \"\", \".\", \"00\", \"01\", \"-00\", \"-\", \"--1\", // plus sign is not allowed for integer part\r\n    \"+1\", \"+\", \"1,0\", \"1,000\", // decimal digit is required\r\n    \"0.\", // integer part is required\r\n    \".1\", \"e1\", \".e1\", \".1e1\", \"1e-\", \"1e+\", \"1e--1\", \"1e+-1\", \"1e1e1\", \"1+e1\", \"1e1.0\" };\r\n    for (String malformedNumber : malformedNumbers) {\r\n        JsonWriter jsonWriter \u003d new JsonWriter(new StringWriter());\r\n        try {\r\n            jsonWriter.value(new LazilyParsedNumber(malformedNumber));\r\n            fail(\"Should have failed writing malformed number: \" + malformedNumber);\r\n        } catch (IllegalArgumentException e) {\r\n            assertThat(e).hasMessageThat().isEqualTo(\"String created by class com.google.gson.internal.LazilyParsedNumber is not a valid JSON number: \" + malformedNumber);\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testMalformedNumbers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBooleans() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(true);\r\n    jsonWriter.value(false);\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[true,false]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testBooleans",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBoxedBooleans() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value((Boolean) true);\r\n    jsonWriter.value((Boolean) false);\r\n    jsonWriter.value((Boolean) null);\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[true,false,null]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testBoxedBooleans",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNulls() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.nullValue();\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[null]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testNulls",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testStrings() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(\"a\");\r\n    jsonWriter.value(\"a\\\"\");\r\n    jsonWriter.value(\"\\\"\");\r\n    jsonWriter.value(\":\");\r\n    jsonWriter.value(\",\");\r\n    jsonWriter.value(\"\\b\");\r\n    jsonWriter.value(\"\\f\");\r\n    jsonWriter.value(\"\\n\");\r\n    jsonWriter.value(\"\\r\");\r\n    jsonWriter.value(\"\\t\");\r\n    jsonWriter.value(\" \");\r\n    jsonWriter.value(\"\\\\\");\r\n    jsonWriter.value(\"{\");\r\n    jsonWriter.value(\"}\");\r\n    jsonWriter.value(\"[\");\r\n    jsonWriter.value(\"]\");\r\n    jsonWriter.value(\"\\0\");\r\n    jsonWriter.value(\"\\u0019\");\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[\\\"a\\\",\" + \"\\\"a\\\\\\\"\\\",\" + \"\\\"\\\\\\\"\\\",\" + \"\\\":\\\",\" + \"\\\",\\\",\" + \"\\\"\\\\b\\\",\" + \"\\\"\\\\f\\\",\" + \"\\\"\\\\n\\\",\" + \"\\\"\\\\r\\\",\" + \"\\\"\\\\t\\\",\" + \"\\\" \\\",\" + \"\\\"\\\\\\\\\\\",\" + \"\\\"{\\\",\" + \"\\\"}\\\",\" + \"\\\"[\\\",\" + \"\\\"]\\\",\" + \"\\\"\\\\u0000\\\",\" + \"\\\"\\\\u0019\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testStrings",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUnicodeLineBreaksEscaped() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(\"\\u2028 \\u2029\");\r\n    jsonWriter.endArray();\r\n    // JSON specification does not require that they are escaped, but Gson escapes them for compatibility with JavaScript\r\n    // where they are considered line breaks\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[\\\"\\\\u2028 \\\\u2029\\\"]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testUnicodeLineBreaksEscaped",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyArray() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testEmptyArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testEmptyObject() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.endObject();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testEmptyObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testObjectsInArrays() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginArray();\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\").value(5);\r\n    jsonWriter.name(\"b\").value(false);\r\n    jsonWriter.endObject();\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"c\").value(6);\r\n    jsonWriter.name(\"d\").value(true);\r\n    jsonWriter.endObject();\r\n    jsonWriter.endArray();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[{\\\"a\\\":5,\\\"b\\\":false},\" + \"{\\\"c\\\":6,\\\"d\\\":true}]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testObjectsInArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testArraysInObjects() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(5);\r\n    jsonWriter.value(false);\r\n    jsonWriter.endArray();\r\n    jsonWriter.name(\"b\");\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(6);\r\n    jsonWriter.value(true);\r\n    jsonWriter.endArray();\r\n    jsonWriter.endObject();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{\\\"a\\\":[5,false],\" + \"\\\"b\\\":[6,true]}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testArraysInObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeepNestingArrays() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    for (int i \u003d 0; i \u003c 20; i++) {\r\n        jsonWriter.beginArray();\r\n    }\r\n    for (int i \u003d 0; i \u003c 20; i++) {\r\n        jsonWriter.endArray();\r\n    }\r\n    assertThat(stringWriter.toString()).isEqualTo(\"[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testDeepNestingArrays",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeepNestingObjects() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    for (int i \u003d 0; i \u003c 20; i++) {\r\n        jsonWriter.name(\"a\");\r\n        jsonWriter.beginObject();\r\n    }\r\n    for (int i \u003d 0; i \u003c 20; i++) {\r\n        jsonWriter.endObject();\r\n    }\r\n    jsonWriter.endObject();\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":\" + \"{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\" + \"}}}}}}}}}}}}}}}}}}}}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testDeepNestingObjects",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testRepeatedName() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\").value(true);\r\n    jsonWriter.name(\"a\").value(false);\r\n    jsonWriter.endObject();\r\n    // JsonWriter doesn\u0027t attempt to detect duplicate names\r\n    assertThat(stringWriter.toString()).isEqualTo(\"{\\\"a\\\":true,\\\"a\\\":false}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testRepeatedName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrettyPrintObject() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setIndent(\"   \");\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\").value(true);\r\n    jsonWriter.name(\"b\").value(false);\r\n    jsonWriter.name(\"c\").value(5.0);\r\n    jsonWriter.name(\"e\").nullValue();\r\n    jsonWriter.name(\"f\").beginArray();\r\n    jsonWriter.value(6.0);\r\n    jsonWriter.value(7.0);\r\n    jsonWriter.endArray();\r\n    jsonWriter.name(\"g\").beginObject();\r\n    jsonWriter.name(\"h\").value(8.0);\r\n    jsonWriter.name(\"i\").value(9.0);\r\n    jsonWriter.endObject();\r\n    jsonWriter.endObject();\r\n    String expected \u003d \"{\\n\" + \"   \\\"a\\\": true,\\n\" + \"   \\\"b\\\": false,\\n\" + \"   \\\"c\\\": 5.0,\\n\" + \"   \\\"e\\\": null,\\n\" + \"   \\\"f\\\": [\\n\" + \"      6.0,\\n\" + \"      7.0\\n\" + \"   ],\\n\" + \"   \\\"g\\\": {\\n\" + \"      \\\"h\\\": 8.0,\\n\" + \"      \\\"i\\\": 9.0\\n\" + \"   }\\n\" + \"}\";\r\n    assertThat(stringWriter.toString()).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testPrettyPrintObject",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testPrettyPrintArray() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setIndent(\"   \");\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(true);\r\n    jsonWriter.value(false);\r\n    jsonWriter.value(5.0);\r\n    jsonWriter.nullValue();\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\").value(6.0);\r\n    jsonWriter.name(\"b\").value(7.0);\r\n    jsonWriter.endObject();\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(8.0);\r\n    jsonWriter.value(9.0);\r\n    jsonWriter.endArray();\r\n    jsonWriter.endArray();\r\n    String expected \u003d \"[\\n\" + \"   true,\\n\" + \"   false,\\n\" + \"   5.0,\\n\" + \"   null,\\n\" + \"   {\\n\" + \"      \\\"a\\\": 6.0,\\n\" + \"      \\\"b\\\": 7.0\\n\" + \"   },\\n\" + \"   [\\n\" + \"      8.0,\\n\" + \"      9.0\\n\" + \"   ]\\n\" + \"]\";\r\n    assertThat(stringWriter.toString()).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testPrettyPrintArray",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClosedWriterThrowsOnStructure() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    try {\r\n        writer.beginArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        writer.endArray();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        writer.beginObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    try {\r\n        writer.endObject();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testClosedWriterThrowsOnStructure",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClosedWriterThrowsOnName() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    try {\r\n        writer.name(\"a\");\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testClosedWriterThrowsOnName",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClosedWriterThrowsOnValue() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    try {\r\n        writer.value(\"a\");\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testClosedWriterThrowsOnValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testClosedWriterThrowsOnFlush() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    try {\r\n        writer.flush();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testClosedWriterThrowsOnFlush",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testWriterCloseIsIdempotent() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter writer \u003d new JsonWriter(stringWriter);\r\n    writer.beginArray();\r\n    writer.endArray();\r\n    writer.close();\r\n    writer.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testWriterCloseIsIdempotent",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSetGetFormattingStyle() throws IOException {\r\n    String lineSeparator \u003d \"\\r\\n\";\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    // Default should be FormattingStyle.COMPACT\r\n    assertThat(jsonWriter.getFormattingStyle()).isSameInstanceAs(FormattingStyle.COMPACT);\r\n    jsonWriter.setFormattingStyle(FormattingStyle.PRETTY.withIndent(\" \\t \").withNewline(lineSeparator));\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(true);\r\n    jsonWriter.value(\"text\");\r\n    jsonWriter.value(5.0);\r\n    jsonWriter.nullValue();\r\n    jsonWriter.endArray();\r\n    String expected \u003d \"[\\r\\n\" + \" \\t true,\\r\\n\" + \" \\t \\\"text\\\",\\r\\n\" + \" \\t 5.0,\\r\\n\" + \" \\t null\\r\\n\" + \"]\";\r\n    assertThat(stringWriter.toString()).isEqualTo(expected);\r\n    assertThat(jsonWriter.getFormattingStyle().getNewline()).isEqualTo(lineSeparator);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testSetGetFormattingStyle",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testIndentOverwritesFormattingStyle() throws IOException {\r\n    StringWriter stringWriter \u003d new StringWriter();\r\n    JsonWriter jsonWriter \u003d new JsonWriter(stringWriter);\r\n    jsonWriter.setFormattingStyle(FormattingStyle.COMPACT);\r\n    // Should overwrite formatting style\r\n    jsonWriter.setIndent(\"  \");\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"a\");\r\n    jsonWriter.beginArray();\r\n    jsonWriter.value(1);\r\n    jsonWriter.value(2);\r\n    jsonWriter.endArray();\r\n    jsonWriter.endObject();\r\n    String expected \u003d \"{\\n\" + \"  \\\"a\\\": [\\n\" + \"    1,\\n\" + \"    2\\n\" + \"  ]\\n\" + \"}\";\r\n    assertThat(stringWriter.toString()).isEqualTo(expected);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.stream.JsonWriterTest",
      "methodName": "testIndentOverwritesFormattingStyle",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDouble() throws IOException {\r\n    ToNumberStrategy strategy \u003d ToNumberPolicy.DOUBLE;\r\n    assertThat(strategy.readNumber(fromString(\"10.1\"))).isEqualTo(10.1);\r\n    assertThat(strategy.readNumber(fromString(\"3.141592653589793238462643383279\"))).isEqualTo(3.141592653589793D);\r\n    MalformedJsonException e \u003d assertThrows(MalformedJsonException.class, () -\u003e strategy.readNumber(fromString(\"1e400\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: Infinity at line 1 column 6 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    assertThrows(NumberFormatException.class, () -\u003e strategy.readNumber(fromString(\"\\\"not-a-number\\\"\")));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ToNumberPolicyTest",
      "methodName": "testDouble",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLazilyParsedNumber() throws IOException {\r\n    ToNumberStrategy strategy \u003d ToNumberPolicy.LAZILY_PARSED_NUMBER;\r\n    assertThat(strategy.readNumber(fromString(\"10.1\"))).isEqualTo(new LazilyParsedNumber(\"10.1\"));\r\n    assertThat(strategy.readNumber(fromString(\"3.141592653589793238462643383279\"))).isEqualTo(new LazilyParsedNumber(\"3.141592653589793238462643383279\"));\r\n    assertThat(strategy.readNumber(fromString(\"1e400\"))).isEqualTo(new LazilyParsedNumber(\"1e400\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ToNumberPolicyTest",
      "methodName": "testLazilyParsedNumber",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testLongOrDouble() throws IOException {\r\n    ToNumberStrategy strategy \u003d ToNumberPolicy.LONG_OR_DOUBLE;\r\n    assertThat(strategy.readNumber(fromString(\"10\"))).isEqualTo(10L);\r\n    assertThat(strategy.readNumber(fromString(\"10.1\"))).isEqualTo(10.1);\r\n    assertThat(strategy.readNumber(fromString(\"3.141592653589793238462643383279\"))).isEqualTo(3.141592653589793D);\r\n    Exception e \u003d assertThrows(MalformedJsonException.class, () -\u003e strategy.readNumber(fromString(\"1e400\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"JSON forbids NaN and infinities: Infinity; at path $\");\r\n    e \u003d assertThrows(JsonParseException.class, () -\u003e strategy.readNumber(fromString(\"\\\"not-a-number\\\"\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Cannot parse not-a-number; at path $\");\r\n    assertThat(strategy.readNumber(fromStringLenient(\"NaN\"))).isEqualTo(Double.NaN);\r\n    assertThat(strategy.readNumber(fromStringLenient(\"Infinity\"))).isEqualTo(Double.POSITIVE_INFINITY);\r\n    assertThat(strategy.readNumber(fromStringLenient(\"-Infinity\"))).isEqualTo(Double.NEGATIVE_INFINITY);\r\n    e \u003d assertThrows(MalformedJsonException.class, () -\u003e strategy.readNumber(fromString(\"NaN\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON at line 1 column 1 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    e \u003d assertThrows(MalformedJsonException.class, () -\u003e strategy.readNumber(fromString(\"Infinity\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON at line 1 column 1 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n    e \u003d assertThrows(MalformedJsonException.class, () -\u003e strategy.readNumber(fromString(\"-Infinity\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON at line 1 column 1 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#malformed-json\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ToNumberPolicyTest",
      "methodName": "testLongOrDouble",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testBigDecimal() throws IOException {\r\n    ToNumberStrategy strategy \u003d ToNumberPolicy.BIG_DECIMAL;\r\n    assertThat(strategy.readNumber(fromString(\"10.1\"))).isEqualTo(new BigDecimal(\"10.1\"));\r\n    assertThat(strategy.readNumber(fromString(\"3.141592653589793238462643383279\"))).isEqualTo(new BigDecimal(\"3.141592653589793238462643383279\"));\r\n    assertThat(strategy.readNumber(fromString(\"1e400\"))).isEqualTo(new BigDecimal(\"1e400\"));\r\n    JsonParseException e \u003d assertThrows(JsonParseException.class, () -\u003e strategy.readNumber(fromString(\"\\\"not-a-number\\\"\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Cannot parse not-a-number; at path $\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ToNumberPolicyTest",
      "methodName": "testBigDecimal",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullsAreNeverExpected() throws IOException {\r\n    IllegalStateException e \u003d assertThrows(IllegalStateException.class, () -\u003e ToNumberPolicy.DOUBLE.readNumber(fromString(\"null\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Expected a double but was NULL at line 1 column 5 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#adapter-not-null-safe\");\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e ToNumberPolicy.LAZILY_PARSED_NUMBER.readNumber(fromString(\"null\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Expected a string but was NULL at line 1 column 5 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#adapter-not-null-safe\");\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e ToNumberPolicy.LONG_OR_DOUBLE.readNumber(fromString(\"null\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Expected a string but was NULL at line 1 column 5 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#adapter-not-null-safe\");\r\n    e \u003d assertThrows(IllegalStateException.class, () -\u003e ToNumberPolicy.BIG_DECIMAL.readNumber(fromString(\"null\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Expected a string but was NULL at line 1 column 5 path $\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#adapter-not-null-safe\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ToNumberPolicyTest",
      "methodName": "testNullsAreNeverExpected",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static JsonReader fromString(String json) {\r\n    return new JsonReader(new StringReader(json));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ToNumberPolicyTest",
      "methodName": "fromString",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonReader"
    }
  },
  {
    "sourceCode": "private static JsonReader fromStringLenient(String json) {\r\n    JsonReader jsonReader \u003d fromString(json);\r\n    jsonReader.setStrictness(Strictness.LENIENT);\r\n    return jsonReader;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.ToNumberPolicyTest",
      "methodName": "fromStringLenient",
      "parameterTypes": [
        "String"
      ],
      "returnType": "JsonReader"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, String value) {\r\n    throw new AssertionError(\"unexpected call\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String read(JsonReader in) {\r\n    throw new AssertionError(\"unexpected call\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNullSafe() throws IOException {\r\n    TypeAdapter\u003cString\u003e adapter \u003d new TypeAdapter\u003cString\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) {\r\n            throw new AssertionError(\"unexpected call\");\r\n        }\r\n\r\n        @Override\r\n        public String read(JsonReader in) {\r\n            throw new AssertionError(\"unexpected call\");\r\n        }\r\n    }.nullSafe();\r\n    assertThat(adapter.toJson(null)).isEqualTo(\"null\");\r\n    assertThat(adapter.fromJson(\"null\")).isNull();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterTest",
      "methodName": "testNullSafe",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, Integer value) throws IOException {\r\n    throw exception;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "Integer"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Integer read(JsonReader in) {\r\n    throw new AssertionError(\"not needed by this test\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "Integer"
    }
  },
  {
    "sourceCode": "/**\r\n * Tests behavior when {@link TypeAdapter#write(JsonWriter, Object)} manually throws\r\n * {@link IOException} which is not caused by writer usage.\r\n */\r\n@Test\r\npublic void testToJson_ThrowingIOException() {\r\n    final IOException exception \u003d new IOException(\"test\");\r\n    TypeAdapter\u003cInteger\u003e adapter \u003d new TypeAdapter\u003cInteger\u003e() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Integer value) throws IOException {\r\n            throw exception;\r\n        }\r\n\r\n        @Override\r\n        public Integer read(JsonReader in) {\r\n            throw new AssertionError(\"not needed by this test\");\r\n        }\r\n    };\r\n    JsonIOException e \u003d assertThrows(JsonIOException.class, () -\u003e adapter.toJson(1));\r\n    assertThat(e).hasCauseThat().isEqualTo(exception);\r\n    e \u003d assertThrows(JsonIOException.class, () -\u003e adapter.toJsonTree(1));\r\n    assertThat(e).hasCauseThat().isEqualTo(exception);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterTest",
      "methodName": "testToJson_ThrowingIOException",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, String value) throws IOException {\r\n    out.value(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterTest",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "String"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String read(JsonReader in) throws IOException {\r\n    return in.nextString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterTest",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "// Note: This test just verifies the current behavior; it is a bit questionable\r\n// whether that behavior is actually desired\r\n@Test\r\npublic void testFromJson_Reader_TrailingData() throws IOException {\r\n    assertThat(adapter.fromJson(new StringReader(\"\\\"a\\\"1\"))).isEqualTo(\"a\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterTest",
      "methodName": "testFromJson_Reader_TrailingData",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "// Note: This test just verifies the current behavior; it is a bit questionable\r\n// whether that behavior is actually desired\r\n@Test\r\npublic void testFromJson_String_TrailingData() throws IOException {\r\n    assertThat(adapter.fromJson(\"\\\"a\\\"1\")).isEqualTo(\"a\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.TypeAdapterTest",
      "methodName": "testFromJson_String_TrailingData",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSameVersion() throws Exception {\r\n    Excluder excluder \u003d Excluder.DEFAULT.withVersion(VERSION);\r\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\r\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\r\n    // Until version is exclusive\r\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\r\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\r\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isFalse();\r\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isFalse();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.VersionExclusionStrategyTest",
      "methodName": "testSameVersion",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNewerVersion() throws Exception {\r\n    Excluder excluder \u003d Excluder.DEFAULT.withVersion(VERSION + 5);\r\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\r\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\r\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\r\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\r\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\r\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.VersionExclusionStrategyTest",
      "methodName": "testNewerVersion",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testOlderVersion() throws Exception {\r\n    Excluder excluder \u003d Excluder.DEFAULT.withVersion(VERSION - 5);\r\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isTrue();\r\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isTrue();\r\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isFalse();\r\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isFalse();\r\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\r\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.VersionExclusionStrategyTest",
      "methodName": "testOlderVersion",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public int getIntValue() {\r\n    return intValue;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.BagOfPrimitives",
      "methodName": "getIntValue",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public String getExpectedJson() {\r\n    return \"{\" + \"\\\"longValue\\\":\" + longValue + \",\" + \"\\\"intValue\\\":\" + intValue + \",\" + \"\\\"booleanValue\\\":\" + booleanValue + \",\" + \"\\\"stringValue\\\":\\\"\" + stringValue + \"\\\"\" + \"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.BagOfPrimitives",
      "methodName": "getExpectedJson",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic int hashCode() {\r\n    final int prime \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d prime * result + (booleanValue ? 1231 : 1237);\r\n    result \u003d prime * result + intValue;\r\n    result \u003d prime * result + (int) (longValue ^ (longValue \u003e\u003e\u003e 32));\r\n    result \u003d prime * result + ((stringValue \u003d\u003d null) ? 0 : stringValue.hashCode());\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.BagOfPrimitives",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@Override\r\npublic boolean equals(Object o) {\r\n    if (this \u003d\u003d o) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof BagOfPrimitives)) {\r\n        return false;\r\n    }\r\n    BagOfPrimitives that \u003d (BagOfPrimitives) o;\r\n    return longValue \u003d\u003d that.longValue \u0026\u0026 intValue \u003d\u003d that.intValue \u0026\u0026 booleanValue \u003d\u003d that.booleanValue \u0026\u0026 Objects.equal(stringValue, that.stringValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.BagOfPrimitives",
      "methodName": "equals",
      "parameterTypes": [
        "Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return String.format(\"(longValue\u003d%d,intValue\u003d%d,booleanValue\u003d%b,stringValue\u003d%s)\", longValue, intValue, booleanValue, stringValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.BagOfPrimitives",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public static void main(String[] args) {\r\n    NonUploadingCaliperRunner.run(BagOfPrimitivesDeserializationBenchmark.class, args);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.BagOfPrimitivesDeserializationBenchmark",
      "methodName": "main",
      "parameterTypes": [
        "String[]"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@BeforeExperiment\r\nvoid setUp() throws Exception {\r\n    this.gson \u003d new Gson();\r\n    BagOfPrimitives bag \u003d new BagOfPrimitives(10L, 1, false, \"foo\");\r\n    this.json \u003d gson.toJson(bag);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.BagOfPrimitivesDeserializationBenchmark",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Benchmark to measure Gson performance for deserializing an object\r\n */\r\npublic void timeBagOfPrimitivesDefault(int reps) {\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        gson.fromJson(json, BagOfPrimitives.class);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.BagOfPrimitivesDeserializationBenchmark",
      "methodName": "timeBagOfPrimitivesDefault",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Benchmark to measure deserializing objects by hand\r\n */\r\npublic void timeBagOfPrimitivesStreaming(int reps) throws IOException {\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginObject();\r\n        long longValue \u003d 0;\r\n        int intValue \u003d 0;\r\n        boolean booleanValue \u003d false;\r\n        String stringValue \u003d null;\r\n        while (jr.hasNext()) {\r\n            String name \u003d jr.nextName();\r\n            if (name.equals(\"longValue\")) {\r\n                longValue \u003d jr.nextLong();\r\n            } else if (name.equals(\"intValue\")) {\r\n                intValue \u003d jr.nextInt();\r\n            } else if (name.equals(\"booleanValue\")) {\r\n                booleanValue \u003d jr.nextBoolean();\r\n            } else if (name.equals(\"stringValue\")) {\r\n                stringValue \u003d jr.nextString();\r\n            } else {\r\n                throw new IOException(\"Unexpected name: \" + name);\r\n            }\r\n        }\r\n        jr.endObject();\r\n        new BagOfPrimitives(longValue, intValue, booleanValue, stringValue);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.BagOfPrimitivesDeserializationBenchmark",
      "methodName": "timeBagOfPrimitivesStreaming",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This benchmark measures the ideal Gson performance: the cost of parsing a JSON stream and\r\n * setting object values by reflection. We should strive to reduce the discrepancy between this\r\n * and {@link #timeBagOfPrimitivesDefault(int)} .\r\n */\r\npublic void timeBagOfPrimitivesReflectionStreaming(int reps) throws Exception {\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginObject();\r\n        BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n        while (jr.hasNext()) {\r\n            String name \u003d jr.nextName();\r\n            for (Field field : BagOfPrimitives.class.getDeclaredFields()) {\r\n                if (field.getName().equals(name)) {\r\n                    Class\u003c?\u003e fieldType \u003d field.getType();\r\n                    if (fieldType.equals(long.class)) {\r\n                        field.setLong(bag, jr.nextLong());\r\n                    } else if (fieldType.equals(int.class)) {\r\n                        field.setInt(bag, jr.nextInt());\r\n                    } else if (fieldType.equals(boolean.class)) {\r\n                        field.setBoolean(bag, jr.nextBoolean());\r\n                    } else if (fieldType.equals(String.class)) {\r\n                        field.set(bag, jr.nextString());\r\n                    } else {\r\n                        throw new RuntimeException(\"Unexpected: type: \" + fieldType + \", name: \" + name);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        jr.endObject();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.BagOfPrimitivesDeserializationBenchmark",
      "methodName": "timeBagOfPrimitivesReflectionStreaming",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public static void main(String[] args) {\r\n    NonUploadingCaliperRunner.run(CollectionsDeserializationBenchmark.class, args);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.CollectionsDeserializationBenchmark",
      "methodName": "main",
      "parameterTypes": [
        "String[]"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@BeforeExperiment\r\nvoid setUp() throws Exception {\r\n    this.gson \u003d new Gson();\r\n    List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c 100; ++i) {\r\n        bags.add(new BagOfPrimitives(10L, 1, false, \"foo\"));\r\n    }\r\n    this.json \u003d gson.toJson(bags, LIST_TYPE);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.CollectionsDeserializationBenchmark",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Benchmark to measure Gson performance for deserializing an object\r\n */\r\npublic void timeCollectionsDefault(int reps) {\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        gson.fromJson(json, LIST_TYPE_TOKEN);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.CollectionsDeserializationBenchmark",
      "methodName": "timeCollectionsDefault",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Benchmark to measure deserializing objects by hand\r\n */\r\n@SuppressWarnings(\"ModifiedButNotUsed\")\r\npublic void timeCollectionsStreaming(int reps) throws IOException {\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginArray();\r\n        List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n        while (jr.hasNext()) {\r\n            jr.beginObject();\r\n            long longValue \u003d 0;\r\n            int intValue \u003d 0;\r\n            boolean booleanValue \u003d false;\r\n            String stringValue \u003d null;\r\n            while (jr.hasNext()) {\r\n                String name \u003d jr.nextName();\r\n                if (name.equals(\"longValue\")) {\r\n                    longValue \u003d jr.nextLong();\r\n                } else if (name.equals(\"intValue\")) {\r\n                    intValue \u003d jr.nextInt();\r\n                } else if (name.equals(\"booleanValue\")) {\r\n                    booleanValue \u003d jr.nextBoolean();\r\n                } else if (name.equals(\"stringValue\")) {\r\n                    stringValue \u003d jr.nextString();\r\n                } else {\r\n                    throw new IOException(\"Unexpected name: \" + name);\r\n                }\r\n            }\r\n            jr.endObject();\r\n            bags.add(new BagOfPrimitives(longValue, intValue, booleanValue, stringValue));\r\n        }\r\n        jr.endArray();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.CollectionsDeserializationBenchmark",
      "methodName": "timeCollectionsStreaming",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * This benchmark measures the ideal Gson performance: the cost of parsing a JSON stream and\r\n * setting object values by reflection. We should strive to reduce the discrepancy between this\r\n * and {@link #timeCollectionsDefault(int)} .\r\n */\r\n@SuppressWarnings(\"ModifiedButNotUsed\")\r\npublic void timeCollectionsReflectionStreaming(int reps) throws Exception {\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        StringReader reader \u003d new StringReader(json);\r\n        JsonReader jr \u003d new JsonReader(reader);\r\n        jr.beginArray();\r\n        List\u003cBagOfPrimitives\u003e bags \u003d new ArrayList\u003c\u003e();\r\n        while (jr.hasNext()) {\r\n            jr.beginObject();\r\n            BagOfPrimitives bag \u003d new BagOfPrimitives();\r\n            while (jr.hasNext()) {\r\n                String name \u003d jr.nextName();\r\n                for (Field field : BagOfPrimitives.class.getDeclaredFields()) {\r\n                    if (field.getName().equals(name)) {\r\n                        Class\u003c?\u003e fieldType \u003d field.getType();\r\n                        if (fieldType.equals(long.class)) {\r\n                            field.setLong(bag, jr.nextLong());\r\n                        } else if (fieldType.equals(int.class)) {\r\n                            field.setInt(bag, jr.nextInt());\r\n                        } else if (fieldType.equals(boolean.class)) {\r\n                            field.setBoolean(bag, jr.nextBoolean());\r\n                        } else if (fieldType.equals(String.class)) {\r\n                            field.set(bag, jr.nextString());\r\n                        } else {\r\n                            throw new RuntimeException(\"Unexpected: type: \" + fieldType + \", name: \" + name);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            jr.endObject();\r\n            bags.add(bag);\r\n        }\r\n        jr.endArray();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.CollectionsDeserializationBenchmark",
      "methodName": "timeCollectionsReflectionStreaming",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static String[] concat(String first, String... others) {\r\n    if (others.length \u003d\u003d 0) {\r\n        return new String[] { first };\r\n    } else {\r\n        String[] result \u003d new String[others.length + 1];\r\n        result[0] \u003d first;\r\n        System.arraycopy(others, 0, result, 1, others.length);\r\n        return result;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.NonUploadingCaliperRunner",
      "methodName": "concat",
      "parameterTypes": [
        "String",
        "String"
      ],
      "returnType": "String[]"
    }
  },
  {
    "sourceCode": "public static void run(Class\u003c?\u003e c, String[] args) {\r\n    // Disable result upload; Caliper uploads results to webapp by default, see https://github.com/google/caliper/issues/356\r\n    CaliperMain.main(c, concat(\"-Cresults.upload.options.url\u003d\", args));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.NonUploadingCaliperRunner",
      "methodName": "run",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "String[]"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\nParser newParser() {\r\n    return new JacksonStreamParser();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "newParser",
      "parameterTypes": [],
      "returnType": "Parser"
    }
  },
  {
    "sourceCode": "@Override\r\nParser newParser() {\r\n    return new JacksonBindParser();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "newParser",
      "parameterTypes": [],
      "returnType": "Parser"
    }
  },
  {
    "sourceCode": "@Override\r\nParser newParser() {\r\n    return new GsonStreamParser();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "newParser",
      "parameterTypes": [],
      "returnType": "Parser"
    }
  },
  {
    "sourceCode": "@Override\r\nParser newParser() {\r\n    return new GsonSkipParser();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "newParser",
      "parameterTypes": [],
      "returnType": "Parser"
    }
  },
  {
    "sourceCode": "@Override\r\nParser newParser() {\r\n    return new GsonDomParser();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "newParser",
      "parameterTypes": [],
      "returnType": "Parser"
    }
  },
  {
    "sourceCode": "@Override\r\nParser newParser() {\r\n    return new GsonBindParser();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "newParser",
      "parameterTypes": [],
      "returnType": "Parser"
    }
  },
  {
    "sourceCode": "abstract Parser newParser();",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "newParser",
      "parameterTypes": [],
      "returnType": "Parser"
    }
  },
  {
    "sourceCode": "@BeforeExperiment\r\nvoid setUp() throws Exception {\r\n    text \u003d resourceToString(document.name() + \".json\").toCharArray();\r\n    parser \u003d api.newParser();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public void timeParse(int reps) throws Exception {\r\n    for (int i \u003d 0; i \u003c reps; i++) {\r\n        parser.parse(text, document);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "timeParse",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static File getResourceFile(String path) throws Exception {\r\n    URL url \u003d ParseBenchmark.class.getResource(path);\r\n    if (url \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Resource \" + path + \" does not exist\");\r\n    }\r\n    File file \u003d new File(url.toURI());\r\n    if (!file.isFile()) {\r\n        throw new IllegalArgumentException(\"Resource \" + path + \" is not a file\");\r\n    }\r\n    return file;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "getResourceFile",
      "parameterTypes": [
        "String"
      ],
      "returnType": "File"
    }
  },
  {
    "sourceCode": "private static String resourceToString(String fileName) throws Exception {\r\n    ZipFile zipFile \u003d new ZipFile(getResourceFile(\"/ParseBenchmarkData.zip\"));\r\n    try {\r\n        ZipEntry zipEntry \u003d zipFile.getEntry(fileName);\r\n        Reader reader \u003d new InputStreamReader(zipFile.getInputStream(zipEntry), StandardCharsets.UTF_8);\r\n        char[] buffer \u003d new char[8192];\r\n        StringWriter writer \u003d new StringWriter();\r\n        int count;\r\n        while ((count \u003d reader.read(buffer)) !\u003d -1) {\r\n            writer.write(buffer, 0, count);\r\n        }\r\n        reader.close();\r\n        return writer.toString();\r\n    } finally {\r\n        zipFile.close();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "resourceToString",
      "parameterTypes": [
        "String"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public static void main(String[] args) throws Exception {\r\n    NonUploadingCaliperRunner.run(ParseBenchmark.class, args);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark",
      "methodName": "main",
      "parameterTypes": [
        "String[]"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "void parse(char[] data, Document document) throws Exception;",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.Parser",
      "methodName": "parse",
      "parameterTypes": [
        "char[]",
        "Document"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void parse(char[] data, Document document) throws Exception {\r\n    com.google.gson.stream.JsonReader jsonReader \u003d new com.google.gson.stream.JsonReader(new CharArrayReader(data));\r\n    readToken(jsonReader);\r\n    jsonReader.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.GsonStreamParser",
      "methodName": "parse",
      "parameterTypes": [
        "char[]",
        "Document"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void readToken(com.google.gson.stream.JsonReader reader) throws IOException {\r\n    while (true) {\r\n        switch(reader.peek()) {\r\n            case BEGIN_ARRAY:\r\n                reader.beginArray();\r\n                break;\r\n            case END_ARRAY:\r\n                reader.endArray();\r\n                break;\r\n            case BEGIN_OBJECT:\r\n                reader.beginObject();\r\n                break;\r\n            case END_OBJECT:\r\n                reader.endObject();\r\n                break;\r\n            case NAME:\r\n                reader.nextName();\r\n                break;\r\n            case BOOLEAN:\r\n                reader.nextBoolean();\r\n                break;\r\n            case NULL:\r\n                reader.nextNull();\r\n                break;\r\n            case NUMBER:\r\n                reader.nextLong();\r\n                break;\r\n            case STRING:\r\n                reader.nextString();\r\n                break;\r\n            case END_DOCUMENT:\r\n                return;\r\n            default:\r\n                throw new IllegalArgumentException(\"Unexpected token\" + reader.peek());\r\n        }\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.GsonStreamParser",
      "methodName": "readToken",
      "parameterTypes": [
        "com.google.gson.stream.JsonReader"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void parse(char[] data, Document document) throws Exception {\r\n    com.google.gson.stream.JsonReader jsonReader \u003d new com.google.gson.stream.JsonReader(new CharArrayReader(data));\r\n    jsonReader.skipValue();\r\n    jsonReader.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.GsonSkipParser",
      "methodName": "parse",
      "parameterTypes": [
        "char[]",
        "Document"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void parse(char[] data, Document document) throws Exception {\r\n    JsonFactory jsonFactory \u003d new JsonFactoryBuilder().configure(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES, false).build();\r\n    com.fasterxml.jackson.core.JsonParser jp \u003d jsonFactory.createParser(new CharArrayReader(data));\r\n    int depth \u003d 0;\r\n    do {\r\n        JsonToken token \u003d jp.nextToken();\r\n        switch(token) {\r\n            case START_OBJECT:\r\n            case START_ARRAY:\r\n                depth++;\r\n                break;\r\n            case END_OBJECT:\r\n            case END_ARRAY:\r\n                depth--;\r\n                break;\r\n            case FIELD_NAME:\r\n                jp.getCurrentName();\r\n                break;\r\n            case VALUE_STRING:\r\n                jp.getText();\r\n                break;\r\n            case VALUE_NUMBER_INT:\r\n            case VALUE_NUMBER_FLOAT:\r\n                jp.getLongValue();\r\n                break;\r\n            case VALUE_TRUE:\r\n            case VALUE_FALSE:\r\n                jp.getBooleanValue();\r\n                break;\r\n            case VALUE_NULL:\r\n                // Do nothing; nextToken() will advance in stream\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Unexpected token \" + token);\r\n        }\r\n    } while (depth \u003e 0);\r\n    jp.close();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.JacksonStreamParser",
      "methodName": "parse",
      "parameterTypes": [
        "char[]",
        "Document"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void parse(char[] data, Document document) throws Exception {\r\n    JsonParser.parseReader(new CharArrayReader(data));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.GsonDomParser",
      "methodName": "parse",
      "parameterTypes": [
        "char[]",
        "Document"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void parse(char[] data, Document document) throws Exception {\r\n    gson.fromJson(new CharArrayReader(data), document.gsonType);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.GsonBindParser",
      "methodName": "parse",
      "parameterTypes": [
        "char[]",
        "Document"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void parse(char[] data, Document document) throws Exception {\r\n    mapper.readValue(new CharArrayReader(data), document.jacksonType);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.JacksonBindParser",
      "methodName": "parse",
      "parameterTypes": [
        "char[]",
        "Document"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    StringBuilder result \u003d new StringBuilder().append(id).append(\"\\n\").append(title).append(\"\\n\").append(description).append(\"\\n\").append(alternates).append(\"\\n\").append(updated);\r\n    int i \u003d 1;\r\n    for (Item item : items) {\r\n        result.append(i++).append(\": \").append(item).append(\"\\n\\n\");\r\n    }\r\n    return result.toString();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.Feed",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return href;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.Link",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return title + \"\\nauthor: \" + author + \"\\npublished: \" + published + \"\\nupdated: \" + updated + \"\\n\" + content + \"\\nliking users: \" + likingUsers + \"\\nalternates: \" + alternates + \"\\ncategories: \" + categories;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.Item",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return content;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.Content",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return userId;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.ParseBenchmark.ReaderUser",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "public static void main(String[] args) {\r\n    NonUploadingCaliperRunner.run(SerializationBenchmark.class, args);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.SerializationBenchmark",
      "methodName": "main",
      "parameterTypes": [
        "String[]"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@BeforeExperiment\r\nvoid setUp() throws Exception {\r\n    this.gson \u003d pretty ? new GsonBuilder().setPrettyPrinting().create() : new Gson();\r\n    this.bag \u003d new BagOfPrimitives(10L, 1, false, \"foo\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.SerializationBenchmark",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public void timeObjectSerialization(int reps) {\r\n    for (int i \u003d 0; i \u003c reps; ++i) {\r\n        gson.toJson(bag);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.metrics.SerializationBenchmark",
      "methodName": "timeObjectSerialization",
      "parameterTypes": [
        "int"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@CanIgnoreReturnValue\r\npublic Builder setEnumSerialization(EnumSerialization enumSerialization) {\r\n    this.enumSerialization \u003d requireNonNull(enumSerialization);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter.Builder",
      "methodName": "setEnumSerialization",
      "parameterTypes": [
        "EnumSerialization"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * Sets the field names serialization format. The first parameter defines how to read the format\r\n * of the proto field names you are converting to JSON. The second parameter defines which\r\n * format to use when serializing them.\r\n * \u003cp\u003e\r\n * For example, if you use the following parameters: {@link CaseFormat#LOWER_UNDERSCORE},\r\n * {@link CaseFormat#LOWER_CAMEL}, the following conversion will occur:\r\n *\r\n * \u003cpre\u003e{@code\r\n * PROTO     \u003c-\u003e  JSON\r\n * my_field       myField\r\n * foo            foo\r\n * n__id_ct       nIdCt\r\n * }\u003c/pre\u003e\r\n */\r\n@CanIgnoreReturnValue\r\npublic Builder setFieldNameSerializationFormat(CaseFormat fromFieldNameFormat, CaseFormat toFieldNameFormat) {\r\n    this.protoFormat \u003d fromFieldNameFormat;\r\n    this.jsonFormat \u003d toFieldNameFormat;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter.Builder",
      "methodName": "setFieldNameSerializationFormat",
      "parameterTypes": [
        "CaseFormat",
        "CaseFormat"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * Adds a field proto annotation that, when set, overrides the default field name\r\n * serialization/deserialization. For example, if you add the \u0027{@code serialized_name}\u0027\r\n * annotation and you define a field in your proto like the one below:\r\n *\r\n * \u003cpre\u003e\r\n * string client_app_id \u003d 1 [(serialized_name) \u003d \"appId\"];\r\n * \u003c/pre\u003e\r\n *\r\n * ...the adapter will serialize the field using \u0027{@code appId}\u0027 instead of the default \u0027\r\n * {@code clientAppId}\u0027. This lets you customize the name serialization of any proto field.\r\n */\r\n@CanIgnoreReturnValue\r\npublic Builder addSerializedNameExtension(Extension\u003cFieldOptions, String\u003e serializedNameExtension) {\r\n    serializedNameExtensions.add(requireNonNull(serializedNameExtension));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter.Builder",
      "methodName": "addSerializedNameExtension",
      "parameterTypes": [
        "Extension\u003cFieldOptions, String\u003e"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * Adds an enum value proto annotation that, when set, overrides the default \u003cb\u003eenum\u003c/b\u003e value\r\n * serialization/deserialization of this adapter. For example, if you add the \u0027\r\n * {@code serialized_value}\u0027 annotation and you define an enum in your proto like the one below:\r\n *\r\n * \u003cpre\u003e\r\n * enum MyEnum {\r\n *   UNKNOWN \u003d 0;\r\n *   CLIENT_APP_ID \u003d 1 [(serialized_value) \u003d \"APP_ID\"];\r\n *   TWO \u003d 2 [(serialized_value) \u003d \"2\"];\r\n * }\r\n * \u003c/pre\u003e\r\n *\r\n * ...the adapter will serialize the value {@code CLIENT_APP_ID} as \"{@code APP_ID}\" and the\r\n * value {@code TWO} as \"{@code 2}\". This works for both serialization and deserialization.\r\n * \u003cp\u003e\r\n * Note that you need to set the enum serialization of this adapter to\r\n * {@link EnumSerialization#NAME}, otherwise these annotations will be ignored.\r\n */\r\n@CanIgnoreReturnValue\r\npublic Builder addSerializedEnumValueExtension(Extension\u003cEnumValueOptions, String\u003e serializedEnumValueExtension) {\r\n    serializedEnumValueExtensions.add(requireNonNull(serializedEnumValueExtension));\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter.Builder",
      "methodName": "addSerializedEnumValueExtension",
      "parameterTypes": [
        "Extension\u003cEnumValueOptions, String\u003e"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public ProtoTypeAdapter build() {\r\n    return new ProtoTypeAdapter(enumSerialization, protoFormat, jsonFormat, serializedNameExtensions, serializedEnumValueExtensions);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter.Builder",
      "methodName": "build",
      "parameterTypes": [],
      "returnType": "ProtoTypeAdapter"
    }
  },
  {
    "sourceCode": "/**\r\n * Creates a new {@link ProtoTypeAdapter} builder, defaulting enum serialization to\r\n * {@link EnumSerialization#NAME} and converting field serialization from\r\n * {@link CaseFormat#LOWER_UNDERSCORE} to {@link CaseFormat#LOWER_CAMEL}.\r\n */\r\npublic static Builder newBuilder() {\r\n    return new Builder(EnumSerialization.NAME, CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_CAMEL);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter",
      "methodName": "newBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(Message src, Type typeOfSrc, JsonSerializationContext context) {\r\n    JsonObject ret \u003d new JsonObject();\r\n    final Map\u003cFieldDescriptor, Object\u003e fields \u003d src.getAllFields();\r\n    for (Map.Entry\u003cFieldDescriptor, Object\u003e fieldPair : fields.entrySet()) {\r\n        final FieldDescriptor desc \u003d fieldPair.getKey();\r\n        String name \u003d getCustSerializedName(desc.getOptions(), desc.getName());\r\n        if (desc.getType() \u003d\u003d ENUM_TYPE) {\r\n            // Enum collections are also returned as ENUM_TYPE\r\n            if (fieldPair.getValue() instanceof Collection) {\r\n                // Build the array to avoid infinite loop\r\n                JsonArray array \u003d new JsonArray();\r\n                @SuppressWarnings(\"unchecked\")\r\n                Collection\u003cEnumValueDescriptor\u003e enumDescs \u003d (Collection\u003cEnumValueDescriptor\u003e) fieldPair.getValue();\r\n                for (EnumValueDescriptor enumDesc : enumDescs) {\r\n                    array.add(context.serialize(getEnumValue(enumDesc)));\r\n                    ret.add(name, array);\r\n                }\r\n            } else {\r\n                EnumValueDescriptor enumDesc \u003d ((EnumValueDescriptor) fieldPair.getValue());\r\n                ret.add(name, context.serialize(getEnumValue(enumDesc)));\r\n            }\r\n        } else {\r\n            ret.add(name, context.serialize(fieldPair.getValue()));\r\n        }\r\n    }\r\n    return ret;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter",
      "methodName": "serialize",
      "parameterTypes": [
        "Message",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic Message deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    try {\r\n        JsonObject jsonObject \u003d json.getAsJsonObject();\r\n        @SuppressWarnings(\"unchecked\")\r\n        Class\u003c? extends Message\u003e protoClass \u003d (Class\u003c? extends Message\u003e) typeOfT;\r\n        if (DynamicMessage.class.isAssignableFrom(protoClass)) {\r\n            throw new IllegalStateException(\"only generated messages are supported\");\r\n        }\r\n        try {\r\n            // Invoke the ProtoClass.newBuilder() method\r\n            Message.Builder protoBuilder \u003d (Message.Builder) getCachedMethod(protoClass, \"newBuilder\").invoke(null);\r\n            Message defaultInstance \u003d (Message) getCachedMethod(protoClass, \"getDefaultInstance\").invoke(null);\r\n            Descriptor protoDescriptor \u003d (Descriptor) getCachedMethod(protoClass, \"getDescriptor\").invoke(null);\r\n            // Call setters on all of the available fields\r\n            for (FieldDescriptor fieldDescriptor : protoDescriptor.getFields()) {\r\n                String jsonFieldName \u003d getCustSerializedName(fieldDescriptor.getOptions(), fieldDescriptor.getName());\r\n                JsonElement jsonElement \u003d jsonObject.get(jsonFieldName);\r\n                if (jsonElement !\u003d null \u0026\u0026 !jsonElement.isJsonNull()) {\r\n                    // Do not reuse jsonFieldName here, it might have a custom value\r\n                    Object fieldValue;\r\n                    if (fieldDescriptor.getType() \u003d\u003d ENUM_TYPE) {\r\n                        if (jsonElement.isJsonArray()) {\r\n                            // Handling array\r\n                            Collection\u003cEnumValueDescriptor\u003e enumCollection \u003d new ArrayList\u003c\u003e(jsonElement.getAsJsonArray().size());\r\n                            for (JsonElement element : jsonElement.getAsJsonArray()) {\r\n                                enumCollection.add(findValueByNameAndExtension(fieldDescriptor.getEnumType(), element));\r\n                            }\r\n                            fieldValue \u003d enumCollection;\r\n                        } else {\r\n                            // No array, just a plain value\r\n                            fieldValue \u003d findValueByNameAndExtension(fieldDescriptor.getEnumType(), jsonElement);\r\n                        }\r\n                        protoBuilder.setField(fieldDescriptor, fieldValue);\r\n                    } else if (fieldDescriptor.isRepeated()) {\r\n                        // If the type is an array, then we have to grab the type from the class.\r\n                        // protobuf java field names are always lower camel case\r\n                        String protoArrayFieldName \u003d protoFormat.to(CaseFormat.LOWER_CAMEL, fieldDescriptor.getName()) + \"_\";\r\n                        Field protoArrayField \u003d protoClass.getDeclaredField(protoArrayFieldName);\r\n                        Type protoArrayFieldType \u003d protoArrayField.getGenericType();\r\n                        fieldValue \u003d context.deserialize(jsonElement, protoArrayFieldType);\r\n                        protoBuilder.setField(fieldDescriptor, fieldValue);\r\n                    } else {\r\n                        Object field \u003d defaultInstance.getField(fieldDescriptor);\r\n                        fieldValue \u003d context.deserialize(jsonElement, field.getClass());\r\n                        protoBuilder.setField(fieldDescriptor, fieldValue);\r\n                    }\r\n                }\r\n            }\r\n            return protoBuilder.build();\r\n        } catch (SecurityException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (NoSuchMethodException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (IllegalArgumentException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new JsonParseException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new JsonParseException(e);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new JsonParseException(\"Error while parsing proto\", e);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "Message"
    }
  },
  {
    "sourceCode": "/**\r\n * Retrieves the custom field name from the given options, and if not found, returns the specified\r\n * default name.\r\n */\r\nprivate String getCustSerializedName(FieldOptions options, String defaultName) {\r\n    for (Extension\u003cFieldOptions, String\u003e extension : serializedNameExtensions) {\r\n        if (options.hasExtension(extension)) {\r\n            return options.getExtension(extension);\r\n        }\r\n    }\r\n    return protoFormat.to(jsonFormat, defaultName);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter",
      "methodName": "getCustSerializedName",
      "parameterTypes": [
        "FieldOptions",
        "String"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Retrieves the custom enum value name from the given options, and if not found, returns the\r\n * specified default value.\r\n */\r\nprivate String getCustSerializedEnumValue(EnumValueOptions options, String defaultValue) {\r\n    for (Extension\u003cEnumValueOptions, String\u003e extension : serializedEnumValueExtensions) {\r\n        if (options.hasExtension(extension)) {\r\n            return options.getExtension(extension);\r\n        }\r\n    }\r\n    return defaultValue;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter",
      "methodName": "getCustSerializedEnumValue",
      "parameterTypes": [
        "EnumValueOptions",
        "String"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns the enum value to use for serialization, depending on the value of\r\n * {@link EnumSerialization} that was given to this adapter.\r\n */\r\nprivate Object getEnumValue(EnumValueDescriptor enumDesc) {\r\n    if (enumSerialization \u003d\u003d EnumSerialization.NAME) {\r\n        return getCustSerializedEnumValue(enumDesc.getOptions(), enumDesc.getName());\r\n    } else {\r\n        return enumDesc.getNumber();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter",
      "methodName": "getEnumValue",
      "parameterTypes": [
        "EnumValueDescriptor"
      ],
      "returnType": "Object"
    }
  },
  {
    "sourceCode": "/**\r\n * Finds an enum value in the given {@link EnumDescriptor} that matches the given JSON element,\r\n * either by name if the current adapter is using {@link EnumSerialization#NAME}, otherwise by\r\n * number. If matching by name, it uses the extension value if it is defined, otherwise it uses\r\n * its default value.\r\n *\r\n * @throws IllegalArgumentException if a matching name/number was not found\r\n */\r\nprivate EnumValueDescriptor findValueByNameAndExtension(EnumDescriptor desc, JsonElement jsonElement) {\r\n    if (enumSerialization \u003d\u003d EnumSerialization.NAME) {\r\n        // With enum name\r\n        for (EnumValueDescriptor enumDesc : desc.getValues()) {\r\n            String enumValue \u003d getCustSerializedEnumValue(enumDesc.getOptions(), enumDesc.getName());\r\n            if (enumValue.equals(jsonElement.getAsString())) {\r\n                return enumDesc;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(String.format(\"Unrecognized enum name: %s\", jsonElement.getAsString()));\r\n    } else {\r\n        // With enum value\r\n        EnumValueDescriptor fieldValue \u003d desc.findValueByNumber(jsonElement.getAsInt());\r\n        if (fieldValue \u003d\u003d null) {\r\n            throw new IllegalArgumentException(String.format(\"Unrecognized enum value: %d\", jsonElement.getAsInt()));\r\n        }\r\n        return fieldValue;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter",
      "methodName": "findValueByNameAndExtension",
      "parameterTypes": [
        "EnumDescriptor",
        "JsonElement"
      ],
      "returnType": "EnumValueDescriptor"
    }
  },
  {
    "sourceCode": "private static Method getCachedMethod(Class\u003c?\u003e clazz, String methodName, Class\u003c?\u003e... methodParamTypes) throws NoSuchMethodException {\r\n    ConcurrentMap\u003cClass\u003c?\u003e, Method\u003e mapOfMethods \u003d mapOfMapOfMethods.get(methodName);\r\n    if (mapOfMethods \u003d\u003d null) {\r\n        mapOfMethods \u003d new MapMaker().makeMap();\r\n        ConcurrentMap\u003cClass\u003c?\u003e, Method\u003e previous \u003d mapOfMapOfMethods.putIfAbsent(methodName, mapOfMethods);\r\n        mapOfMethods \u003d previous \u003d\u003d null ? mapOfMethods : previous;\r\n    }\r\n    Method method \u003d mapOfMethods.get(clazz);\r\n    if (method \u003d\u003d null) {\r\n        method \u003d clazz.getMethod(methodName, methodParamTypes);\r\n        mapOfMethods.putIfAbsent(clazz, method);\r\n        // NB: it doesn\u0027t matter which method we return in the event of a race.\r\n    }\r\n    return method;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.ProtoTypeAdapter",
      "methodName": "getCachedMethod",
      "parameterTypes": [
        "Class\u003c?\u003e",
        "String",
        "Class\u003c?\u003e"
      ],
      "returnType": "Method"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    ProtoTypeAdapter.Builder protoTypeAdapter \u003d ProtoTypeAdapter.newBuilder().setEnumSerialization(EnumSerialization.NAME).addSerializedNameExtension(Annotations.serializedName).addSerializedEnumValueExtension(Annotations.serializedValue);\r\n    gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, protoTypeAdapter.build()).create();\r\n    gsonWithEnumNumbers \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, protoTypeAdapter.setEnumSerialization(EnumSerialization.NUMBER).build()).create();\r\n    gsonWithLowerHyphen \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, protoTypeAdapter.setFieldNameSerializationFormat(CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_HYPHEN).build()).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testProtoWithAnnotations_deserialize() {\r\n    String json \u003d String.format(\"{  %n\" + \"   \\\"id\\\":\\\"41e5e7fd6065d101b97018a465ffff01\\\",%n\" + \"   \\\"expiration_date\\\":{  %n\" + \"      \\\"month\\\":\\\"12\\\",%n\" + \"      \\\"year\\\":\\\"2017\\\",%n\" + \"      \\\"timeStamp\\\":\\\"9864653135687\\\",%n\" + \"      \\\"countryCode5f55\\\":\\\"en_US\\\"%n\" + \"   },%n\" + // Don\u0027t define innerMessage1\r\n    \"   \\\"innerMessage2\\\":{  %n\" + // Set a number as a string; it should work\r\n    \"      \\\"nIdCt\\\":\\\"98798465\\\",%n\" + \"      \\\"content\\\":\\\"text/plain\\\",%n\" + \"      \\\"$binary_data$\\\":[  %n\" + \"         {  %n\" + \"            \\\"data\\\":\\\"OFIN8e9fhwoeh8((8efywoih\\\",%n\" + // Don\u0027t define width\r\n    \"            \\\"height\\\":665%n\" + \"         },%n\" + \"         {  %n\" + // Define as an int; it should work\r\n    \"            \\\"data\\\":65,%n\" + \"            \\\"width\\\":-56684%n\" + // Don\u0027t define height\r\n    \"         }%n\" + \"      ]%n\" + \"   },%n\" + // Define a bunch of non recognizable data\r\n    \"   \\\"non_existing\\\":\\\"foobar\\\",%n\" + \"   \\\"stillNot\\\":{  %n\" + \"      \\\"bunch\\\":\\\"of_useless data\\\"%n\" + \"   }%n\" + \"}\");\r\n    ProtoWithAnnotations proto \u003d gson.fromJson(json, ProtoWithAnnotations.class);\r\n    assertThat(proto.getId()).isEqualTo(\"41e5e7fd6065d101b97018a465ffff01\");\r\n    assertThat(proto.getOuterMessage()).isEqualTo(OuterMessage.newBuilder().setMonth(12).setYear(2017).setLongTimestamp(9864653135687L).setCountryCode5F55(\"en_US\").build());\r\n    assertThat(proto.hasInnerMessage1()).isFalse();\r\n    assertThat(proto.getInnerMessage2()).isEqualTo(InnerMessage.newBuilder().setNIdCt(98798465).setContent(InnerMessage.Type.TEXT).addData(InnerMessage.Data.newBuilder().setData(\"OFIN8e9fhwoeh8((8efywoih\").setHeight(665)).addData(InnerMessage.Data.newBuilder().setData(\"65\").setWidth(-56684)).build());\r\n    String rebuilt \u003d gson.toJson(proto);\r\n    assertThat(rebuilt).isEqualTo(\"{\" + \"\\\"id\\\":\\\"41e5e7fd6065d101b97018a465ffff01\\\",\" + \"\\\"expiration_date\\\":{\" + \"\\\"month\\\":12,\" + \"\\\"year\\\":2017,\" + \"\\\"timeStamp\\\":9864653135687,\" + \"\\\"countryCode5f55\\\":\\\"en_US\\\"\" + \"},\" + \"\\\"innerMessage2\\\":{\" + \"\\\"nIdCt\\\":98798465,\" + \"\\\"content\\\":\\\"text/plain\\\",\" + \"\\\"$binary_data$\\\":[\" + \"{\" + \"\\\"data\\\":\\\"OFIN8e9fhwoeh8((8efywoih\\\",\" + \"\\\"height\\\":665\" + \"},\" + \"{\" + \"\\\"data\\\":\\\"65\\\",\" + \"\\\"width\\\":-56684\" + \"}]}}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest",
      "methodName": "testProtoWithAnnotations_deserialize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testProtoWithAnnotations_deserializeUnknownEnumValue() {\r\n    String json \u003d String.format(\"{  %n\" + \"   \\\"content\\\":\\\"UNKNOWN\\\"%n\" + \"}\");\r\n    InnerMessage proto \u003d gson.fromJson(json, InnerMessage.class);\r\n    assertThat(proto.getContent()).isEqualTo(InnerMessage.Type.UNKNOWN);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest",
      "methodName": "testProtoWithAnnotations_deserializeUnknownEnumValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testProtoWithAnnotations_deserializeUnrecognizedEnumValue() {\r\n    String json \u003d String.format(\"{  %n\" + \"   \\\"content\\\":\\\"UNRECOGNIZED\\\"%n\" + \"}\");\r\n    try {\r\n        gson.fromJson(json, InnerMessage.class);\r\n        assertWithMessage(\"Should have thrown\").fail();\r\n    } catch (JsonParseException e) {\r\n        // expected\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest",
      "methodName": "testProtoWithAnnotations_deserializeUnrecognizedEnumValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testProtoWithAnnotations_deserializeWithEnumNumbers() {\r\n    String json \u003d String.format(\"{  %n\" + \"   \\\"content\\\":\\\"0\\\"%n\" + \"}\");\r\n    InnerMessage proto \u003d gsonWithEnumNumbers.fromJson(json, InnerMessage.class);\r\n    assertThat(proto.getContent()).isEqualTo(InnerMessage.Type.UNKNOWN);\r\n    String rebuilt \u003d gsonWithEnumNumbers.toJson(proto);\r\n    assertThat(rebuilt).isEqualTo(\"{\\\"content\\\":0}\");\r\n    json \u003d String.format(\"{  %n\" + \"   \\\"content\\\":\\\"2\\\"%n\" + \"}\");\r\n    proto \u003d gsonWithEnumNumbers.fromJson(json, InnerMessage.class);\r\n    assertThat(proto.getContent()).isEqualTo(InnerMessage.Type.IMAGE);\r\n    rebuilt \u003d gsonWithEnumNumbers.toJson(proto);\r\n    assertThat(rebuilt).isEqualTo(\"{\\\"content\\\":2}\");\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest",
      "methodName": "testProtoWithAnnotations_deserializeWithEnumNumbers",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testProtoWithAnnotations_serialize() {\r\n    ProtoWithAnnotations proto \u003d ProtoWithAnnotations.newBuilder().setId(\"09f3j20839h032y0329hf30932h0nffn\").setOuterMessage(OuterMessage.newBuilder().setMonth(14).setYear(6650).setLongTimestamp(468406876880768L)).setInnerMessage1(InnerMessage.newBuilder().setNIdCt(12).setContent(InnerMessage.Type.IMAGE).addData(InnerMessage.Data.newBuilder().setData(\"data$$\").setWidth(200)).addData(InnerMessage.Data.newBuilder().setHeight(56))).build();\r\n    String json \u003d gsonWithLowerHyphen.toJson(proto);\r\n    assertThat(json).isEqualTo(\"{\\\"id\\\":\\\"09f3j20839h032y0329hf30932h0nffn\\\",\" + \"\\\"expiration_date\\\":{\" + \"\\\"month\\\":14,\" + \"\\\"year\\\":6650,\" + \"\\\"timeStamp\\\":468406876880768\" + \"},\" + // This field should be using hyphens\r\n    \"\\\"inner-message-1\\\":{\" + \"\\\"n--id-ct\\\":12,\" + \"\\\"content\\\":2,\" + \"\\\"$binary_data$\\\":[\" + \"{\" + \"\\\"data\\\":\\\"data$$\\\",\" + \"\\\"width\\\":200\" + \"},\" + \"{\" + \"\\\"height\\\":56\" + \"}]\" + \"}\" + \"}\");\r\n    ProtoWithAnnotations rebuilt \u003d gsonWithLowerHyphen.fromJson(json, ProtoWithAnnotations.class);\r\n    assertThat(rebuilt).isEqualTo(proto);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest",
      "methodName": "testProtoWithAnnotations_serialize",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, ProtoTypeAdapter.newBuilder().setEnumSerialization(EnumSerialization.NUMBER).build()).create();\r\n    upperCamelGson \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, ProtoTypeAdapter.newBuilder().setFieldNameSerializationFormat(CaseFormat.LOWER_UNDERSCORE, CaseFormat.UPPER_CAMEL).build()).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeRepeatedFields() {\r\n    ProtoWithRepeatedFields proto \u003d ProtoWithRepeatedFields.newBuilder().addNumbers(2).addNumbers(3).addSimples(SimpleProto.newBuilder().setMsg(\"foo\").build()).addSimples(SimpleProto.newBuilder().setCount(3).build()).build();\r\n    String json \u003d gson.toJson(proto);\r\n    assertTrue(json.contains(\"[2,3]\"));\r\n    assertTrue(json.contains(\"foo\"));\r\n    assertTrue(json.contains(\"count\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest",
      "methodName": "testSerializeRepeatedFields",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeRepeatedFieldsProto() {\r\n    String json \u003d \"{numbers:[4,6],simples:[{msg:\u0027bar\u0027},{count:7}]}\";\r\n    ProtoWithRepeatedFields proto \u003d gson.fromJson(json, ProtoWithRepeatedFields.class);\r\n    assertEquals(4, proto.getNumbers(0));\r\n    assertEquals(6, proto.getNumbers(1));\r\n    assertEquals(\"bar\", proto.getSimples(0).getMsg());\r\n    assertEquals(7, proto.getSimples(1).getCount());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest",
      "methodName": "testDeserializeRepeatedFieldsProto",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeDifferentCaseFormat() {\r\n    final ProtoWithDifferentCaseFormat proto \u003d ProtoWithDifferentCaseFormat.newBuilder().setAnotherField(\"foo\").addNameThatTestsCaseFormat(\"bar\").build();\r\n    final JsonObject json \u003d upperCamelGson.toJsonTree(proto).getAsJsonObject();\r\n    assertEquals(\"foo\", json.get(\"AnotherField\").getAsString());\r\n    assertEquals(\"bar\", json.get(\"NameThatTestsCaseFormat\").getAsJsonArray().get(0).getAsString());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest",
      "methodName": "testSerializeDifferentCaseFormat",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeDifferentCaseFormat() {\r\n    final String json \u003d \"{NameThatTestsCaseFormat:[\u0027bar\u0027],AnotherField:\u0027foo\u0027}\";\r\n    ProtoWithDifferentCaseFormat proto \u003d upperCamelGson.fromJson(json, ProtoWithDifferentCaseFormat.class);\r\n    assertEquals(\"foo\", proto.getAnotherField());\r\n    assertEquals(\"bar\", proto.getNameThatTestsCaseFormat(0));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest",
      "methodName": "testDeserializeDifferentCaseFormat",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void setUp() throws Exception {\r\n    gson \u003d new GsonBuilder().registerTypeHierarchyAdapter(GeneratedMessageV3.class, ProtoTypeAdapter.newBuilder().setEnumSerialization(EnumSerialization.NUMBER).build()).create();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest",
      "methodName": "setUp",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeEmptyProto() {\r\n    SimpleProto proto \u003d SimpleProto.newBuilder().build();\r\n    String json \u003d gson.toJson(proto);\r\n    assertEquals(\"{}\", json);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest",
      "methodName": "testSerializeEmptyProto",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeEmptyProto() {\r\n    SimpleProto proto \u003d gson.fromJson(\"{}\", SimpleProto.class);\r\n    assertFalse(proto.hasCount());\r\n    assertFalse(proto.hasMsg());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest",
      "methodName": "testDeserializeEmptyProto",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testSerializeProto() {\r\n    SimpleProto proto \u003d SimpleProto.newBuilder().setCount(3).setMsg(\"foo\").build();\r\n    String json \u003d gson.toJson(proto);\r\n    assertTrue(json.contains(\"\\\"msg\\\":\\\"foo\\\"\"));\r\n    assertTrue(json.contains(\"\\\"count\\\":3\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest",
      "methodName": "testSerializeProto",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeProto() {\r\n    SimpleProto proto \u003d gson.fromJson(\"{msg:\u0027foo\u0027,count:3}\", SimpleProto.class);\r\n    assertEquals(\"foo\", proto.getMsg());\r\n    assertEquals(3, proto.getCount());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest",
      "methodName": "testDeserializeProto",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testDeserializeWithExplicitNullValue() {\r\n    SimpleProto proto \u003d gson.fromJson(\"{msg:\u0027foo\u0027,count:null}\", SimpleProto.class);\r\n    assertEquals(\"foo\", proto.getMsg());\r\n    assertEquals(0, proto.getCount());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest",
      "methodName": "testDeserializeWithExplicitNullValue",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public static void registerAllExtensions(com.google.protobuf.ExtensionRegistryLite registry) {\r\n    registry.add(com.google.gson.protobuf.generated.Annotations.serializedName);\r\n    registry.add(com.google.gson.protobuf.generated.Annotations.serializedValue);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Annotations",
      "methodName": "registerAllExtensions",
      "parameterTypes": [
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public static void registerAllExtensions(com.google.protobuf.ExtensionRegistry registry) {\r\n    registerAllExtensions((com.google.protobuf.ExtensionRegistryLite) registry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Annotations",
      "methodName": "registerAllExtensions",
      "parameterTypes": [
        "com.google.protobuf.ExtensionRegistry"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public static com.google.protobuf.Descriptors.FileDescriptor getDescriptor() {\r\n    return descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Annotations",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.FileDescriptor"
    }
  },
  {
    "sourceCode": "public static void registerAllExtensions(com.google.protobuf.ExtensionRegistryLite registry) {\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag",
      "methodName": "registerAllExtensions",
      "parameterTypes": [
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "public static void registerAllExtensions(com.google.protobuf.ExtensionRegistry registry) {\r\n    registerAllExtensions((com.google.protobuf.ExtensionRegistryLite) registry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag",
      "methodName": "registerAllExtensions",
      "parameterTypes": [
        "com.google.protobuf.ExtensionRegistry"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @return Whether the msg field is set.\r\n */\r\nboolean hasMsg();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder",
      "methodName": "hasMsg",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @return The msg.\r\n */\r\njava.lang.String getMsg();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder",
      "methodName": "getMsg",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @return The bytes for msg.\r\n */\r\ncom.google.protobuf.ByteString getMsgBytes();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder",
      "methodName": "getMsgBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 count \u003d 2;\u003c/code\u003e\r\n * @return Whether the count field is set.\r\n */\r\nboolean hasCount();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder",
      "methodName": "hasCount",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 count \u003d 2;\u003c/code\u003e\r\n * @return The count.\r\n */\r\nint getCount();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder",
      "methodName": "getCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\n@SuppressWarnings({ \"unused\" })\r\nprotected java.lang.Object newInstance(UnusedPrivateParameter unused) {\r\n    return new SimpleProto();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "newInstance",
      "parameterTypes": [
        "UnusedPrivateParameter"
      ],
      "returnType": "java.lang.Object"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final com.google.protobuf.UnknownFieldSet getUnknownFields() {\r\n    return this.unknownFields;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "getUnknownFields",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.UnknownFieldSet"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_SimpleProto_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_SimpleProto_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.SimpleProto.class, com.google.gson.protobuf.generated.Bag.SimpleProto.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @return Whether the msg field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasMsg() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "hasMsg",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @return The msg.\r\n */\r\n@java.lang.Override\r\npublic java.lang.String getMsg() {\r\n    java.lang.Object ref \u003d msg_;\r\n    if (ref instanceof java.lang.String) {\r\n        return (java.lang.String) ref;\r\n    } else {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            msg_ \u003d s;\r\n        }\r\n        return s;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "getMsg",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @return The bytes for msg.\r\n */\r\n@java.lang.Override\r\npublic com.google.protobuf.ByteString getMsgBytes() {\r\n    java.lang.Object ref \u003d msg_;\r\n    if (ref instanceof java.lang.String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        msg_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "getMsgBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 count \u003d 2;\u003c/code\u003e\r\n * @return Whether the count field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasCount() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "hasCount",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 count \u003d 2;\u003c/code\u003e\r\n * @return The count.\r\n */\r\n@java.lang.Override\r\npublic int getCount() {\r\n    return count_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "getCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    byte isInitialized \u003d memoizedIsInitialized;\r\n    if (isInitialized \u003d\u003d 1)\r\n        return true;\r\n    if (isInitialized \u003d\u003d 0)\r\n        return false;\r\n    memoizedIsInitialized \u003d 1;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, msg_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        output.writeInt32(2, count_);\r\n    }\r\n    unknownFields.writeTo(output);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "writeTo",
      "parameterTypes": [
        "com.google.protobuf.CodedOutputStream"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int getSerializedSize() {\r\n    int size \u003d memoizedSize;\r\n    if (size !\u003d -1)\r\n        return size;\r\n    size \u003d 0;\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.GeneratedMessageV3.computeStringSize(1, msg_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeInt32Size(2, count_);\r\n    }\r\n    size +\u003d unknownFields.getSerializedSize();\r\n    memoizedSize \u003d size;\r\n    return size;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "getSerializedSize",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic boolean equals(final java.lang.Object obj) {\r\n    if (obj \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof com.google.gson.protobuf.generated.Bag.SimpleProto)) {\r\n        return super.equals(obj);\r\n    }\r\n    com.google.gson.protobuf.generated.Bag.SimpleProto other \u003d (com.google.gson.protobuf.generated.Bag.SimpleProto) obj;\r\n    if (hasMsg() !\u003d other.hasMsg())\r\n        return false;\r\n    if (hasMsg()) {\r\n        if (!getMsg().equals(other.getMsg()))\r\n            return false;\r\n    }\r\n    if (hasCount() !\u003d other.hasCount())\r\n        return false;\r\n    if (hasCount()) {\r\n        if (getCount() !\u003d other.getCount())\r\n            return false;\r\n    }\r\n    if (!unknownFields.equals(other.unknownFields))\r\n        return false;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "equals",
      "parameterTypes": [
        "java.lang.Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int hashCode() {\r\n    if (memoizedHashCode !\u003d 0) {\r\n        return memoizedHashCode;\r\n    }\r\n    int hash \u003d 41;\r\n    hash \u003d (19 * hash) + getDescriptor().hashCode();\r\n    if (hasMsg()) {\r\n        hash \u003d (37 * hash) + MSG_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getMsg().hashCode();\r\n    }\r\n    if (hasCount()) {\r\n        hash \u003d (37 * hash) + COUNT_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getCount();\r\n    }\r\n    hash \u003d (29 * hash) + unknownFields.hashCode();\r\n    memoizedHashCode \u003d hash;\r\n    return hash;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder newBuilderForType() {\r\n    return newBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "newBuilderForType",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder() {\r\n    return DEFAULT_INSTANCE.toBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "newBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder(com.google.gson.protobuf.generated.Bag.SimpleProto prototype) {\r\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "newBuilder",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.SimpleProto"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder toBuilder() {\r\n    return this \u003d\u003d DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "toBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\r\n    Builder builder \u003d new Builder(parent);\r\n    return builder;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "newBuilderForType",
      "parameterTypes": [
        "com.google.protobuf.GeneratedMessageV3.BuilderParent"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_SimpleProto_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_SimpleProto_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.SimpleProto.class, com.google.gson.protobuf.generated.Bag.SimpleProto.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "private void maybeForceBuilderInitialization() {\r\n    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "maybeForceBuilderInitialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clear() {\r\n    super.clear();\r\n    msg_ \u003d \"\";\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    count_ \u003d 0;\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_SimpleProto_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "getDescriptorForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProto getDefaultInstanceForType() {\r\n    return com.google.gson.protobuf.generated.Bag.SimpleProto.getDefaultInstance();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProto build() {\r\n    com.google.gson.protobuf.generated.Bag.SimpleProto result \u003d buildPartial();\r\n    if (!result.isInitialized()) {\r\n        throw newUninitializedMessageException(result);\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "build",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProto buildPartial() {\r\n    com.google.gson.protobuf.generated.Bag.SimpleProto result \u003d new com.google.gson.protobuf.generated.Bag.SimpleProto(this);\r\n    int from_bitField0_ \u003d bitField0_;\r\n    int to_bitField0_ \u003d 0;\r\n    if (((from_bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        to_bitField0_ |\u003d 0x00000001;\r\n    }\r\n    result.msg_ \u003d msg_;\r\n    if (((from_bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        result.count_ \u003d count_;\r\n        to_bitField0_ |\u003d 0x00000002;\r\n    }\r\n    result.bitField0_ \u003d to_bitField0_;\r\n    onBuilt();\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "buildPartial",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clone() {\r\n    return super.clone();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "clone",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.setField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "setField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {\r\n    return super.clearField(field);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "clearField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {\r\n    return super.clearOneof(oneof);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "clearOneof",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.OneofDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {\r\n    return super.setRepeatedField(field, index, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "setRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "int",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.addRepeatedField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "addRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.Message other) {\r\n    if (other instanceof com.google.gson.protobuf.generated.Bag.SimpleProto) {\r\n        return mergeFrom((com.google.gson.protobuf.generated.Bag.SimpleProto) other);\r\n    } else {\r\n        super.mergeFrom(other);\r\n        return this;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.Message"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public Builder mergeFrom(com.google.gson.protobuf.generated.Bag.SimpleProto other) {\r\n    if (other \u003d\u003d com.google.gson.protobuf.generated.Bag.SimpleProto.getDefaultInstance())\r\n        return this;\r\n    if (other.hasMsg()) {\r\n        bitField0_ |\u003d 0x00000001;\r\n        msg_ \u003d other.msg_;\r\n        onChanged();\r\n    }\r\n    if (other.hasCount()) {\r\n        setCount(other.getCount());\r\n    }\r\n    this.mergeUnknownFields(other.unknownFields);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.SimpleProto"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    com.google.gson.protobuf.generated.Bag.SimpleProto parsedMessage \u003d null;\r\n    try {\r\n        parsedMessage \u003d PARSER.parsePartialFrom(input, extensionRegistry);\r\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\r\n        parsedMessage \u003d (com.google.gson.protobuf.generated.Bag.SimpleProto) e.getUnfinishedMessage();\r\n        throw e.unwrapIOException();\r\n    } finally {\r\n        if (parsedMessage !\u003d null) {\r\n            mergeFrom(parsedMessage);\r\n        }\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @return Whether the msg field is set.\r\n */\r\npublic boolean hasMsg() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "hasMsg",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @return The msg.\r\n */\r\npublic java.lang.String getMsg() {\r\n    java.lang.Object ref \u003d msg_;\r\n    if (!(ref instanceof java.lang.String)) {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            msg_ \u003d s;\r\n        }\r\n        return s;\r\n    } else {\r\n        return (java.lang.String) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "getMsg",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @return The bytes for msg.\r\n */\r\npublic com.google.protobuf.ByteString getMsgBytes() {\r\n    java.lang.Object ref \u003d msg_;\r\n    if (ref instanceof String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        msg_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "getMsgBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @param value The msg to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setMsg(java.lang.String value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000001;\r\n    msg_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "setMsg",
      "parameterTypes": [
        "java.lang.String"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearMsg() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    msg_ \u003d getDefaultInstance().getMsg();\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "clearMsg",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string msg \u003d 1;\u003c/code\u003e\r\n * @param value The bytes for msg to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setMsgBytes(com.google.protobuf.ByteString value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000001;\r\n    msg_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "setMsgBytes",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 count \u003d 2;\u003c/code\u003e\r\n * @return Whether the count field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasCount() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "hasCount",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 count \u003d 2;\u003c/code\u003e\r\n * @return The count.\r\n */\r\n@java.lang.Override\r\npublic int getCount() {\r\n    return count_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "getCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 count \u003d 2;\u003c/code\u003e\r\n * @param value The count to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setCount(int value) {\r\n    bitField0_ |\u003d 0x00000002;\r\n    count_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "setCount",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 count \u003d 2;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearCount() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    count_ \u003d 0;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "clearCount",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.setUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "setUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.mergeUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder",
      "methodName": "mergeUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.SimpleProto getDefaultInstance() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "getDefaultInstance",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic SimpleProto parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return new SimpleProto(input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parsePartialFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "SimpleProto"
    }
  },
  {
    "sourceCode": "public static com.google.protobuf.Parser\u003cSimpleProto\u003e parser() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "parser",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cSimpleProto\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Parser\u003cSimpleProto\u003e getParserForType() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "getParserForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cSimpleProto\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProto getDefaultInstanceForType() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.SimpleProto",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @return A list containing the nameThatTestsCaseFormat.\r\n */\r\njava.util.List\u003cjava.lang.String\u003e getNameThatTestsCaseFormatList();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormatOrBuilder",
      "methodName": "getNameThatTestsCaseFormatList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003cjava.lang.String\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @return The count of nameThatTestsCaseFormat.\r\n */\r\nint getNameThatTestsCaseFormatCount();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormatOrBuilder",
      "methodName": "getNameThatTestsCaseFormatCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @param index The index of the element to return.\r\n * @return The nameThatTestsCaseFormat at the given index.\r\n */\r\njava.lang.String getNameThatTestsCaseFormat(int index);",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormatOrBuilder",
      "methodName": "getNameThatTestsCaseFormat",
      "parameterTypes": [
        "int"
      ],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @param index The index of the value to return.\r\n * @return The bytes of the nameThatTestsCaseFormat at the given index.\r\n */\r\ncom.google.protobuf.ByteString getNameThatTestsCaseFormatBytes(int index);",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormatOrBuilder",
      "methodName": "getNameThatTestsCaseFormatBytes",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @return Whether the anotherField field is set.\r\n */\r\nboolean hasAnotherField();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormatOrBuilder",
      "methodName": "hasAnotherField",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @return The anotherField.\r\n */\r\njava.lang.String getAnotherField();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormatOrBuilder",
      "methodName": "getAnotherField",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @return The bytes for anotherField.\r\n */\r\ncom.google.protobuf.ByteString getAnotherFieldBytes();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormatOrBuilder",
      "methodName": "getAnotherFieldBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\n@SuppressWarnings({ \"unused\" })\r\nprotected java.lang.Object newInstance(UnusedPrivateParameter unused) {\r\n    return new ProtoWithDifferentCaseFormat();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "newInstance",
      "parameterTypes": [
        "UnusedPrivateParameter"
      ],
      "returnType": "java.lang.Object"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final com.google.protobuf.UnknownFieldSet getUnknownFields() {\r\n    return this.unknownFields;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getUnknownFields",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.UnknownFieldSet"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithDifferentCaseFormat_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithDifferentCaseFormat_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.class, com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @return A list containing the nameThatTestsCaseFormat.\r\n */\r\npublic com.google.protobuf.ProtocolStringList getNameThatTestsCaseFormatList() {\r\n    return nameThatTestsCaseFormat_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getNameThatTestsCaseFormatList",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ProtocolStringList"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @return The count of nameThatTestsCaseFormat.\r\n */\r\npublic int getNameThatTestsCaseFormatCount() {\r\n    return nameThatTestsCaseFormat_.size();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getNameThatTestsCaseFormatCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @param index The index of the element to return.\r\n * @return The nameThatTestsCaseFormat at the given index.\r\n */\r\npublic java.lang.String getNameThatTestsCaseFormat(int index) {\r\n    return nameThatTestsCaseFormat_.get(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getNameThatTestsCaseFormat",
      "parameterTypes": [
        "int"
      ],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @param index The index of the value to return.\r\n * @return The bytes of the nameThatTestsCaseFormat at the given index.\r\n */\r\npublic com.google.protobuf.ByteString getNameThatTestsCaseFormatBytes(int index) {\r\n    return nameThatTestsCaseFormat_.getByteString(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getNameThatTestsCaseFormatBytes",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @return Whether the anotherField field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasAnotherField() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "hasAnotherField",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @return The anotherField.\r\n */\r\n@java.lang.Override\r\npublic java.lang.String getAnotherField() {\r\n    java.lang.Object ref \u003d anotherField_;\r\n    if (ref instanceof java.lang.String) {\r\n        return (java.lang.String) ref;\r\n    } else {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            anotherField_ \u003d s;\r\n        }\r\n        return s;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getAnotherField",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @return The bytes for anotherField.\r\n */\r\n@java.lang.Override\r\npublic com.google.protobuf.ByteString getAnotherFieldBytes() {\r\n    java.lang.Object ref \u003d anotherField_;\r\n    if (ref instanceof java.lang.String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        anotherField_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getAnotherFieldBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    byte isInitialized \u003d memoizedIsInitialized;\r\n    if (isInitialized \u003d\u003d 1)\r\n        return true;\r\n    if (isInitialized \u003d\u003d 0)\r\n        return false;\r\n    memoizedIsInitialized \u003d 1;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {\r\n    for (int i \u003d 0; i \u003c nameThatTestsCaseFormat_.size(); i++) {\r\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, nameThatTestsCaseFormat_.getRaw(i));\r\n    }\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, anotherField_);\r\n    }\r\n    unknownFields.writeTo(output);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "writeTo",
      "parameterTypes": [
        "com.google.protobuf.CodedOutputStream"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int getSerializedSize() {\r\n    int size \u003d memoizedSize;\r\n    if (size !\u003d -1)\r\n        return size;\r\n    size \u003d 0;\r\n    {\r\n        int dataSize \u003d 0;\r\n        for (int i \u003d 0; i \u003c nameThatTestsCaseFormat_.size(); i++) {\r\n            dataSize +\u003d computeStringSizeNoTag(nameThatTestsCaseFormat_.getRaw(i));\r\n        }\r\n        size +\u003d dataSize;\r\n        size +\u003d 1 * getNameThatTestsCaseFormatList().size();\r\n    }\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.GeneratedMessageV3.computeStringSize(2, anotherField_);\r\n    }\r\n    size +\u003d unknownFields.getSerializedSize();\r\n    memoizedSize \u003d size;\r\n    return size;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getSerializedSize",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic boolean equals(final java.lang.Object obj) {\r\n    if (obj \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat)) {\r\n        return super.equals(obj);\r\n    }\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat other \u003d (com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat) obj;\r\n    if (!getNameThatTestsCaseFormatList().equals(other.getNameThatTestsCaseFormatList()))\r\n        return false;\r\n    if (hasAnotherField() !\u003d other.hasAnotherField())\r\n        return false;\r\n    if (hasAnotherField()) {\r\n        if (!getAnotherField().equals(other.getAnotherField()))\r\n            return false;\r\n    }\r\n    if (!unknownFields.equals(other.unknownFields))\r\n        return false;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "equals",
      "parameterTypes": [
        "java.lang.Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int hashCode() {\r\n    if (memoizedHashCode !\u003d 0) {\r\n        return memoizedHashCode;\r\n    }\r\n    int hash \u003d 41;\r\n    hash \u003d (19 * hash) + getDescriptor().hashCode();\r\n    if (getNameThatTestsCaseFormatCount() \u003e 0) {\r\n        hash \u003d (37 * hash) + NAME_THAT_TESTS_CASE_FORMAT_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getNameThatTestsCaseFormatList().hashCode();\r\n    }\r\n    if (hasAnotherField()) {\r\n        hash \u003d (37 * hash) + ANOTHER_FIELD_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getAnotherField().hashCode();\r\n    }\r\n    hash \u003d (29 * hash) + unknownFields.hashCode();\r\n    memoizedHashCode \u003d hash;\r\n    return hash;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder newBuilderForType() {\r\n    return newBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "newBuilderForType",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder() {\r\n    return DEFAULT_INSTANCE.toBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "newBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder(com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat prototype) {\r\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "newBuilder",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder toBuilder() {\r\n    return this \u003d\u003d DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "toBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\r\n    Builder builder \u003d new Builder(parent);\r\n    return builder;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "newBuilderForType",
      "parameterTypes": [
        "com.google.protobuf.GeneratedMessageV3.BuilderParent"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithDifferentCaseFormat_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithDifferentCaseFormat_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.class, com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "private void maybeForceBuilderInitialization() {\r\n    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "maybeForceBuilderInitialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clear() {\r\n    super.clear();\r\n    nameThatTestsCaseFormat_ \u003d com.google.protobuf.LazyStringArrayList.EMPTY;\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    anotherField_ \u003d \"\";\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithDifferentCaseFormat_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "getDescriptorForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat getDefaultInstanceForType() {\r\n    return com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.getDefaultInstance();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat build() {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat result \u003d buildPartial();\r\n    if (!result.isInitialized()) {\r\n        throw newUninitializedMessageException(result);\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "build",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat buildPartial() {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat result \u003d new com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat(this);\r\n    int from_bitField0_ \u003d bitField0_;\r\n    int to_bitField0_ \u003d 0;\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        nameThatTestsCaseFormat_ \u003d nameThatTestsCaseFormat_.getUnmodifiableView();\r\n        bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    }\r\n    result.nameThatTestsCaseFormat_ \u003d nameThatTestsCaseFormat_;\r\n    if (((from_bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        to_bitField0_ |\u003d 0x00000001;\r\n    }\r\n    result.anotherField_ \u003d anotherField_;\r\n    result.bitField0_ \u003d to_bitField0_;\r\n    onBuilt();\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "buildPartial",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clone() {\r\n    return super.clone();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "clone",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.setField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "setField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {\r\n    return super.clearField(field);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "clearField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {\r\n    return super.clearOneof(oneof);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "clearOneof",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.OneofDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {\r\n    return super.setRepeatedField(field, index, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "setRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "int",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.addRepeatedField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "addRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.Message other) {\r\n    if (other instanceof com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat) {\r\n        return mergeFrom((com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat) other);\r\n    } else {\r\n        super.mergeFrom(other);\r\n        return this;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.Message"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public Builder mergeFrom(com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat other) {\r\n    if (other \u003d\u003d com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.getDefaultInstance())\r\n        return this;\r\n    if (!other.nameThatTestsCaseFormat_.isEmpty()) {\r\n        if (nameThatTestsCaseFormat_.isEmpty()) {\r\n            nameThatTestsCaseFormat_ \u003d other.nameThatTestsCaseFormat_;\r\n            bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n        } else {\r\n            ensureNameThatTestsCaseFormatIsMutable();\r\n            nameThatTestsCaseFormat_.addAll(other.nameThatTestsCaseFormat_);\r\n        }\r\n        onChanged();\r\n    }\r\n    if (other.hasAnotherField()) {\r\n        bitField0_ |\u003d 0x00000002;\r\n        anotherField_ \u003d other.anotherField_;\r\n        onChanged();\r\n    }\r\n    this.mergeUnknownFields(other.unknownFields);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat parsedMessage \u003d null;\r\n    try {\r\n        parsedMessage \u003d PARSER.parsePartialFrom(input, extensionRegistry);\r\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\r\n        parsedMessage \u003d (com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat) e.getUnfinishedMessage();\r\n        throw e.unwrapIOException();\r\n    } finally {\r\n        if (parsedMessage !\u003d null) {\r\n            mergeFrom(parsedMessage);\r\n        }\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "private void ensureNameThatTestsCaseFormatIsMutable() {\r\n    if (!((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        nameThatTestsCaseFormat_ \u003d new com.google.protobuf.LazyStringArrayList(nameThatTestsCaseFormat_);\r\n        bitField0_ |\u003d 0x00000001;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "ensureNameThatTestsCaseFormatIsMutable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @return A list containing the nameThatTestsCaseFormat.\r\n */\r\npublic com.google.protobuf.ProtocolStringList getNameThatTestsCaseFormatList() {\r\n    return nameThatTestsCaseFormat_.getUnmodifiableView();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "getNameThatTestsCaseFormatList",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ProtocolStringList"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @return The count of nameThatTestsCaseFormat.\r\n */\r\npublic int getNameThatTestsCaseFormatCount() {\r\n    return nameThatTestsCaseFormat_.size();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "getNameThatTestsCaseFormatCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @param index The index of the element to return.\r\n * @return The nameThatTestsCaseFormat at the given index.\r\n */\r\npublic java.lang.String getNameThatTestsCaseFormat(int index) {\r\n    return nameThatTestsCaseFormat_.get(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "getNameThatTestsCaseFormat",
      "parameterTypes": [
        "int"
      ],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @param index The index of the value to return.\r\n * @return The bytes of the nameThatTestsCaseFormat at the given index.\r\n */\r\npublic com.google.protobuf.ByteString getNameThatTestsCaseFormatBytes(int index) {\r\n    return nameThatTestsCaseFormat_.getByteString(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "getNameThatTestsCaseFormatBytes",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @param index The index to set the value at.\r\n * @param value The nameThatTestsCaseFormat to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setNameThatTestsCaseFormat(int index, java.lang.String value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    ensureNameThatTestsCaseFormatIsMutable();\r\n    nameThatTestsCaseFormat_.set(index, value);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "setNameThatTestsCaseFormat",
      "parameterTypes": [
        "int",
        "java.lang.String"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @param value The nameThatTestsCaseFormat to add.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder addNameThatTestsCaseFormat(java.lang.String value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    ensureNameThatTestsCaseFormatIsMutable();\r\n    nameThatTestsCaseFormat_.add(value);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "addNameThatTestsCaseFormat",
      "parameterTypes": [
        "java.lang.String"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @param values The nameThatTestsCaseFormat to add.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder addAllNameThatTestsCaseFormat(java.lang.Iterable\u003cjava.lang.String\u003e values) {\r\n    ensureNameThatTestsCaseFormatIsMutable();\r\n    com.google.protobuf.AbstractMessageLite.Builder.addAll(values, nameThatTestsCaseFormat_);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "addAllNameThatTestsCaseFormat",
      "parameterTypes": [
        "java.lang.Iterable\u003cjava.lang.String\u003e"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearNameThatTestsCaseFormat() {\r\n    nameThatTestsCaseFormat_ \u003d com.google.protobuf.LazyStringArrayList.EMPTY;\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "clearNameThatTestsCaseFormat",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated string name_that_tests_case_format \u003d 1;\u003c/code\u003e\r\n * @param value The bytes of the nameThatTestsCaseFormat to add.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder addNameThatTestsCaseFormatBytes(com.google.protobuf.ByteString value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    ensureNameThatTestsCaseFormatIsMutable();\r\n    nameThatTestsCaseFormat_.add(value);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "addNameThatTestsCaseFormatBytes",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @return Whether the anotherField field is set.\r\n */\r\npublic boolean hasAnotherField() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "hasAnotherField",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @return The anotherField.\r\n */\r\npublic java.lang.String getAnotherField() {\r\n    java.lang.Object ref \u003d anotherField_;\r\n    if (!(ref instanceof java.lang.String)) {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            anotherField_ \u003d s;\r\n        }\r\n        return s;\r\n    } else {\r\n        return (java.lang.String) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "getAnotherField",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @return The bytes for anotherField.\r\n */\r\npublic com.google.protobuf.ByteString getAnotherFieldBytes() {\r\n    java.lang.Object ref \u003d anotherField_;\r\n    if (ref instanceof String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        anotherField_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "getAnotherFieldBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @param value The anotherField to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setAnotherField(java.lang.String value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000002;\r\n    anotherField_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "setAnotherField",
      "parameterTypes": [
        "java.lang.String"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearAnotherField() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    anotherField_ \u003d getDefaultInstance().getAnotherField();\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "clearAnotherField",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string another_field \u003d 2;\u003c/code\u003e\r\n * @param value The bytes for anotherField to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setAnotherFieldBytes(com.google.protobuf.ByteString value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000002;\r\n    anotherField_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "setAnotherFieldBytes",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.setUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "setUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.mergeUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat.Builder",
      "methodName": "mergeUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat getDefaultInstance() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getDefaultInstance",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic ProtoWithDifferentCaseFormat parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return new ProtoWithDifferentCaseFormat(input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parsePartialFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "public static com.google.protobuf.Parser\u003cProtoWithDifferentCaseFormat\u003e parser() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "parser",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cProtoWithDifferentCaseFormat\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Parser\u003cProtoWithDifferentCaseFormat\u003e getParserForType() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getParserForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cProtoWithDifferentCaseFormat\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat getDefaultInstanceForType() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @return A list containing the numbers.\r\n */\r\njava.util.List\u003cjava.lang.Long\u003e getNumbersList();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "getNumbersList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003cjava.lang.Long\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @return The count of numbers.\r\n */\r\nint getNumbersCount();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "getNumbersCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @param index The index of the element to return.\r\n * @return The numbers at the given index.\r\n */\r\nlong getNumbers(int index);",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "getNumbers",
      "parameterTypes": [
        "int"
      ],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\njava.util.List\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto\u003e getSimplesList();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "getSimplesList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\ncom.google.gson.protobuf.generated.Bag.SimpleProto getSimples(int index);",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "getSimples",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\nint getSimplesCount();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "getSimplesCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\njava.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder\u003e getSimplesOrBuilderList();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "getSimplesOrBuilderList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\ncom.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder getSimplesOrBuilder(int index);",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "getSimplesOrBuilder",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @return Whether the name field is set.\r\n */\r\nboolean hasName();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "hasName",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @return The name.\r\n */\r\njava.lang.String getName();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "getName",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @return The bytes for name.\r\n */\r\ncom.google.protobuf.ByteString getNameBytes();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFieldsOrBuilder",
      "methodName": "getNameBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\n@SuppressWarnings({ \"unused\" })\r\nprotected java.lang.Object newInstance(UnusedPrivateParameter unused) {\r\n    return new ProtoWithRepeatedFields();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "newInstance",
      "parameterTypes": [
        "UnusedPrivateParameter"
      ],
      "returnType": "java.lang.Object"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final com.google.protobuf.UnknownFieldSet getUnknownFields() {\r\n    return this.unknownFields;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getUnknownFields",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.UnknownFieldSet"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithRepeatedFields_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithRepeatedFields_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.class, com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @return A list containing the numbers.\r\n */\r\n@java.lang.Override\r\npublic java.util.List\u003cjava.lang.Long\u003e getNumbersList() {\r\n    return numbers_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getNumbersList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003cjava.lang.Long\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @return The count of numbers.\r\n */\r\npublic int getNumbersCount() {\r\n    return numbers_.size();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getNumbersCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @param index The index of the element to return.\r\n * @return The numbers at the given index.\r\n */\r\npublic long getNumbers(int index) {\r\n    return numbers_.getLong(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getNumbers",
      "parameterTypes": [
        "int"
      ],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic java.util.List\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto\u003e getSimplesList() {\r\n    return simples_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getSimplesList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic java.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder\u003e getSimplesOrBuilderList() {\r\n    return simples_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getSimplesOrBuilderList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic int getSimplesCount() {\r\n    return simples_.size();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getSimplesCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProto getSimples(int index) {\r\n    return simples_.get(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getSimples",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder getSimplesOrBuilder(int index) {\r\n    return simples_.get(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getSimplesOrBuilder",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @return Whether the name field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasName() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "hasName",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @return The name.\r\n */\r\n@java.lang.Override\r\npublic java.lang.String getName() {\r\n    java.lang.Object ref \u003d name_;\r\n    if (ref instanceof java.lang.String) {\r\n        return (java.lang.String) ref;\r\n    } else {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            name_ \u003d s;\r\n        }\r\n        return s;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getName",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @return The bytes for name.\r\n */\r\n@java.lang.Override\r\npublic com.google.protobuf.ByteString getNameBytes() {\r\n    java.lang.Object ref \u003d name_;\r\n    if (ref instanceof java.lang.String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        name_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getNameBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    byte isInitialized \u003d memoizedIsInitialized;\r\n    if (isInitialized \u003d\u003d 1)\r\n        return true;\r\n    if (isInitialized \u003d\u003d 0)\r\n        return false;\r\n    memoizedIsInitialized \u003d 1;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {\r\n    for (int i \u003d 0; i \u003c numbers_.size(); i++) {\r\n        output.writeInt64(1, numbers_.getLong(i));\r\n    }\r\n    for (int i \u003d 0; i \u003c simples_.size(); i++) {\r\n        output.writeMessage(2, simples_.get(i));\r\n    }\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, name_);\r\n    }\r\n    unknownFields.writeTo(output);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "writeTo",
      "parameterTypes": [
        "com.google.protobuf.CodedOutputStream"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int getSerializedSize() {\r\n    int size \u003d memoizedSize;\r\n    if (size !\u003d -1)\r\n        return size;\r\n    size \u003d 0;\r\n    {\r\n        int dataSize \u003d 0;\r\n        for (int i \u003d 0; i \u003c numbers_.size(); i++) {\r\n            dataSize +\u003d com.google.protobuf.CodedOutputStream.computeInt64SizeNoTag(numbers_.getLong(i));\r\n        }\r\n        size +\u003d dataSize;\r\n        size +\u003d 1 * getNumbersList().size();\r\n    }\r\n    for (int i \u003d 0; i \u003c simples_.size(); i++) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeMessageSize(2, simples_.get(i));\r\n    }\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.GeneratedMessageV3.computeStringSize(3, name_);\r\n    }\r\n    size +\u003d unknownFields.getSerializedSize();\r\n    memoizedSize \u003d size;\r\n    return size;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getSerializedSize",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic boolean equals(final java.lang.Object obj) {\r\n    if (obj \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields)) {\r\n        return super.equals(obj);\r\n    }\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields other \u003d (com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields) obj;\r\n    if (!getNumbersList().equals(other.getNumbersList()))\r\n        return false;\r\n    if (!getSimplesList().equals(other.getSimplesList()))\r\n        return false;\r\n    if (hasName() !\u003d other.hasName())\r\n        return false;\r\n    if (hasName()) {\r\n        if (!getName().equals(other.getName()))\r\n            return false;\r\n    }\r\n    if (!unknownFields.equals(other.unknownFields))\r\n        return false;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "equals",
      "parameterTypes": [
        "java.lang.Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int hashCode() {\r\n    if (memoizedHashCode !\u003d 0) {\r\n        return memoizedHashCode;\r\n    }\r\n    int hash \u003d 41;\r\n    hash \u003d (19 * hash) + getDescriptor().hashCode();\r\n    if (getNumbersCount() \u003e 0) {\r\n        hash \u003d (37 * hash) + NUMBERS_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getNumbersList().hashCode();\r\n    }\r\n    if (getSimplesCount() \u003e 0) {\r\n        hash \u003d (37 * hash) + SIMPLES_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getSimplesList().hashCode();\r\n    }\r\n    if (hasName()) {\r\n        hash \u003d (37 * hash) + NAME_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getName().hashCode();\r\n    }\r\n    hash \u003d (29 * hash) + unknownFields.hashCode();\r\n    memoizedHashCode \u003d hash;\r\n    return hash;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder newBuilderForType() {\r\n    return newBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "newBuilderForType",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder() {\r\n    return DEFAULT_INSTANCE.toBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "newBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder(com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields prototype) {\r\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "newBuilder",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder toBuilder() {\r\n    return this \u003d\u003d DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "toBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\r\n    Builder builder \u003d new Builder(parent);\r\n    return builder;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "newBuilderForType",
      "parameterTypes": [
        "com.google.protobuf.GeneratedMessageV3.BuilderParent"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithRepeatedFields_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithRepeatedFields_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.class, com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "private void maybeForceBuilderInitialization() {\r\n    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {\r\n        getSimplesFieldBuilder();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "maybeForceBuilderInitialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clear() {\r\n    super.clear();\r\n    numbers_ \u003d emptyLongList();\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        simples_ \u003d java.util.Collections.emptyList();\r\n        bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    } else {\r\n        simplesBuilder_.clear();\r\n    }\r\n    name_ \u003d \"\";\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithRepeatedFields_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getDescriptorForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields getDefaultInstanceForType() {\r\n    return com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.getDefaultInstance();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields build() {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields result \u003d buildPartial();\r\n    if (!result.isInitialized()) {\r\n        throw newUninitializedMessageException(result);\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "build",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields buildPartial() {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields result \u003d new com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields(this);\r\n    int from_bitField0_ \u003d bitField0_;\r\n    int to_bitField0_ \u003d 0;\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        numbers_.makeImmutable();\r\n        bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    }\r\n    result.numbers_ \u003d numbers_;\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n            simples_ \u003d java.util.Collections.unmodifiableList(simples_);\r\n            bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n        }\r\n        result.simples_ \u003d simples_;\r\n    } else {\r\n        result.simples_ \u003d simplesBuilder_.build();\r\n    }\r\n    if (((from_bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        to_bitField0_ |\u003d 0x00000001;\r\n    }\r\n    result.name_ \u003d name_;\r\n    result.bitField0_ \u003d to_bitField0_;\r\n    onBuilt();\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "buildPartial",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clone() {\r\n    return super.clone();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "clone",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.setField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "setField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {\r\n    return super.clearField(field);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "clearField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {\r\n    return super.clearOneof(oneof);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "clearOneof",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.OneofDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {\r\n    return super.setRepeatedField(field, index, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "setRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "int",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.addRepeatedField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "addRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.Message other) {\r\n    if (other instanceof com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields) {\r\n        return mergeFrom((com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields) other);\r\n    } else {\r\n        super.mergeFrom(other);\r\n        return this;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.Message"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public Builder mergeFrom(com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields other) {\r\n    if (other \u003d\u003d com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.getDefaultInstance())\r\n        return this;\r\n    if (!other.numbers_.isEmpty()) {\r\n        if (numbers_.isEmpty()) {\r\n            numbers_ \u003d other.numbers_;\r\n            bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n        } else {\r\n            ensureNumbersIsMutable();\r\n            numbers_.addAll(other.numbers_);\r\n        }\r\n        onChanged();\r\n    }\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        if (!other.simples_.isEmpty()) {\r\n            if (simples_.isEmpty()) {\r\n                simples_ \u003d other.simples_;\r\n                bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n            } else {\r\n                ensureSimplesIsMutable();\r\n                simples_.addAll(other.simples_);\r\n            }\r\n            onChanged();\r\n        }\r\n    } else {\r\n        if (!other.simples_.isEmpty()) {\r\n            if (simplesBuilder_.isEmpty()) {\r\n                simplesBuilder_.dispose();\r\n                simplesBuilder_ \u003d null;\r\n                simples_ \u003d other.simples_;\r\n                bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n                simplesBuilder_ \u003d com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ? getSimplesFieldBuilder() : null;\r\n            } else {\r\n                simplesBuilder_.addAllMessages(other.simples_);\r\n            }\r\n        }\r\n    }\r\n    if (other.hasName()) {\r\n        bitField0_ |\u003d 0x00000004;\r\n        name_ \u003d other.name_;\r\n        onChanged();\r\n    }\r\n    this.mergeUnknownFields(other.unknownFields);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields parsedMessage \u003d null;\r\n    try {\r\n        parsedMessage \u003d PARSER.parsePartialFrom(input, extensionRegistry);\r\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\r\n        parsedMessage \u003d (com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields) e.getUnfinishedMessage();\r\n        throw e.unwrapIOException();\r\n    } finally {\r\n        if (parsedMessage !\u003d null) {\r\n            mergeFrom(parsedMessage);\r\n        }\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "private void ensureNumbersIsMutable() {\r\n    if (!((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        numbers_ \u003d mutableCopy(numbers_);\r\n        bitField0_ |\u003d 0x00000001;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "ensureNumbersIsMutable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @return A list containing the numbers.\r\n */\r\npublic java.util.List\u003cjava.lang.Long\u003e getNumbersList() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0) ? java.util.Collections.unmodifiableList(numbers_) : numbers_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getNumbersList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003cjava.lang.Long\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @return The count of numbers.\r\n */\r\npublic int getNumbersCount() {\r\n    return numbers_.size();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getNumbersCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @param index The index of the element to return.\r\n * @return The numbers at the given index.\r\n */\r\npublic long getNumbers(int index) {\r\n    return numbers_.getLong(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getNumbers",
      "parameterTypes": [
        "int"
      ],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @param index The index to set the value at.\r\n * @param value The numbers to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setNumbers(int index, long value) {\r\n    ensureNumbersIsMutable();\r\n    numbers_.setLong(index, value);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "setNumbers",
      "parameterTypes": [
        "int",
        "long"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @param value The numbers to add.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder addNumbers(long value) {\r\n    ensureNumbersIsMutable();\r\n    numbers_.addLong(value);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "addNumbers",
      "parameterTypes": [
        "long"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @param values The numbers to add.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder addAllNumbers(java.lang.Iterable\u003c? extends java.lang.Long\u003e values) {\r\n    ensureNumbersIsMutable();\r\n    com.google.protobuf.AbstractMessageLite.Builder.addAll(values, numbers_);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "addAllNumbers",
      "parameterTypes": [
        "java.lang.Iterable\u003c? extends java.lang.Long\u003e"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated int64 numbers \u003d 1;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearNumbers() {\r\n    numbers_ \u003d emptyLongList();\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "clearNumbers",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "private void ensureSimplesIsMutable() {\r\n    if (!((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        simples_ \u003d new java.util.ArrayList\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto\u003e(simples_);\r\n        bitField0_ |\u003d 0x00000002;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "ensureSimplesIsMutable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic java.util.List\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto\u003e getSimplesList() {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        return java.util.Collections.unmodifiableList(simples_);\r\n    } else {\r\n        return simplesBuilder_.getMessageList();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getSimplesList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic int getSimplesCount() {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        return simples_.size();\r\n    } else {\r\n        return simplesBuilder_.getCount();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getSimplesCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProto getSimples(int index) {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        return simples_.get(index);\r\n    } else {\r\n        return simplesBuilder_.getMessage(index);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getSimples",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic Builder setSimples(int index, com.google.gson.protobuf.generated.Bag.SimpleProto value) {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        if (value \u003d\u003d null) {\r\n            throw new NullPointerException();\r\n        }\r\n        ensureSimplesIsMutable();\r\n        simples_.set(index, value);\r\n        onChanged();\r\n    } else {\r\n        simplesBuilder_.setMessage(index, value);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "setSimples",
      "parameterTypes": [
        "int",
        "com.google.gson.protobuf.generated.Bag.SimpleProto"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic Builder setSimples(int index, com.google.gson.protobuf.generated.Bag.SimpleProto.Builder builderForValue) {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        ensureSimplesIsMutable();\r\n        simples_.set(index, builderForValue.build());\r\n        onChanged();\r\n    } else {\r\n        simplesBuilder_.setMessage(index, builderForValue.build());\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "setSimples",
      "parameterTypes": [
        "int",
        "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic Builder addSimples(com.google.gson.protobuf.generated.Bag.SimpleProto value) {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        if (value \u003d\u003d null) {\r\n            throw new NullPointerException();\r\n        }\r\n        ensureSimplesIsMutable();\r\n        simples_.add(value);\r\n        onChanged();\r\n    } else {\r\n        simplesBuilder_.addMessage(value);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "addSimples",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.SimpleProto"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic Builder addSimples(int index, com.google.gson.protobuf.generated.Bag.SimpleProto value) {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        if (value \u003d\u003d null) {\r\n            throw new NullPointerException();\r\n        }\r\n        ensureSimplesIsMutable();\r\n        simples_.add(index, value);\r\n        onChanged();\r\n    } else {\r\n        simplesBuilder_.addMessage(index, value);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "addSimples",
      "parameterTypes": [
        "int",
        "com.google.gson.protobuf.generated.Bag.SimpleProto"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic Builder addSimples(com.google.gson.protobuf.generated.Bag.SimpleProto.Builder builderForValue) {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        ensureSimplesIsMutable();\r\n        simples_.add(builderForValue.build());\r\n        onChanged();\r\n    } else {\r\n        simplesBuilder_.addMessage(builderForValue.build());\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "addSimples",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic Builder addSimples(int index, com.google.gson.protobuf.generated.Bag.SimpleProto.Builder builderForValue) {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        ensureSimplesIsMutable();\r\n        simples_.add(index, builderForValue.build());\r\n        onChanged();\r\n    } else {\r\n        simplesBuilder_.addMessage(index, builderForValue.build());\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "addSimples",
      "parameterTypes": [
        "int",
        "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic Builder addAllSimples(java.lang.Iterable\u003c? extends com.google.gson.protobuf.generated.Bag.SimpleProto\u003e values) {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        ensureSimplesIsMutable();\r\n        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, simples_);\r\n        onChanged();\r\n    } else {\r\n        simplesBuilder_.addAllMessages(values);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "addAllSimples",
      "parameterTypes": [
        "java.lang.Iterable\u003c? extends com.google.gson.protobuf.generated.Bag.SimpleProto\u003e"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic Builder clearSimples() {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        simples_ \u003d java.util.Collections.emptyList();\r\n        bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n        onChanged();\r\n    } else {\r\n        simplesBuilder_.clear();\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "clearSimples",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic Builder removeSimples(int index) {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        ensureSimplesIsMutable();\r\n        simples_.remove(index);\r\n        onChanged();\r\n    } else {\r\n        simplesBuilder_.remove(index);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "removeSimples",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProto.Builder getSimplesBuilder(int index) {\r\n    return getSimplesFieldBuilder().getBuilder(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getSimplesBuilder",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder getSimplesOrBuilder(int index) {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        return simples_.get(index);\r\n    } else {\r\n        return simplesBuilder_.getMessageOrBuilder(index);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getSimplesOrBuilder",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic java.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder\u003e getSimplesOrBuilderList() {\r\n    if (simplesBuilder_ !\u003d null) {\r\n        return simplesBuilder_.getMessageOrBuilderList();\r\n    } else {\r\n        return java.util.Collections.unmodifiableList(simples_);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getSimplesOrBuilderList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProto.Builder addSimplesBuilder() {\r\n    return getSimplesFieldBuilder().addBuilder(com.google.gson.protobuf.generated.Bag.SimpleProto.getDefaultInstance());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "addSimplesBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.SimpleProto.Builder addSimplesBuilder(int index) {\r\n    return getSimplesFieldBuilder().addBuilder(index, com.google.gson.protobuf.generated.Bag.SimpleProto.getDefaultInstance());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "addSimplesBuilder",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.SimpleProto.Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.SimpleProto simples \u003d 2;\u003c/code\u003e\r\n */\r\npublic java.util.List\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto.Builder\u003e getSimplesBuilderList() {\r\n    return getSimplesFieldBuilder().getBuilderList();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getSimplesBuilderList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto.Builder\u003e"
    }
  },
  {
    "sourceCode": "private com.google.protobuf.RepeatedFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto, com.google.gson.protobuf.generated.Bag.SimpleProto.Builder, com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder\u003e getSimplesFieldBuilder() {\r\n    if (simplesBuilder_ \u003d\u003d null) {\r\n        simplesBuilder_ \u003d new com.google.protobuf.RepeatedFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto, com.google.gson.protobuf.generated.Bag.SimpleProto.Builder, com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder\u003e(simples_, ((bitField0_ \u0026 0x00000002) !\u003d 0), getParentForChildren(), isClean());\r\n        simples_ \u003d null;\r\n    }\r\n    return simplesBuilder_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getSimplesFieldBuilder",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.RepeatedFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.SimpleProto, com.google.gson.protobuf.generated.Bag.SimpleProto.Builder, com.google.gson.protobuf.generated.Bag.SimpleProtoOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @return Whether the name field is set.\r\n */\r\npublic boolean hasName() {\r\n    return ((bitField0_ \u0026 0x00000004) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "hasName",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @return The name.\r\n */\r\npublic java.lang.String getName() {\r\n    java.lang.Object ref \u003d name_;\r\n    if (!(ref instanceof java.lang.String)) {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            name_ \u003d s;\r\n        }\r\n        return s;\r\n    } else {\r\n        return (java.lang.String) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getName",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @return The bytes for name.\r\n */\r\npublic com.google.protobuf.ByteString getNameBytes() {\r\n    java.lang.Object ref \u003d name_;\r\n    if (ref instanceof String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        name_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "getNameBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @param value The name to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setName(java.lang.String value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000004;\r\n    name_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "setName",
      "parameterTypes": [
        "java.lang.String"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearName() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n    name_ \u003d getDefaultInstance().getName();\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "clearName",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string name \u003d 3;\u003c/code\u003e\r\n * @param value The bytes for name to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setNameBytes(com.google.protobuf.ByteString value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000004;\r\n    name_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "setNameBytes",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.setUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "setUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.mergeUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields.Builder",
      "methodName": "mergeUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields getDefaultInstance() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getDefaultInstance",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic ProtoWithRepeatedFields parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return new ProtoWithRepeatedFields(input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parsePartialFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "public static com.google.protobuf.Parser\u003cProtoWithRepeatedFields\u003e parser() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "parser",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cProtoWithRepeatedFields\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Parser\u003cProtoWithRepeatedFields\u003e getParserForType() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getParserForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cProtoWithRepeatedFields\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields getDefaultInstanceForType() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 month \u003d 1;\u003c/code\u003e\r\n * @return Whether the month field is set.\r\n */\r\nboolean hasMonth();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder",
      "methodName": "hasMonth",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 month \u003d 1;\u003c/code\u003e\r\n * @return The month.\r\n */\r\nint getMonth();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder",
      "methodName": "getMonth",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 year \u003d 2;\u003c/code\u003e\r\n * @return Whether the year field is set.\r\n */\r\nboolean hasYear();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder",
      "methodName": "hasYear",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 year \u003d 2;\u003c/code\u003e\r\n * @return The year.\r\n */\r\nint getYear();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder",
      "methodName": "getYear",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int64 long_timestamp \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"timeStamp\"];\u003c/code\u003e\r\n * @return Whether the longTimestamp field is set.\r\n */\r\nboolean hasLongTimestamp();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder",
      "methodName": "hasLongTimestamp",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int64 long_timestamp \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"timeStamp\"];\u003c/code\u003e\r\n * @return The longTimestamp.\r\n */\r\nlong getLongTimestamp();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder",
      "methodName": "getLongTimestamp",
      "parameterTypes": [],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @return Whether the countryCode5f55 field is set.\r\n */\r\nboolean hasCountryCode5F55();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder",
      "methodName": "hasCountryCode5F55",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @return The countryCode5f55.\r\n */\r\njava.lang.String getCountryCode5F55();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder",
      "methodName": "getCountryCode5F55",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @return The bytes for countryCode5f55.\r\n */\r\ncom.google.protobuf.ByteString getCountryCode5F55Bytes();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder",
      "methodName": "getCountryCode5F55Bytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\n@SuppressWarnings({ \"unused\" })\r\nprotected java.lang.Object newInstance(UnusedPrivateParameter unused) {\r\n    return new OuterMessage();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "newInstance",
      "parameterTypes": [
        "UnusedPrivateParameter"
      ],
      "returnType": "java.lang.Object"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final com.google.protobuf.UnknownFieldSet getUnknownFields() {\r\n    return this.unknownFields;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getUnknownFields",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.UnknownFieldSet"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_OuterMessage_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_OuterMessage_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.OuterMessage.class, com.google.gson.protobuf.generated.Bag.OuterMessage.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 month \u003d 1;\u003c/code\u003e\r\n * @return Whether the month field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasMonth() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "hasMonth",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 month \u003d 1;\u003c/code\u003e\r\n * @return The month.\r\n */\r\n@java.lang.Override\r\npublic int getMonth() {\r\n    return month_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getMonth",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 year \u003d 2;\u003c/code\u003e\r\n * @return Whether the year field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasYear() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "hasYear",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 year \u003d 2;\u003c/code\u003e\r\n * @return The year.\r\n */\r\n@java.lang.Override\r\npublic int getYear() {\r\n    return year_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getYear",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int64 long_timestamp \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"timeStamp\"];\u003c/code\u003e\r\n * @return Whether the longTimestamp field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasLongTimestamp() {\r\n    return ((bitField0_ \u0026 0x00000004) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "hasLongTimestamp",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int64 long_timestamp \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"timeStamp\"];\u003c/code\u003e\r\n * @return The longTimestamp.\r\n */\r\n@java.lang.Override\r\npublic long getLongTimestamp() {\r\n    return longTimestamp_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getLongTimestamp",
      "parameterTypes": [],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @return Whether the countryCode5f55 field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasCountryCode5F55() {\r\n    return ((bitField0_ \u0026 0x00000008) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "hasCountryCode5F55",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @return The countryCode5f55.\r\n */\r\n@java.lang.Override\r\npublic java.lang.String getCountryCode5F55() {\r\n    java.lang.Object ref \u003d countryCode5F55_;\r\n    if (ref instanceof java.lang.String) {\r\n        return (java.lang.String) ref;\r\n    } else {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            countryCode5F55_ \u003d s;\r\n        }\r\n        return s;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getCountryCode5F55",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @return The bytes for countryCode5f55.\r\n */\r\n@java.lang.Override\r\npublic com.google.protobuf.ByteString getCountryCode5F55Bytes() {\r\n    java.lang.Object ref \u003d countryCode5F55_;\r\n    if (ref instanceof java.lang.String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        countryCode5F55_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getCountryCode5F55Bytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    byte isInitialized \u003d memoizedIsInitialized;\r\n    if (isInitialized \u003d\u003d 1)\r\n        return true;\r\n    if (isInitialized \u003d\u003d 0)\r\n        return false;\r\n    memoizedIsInitialized \u003d 1;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        output.writeInt32(1, month_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        output.writeInt32(2, year_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        output.writeInt64(3, longTimestamp_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000008) !\u003d 0)) {\r\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, countryCode5F55_);\r\n    }\r\n    unknownFields.writeTo(output);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "writeTo",
      "parameterTypes": [
        "com.google.protobuf.CodedOutputStream"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int getSerializedSize() {\r\n    int size \u003d memoizedSize;\r\n    if (size !\u003d -1)\r\n        return size;\r\n    size \u003d 0;\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeInt32Size(1, month_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeInt32Size(2, year_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeInt64Size(3, longTimestamp_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000008) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.GeneratedMessageV3.computeStringSize(4, countryCode5F55_);\r\n    }\r\n    size +\u003d unknownFields.getSerializedSize();\r\n    memoizedSize \u003d size;\r\n    return size;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getSerializedSize",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic boolean equals(final java.lang.Object obj) {\r\n    if (obj \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof com.google.gson.protobuf.generated.Bag.OuterMessage)) {\r\n        return super.equals(obj);\r\n    }\r\n    com.google.gson.protobuf.generated.Bag.OuterMessage other \u003d (com.google.gson.protobuf.generated.Bag.OuterMessage) obj;\r\n    if (hasMonth() !\u003d other.hasMonth())\r\n        return false;\r\n    if (hasMonth()) {\r\n        if (getMonth() !\u003d other.getMonth())\r\n            return false;\r\n    }\r\n    if (hasYear() !\u003d other.hasYear())\r\n        return false;\r\n    if (hasYear()) {\r\n        if (getYear() !\u003d other.getYear())\r\n            return false;\r\n    }\r\n    if (hasLongTimestamp() !\u003d other.hasLongTimestamp())\r\n        return false;\r\n    if (hasLongTimestamp()) {\r\n        if (getLongTimestamp() !\u003d other.getLongTimestamp())\r\n            return false;\r\n    }\r\n    if (hasCountryCode5F55() !\u003d other.hasCountryCode5F55())\r\n        return false;\r\n    if (hasCountryCode5F55()) {\r\n        if (!getCountryCode5F55().equals(other.getCountryCode5F55()))\r\n            return false;\r\n    }\r\n    if (!unknownFields.equals(other.unknownFields))\r\n        return false;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "equals",
      "parameterTypes": [
        "java.lang.Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int hashCode() {\r\n    if (memoizedHashCode !\u003d 0) {\r\n        return memoizedHashCode;\r\n    }\r\n    int hash \u003d 41;\r\n    hash \u003d (19 * hash) + getDescriptor().hashCode();\r\n    if (hasMonth()) {\r\n        hash \u003d (37 * hash) + MONTH_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getMonth();\r\n    }\r\n    if (hasYear()) {\r\n        hash \u003d (37 * hash) + YEAR_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getYear();\r\n    }\r\n    if (hasLongTimestamp()) {\r\n        hash \u003d (37 * hash) + LONG_TIMESTAMP_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + com.google.protobuf.Internal.hashLong(getLongTimestamp());\r\n    }\r\n    if (hasCountryCode5F55()) {\r\n        hash \u003d (37 * hash) + COUNTRY_CODE_5F55_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getCountryCode5F55().hashCode();\r\n    }\r\n    hash \u003d (29 * hash) + unknownFields.hashCode();\r\n    memoizedHashCode \u003d hash;\r\n    return hash;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder newBuilderForType() {\r\n    return newBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "newBuilderForType",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder() {\r\n    return DEFAULT_INSTANCE.toBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "newBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder(com.google.gson.protobuf.generated.Bag.OuterMessage prototype) {\r\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "newBuilder",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.OuterMessage"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder toBuilder() {\r\n    return this \u003d\u003d DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "toBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\r\n    Builder builder \u003d new Builder(parent);\r\n    return builder;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "newBuilderForType",
      "parameterTypes": [
        "com.google.protobuf.GeneratedMessageV3.BuilderParent"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_OuterMessage_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_OuterMessage_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.OuterMessage.class, com.google.gson.protobuf.generated.Bag.OuterMessage.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "private void maybeForceBuilderInitialization() {\r\n    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "maybeForceBuilderInitialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clear() {\r\n    super.clear();\r\n    month_ \u003d 0;\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    year_ \u003d 0;\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    longTimestamp_ \u003d 0L;\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n    countryCode5F55_ \u003d \"\";\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000008);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_OuterMessage_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "getDescriptorForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.OuterMessage getDefaultInstanceForType() {\r\n    return com.google.gson.protobuf.generated.Bag.OuterMessage.getDefaultInstance();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.OuterMessage build() {\r\n    com.google.gson.protobuf.generated.Bag.OuterMessage result \u003d buildPartial();\r\n    if (!result.isInitialized()) {\r\n        throw newUninitializedMessageException(result);\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "build",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.OuterMessage buildPartial() {\r\n    com.google.gson.protobuf.generated.Bag.OuterMessage result \u003d new com.google.gson.protobuf.generated.Bag.OuterMessage(this);\r\n    int from_bitField0_ \u003d bitField0_;\r\n    int to_bitField0_ \u003d 0;\r\n    if (((from_bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        result.month_ \u003d month_;\r\n        to_bitField0_ |\u003d 0x00000001;\r\n    }\r\n    if (((from_bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        result.year_ \u003d year_;\r\n        to_bitField0_ |\u003d 0x00000002;\r\n    }\r\n    if (((from_bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        result.longTimestamp_ \u003d longTimestamp_;\r\n        to_bitField0_ |\u003d 0x00000004;\r\n    }\r\n    if (((from_bitField0_ \u0026 0x00000008) !\u003d 0)) {\r\n        to_bitField0_ |\u003d 0x00000008;\r\n    }\r\n    result.countryCode5F55_ \u003d countryCode5F55_;\r\n    result.bitField0_ \u003d to_bitField0_;\r\n    onBuilt();\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "buildPartial",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clone() {\r\n    return super.clone();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "clone",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.setField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "setField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {\r\n    return super.clearField(field);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "clearField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {\r\n    return super.clearOneof(oneof);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "clearOneof",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.OneofDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {\r\n    return super.setRepeatedField(field, index, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "setRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "int",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.addRepeatedField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "addRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.Message other) {\r\n    if (other instanceof com.google.gson.protobuf.generated.Bag.OuterMessage) {\r\n        return mergeFrom((com.google.gson.protobuf.generated.Bag.OuterMessage) other);\r\n    } else {\r\n        super.mergeFrom(other);\r\n        return this;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.Message"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public Builder mergeFrom(com.google.gson.protobuf.generated.Bag.OuterMessage other) {\r\n    if (other \u003d\u003d com.google.gson.protobuf.generated.Bag.OuterMessage.getDefaultInstance())\r\n        return this;\r\n    if (other.hasMonth()) {\r\n        setMonth(other.getMonth());\r\n    }\r\n    if (other.hasYear()) {\r\n        setYear(other.getYear());\r\n    }\r\n    if (other.hasLongTimestamp()) {\r\n        setLongTimestamp(other.getLongTimestamp());\r\n    }\r\n    if (other.hasCountryCode5F55()) {\r\n        bitField0_ |\u003d 0x00000008;\r\n        countryCode5F55_ \u003d other.countryCode5F55_;\r\n        onChanged();\r\n    }\r\n    this.mergeUnknownFields(other.unknownFields);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.OuterMessage"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    com.google.gson.protobuf.generated.Bag.OuterMessage parsedMessage \u003d null;\r\n    try {\r\n        parsedMessage \u003d PARSER.parsePartialFrom(input, extensionRegistry);\r\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\r\n        parsedMessage \u003d (com.google.gson.protobuf.generated.Bag.OuterMessage) e.getUnfinishedMessage();\r\n        throw e.unwrapIOException();\r\n    } finally {\r\n        if (parsedMessage !\u003d null) {\r\n            mergeFrom(parsedMessage);\r\n        }\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 month \u003d 1;\u003c/code\u003e\r\n * @return Whether the month field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasMonth() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "hasMonth",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 month \u003d 1;\u003c/code\u003e\r\n * @return The month.\r\n */\r\n@java.lang.Override\r\npublic int getMonth() {\r\n    return month_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "getMonth",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 month \u003d 1;\u003c/code\u003e\r\n * @param value The month to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setMonth(int value) {\r\n    bitField0_ |\u003d 0x00000001;\r\n    month_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "setMonth",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 month \u003d 1;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearMonth() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    month_ \u003d 0;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "clearMonth",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 year \u003d 2;\u003c/code\u003e\r\n * @return Whether the year field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasYear() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "hasYear",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 year \u003d 2;\u003c/code\u003e\r\n * @return The year.\r\n */\r\n@java.lang.Override\r\npublic int getYear() {\r\n    return year_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "getYear",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 year \u003d 2;\u003c/code\u003e\r\n * @param value The year to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setYear(int value) {\r\n    bitField0_ |\u003d 0x00000002;\r\n    year_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "setYear",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 year \u003d 2;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearYear() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    year_ \u003d 0;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "clearYear",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int64 long_timestamp \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"timeStamp\"];\u003c/code\u003e\r\n * @return Whether the longTimestamp field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasLongTimestamp() {\r\n    return ((bitField0_ \u0026 0x00000004) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "hasLongTimestamp",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int64 long_timestamp \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"timeStamp\"];\u003c/code\u003e\r\n * @return The longTimestamp.\r\n */\r\n@java.lang.Override\r\npublic long getLongTimestamp() {\r\n    return longTimestamp_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "getLongTimestamp",
      "parameterTypes": [],
      "returnType": "long"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int64 long_timestamp \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"timeStamp\"];\u003c/code\u003e\r\n * @param value The longTimestamp to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setLongTimestamp(long value) {\r\n    bitField0_ |\u003d 0x00000004;\r\n    longTimestamp_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "setLongTimestamp",
      "parameterTypes": [
        "long"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int64 long_timestamp \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"timeStamp\"];\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearLongTimestamp() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n    longTimestamp_ \u003d 0L;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "clearLongTimestamp",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @return Whether the countryCode5f55 field is set.\r\n */\r\npublic boolean hasCountryCode5F55() {\r\n    return ((bitField0_ \u0026 0x00000008) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "hasCountryCode5F55",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @return The countryCode5f55.\r\n */\r\npublic java.lang.String getCountryCode5F55() {\r\n    java.lang.Object ref \u003d countryCode5F55_;\r\n    if (!(ref instanceof java.lang.String)) {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            countryCode5F55_ \u003d s;\r\n        }\r\n        return s;\r\n    } else {\r\n        return (java.lang.String) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "getCountryCode5F55",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @return The bytes for countryCode5f55.\r\n */\r\npublic com.google.protobuf.ByteString getCountryCode5F55Bytes() {\r\n    java.lang.Object ref \u003d countryCode5F55_;\r\n    if (ref instanceof String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        countryCode5F55_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "getCountryCode5F55Bytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @param value The countryCode5f55 to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setCountryCode5F55(java.lang.String value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000008;\r\n    countryCode5F55_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "setCountryCode5F55",
      "parameterTypes": [
        "java.lang.String"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearCountryCode5F55() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000008);\r\n    countryCode5F55_ \u003d getDefaultInstance().getCountryCode5F55();\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "clearCountryCode5F55",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string country_code_5f55 \u003d 4;\u003c/code\u003e\r\n * @param value The bytes for countryCode5f55 to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setCountryCode5F55Bytes(com.google.protobuf.ByteString value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000008;\r\n    countryCode5F55_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "setCountryCode5F55Bytes",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.setUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "setUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.mergeUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder",
      "methodName": "mergeUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.OuterMessage getDefaultInstance() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getDefaultInstance",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic OuterMessage parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return new OuterMessage(input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parsePartialFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "OuterMessage"
    }
  },
  {
    "sourceCode": "public static com.google.protobuf.Parser\u003cOuterMessage\u003e parser() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "parser",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cOuterMessage\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Parser\u003cOuterMessage\u003e getParserForType() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getParserForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cOuterMessage\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.OuterMessage getDefaultInstanceForType() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.OuterMessage",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @return Whether the id field is set.\r\n */\r\nboolean hasId();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "hasId",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @return The id.\r\n */\r\njava.lang.String getId();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "getId",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @return The bytes for id.\r\n */\r\ncom.google.protobuf.ByteString getIdBytes();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "getIdBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n * @return Whether the outerMessage field is set.\r\n */\r\nboolean hasOuterMessage();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "hasOuterMessage",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n * @return The outerMessage.\r\n */\r\ncom.google.gson.protobuf.generated.Bag.OuterMessage getOuterMessage();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "getOuterMessage",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n */\r\ncom.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder getOuterMessageOrBuilder();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "getOuterMessageOrBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n * @return Whether the innerMessage1 field is set.\r\n */\r\nboolean hasInnerMessage1();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "hasInnerMessage1",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n * @return The innerMessage1.\r\n */\r\ncom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage getInnerMessage1();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "getInnerMessage1",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n */\r\ncom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder getInnerMessage1OrBuilder();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "getInnerMessage1OrBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n * @return Whether the innerMessage2 field is set.\r\n */\r\nboolean hasInnerMessage2();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "hasInnerMessage2",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n * @return The innerMessage2.\r\n */\r\ncom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage getInnerMessage2();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "getInnerMessage2",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n */\r\ncom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder getInnerMessage2OrBuilder();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotationsOrBuilder",
      "methodName": "getInnerMessage2OrBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\n@SuppressWarnings({ \"unused\" })\r\nprotected java.lang.Object newInstance(UnusedPrivateParameter unused) {\r\n    return new ProtoWithAnnotations();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "newInstance",
      "parameterTypes": [
        "UnusedPrivateParameter"
      ],
      "returnType": "java.lang.Object"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final com.google.protobuf.UnknownFieldSet getUnknownFields() {\r\n    return this.unknownFields;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getUnknownFields",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.UnknownFieldSet"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.class, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 n__id_ct \u003d 1;\u003c/code\u003e\r\n * @return Whether the nIdCt field is set.\r\n */\r\nboolean hasNIdCt();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder",
      "methodName": "hasNIdCt",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 n__id_ct \u003d 1;\u003c/code\u003e\r\n * @return The nIdCt.\r\n */\r\nint getNIdCt();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder",
      "methodName": "getNIdCt",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content \u003d 2;\u003c/code\u003e\r\n * @return Whether the content field is set.\r\n */\r\nboolean hasContent();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder",
      "methodName": "hasContent",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content \u003d 2;\u003c/code\u003e\r\n * @return The content.\r\n */\r\ncom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type getContent();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder",
      "methodName": "getContent",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\njava.util.List\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data\u003e getDataList();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder",
      "methodName": "getDataList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\ncom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data getData(int index);",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder",
      "methodName": "getData",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\nint getDataCount();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder",
      "methodName": "getDataCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\njava.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder\u003e getDataOrBuilderList();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder",
      "methodName": "getDataOrBuilderList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\ncom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder getDataOrBuilder(int index);",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder",
      "methodName": "getDataOrBuilder",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\n@SuppressWarnings({ \"unused\" })\r\nprotected java.lang.Object newInstance(UnusedPrivateParameter unused) {\r\n    return new InnerMessage();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "newInstance",
      "parameterTypes": [
        "UnusedPrivateParameter"
      ],
      "returnType": "java.lang.Object"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final com.google.protobuf.UnknownFieldSet getUnknownFields() {\r\n    return this.unknownFields;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getUnknownFields",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.UnknownFieldSet"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_InnerMessage_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_InnerMessage_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.class, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "public final int getNumber() {\r\n    return value;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getNumber",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * @param value The numeric wire value of the corresponding enum entry.\r\n * @return The enum associated with the given numeric wire value.\r\n * @deprecated Use {@link #forNumber(int)} instead.\r\n */\r\n@java.lang.Deprecated\r\npublic static Type valueOf(int value) {\r\n    return forNumber(value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "valueOf",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "/**\r\n * @param value The numeric wire value of the corresponding enum entry.\r\n * @return The enum associated with the given numeric wire value.\r\n */\r\npublic static Type forNumber(int value) {\r\n    switch(value) {\r\n        case 0:\r\n            return UNKNOWN;\r\n        case 1:\r\n            return TEXT;\r\n        case 2:\r\n            return IMAGE;\r\n        default:\r\n            return null;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "forNumber",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "public static com.google.protobuf.Internal.EnumLiteMap\u003cType\u003e internalGetValueMap() {\r\n    return internalValueMap;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "internalGetValueMap",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Internal.EnumLiteMap\u003cType\u003e"
    }
  },
  {
    "sourceCode": "public Type findValueByNumber(int number) {\r\n    return Type.forNumber(number);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "findValueByNumber",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {\r\n    return getDescriptor().getValues().get(ordinal());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getValueDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.EnumValueDescriptor"
    }
  },
  {
    "sourceCode": "public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {\r\n    return getDescriptor();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getDescriptorForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.EnumDescriptor"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDescriptor().getEnumTypes().get(0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.EnumDescriptor"
    }
  },
  {
    "sourceCode": "public static Type valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\r\n    if (desc.getType() !\u003d getDescriptor()) {\r\n        throw new java.lang.IllegalArgumentException(\"EnumValueDescriptor is not for this type.\");\r\n    }\r\n    return VALUES[desc.getIndex()];\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "valueOf",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.EnumValueDescriptor"
      ],
      "returnType": "Type"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @return Whether the data field is set.\r\n */\r\nboolean hasData();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder",
      "methodName": "hasData",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @return The data.\r\n */\r\njava.lang.String getData();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder",
      "methodName": "getData",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @return The bytes for data.\r\n */\r\ncom.google.protobuf.ByteString getDataBytes();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder",
      "methodName": "getDataBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 width \u003d 2;\u003c/code\u003e\r\n * @return Whether the width field is set.\r\n */\r\nboolean hasWidth();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder",
      "methodName": "hasWidth",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 width \u003d 2;\u003c/code\u003e\r\n * @return The width.\r\n */\r\nint getWidth();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder",
      "methodName": "getWidth",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 height \u003d 3;\u003c/code\u003e\r\n * @return Whether the height field is set.\r\n */\r\nboolean hasHeight();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder",
      "methodName": "hasHeight",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 height \u003d 3;\u003c/code\u003e\r\n * @return The height.\r\n */\r\nint getHeight();",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder",
      "methodName": "getHeight",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\n@SuppressWarnings({ \"unused\" })\r\nprotected java.lang.Object newInstance(UnusedPrivateParameter unused) {\r\n    return new Data();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "newInstance",
      "parameterTypes": [
        "UnusedPrivateParameter"
      ],
      "returnType": "java.lang.Object"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final com.google.protobuf.UnknownFieldSet getUnknownFields() {\r\n    return this.unknownFields;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "getUnknownFields",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.UnknownFieldSet"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_InnerMessage_Data_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_InnerMessage_Data_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.class, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @return Whether the data field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasData() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "hasData",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @return The data.\r\n */\r\n@java.lang.Override\r\npublic java.lang.String getData() {\r\n    java.lang.Object ref \u003d data_;\r\n    if (ref instanceof java.lang.String) {\r\n        return (java.lang.String) ref;\r\n    } else {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            data_ \u003d s;\r\n        }\r\n        return s;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "getData",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @return The bytes for data.\r\n */\r\n@java.lang.Override\r\npublic com.google.protobuf.ByteString getDataBytes() {\r\n    java.lang.Object ref \u003d data_;\r\n    if (ref instanceof java.lang.String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        data_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "getDataBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 width \u003d 2;\u003c/code\u003e\r\n * @return Whether the width field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasWidth() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "hasWidth",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 width \u003d 2;\u003c/code\u003e\r\n * @return The width.\r\n */\r\n@java.lang.Override\r\npublic int getWidth() {\r\n    return width_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "getWidth",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 height \u003d 3;\u003c/code\u003e\r\n * @return Whether the height field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasHeight() {\r\n    return ((bitField0_ \u0026 0x00000004) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "hasHeight",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 height \u003d 3;\u003c/code\u003e\r\n * @return The height.\r\n */\r\n@java.lang.Override\r\npublic int getHeight() {\r\n    return height_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "getHeight",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    byte isInitialized \u003d memoizedIsInitialized;\r\n    if (isInitialized \u003d\u003d 1)\r\n        return true;\r\n    if (isInitialized \u003d\u003d 0)\r\n        return false;\r\n    memoizedIsInitialized \u003d 1;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, data_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        output.writeInt32(2, width_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        output.writeInt32(3, height_);\r\n    }\r\n    unknownFields.writeTo(output);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "writeTo",
      "parameterTypes": [
        "com.google.protobuf.CodedOutputStream"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int getSerializedSize() {\r\n    int size \u003d memoizedSize;\r\n    if (size !\u003d -1)\r\n        return size;\r\n    size \u003d 0;\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.GeneratedMessageV3.computeStringSize(1, data_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeInt32Size(2, width_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeInt32Size(3, height_);\r\n    }\r\n    size +\u003d unknownFields.getSerializedSize();\r\n    memoizedSize \u003d size;\r\n    return size;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "getSerializedSize",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic boolean equals(final java.lang.Object obj) {\r\n    if (obj \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data)) {\r\n        return super.equals(obj);\r\n    }\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data other \u003d (com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data) obj;\r\n    if (hasData() !\u003d other.hasData())\r\n        return false;\r\n    if (hasData()) {\r\n        if (!getData().equals(other.getData()))\r\n            return false;\r\n    }\r\n    if (hasWidth() !\u003d other.hasWidth())\r\n        return false;\r\n    if (hasWidth()) {\r\n        if (getWidth() !\u003d other.getWidth())\r\n            return false;\r\n    }\r\n    if (hasHeight() !\u003d other.hasHeight())\r\n        return false;\r\n    if (hasHeight()) {\r\n        if (getHeight() !\u003d other.getHeight())\r\n            return false;\r\n    }\r\n    if (!unknownFields.equals(other.unknownFields))\r\n        return false;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "equals",
      "parameterTypes": [
        "java.lang.Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int hashCode() {\r\n    if (memoizedHashCode !\u003d 0) {\r\n        return memoizedHashCode;\r\n    }\r\n    int hash \u003d 41;\r\n    hash \u003d (19 * hash) + getDescriptor().hashCode();\r\n    if (hasData()) {\r\n        hash \u003d (37 * hash) + DATA_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getData().hashCode();\r\n    }\r\n    if (hasWidth()) {\r\n        hash \u003d (37 * hash) + WIDTH_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getWidth();\r\n    }\r\n    if (hasHeight()) {\r\n        hash \u003d (37 * hash) + HEIGHT_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getHeight();\r\n    }\r\n    hash \u003d (29 * hash) + unknownFields.hashCode();\r\n    memoizedHashCode \u003d hash;\r\n    return hash;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder newBuilderForType() {\r\n    return newBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "newBuilderForType",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder() {\r\n    return DEFAULT_INSTANCE.toBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "newBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data prototype) {\r\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "newBuilder",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder toBuilder() {\r\n    return this \u003d\u003d DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "toBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\r\n    Builder builder \u003d new Builder(parent);\r\n    return builder;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "newBuilderForType",
      "parameterTypes": [
        "com.google.protobuf.GeneratedMessageV3.BuilderParent"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_InnerMessage_Data_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_InnerMessage_Data_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.class, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "private void maybeForceBuilderInitialization() {\r\n    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "maybeForceBuilderInitialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clear() {\r\n    super.clear();\r\n    data_ \u003d \"\";\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    width_ \u003d 0;\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    height_ \u003d 0;\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_InnerMessage_Data_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "getDescriptorForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data getDefaultInstanceForType() {\r\n    return com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.getDefaultInstance();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data build() {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data result \u003d buildPartial();\r\n    if (!result.isInitialized()) {\r\n        throw newUninitializedMessageException(result);\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "build",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data buildPartial() {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data result \u003d new com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data(this);\r\n    int from_bitField0_ \u003d bitField0_;\r\n    int to_bitField0_ \u003d 0;\r\n    if (((from_bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        to_bitField0_ |\u003d 0x00000001;\r\n    }\r\n    result.data_ \u003d data_;\r\n    if (((from_bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        result.width_ \u003d width_;\r\n        to_bitField0_ |\u003d 0x00000002;\r\n    }\r\n    if (((from_bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        result.height_ \u003d height_;\r\n        to_bitField0_ |\u003d 0x00000004;\r\n    }\r\n    result.bitField0_ \u003d to_bitField0_;\r\n    onBuilt();\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "buildPartial",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clone() {\r\n    return super.clone();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "clone",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.setField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "setField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {\r\n    return super.clearField(field);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "clearField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {\r\n    return super.clearOneof(oneof);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "clearOneof",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.OneofDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {\r\n    return super.setRepeatedField(field, index, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "setRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "int",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.addRepeatedField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "addRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.Message other) {\r\n    if (other instanceof com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data) {\r\n        return mergeFrom((com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data) other);\r\n    } else {\r\n        super.mergeFrom(other);\r\n        return this;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.Message"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public Builder mergeFrom(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data other) {\r\n    if (other \u003d\u003d com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.getDefaultInstance())\r\n        return this;\r\n    if (other.hasData()) {\r\n        bitField0_ |\u003d 0x00000001;\r\n        data_ \u003d other.data_;\r\n        onChanged();\r\n    }\r\n    if (other.hasWidth()) {\r\n        setWidth(other.getWidth());\r\n    }\r\n    if (other.hasHeight()) {\r\n        setHeight(other.getHeight());\r\n    }\r\n    this.mergeUnknownFields(other.unknownFields);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data parsedMessage \u003d null;\r\n    try {\r\n        parsedMessage \u003d PARSER.parsePartialFrom(input, extensionRegistry);\r\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\r\n        parsedMessage \u003d (com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data) e.getUnfinishedMessage();\r\n        throw e.unwrapIOException();\r\n    } finally {\r\n        if (parsedMessage !\u003d null) {\r\n            mergeFrom(parsedMessage);\r\n        }\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @return Whether the data field is set.\r\n */\r\npublic boolean hasData() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "hasData",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @return The data.\r\n */\r\npublic java.lang.String getData() {\r\n    java.lang.Object ref \u003d data_;\r\n    if (!(ref instanceof java.lang.String)) {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            data_ \u003d s;\r\n        }\r\n        return s;\r\n    } else {\r\n        return (java.lang.String) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "getData",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @return The bytes for data.\r\n */\r\npublic com.google.protobuf.ByteString getDataBytes() {\r\n    java.lang.Object ref \u003d data_;\r\n    if (ref instanceof String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        data_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "getDataBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @param value The data to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setData(java.lang.String value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000001;\r\n    data_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "setData",
      "parameterTypes": [
        "java.lang.String"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearData() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    data_ \u003d getDefaultInstance().getData();\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "clearData",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string data \u003d 1;\u003c/code\u003e\r\n * @param value The bytes for data to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setDataBytes(com.google.protobuf.ByteString value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000001;\r\n    data_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "setDataBytes",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 width \u003d 2;\u003c/code\u003e\r\n * @return Whether the width field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasWidth() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "hasWidth",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 width \u003d 2;\u003c/code\u003e\r\n * @return The width.\r\n */\r\n@java.lang.Override\r\npublic int getWidth() {\r\n    return width_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "getWidth",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 width \u003d 2;\u003c/code\u003e\r\n * @param value The width to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setWidth(int value) {\r\n    bitField0_ |\u003d 0x00000002;\r\n    width_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "setWidth",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 width \u003d 2;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearWidth() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    width_ \u003d 0;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "clearWidth",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 height \u003d 3;\u003c/code\u003e\r\n * @return Whether the height field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasHeight() {\r\n    return ((bitField0_ \u0026 0x00000004) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "hasHeight",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 height \u003d 3;\u003c/code\u003e\r\n * @return The height.\r\n */\r\n@java.lang.Override\r\npublic int getHeight() {\r\n    return height_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "getHeight",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 height \u003d 3;\u003c/code\u003e\r\n * @param value The height to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setHeight(int value) {\r\n    bitField0_ |\u003d 0x00000004;\r\n    height_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "setHeight",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 height \u003d 3;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearHeight() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n    height_ \u003d 0;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "clearHeight",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.setUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "setUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.mergeUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder",
      "methodName": "mergeUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data getDefaultInstance() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "getDefaultInstance",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Data parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return new Data(input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parsePartialFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "Data"
    }
  },
  {
    "sourceCode": "public static com.google.protobuf.Parser\u003cData\u003e parser() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "parser",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cData\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Parser\u003cData\u003e getParserForType() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "getParserForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cData\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data getDefaultInstanceForType() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 n__id_ct \u003d 1;\u003c/code\u003e\r\n * @return Whether the nIdCt field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasNIdCt() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "hasNIdCt",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 n__id_ct \u003d 1;\u003c/code\u003e\r\n * @return The nIdCt.\r\n */\r\n@java.lang.Override\r\npublic int getNIdCt() {\r\n    return nIdCt_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getNIdCt",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content \u003d 2;\u003c/code\u003e\r\n * @return Whether the content field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasContent() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "hasContent",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content \u003d 2;\u003c/code\u003e\r\n * @return The content.\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type getContent() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type result \u003d com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type.valueOf(content_);\r\n    return result \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type.UNKNOWN : result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getContent",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic java.util.List\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data\u003e getDataList() {\r\n    return data_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getDataList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic java.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder\u003e getDataOrBuilderList() {\r\n    return data_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getDataOrBuilderList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic int getDataCount() {\r\n    return data_.size();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getDataCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data getData(int index) {\r\n    return data_.get(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getData",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder getDataOrBuilder(int index) {\r\n    return data_.get(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getDataOrBuilder",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    byte isInitialized \u003d memoizedIsInitialized;\r\n    if (isInitialized \u003d\u003d 1)\r\n        return true;\r\n    if (isInitialized \u003d\u003d 0)\r\n        return false;\r\n    memoizedIsInitialized \u003d 1;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        output.writeInt32(1, nIdCt_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        output.writeEnum(2, content_);\r\n    }\r\n    for (int i \u003d 0; i \u003c data_.size(); i++) {\r\n        output.writeMessage(3, data_.get(i));\r\n    }\r\n    unknownFields.writeTo(output);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "writeTo",
      "parameterTypes": [
        "com.google.protobuf.CodedOutputStream"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int getSerializedSize() {\r\n    int size \u003d memoizedSize;\r\n    if (size !\u003d -1)\r\n        return size;\r\n    size \u003d 0;\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeInt32Size(1, nIdCt_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeEnumSize(2, content_);\r\n    }\r\n    for (int i \u003d 0; i \u003c data_.size(); i++) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeMessageSize(3, data_.get(i));\r\n    }\r\n    size +\u003d unknownFields.getSerializedSize();\r\n    memoizedSize \u003d size;\r\n    return size;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getSerializedSize",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic boolean equals(final java.lang.Object obj) {\r\n    if (obj \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage)) {\r\n        return super.equals(obj);\r\n    }\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage other \u003d (com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage) obj;\r\n    if (hasNIdCt() !\u003d other.hasNIdCt())\r\n        return false;\r\n    if (hasNIdCt()) {\r\n        if (getNIdCt() !\u003d other.getNIdCt())\r\n            return false;\r\n    }\r\n    if (hasContent() !\u003d other.hasContent())\r\n        return false;\r\n    if (hasContent()) {\r\n        if (content_ !\u003d other.content_)\r\n            return false;\r\n    }\r\n    if (!getDataList().equals(other.getDataList()))\r\n        return false;\r\n    if (!unknownFields.equals(other.unknownFields))\r\n        return false;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "equals",
      "parameterTypes": [
        "java.lang.Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int hashCode() {\r\n    if (memoizedHashCode !\u003d 0) {\r\n        return memoizedHashCode;\r\n    }\r\n    int hash \u003d 41;\r\n    hash \u003d (19 * hash) + getDescriptor().hashCode();\r\n    if (hasNIdCt()) {\r\n        hash \u003d (37 * hash) + N__ID_CT_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getNIdCt();\r\n    }\r\n    if (hasContent()) {\r\n        hash \u003d (37 * hash) + CONTENT_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + content_;\r\n    }\r\n    if (getDataCount() \u003e 0) {\r\n        hash \u003d (37 * hash) + DATA_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getDataList().hashCode();\r\n    }\r\n    hash \u003d (29 * hash) + unknownFields.hashCode();\r\n    memoizedHashCode \u003d hash;\r\n    return hash;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder newBuilderForType() {\r\n    return newBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "newBuilderForType",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder() {\r\n    return DEFAULT_INSTANCE.toBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "newBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage prototype) {\r\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "newBuilder",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder toBuilder() {\r\n    return this \u003d\u003d DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "toBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\r\n    Builder builder \u003d new Builder(parent);\r\n    return builder;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "newBuilderForType",
      "parameterTypes": [
        "com.google.protobuf.GeneratedMessageV3.BuilderParent"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_InnerMessage_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_InnerMessage_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.class, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "private void maybeForceBuilderInitialization() {\r\n    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {\r\n        getDataFieldBuilder();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "maybeForceBuilderInitialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clear() {\r\n    super.clear();\r\n    nIdCt_ \u003d 0;\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    content_ \u003d 0;\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        data_ \u003d java.util.Collections.emptyList();\r\n        bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n    } else {\r\n        dataBuilder_.clear();\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_InnerMessage_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getDescriptorForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage getDefaultInstanceForType() {\r\n    return com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage build() {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage result \u003d buildPartial();\r\n    if (!result.isInitialized()) {\r\n        throw newUninitializedMessageException(result);\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "build",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage buildPartial() {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage result \u003d new com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage(this);\r\n    int from_bitField0_ \u003d bitField0_;\r\n    int to_bitField0_ \u003d 0;\r\n    if (((from_bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        result.nIdCt_ \u003d nIdCt_;\r\n        to_bitField0_ |\u003d 0x00000001;\r\n    }\r\n    if (((from_bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        to_bitField0_ |\u003d 0x00000002;\r\n    }\r\n    result.content_ \u003d content_;\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        if (((bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n            data_ \u003d java.util.Collections.unmodifiableList(data_);\r\n            bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n        }\r\n        result.data_ \u003d data_;\r\n    } else {\r\n        result.data_ \u003d dataBuilder_.build();\r\n    }\r\n    result.bitField0_ \u003d to_bitField0_;\r\n    onBuilt();\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "buildPartial",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clone() {\r\n    return super.clone();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "clone",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.setField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "setField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {\r\n    return super.clearField(field);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "clearField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {\r\n    return super.clearOneof(oneof);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "clearOneof",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.OneofDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {\r\n    return super.setRepeatedField(field, index, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "setRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "int",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.addRepeatedField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "addRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.Message other) {\r\n    if (other instanceof com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage) {\r\n        return mergeFrom((com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage) other);\r\n    } else {\r\n        super.mergeFrom(other);\r\n        return this;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.Message"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public Builder mergeFrom(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage other) {\r\n    if (other \u003d\u003d com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance())\r\n        return this;\r\n    if (other.hasNIdCt()) {\r\n        setNIdCt(other.getNIdCt());\r\n    }\r\n    if (other.hasContent()) {\r\n        setContent(other.getContent());\r\n    }\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        if (!other.data_.isEmpty()) {\r\n            if (data_.isEmpty()) {\r\n                data_ \u003d other.data_;\r\n                bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n            } else {\r\n                ensureDataIsMutable();\r\n                data_.addAll(other.data_);\r\n            }\r\n            onChanged();\r\n        }\r\n    } else {\r\n        if (!other.data_.isEmpty()) {\r\n            if (dataBuilder_.isEmpty()) {\r\n                dataBuilder_.dispose();\r\n                dataBuilder_ \u003d null;\r\n                data_ \u003d other.data_;\r\n                bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n                dataBuilder_ \u003d com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ? getDataFieldBuilder() : null;\r\n            } else {\r\n                dataBuilder_.addAllMessages(other.data_);\r\n            }\r\n        }\r\n    }\r\n    this.mergeUnknownFields(other.unknownFields);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage parsedMessage \u003d null;\r\n    try {\r\n        parsedMessage \u003d PARSER.parsePartialFrom(input, extensionRegistry);\r\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\r\n        parsedMessage \u003d (com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage) e.getUnfinishedMessage();\r\n        throw e.unwrapIOException();\r\n    } finally {\r\n        if (parsedMessage !\u003d null) {\r\n            mergeFrom(parsedMessage);\r\n        }\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 n__id_ct \u003d 1;\u003c/code\u003e\r\n * @return Whether the nIdCt field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasNIdCt() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "hasNIdCt",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 n__id_ct \u003d 1;\u003c/code\u003e\r\n * @return The nIdCt.\r\n */\r\n@java.lang.Override\r\npublic int getNIdCt() {\r\n    return nIdCt_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getNIdCt",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 n__id_ct \u003d 1;\u003c/code\u003e\r\n * @param value The nIdCt to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setNIdCt(int value) {\r\n    bitField0_ |\u003d 0x00000001;\r\n    nIdCt_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "setNIdCt",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional int32 n__id_ct \u003d 1;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearNIdCt() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    nIdCt_ \u003d 0;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "clearNIdCt",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content \u003d 2;\u003c/code\u003e\r\n * @return Whether the content field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasContent() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "hasContent",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content \u003d 2;\u003c/code\u003e\r\n * @return The content.\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type getContent() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type result \u003d com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type.valueOf(content_);\r\n    return result \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type.UNKNOWN : result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getContent",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content \u003d 2;\u003c/code\u003e\r\n * @param value The content to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setContent(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000002;\r\n    content_ \u003d value.getNumber();\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "setContent",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content \u003d 2;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearContent() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    content_ \u003d 0;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "clearContent",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "private void ensureDataIsMutable() {\r\n    if (!((bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        data_ \u003d new java.util.ArrayList\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data\u003e(data_);\r\n        bitField0_ |\u003d 0x00000004;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "ensureDataIsMutable",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic java.util.List\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data\u003e getDataList() {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        return java.util.Collections.unmodifiableList(data_);\r\n    } else {\r\n        return dataBuilder_.getMessageList();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getDataList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic int getDataCount() {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        return data_.size();\r\n    } else {\r\n        return dataBuilder_.getCount();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getDataCount",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data getData(int index) {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        return data_.get(index);\r\n    } else {\r\n        return dataBuilder_.getMessage(index);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getData",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic Builder setData(int index, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data value) {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        if (value \u003d\u003d null) {\r\n            throw new NullPointerException();\r\n        }\r\n        ensureDataIsMutable();\r\n        data_.set(index, value);\r\n        onChanged();\r\n    } else {\r\n        dataBuilder_.setMessage(index, value);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "setData",
      "parameterTypes": [
        "int",
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic Builder setData(int index, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder builderForValue) {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        ensureDataIsMutable();\r\n        data_.set(index, builderForValue.build());\r\n        onChanged();\r\n    } else {\r\n        dataBuilder_.setMessage(index, builderForValue.build());\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "setData",
      "parameterTypes": [
        "int",
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic Builder addData(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data value) {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        if (value \u003d\u003d null) {\r\n            throw new NullPointerException();\r\n        }\r\n        ensureDataIsMutable();\r\n        data_.add(value);\r\n        onChanged();\r\n    } else {\r\n        dataBuilder_.addMessage(value);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "addData",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic Builder addData(int index, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data value) {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        if (value \u003d\u003d null) {\r\n            throw new NullPointerException();\r\n        }\r\n        ensureDataIsMutable();\r\n        data_.add(index, value);\r\n        onChanged();\r\n    } else {\r\n        dataBuilder_.addMessage(index, value);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "addData",
      "parameterTypes": [
        "int",
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic Builder addData(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder builderForValue) {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        ensureDataIsMutable();\r\n        data_.add(builderForValue.build());\r\n        onChanged();\r\n    } else {\r\n        dataBuilder_.addMessage(builderForValue.build());\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "addData",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic Builder addData(int index, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder builderForValue) {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        ensureDataIsMutable();\r\n        data_.add(index, builderForValue.build());\r\n        onChanged();\r\n    } else {\r\n        dataBuilder_.addMessage(index, builderForValue.build());\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "addData",
      "parameterTypes": [
        "int",
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic Builder addAllData(java.lang.Iterable\u003c? extends com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data\u003e values) {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        ensureDataIsMutable();\r\n        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, data_);\r\n        onChanged();\r\n    } else {\r\n        dataBuilder_.addAllMessages(values);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "addAllData",
      "parameterTypes": [
        "java.lang.Iterable\u003c? extends com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data\u003e"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic Builder clearData() {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        data_ \u003d java.util.Collections.emptyList();\r\n        bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n        onChanged();\r\n    } else {\r\n        dataBuilder_.clear();\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "clearData",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic Builder removeData(int index) {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        ensureDataIsMutable();\r\n        data_.remove(index);\r\n        onChanged();\r\n    } else {\r\n        dataBuilder_.remove(index);\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "removeData",
      "parameterTypes": [
        "int"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder getDataBuilder(int index) {\r\n    return getDataFieldBuilder().getBuilder(index);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getDataBuilder",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder getDataOrBuilder(int index) {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        return data_.get(index);\r\n    } else {\r\n        return dataBuilder_.getMessageOrBuilder(index);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getDataOrBuilder",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic java.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder\u003e getDataOrBuilderList() {\r\n    if (dataBuilder_ !\u003d null) {\r\n        return dataBuilder_.getMessageOrBuilderList();\r\n    } else {\r\n        return java.util.Collections.unmodifiableList(data_);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getDataOrBuilderList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003c? extends com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder addDataBuilder() {\r\n    return getDataFieldBuilder().addBuilder(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.getDefaultInstance());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "addDataBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder addDataBuilder(int index) {\r\n    return getDataFieldBuilder().addBuilder(index, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.getDefaultInstance());\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "addDataBuilder",
      "parameterTypes": [
        "int"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003erepeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data \u003d 3 [(.google.gson.protobuf.generated.serialized_name) \u003d \"$binary_data$\"];\u003c/code\u003e\r\n */\r\npublic java.util.List\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder\u003e getDataBuilderList() {\r\n    return getDataFieldBuilder().getBuilderList();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getDataBuilderList",
      "parameterTypes": [],
      "returnType": "java.util.List\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder\u003e"
    }
  },
  {
    "sourceCode": "private com.google.protobuf.RepeatedFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder\u003e getDataFieldBuilder() {\r\n    if (dataBuilder_ \u003d\u003d null) {\r\n        dataBuilder_ \u003d new com.google.protobuf.RepeatedFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder\u003e(data_, ((bitField0_ \u0026 0x00000004) !\u003d 0), getParentForChildren(), isClean());\r\n        data_ \u003d null;\r\n    }\r\n    return dataBuilder_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "getDataFieldBuilder",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.RepeatedFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data.Builder, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.DataOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.setUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "setUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.mergeUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder",
      "methodName": "mergeUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage getDefaultInstance() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getDefaultInstance",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic InnerMessage parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return new InnerMessage(input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parsePartialFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "InnerMessage"
    }
  },
  {
    "sourceCode": "public static com.google.protobuf.Parser\u003cInnerMessage\u003e parser() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "parser",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cInnerMessage\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Parser\u003cInnerMessage\u003e getParserForType() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getParserForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cInnerMessage\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage getDefaultInstanceForType() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @return Whether the id field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasId() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "hasId",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @return The id.\r\n */\r\n@java.lang.Override\r\npublic java.lang.String getId() {\r\n    java.lang.Object ref \u003d id_;\r\n    if (ref instanceof java.lang.String) {\r\n        return (java.lang.String) ref;\r\n    } else {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            id_ \u003d s;\r\n        }\r\n        return s;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getId",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @return The bytes for id.\r\n */\r\n@java.lang.Override\r\npublic com.google.protobuf.ByteString getIdBytes() {\r\n    java.lang.Object ref \u003d id_;\r\n    if (ref instanceof java.lang.String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        id_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getIdBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n * @return Whether the outerMessage field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasOuterMessage() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "hasOuterMessage",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n * @return The outerMessage.\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.OuterMessage getOuterMessage() {\r\n    return outerMessage_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.OuterMessage.getDefaultInstance() : outerMessage_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getOuterMessage",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder getOuterMessageOrBuilder() {\r\n    return outerMessage_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.OuterMessage.getDefaultInstance() : outerMessage_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getOuterMessageOrBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n * @return Whether the innerMessage1 field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasInnerMessage1() {\r\n    return ((bitField0_ \u0026 0x00000004) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "hasInnerMessage1",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n * @return The innerMessage1.\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage getInnerMessage1() {\r\n    return innerMessage1_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance() : innerMessage1_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getInnerMessage1",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder getInnerMessage1OrBuilder() {\r\n    return innerMessage1_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance() : innerMessage1_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getInnerMessage1OrBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n * @return Whether the innerMessage2 field is set.\r\n */\r\n@java.lang.Override\r\npublic boolean hasInnerMessage2() {\r\n    return ((bitField0_ \u0026 0x00000008) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "hasInnerMessage2",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n * @return The innerMessage2.\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage getInnerMessage2() {\r\n    return innerMessage2_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance() : innerMessage2_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getInnerMessage2",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n */\r\n@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder getInnerMessage2OrBuilder() {\r\n    return innerMessage2_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance() : innerMessage2_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getInnerMessage2OrBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    byte isInitialized \u003d memoizedIsInitialized;\r\n    if (isInitialized \u003d\u003d 1)\r\n        return true;\r\n    if (isInitialized \u003d\u003d 0)\r\n        return false;\r\n    memoizedIsInitialized \u003d 1;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, id_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        output.writeMessage(2, getOuterMessage());\r\n    }\r\n    if (((bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        output.writeMessage(3, getInnerMessage1());\r\n    }\r\n    if (((bitField0_ \u0026 0x00000008) !\u003d 0)) {\r\n        output.writeMessage(4, getInnerMessage2());\r\n    }\r\n    unknownFields.writeTo(output);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "writeTo",
      "parameterTypes": [
        "com.google.protobuf.CodedOutputStream"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int getSerializedSize() {\r\n    int size \u003d memoizedSize;\r\n    if (size !\u003d -1)\r\n        return size;\r\n    size \u003d 0;\r\n    if (((bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.GeneratedMessageV3.computeStringSize(1, id_);\r\n    }\r\n    if (((bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeMessageSize(2, getOuterMessage());\r\n    }\r\n    if (((bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeMessageSize(3, getInnerMessage1());\r\n    }\r\n    if (((bitField0_ \u0026 0x00000008) !\u003d 0)) {\r\n        size +\u003d com.google.protobuf.CodedOutputStream.computeMessageSize(4, getInnerMessage2());\r\n    }\r\n    size +\u003d unknownFields.getSerializedSize();\r\n    memoizedSize \u003d size;\r\n    return size;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getSerializedSize",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic boolean equals(final java.lang.Object obj) {\r\n    if (obj \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations)) {\r\n        return super.equals(obj);\r\n    }\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations other \u003d (com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations) obj;\r\n    if (hasId() !\u003d other.hasId())\r\n        return false;\r\n    if (hasId()) {\r\n        if (!getId().equals(other.getId()))\r\n            return false;\r\n    }\r\n    if (hasOuterMessage() !\u003d other.hasOuterMessage())\r\n        return false;\r\n    if (hasOuterMessage()) {\r\n        if (!getOuterMessage().equals(other.getOuterMessage()))\r\n            return false;\r\n    }\r\n    if (hasInnerMessage1() !\u003d other.hasInnerMessage1())\r\n        return false;\r\n    if (hasInnerMessage1()) {\r\n        if (!getInnerMessage1().equals(other.getInnerMessage1()))\r\n            return false;\r\n    }\r\n    if (hasInnerMessage2() !\u003d other.hasInnerMessage2())\r\n        return false;\r\n    if (hasInnerMessage2()) {\r\n        if (!getInnerMessage2().equals(other.getInnerMessage2()))\r\n            return false;\r\n    }\r\n    if (!unknownFields.equals(other.unknownFields))\r\n        return false;\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "equals",
      "parameterTypes": [
        "java.lang.Object"
      ],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic int hashCode() {\r\n    if (memoizedHashCode !\u003d 0) {\r\n        return memoizedHashCode;\r\n    }\r\n    int hash \u003d 41;\r\n    hash \u003d (19 * hash) + getDescriptor().hashCode();\r\n    if (hasId()) {\r\n        hash \u003d (37 * hash) + ID_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getId().hashCode();\r\n    }\r\n    if (hasOuterMessage()) {\r\n        hash \u003d (37 * hash) + OUTER_MESSAGE_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getOuterMessage().hashCode();\r\n    }\r\n    if (hasInnerMessage1()) {\r\n        hash \u003d (37 * hash) + INNER_MESSAGE_1_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getInnerMessage1().hashCode();\r\n    }\r\n    if (hasInnerMessage2()) {\r\n        hash \u003d (37 * hash) + INNER_MESSAGE_2_FIELD_NUMBER;\r\n        hash \u003d (53 * hash) + getInnerMessage2().hashCode();\r\n    }\r\n    hash \u003d (29 * hash) + unknownFields.hashCode();\r\n    memoizedHashCode \u003d hash;\r\n    return hash;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "hashCode",
      "parameterTypes": [],
      "returnType": "int"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.nio.ByteBuffer",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.ByteString",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return PARSER.parseFrom(data, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseFrom",
      "parameterTypes": [
        "byte[]",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseDelimitedFrom",
      "parameterTypes": [
        "java.io.InputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parseFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder newBuilderForType() {\r\n    return newBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "newBuilderForType",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder() {\r\n    return DEFAULT_INSTANCE.toBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "newBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static Builder newBuilder(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations prototype) {\r\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "newBuilder",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder toBuilder() {\r\n    return this \u003d\u003d DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "toBuilder",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\r\n    Builder builder \u003d new Builder(parent);\r\n    return builder;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "newBuilderForType",
      "parameterTypes": [
        "com.google.protobuf.GeneratedMessageV3.BuilderParent"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\nprotected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_fieldAccessorTable.ensureFieldAccessorsInitialized(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.class, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder.class);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "internalGetFieldAccessorTable",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.GeneratedMessageV3.FieldAccessorTable"
    }
  },
  {
    "sourceCode": "private void maybeForceBuilderInitialization() {\r\n    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {\r\n        getOuterMessageFieldBuilder();\r\n        getInnerMessage1FieldBuilder();\r\n        getInnerMessage2FieldBuilder();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "maybeForceBuilderInitialization",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clear() {\r\n    super.clear();\r\n    id_ \u003d \"\";\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    if (outerMessageBuilder_ \u003d\u003d null) {\r\n        outerMessage_ \u003d null;\r\n    } else {\r\n        outerMessageBuilder_.clear();\r\n    }\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    if (innerMessage1Builder_ \u003d\u003d null) {\r\n        innerMessage1_ \u003d null;\r\n    } else {\r\n        innerMessage1Builder_.clear();\r\n    }\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n    if (innerMessage2Builder_ \u003d\u003d null) {\r\n        innerMessage2_ \u003d null;\r\n    } else {\r\n        innerMessage2Builder_.clear();\r\n    }\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000008);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "clear",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {\r\n    return com.google.gson.protobuf.generated.Bag.internal_static_google_gson_protobuf_generated_ProtoWithAnnotations_descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getDescriptorForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.Descriptor"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations getDefaultInstanceForType() {\r\n    return com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.getDefaultInstance();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations build() {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations result \u003d buildPartial();\r\n    if (!result.isInitialized()) {\r\n        throw newUninitializedMessageException(result);\r\n    }\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "build",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations buildPartial() {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations result \u003d new com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations(this);\r\n    int from_bitField0_ \u003d bitField0_;\r\n    int to_bitField0_ \u003d 0;\r\n    if (((from_bitField0_ \u0026 0x00000001) !\u003d 0)) {\r\n        to_bitField0_ |\u003d 0x00000001;\r\n    }\r\n    result.id_ \u003d id_;\r\n    if (((from_bitField0_ \u0026 0x00000002) !\u003d 0)) {\r\n        if (outerMessageBuilder_ \u003d\u003d null) {\r\n            result.outerMessage_ \u003d outerMessage_;\r\n        } else {\r\n            result.outerMessage_ \u003d outerMessageBuilder_.build();\r\n        }\r\n        to_bitField0_ |\u003d 0x00000002;\r\n    }\r\n    if (((from_bitField0_ \u0026 0x00000004) !\u003d 0)) {\r\n        if (innerMessage1Builder_ \u003d\u003d null) {\r\n            result.innerMessage1_ \u003d innerMessage1_;\r\n        } else {\r\n            result.innerMessage1_ \u003d innerMessage1Builder_.build();\r\n        }\r\n        to_bitField0_ |\u003d 0x00000004;\r\n    }\r\n    if (((from_bitField0_ \u0026 0x00000008) !\u003d 0)) {\r\n        if (innerMessage2Builder_ \u003d\u003d null) {\r\n            result.innerMessage2_ \u003d innerMessage2_;\r\n        } else {\r\n            result.innerMessage2_ \u003d innerMessage2Builder_.build();\r\n        }\r\n        to_bitField0_ |\u003d 0x00000008;\r\n    }\r\n    result.bitField0_ \u003d to_bitField0_;\r\n    onBuilt();\r\n    return result;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "buildPartial",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clone() {\r\n    return super.clone();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "clone",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.setField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {\r\n    return super.clearField(field);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "clearField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {\r\n    return super.clearOneof(oneof);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "clearOneof",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.OneofDescriptor"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {\r\n    return super.setRepeatedField(field, index, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "int",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {\r\n    return super.addRepeatedField(field, value);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "addRepeatedField",
      "parameterTypes": [
        "com.google.protobuf.Descriptors.FieldDescriptor",
        "java.lang.Object"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.Message other) {\r\n    if (other instanceof com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations) {\r\n        return mergeFrom((com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations) other);\r\n    } else {\r\n        super.mergeFrom(other);\r\n        return this;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.Message"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public Builder mergeFrom(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations other) {\r\n    if (other \u003d\u003d com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.getDefaultInstance())\r\n        return this;\r\n    if (other.hasId()) {\r\n        bitField0_ |\u003d 0x00000001;\r\n        id_ \u003d other.id_;\r\n        onChanged();\r\n    }\r\n    if (other.hasOuterMessage()) {\r\n        mergeOuterMessage(other.getOuterMessage());\r\n    }\r\n    if (other.hasInnerMessage1()) {\r\n        mergeInnerMessage1(other.getInnerMessage1());\r\n    }\r\n    if (other.hasInnerMessage2()) {\r\n        mergeInnerMessage2(other.getInnerMessage2());\r\n    }\r\n    this.mergeUnknownFields(other.unknownFields);\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final boolean isInitialized() {\r\n    return true;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "isInitialized",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {\r\n    com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations parsedMessage \u003d null;\r\n    try {\r\n        parsedMessage \u003d PARSER.parsePartialFrom(input, extensionRegistry);\r\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\r\n        parsedMessage \u003d (com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations) e.getUnfinishedMessage();\r\n        throw e.unwrapIOException();\r\n    } finally {\r\n        if (parsedMessage !\u003d null) {\r\n            mergeFrom(parsedMessage);\r\n        }\r\n    }\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "mergeFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @return Whether the id field is set.\r\n */\r\npublic boolean hasId() {\r\n    return ((bitField0_ \u0026 0x00000001) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "hasId",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @return The id.\r\n */\r\npublic java.lang.String getId() {\r\n    java.lang.Object ref \u003d id_;\r\n    if (!(ref instanceof java.lang.String)) {\r\n        com.google.protobuf.ByteString bs \u003d (com.google.protobuf.ByteString) ref;\r\n        java.lang.String s \u003d bs.toStringUtf8();\r\n        if (bs.isValidUtf8()) {\r\n            id_ \u003d s;\r\n        }\r\n        return s;\r\n    } else {\r\n        return (java.lang.String) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getId",
      "parameterTypes": [],
      "returnType": "java.lang.String"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @return The bytes for id.\r\n */\r\npublic com.google.protobuf.ByteString getIdBytes() {\r\n    java.lang.Object ref \u003d id_;\r\n    if (ref instanceof String) {\r\n        com.google.protobuf.ByteString b \u003d com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);\r\n        id_ \u003d b;\r\n        return b;\r\n    } else {\r\n        return (com.google.protobuf.ByteString) ref;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getIdBytes",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.ByteString"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @param value The id to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setId(java.lang.String value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000001;\r\n    id_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setId",
      "parameterTypes": [
        "java.lang.String"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @return This builder for chaining.\r\n */\r\npublic Builder clearId() {\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000001);\r\n    id_ \u003d getDefaultInstance().getId();\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "clearId",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional string id \u003d 1;\u003c/code\u003e\r\n * @param value The bytes for id to set.\r\n * @return This builder for chaining.\r\n */\r\npublic Builder setIdBytes(com.google.protobuf.ByteString value) {\r\n    if (value \u003d\u003d null) {\r\n        throw new NullPointerException();\r\n    }\r\n    bitField0_ |\u003d 0x00000001;\r\n    id_ \u003d value;\r\n    onChanged();\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setIdBytes",
      "parameterTypes": [
        "com.google.protobuf.ByteString"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n * @return Whether the outerMessage field is set.\r\n */\r\npublic boolean hasOuterMessage() {\r\n    return ((bitField0_ \u0026 0x00000002) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "hasOuterMessage",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n * @return The outerMessage.\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.OuterMessage getOuterMessage() {\r\n    if (outerMessageBuilder_ \u003d\u003d null) {\r\n        return outerMessage_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.OuterMessage.getDefaultInstance() : outerMessage_;\r\n    } else {\r\n        return outerMessageBuilder_.getMessage();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getOuterMessage",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n */\r\npublic Builder setOuterMessage(com.google.gson.protobuf.generated.Bag.OuterMessage value) {\r\n    if (outerMessageBuilder_ \u003d\u003d null) {\r\n        if (value \u003d\u003d null) {\r\n            throw new NullPointerException();\r\n        }\r\n        outerMessage_ \u003d value;\r\n        onChanged();\r\n    } else {\r\n        outerMessageBuilder_.setMessage(value);\r\n    }\r\n    bitField0_ |\u003d 0x00000002;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setOuterMessage",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.OuterMessage"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n */\r\npublic Builder setOuterMessage(com.google.gson.protobuf.generated.Bag.OuterMessage.Builder builderForValue) {\r\n    if (outerMessageBuilder_ \u003d\u003d null) {\r\n        outerMessage_ \u003d builderForValue.build();\r\n        onChanged();\r\n    } else {\r\n        outerMessageBuilder_.setMessage(builderForValue.build());\r\n    }\r\n    bitField0_ |\u003d 0x00000002;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setOuterMessage",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n */\r\npublic Builder mergeOuterMessage(com.google.gson.protobuf.generated.Bag.OuterMessage value) {\r\n    if (outerMessageBuilder_ \u003d\u003d null) {\r\n        if (((bitField0_ \u0026 0x00000002) !\u003d 0) \u0026\u0026 outerMessage_ !\u003d null \u0026\u0026 outerMessage_ !\u003d com.google.gson.protobuf.generated.Bag.OuterMessage.getDefaultInstance()) {\r\n            outerMessage_ \u003d com.google.gson.protobuf.generated.Bag.OuterMessage.newBuilder(outerMessage_).mergeFrom(value).buildPartial();\r\n        } else {\r\n            outerMessage_ \u003d value;\r\n        }\r\n        onChanged();\r\n    } else {\r\n        outerMessageBuilder_.mergeFrom(value);\r\n    }\r\n    bitField0_ |\u003d 0x00000002;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "mergeOuterMessage",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.OuterMessage"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n */\r\npublic Builder clearOuterMessage() {\r\n    if (outerMessageBuilder_ \u003d\u003d null) {\r\n        outerMessage_ \u003d null;\r\n        onChanged();\r\n    } else {\r\n        outerMessageBuilder_.clear();\r\n    }\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000002);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "clearOuterMessage",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.OuterMessage.Builder getOuterMessageBuilder() {\r\n    bitField0_ |\u003d 0x00000002;\r\n    onChanged();\r\n    return getOuterMessageFieldBuilder().getBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getOuterMessageBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessage.Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder getOuterMessageOrBuilder() {\r\n    if (outerMessageBuilder_ !\u003d null) {\r\n        return outerMessageBuilder_.getMessageOrBuilder();\r\n    } else {\r\n        return outerMessage_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.OuterMessage.getDefaultInstance() : outerMessage_;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getOuterMessageOrBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.OuterMessage outer_message \u003d 2 [(.google.gson.protobuf.generated.serialized_name) \u003d \"expiration_date\"];\u003c/code\u003e\r\n */\r\nprivate com.google.protobuf.SingleFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.OuterMessage, com.google.gson.protobuf.generated.Bag.OuterMessage.Builder, com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder\u003e getOuterMessageFieldBuilder() {\r\n    if (outerMessageBuilder_ \u003d\u003d null) {\r\n        outerMessageBuilder_ \u003d new com.google.protobuf.SingleFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.OuterMessage, com.google.gson.protobuf.generated.Bag.OuterMessage.Builder, com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder\u003e(getOuterMessage(), getParentForChildren(), isClean());\r\n        outerMessage_ \u003d null;\r\n    }\r\n    return outerMessageBuilder_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getOuterMessageFieldBuilder",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.SingleFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.OuterMessage, com.google.gson.protobuf.generated.Bag.OuterMessage.Builder, com.google.gson.protobuf.generated.Bag.OuterMessageOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n * @return Whether the innerMessage1 field is set.\r\n */\r\npublic boolean hasInnerMessage1() {\r\n    return ((bitField0_ \u0026 0x00000004) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "hasInnerMessage1",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n * @return The innerMessage1.\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage getInnerMessage1() {\r\n    if (innerMessage1Builder_ \u003d\u003d null) {\r\n        return innerMessage1_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance() : innerMessage1_;\r\n    } else {\r\n        return innerMessage1Builder_.getMessage();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getInnerMessage1",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n */\r\npublic Builder setInnerMessage1(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage value) {\r\n    if (innerMessage1Builder_ \u003d\u003d null) {\r\n        if (value \u003d\u003d null) {\r\n            throw new NullPointerException();\r\n        }\r\n        innerMessage1_ \u003d value;\r\n        onChanged();\r\n    } else {\r\n        innerMessage1Builder_.setMessage(value);\r\n    }\r\n    bitField0_ |\u003d 0x00000004;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setInnerMessage1",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n */\r\npublic Builder setInnerMessage1(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder builderForValue) {\r\n    if (innerMessage1Builder_ \u003d\u003d null) {\r\n        innerMessage1_ \u003d builderForValue.build();\r\n        onChanged();\r\n    } else {\r\n        innerMessage1Builder_.setMessage(builderForValue.build());\r\n    }\r\n    bitField0_ |\u003d 0x00000004;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setInnerMessage1",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n */\r\npublic Builder mergeInnerMessage1(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage value) {\r\n    if (innerMessage1Builder_ \u003d\u003d null) {\r\n        if (((bitField0_ \u0026 0x00000004) !\u003d 0) \u0026\u0026 innerMessage1_ !\u003d null \u0026\u0026 innerMessage1_ !\u003d com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance()) {\r\n            innerMessage1_ \u003d com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.newBuilder(innerMessage1_).mergeFrom(value).buildPartial();\r\n        } else {\r\n            innerMessage1_ \u003d value;\r\n        }\r\n        onChanged();\r\n    } else {\r\n        innerMessage1Builder_.mergeFrom(value);\r\n    }\r\n    bitField0_ |\u003d 0x00000004;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "mergeInnerMessage1",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n */\r\npublic Builder clearInnerMessage1() {\r\n    if (innerMessage1Builder_ \u003d\u003d null) {\r\n        innerMessage1_ \u003d null;\r\n        onChanged();\r\n    } else {\r\n        innerMessage1Builder_.clear();\r\n    }\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000004);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "clearInnerMessage1",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder getInnerMessage1Builder() {\r\n    bitField0_ |\u003d 0x00000004;\r\n    onChanged();\r\n    return getInnerMessage1FieldBuilder().getBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getInnerMessage1Builder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder getInnerMessage1OrBuilder() {\r\n    if (innerMessage1Builder_ !\u003d null) {\r\n        return innerMessage1Builder_.getMessageOrBuilder();\r\n    } else {\r\n        return innerMessage1_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance() : innerMessage1_;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getInnerMessage1OrBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 \u003d 3;\u003c/code\u003e\r\n */\r\nprivate com.google.protobuf.SingleFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder\u003e getInnerMessage1FieldBuilder() {\r\n    if (innerMessage1Builder_ \u003d\u003d null) {\r\n        innerMessage1Builder_ \u003d new com.google.protobuf.SingleFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder\u003e(getInnerMessage1(), getParentForChildren(), isClean());\r\n        innerMessage1_ \u003d null;\r\n    }\r\n    return innerMessage1Builder_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getInnerMessage1FieldBuilder",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.SingleFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n * @return Whether the innerMessage2 field is set.\r\n */\r\npublic boolean hasInnerMessage2() {\r\n    return ((bitField0_ \u0026 0x00000008) !\u003d 0);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "hasInnerMessage2",
      "parameterTypes": [],
      "returnType": "boolean"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n * @return The innerMessage2.\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage getInnerMessage2() {\r\n    if (innerMessage2Builder_ \u003d\u003d null) {\r\n        return innerMessage2_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance() : innerMessage2_;\r\n    } else {\r\n        return innerMessage2Builder_.getMessage();\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getInnerMessage2",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n */\r\npublic Builder setInnerMessage2(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage value) {\r\n    if (innerMessage2Builder_ \u003d\u003d null) {\r\n        if (value \u003d\u003d null) {\r\n            throw new NullPointerException();\r\n        }\r\n        innerMessage2_ \u003d value;\r\n        onChanged();\r\n    } else {\r\n        innerMessage2Builder_.setMessage(value);\r\n    }\r\n    bitField0_ |\u003d 0x00000008;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setInnerMessage2",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n */\r\npublic Builder setInnerMessage2(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder builderForValue) {\r\n    if (innerMessage2Builder_ \u003d\u003d null) {\r\n        innerMessage2_ \u003d builderForValue.build();\r\n        onChanged();\r\n    } else {\r\n        innerMessage2Builder_.setMessage(builderForValue.build());\r\n    }\r\n    bitField0_ |\u003d 0x00000008;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setInnerMessage2",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n */\r\npublic Builder mergeInnerMessage2(com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage value) {\r\n    if (innerMessage2Builder_ \u003d\u003d null) {\r\n        if (((bitField0_ \u0026 0x00000008) !\u003d 0) \u0026\u0026 innerMessage2_ !\u003d null \u0026\u0026 innerMessage2_ !\u003d com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance()) {\r\n            innerMessage2_ \u003d com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.newBuilder(innerMessage2_).mergeFrom(value).buildPartial();\r\n        } else {\r\n            innerMessage2_ \u003d value;\r\n        }\r\n        onChanged();\r\n    } else {\r\n        innerMessage2Builder_.mergeFrom(value);\r\n    }\r\n    bitField0_ |\u003d 0x00000008;\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "mergeInnerMessage2",
      "parameterTypes": [
        "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n */\r\npublic Builder clearInnerMessage2() {\r\n    if (innerMessage2Builder_ \u003d\u003d null) {\r\n        innerMessage2_ \u003d null;\r\n        onChanged();\r\n    } else {\r\n        innerMessage2Builder_.clear();\r\n    }\r\n    bitField0_ \u003d (bitField0_ \u0026 ~0x00000008);\r\n    return this;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "clearInnerMessage2",
      "parameterTypes": [],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder getInnerMessage2Builder() {\r\n    bitField0_ |\u003d 0x00000008;\r\n    onChanged();\r\n    return getInnerMessage2FieldBuilder().getBuilder();\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getInnerMessage2Builder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n */\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder getInnerMessage2OrBuilder() {\r\n    if (innerMessage2Builder_ !\u003d null) {\r\n        return innerMessage2Builder_.getMessageOrBuilder();\r\n    } else {\r\n        return innerMessage2_ \u003d\u003d null ? com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.getDefaultInstance() : innerMessage2_;\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getInnerMessage2OrBuilder",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder"
    }
  },
  {
    "sourceCode": "/**\r\n * \u003ccode\u003eoptional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 \u003d 4;\u003c/code\u003e\r\n */\r\nprivate com.google.protobuf.SingleFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder\u003e getInnerMessage2FieldBuilder() {\r\n    if (innerMessage2Builder_ \u003d\u003d null) {\r\n        innerMessage2Builder_ \u003d new com.google.protobuf.SingleFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder\u003e(getInnerMessage2(), getParentForChildren(), isClean());\r\n        innerMessage2_ \u003d null;\r\n    }\r\n    return innerMessage2Builder_;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "getInnerMessage2FieldBuilder",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.SingleFieldBuilderV3\u003ccom.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Builder, com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessageOrBuilder\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.setUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "setUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {\r\n    return super.mergeUnknownFields(unknownFields);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.Builder",
      "methodName": "mergeUnknownFields",
      "parameterTypes": [
        "com.google.protobuf.UnknownFieldSet"
      ],
      "returnType": "Builder"
    }
  },
  {
    "sourceCode": "public static com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations getDefaultInstance() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getDefaultInstance",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic ProtoWithAnnotations parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {\r\n    return new ProtoWithAnnotations(input, extensionRegistry);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parsePartialFrom",
      "parameterTypes": [
        "com.google.protobuf.CodedInputStream",
        "com.google.protobuf.ExtensionRegistryLite"
      ],
      "returnType": "ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.protobuf.Parser\u003cProtoWithAnnotations\u003e parser() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "parser",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cProtoWithAnnotations\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.protobuf.Parser\u003cProtoWithAnnotations\u003e getParserForType() {\r\n    return PARSER;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getParserForType",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Parser\u003cProtoWithAnnotations\u003e"
    }
  },
  {
    "sourceCode": "@java.lang.Override\r\npublic com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations getDefaultInstanceForType() {\r\n    return DEFAULT_INSTANCE;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations",
      "methodName": "getDefaultInstanceForType",
      "parameterTypes": [],
      "returnType": "com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations"
    }
  },
  {
    "sourceCode": "public static com.google.protobuf.Descriptors.FileDescriptor getDescriptor() {\r\n    return descriptor;\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.protobuf.generated.Bag",
      "methodName": "getDescriptor",
      "parameterTypes": [],
      "returnType": "com.google.protobuf.Descriptors.FileDescriptor"
    }
  },
  {
    "sourceCode": "@Override\r\npublic ClassWithAdapter read(JsonReader in) throws IOException {\r\n    in.beginObject();\r\n    String name \u003d in.nextName();\r\n    if (!name.equals(\"custom\")) {\r\n        throw new IllegalArgumentException(\"Unexpected name: \" + name);\r\n    }\r\n    int i \u003d in.nextInt();\r\n    in.endObject();\r\n    return new ClassWithAdapter(i);\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithAdapter.Adapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "ClassWithAdapter"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, ClassWithAdapter value) throws IOException {\r\n    out.beginObject();\r\n    out.name(\"custom\");\r\n    out.value(value.i);\r\n    out.endObject();\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithAdapter.Adapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "ClassWithAdapter"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"ClassWithAdapter[\" + i + \"]\";\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithAdapter",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"ClassWithJsonAdapterAnnotation[f1\u003d\" + f1 + \", f2\u003d\" + f2 + \", f3\u003d\" + f3 + \", f4\u003d\" + f4 + \"]\";\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithJsonAdapterAnnotation",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic DummyClass read(JsonReader in) throws IOException {\r\n    return new DummyClass(\"adapter-\" + in.nextInt());\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithJsonAdapterAnnotation.Adapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "DummyClass"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, DummyClass value) throws IOException {\r\n    out.value(\"adapter-\" + value);\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithJsonAdapterAnnotation.Adapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "DummyClass"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic DummyClass read(JsonReader in) throws IOException {\r\n    return new DummyClass(\"factory-\" + in.nextInt());\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithJsonAdapterAnnotation.Factory",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "DummyClass"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, DummyClass value) throws IOException {\r\n    out.value(\"factory-\" + value.s);\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithJsonAdapterAnnotation.Factory",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "DummyClass"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Override\r\npublic \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n    // the code below is not type-safe, but does not matter for this test\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cT\u003e r \u003d (TypeAdapter\u003cT\u003e) new TypeAdapter\u003cDummyClass\u003e() {\r\n\r\n        @Override\r\n        public DummyClass read(JsonReader in) throws IOException {\r\n            return new DummyClass(\"factory-\" + in.nextInt());\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, DummyClass value) throws IOException {\r\n            out.value(\"factory-\" + value.s);\r\n        }\r\n    };\r\n    return r;\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithJsonAdapterAnnotation.Factory",
      "methodName": "create",
      "parameterTypes": [
        "Gson",
        "TypeToken\u003cT\u003e"
      ],
      "returnType": "TypeAdapter\u003cT\u003e"
    }
  },
  {
    "sourceCode": "@Override\r\npublic JsonElement serialize(DummyClass src, Type typeOfSrc, JsonSerializationContext context) {\r\n    return new JsonPrimitive(\"serializer-\" + src.s);\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithJsonAdapterAnnotation.Serializer",
      "methodName": "serialize",
      "parameterTypes": [
        "DummyClass",
        "Type",
        "JsonSerializationContext"
      ],
      "returnType": "JsonElement"
    }
  },
  {
    "sourceCode": "@Override\r\npublic DummyClass deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n    return new DummyClass(\"deserializer-\" + json.getAsInt());\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithJsonAdapterAnnotation.Deserializer",
      "methodName": "deserialize",
      "parameterTypes": [
        "JsonElement",
        "Type",
        "JsonDeserializationContext"
      ],
      "returnType": "DummyClass"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return s;\r\n}",
    "methodIdentifier": {
      "className": "com.example.ClassWithJsonAdapterAnnotation.DummyClass",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"{t\u003d\" + t + \"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.example.GenericClasses.GenericClass",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"{g\u003d\" + g + \"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.example.GenericClasses.UsingGenericClass",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return \"{g\u003d\" + g + \"}\";\r\n}",
    "methodIdentifier": {
      "className": "com.example.GenericClasses.GenericUsingGenericClass",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic String toString() {\r\n    return s;\r\n}",
    "methodIdentifier": {
      "className": "com.example.GenericClasses.DummyClass",
      "methodName": "toString",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "@Override\r\npublic DummyClass read(JsonReader in) throws IOException {\r\n    return new DummyClass(\"read-\" + in.nextInt());\r\n}",
    "methodIdentifier": {
      "className": "com.example.GenericClasses.DummyClass.Adapter",
      "methodName": "read",
      "parameterTypes": [
        "JsonReader"
      ],
      "returnType": "DummyClass"
    }
  },
  {
    "sourceCode": "@Override\r\npublic void write(JsonWriter out, DummyClass value) throws IOException {\r\n    throw new UnsupportedOperationException();\r\n}",
    "methodIdentifier": {
      "className": "com.example.GenericClasses.DummyClass.Adapter",
      "methodName": "write",
      "parameterTypes": [
        "JsonWriter",
        "DummyClass"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Main entrypoint, called by {@code ShrinkingIT.test()}.\r\n *\r\n * \u003cp\u003eTo be safe let all tests put their output to the consumer and let integration test verify it;\r\n * don\u0027t perform any relevant assertions in this code because code shrinkers could affect it.\r\n *\r\n * @param outputConsumer consumes the test output: {@code name, content} pairs\r\n */\r\npublic static void runTests(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    // Create the TypeToken instances on demand because creation of them can fail when\r\n    // generic signatures were erased\r\n    testTypeTokenWriteRead(outputConsumer, \"anonymous\", () -\u003e new TypeToken\u003cList\u003cClassWithAdapter\u003e\u003e() {\r\n    });\r\n    testTypeTokenWriteRead(outputConsumer, \"manual\", () -\u003e TypeToken.getParameterized(List.class, ClassWithAdapter.class));\r\n    testNamedFields(outputConsumer);\r\n    testSerializedName(outputConsumer);\r\n    testConstructorNoArgs(outputConsumer);\r\n    testConstructorHasArgs(outputConsumer);\r\n    testUnreferencedConstructorNoArgs(outputConsumer);\r\n    testUnreferencedConstructorHasArgs(outputConsumer);\r\n    testNoJdkUnsafe(outputConsumer);\r\n    testEnum(outputConsumer);\r\n    testEnumSerializedName(outputConsumer);\r\n    testExposeAnnotation(outputConsumer);\r\n    testVersionAnnotations(outputConsumer);\r\n    testJsonAdapterAnnotation(outputConsumer);\r\n    testGenericClasses(outputConsumer);\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "runTests",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testTypeTokenWriteRead(BiConsumer\u003cString, String\u003e outputConsumer, String description, Supplier\u003cTypeToken\u003c?\u003e\u003e typeTokenSupplier) {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: TypeToken \" + description, () -\u003e gson.toJson(Arrays.asList(new ClassWithAdapter(1)), typeTokenSupplier.get().getType()));\r\n    TestExecutor.run(outputConsumer, \"Read: TypeToken \" + description, () -\u003e {\r\n        Object deserialized \u003d gson.fromJson(\"[{\\\"custom\\\": 3}]\", typeTokenSupplier.get());\r\n        return deserialized.toString();\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testTypeTokenWriteRead",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e",
        "String",
        "Supplier\u003cTypeToken\u003c?\u003e\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Calls {@link Gson#toJson}, but (hopefully) in a way which prevents code shrinkers\r\n * from understanding that reflection is used for {@code obj}.\r\n */\r\nprivate static String toJson(Gson gson, Object obj) {\r\n    return gson.toJson(same(obj));\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "toJson",
      "parameterTypes": [
        "Gson",
        "Object"
      ],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Calls {@link Gson#fromJson}, but (hopefully) in a way which prevents code shrinkers\r\n * from understanding that reflection is used for {@code c}.\r\n */\r\nprivate static \u003cT\u003e T fromJson(Gson gson, String json, Class\u003cT\u003e c) {\r\n    return gson.fromJson(json, same(c));\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "fromJson",
      "parameterTypes": [
        "Gson",
        "String",
        "Class\u003cT\u003e"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "private static void testNamedFields(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Named fields\", () -\u003e toJson(gson, new ClassWithNamedFields(2)));\r\n    TestExecutor.run(outputConsumer, \"Read: Named fields\", () -\u003e {\r\n        ClassWithNamedFields deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithNamedFields.class);\r\n        return Integer.toString(deserialized.myField);\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testNamedFields",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testSerializedName(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: SerializedName\", () -\u003e toJson(gson, new ClassWithSerializedName(2)));\r\n    TestExecutor.run(outputConsumer, \"Read: SerializedName\", () -\u003e {\r\n        ClassWithSerializedName deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithSerializedName.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testSerializedName",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testConstructorNoArgs(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: No args constructor\", () -\u003e toJson(gson, new ClassWithNoArgsConstructor()));\r\n    TestExecutor.run(outputConsumer, \"Read: No args constructor; initial constructor value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n    TestExecutor.run(outputConsumer, \"Read: No args constructor; custom value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testConstructorNoArgs",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testConstructorHasArgs(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Constructor with args\", () -\u003e toJson(gson, new ClassWithHasArgsConstructor(2)));\r\n    // This most likely relies on JDK Unsafe (unless the shrinker rewrites the constructor in some way)\r\n    TestExecutor.run(outputConsumer, \"Read: Constructor with args\", () -\u003e {\r\n        ClassWithHasArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithHasArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testConstructorHasArgs",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testUnreferencedConstructorNoArgs(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    // No write because we\u0027re not referencing this class\u0027s constructor.\r\n    // This runs the no-args constructor.\r\n    TestExecutor.run(outputConsumer, \"Read: Unreferenced no args constructor; initial constructor value\", () -\u003e {\r\n        ClassWithUnreferencedNoArgsConstructor deserialized \u003d fromJson(gson, \"{}\", ClassWithUnreferencedNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n    TestExecutor.run(outputConsumer, \"Read: Unreferenced no args constructor; custom value\", () -\u003e {\r\n        ClassWithUnreferencedNoArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithUnreferencedNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testUnreferencedConstructorNoArgs",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testUnreferencedConstructorHasArgs(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    // No write because we\u0027re not referencing this class\u0027s constructor.\r\n    // This most likely relies on JDK Unsafe (unless the shrinker rewrites the constructor in some way)\r\n    TestExecutor.run(outputConsumer, \"Read: Unreferenced constructor with args\", () -\u003e {\r\n        ClassWithUnreferencedHasArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithUnreferencedHasArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testUnreferencedConstructorHasArgs",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testNoJdkUnsafe(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().disableJdkUnsafe().create();\r\n    TestExecutor.run(outputConsumer, \"Read: No JDK Unsafe; initial constructor value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n    TestExecutor.run(outputConsumer, \"Read: No JDK Unsafe; custom value\", () -\u003e {\r\n        ClassWithNoArgsConstructor deserialized \u003d fromJson(gson, \"{\\\"myField\\\": 3}\", ClassWithNoArgsConstructor.class);\r\n        return Integer.toString(deserialized.i);\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testNoJdkUnsafe",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testEnum(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Enum\", () -\u003e toJson(gson, EnumClass.FIRST));\r\n    TestExecutor.run(outputConsumer, \"Read: Enum\", () -\u003e fromJson(gson, \"\\\"SECOND\\\"\", EnumClass.class).toString());\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testEnum",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testEnumSerializedName(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: Enum SerializedName\", () -\u003e toJson(gson, EnumClassWithSerializedName.FIRST));\r\n    TestExecutor.run(outputConsumer, \"Read: Enum SerializedName\", () -\u003e fromJson(gson, \"\\\"two\\\"\", EnumClassWithSerializedName.class).toString());\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testEnumSerializedName",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testExposeAnnotation(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();\r\n    TestExecutor.run(outputConsumer, \"Write: @Expose\", () -\u003e toJson(gson, new ClassWithExposeAnnotation()));\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testExposeAnnotation",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testVersionAnnotations(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().setVersion(1).create();\r\n    TestExecutor.run(outputConsumer, \"Write: Version annotations\", () -\u003e toJson(gson, new ClassWithVersionAnnotations()));\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testVersionAnnotations",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testJsonAdapterAnnotation(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new GsonBuilder().setPrettyPrinting().create();\r\n    TestExecutor.run(outputConsumer, \"Write: JsonAdapter on fields\", () -\u003e toJson(gson, new ClassWithJsonAdapterAnnotation(1, 2, 3, 4)));\r\n    String json \u003d \"{\\\"f1\\\": 1, \\\"f2\\\": 2, \\\"f3\\\": {\\\"s\\\": \\\"3\\\"}, \\\"f4\\\": 4}\";\r\n    TestExecutor.run(outputConsumer, \"Read: JsonAdapter on fields\", () -\u003e fromJson(gson, json, ClassWithJsonAdapterAnnotation.class).toString());\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testJsonAdapterAnnotation",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private static void testGenericClasses(BiConsumer\u003cString, String\u003e outputConsumer) {\r\n    Gson gson \u003d new Gson();\r\n    TestExecutor.run(outputConsumer, \"Read: Generic TypeToken\", () -\u003e gson.fromJson(\"{\\\"t\\\": 1}\", new TypeToken\u003cGenericClass\u003cDummyClass\u003e\u003e() {\r\n    }).toString());\r\n    TestExecutor.run(outputConsumer, \"Read: Using Generic\", () -\u003e fromJson(gson, \"{\\\"g\\\": {\\\"t\\\": 1}}\", UsingGenericClass.class).toString());\r\n    TestExecutor.run(outputConsumer, \"Read: Using Generic TypeToken\", () -\u003e gson.fromJson(\"{\\\"g\\\": {\\\"t\\\": 1}}\", new TypeToken\u003cGenericUsingGenericClass\u003cDummyClass\u003e\u003e() {\r\n    }).toString());\r\n}",
    "methodIdentifier": {
      "className": "com.example.Main",
      "methodName": "testGenericClasses",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Main entrypoint, called by {@code ShrinkingIT.testNoSerializedName_NoArgsConstructor()}.\r\n */\r\npublic static String runTestNoArgsConstructor() {\r\n    TestClassNoArgsConstructor deserialized \u003d new Gson().fromJson(\"{\\\"s\\\":\\\"value\\\"}\", same(TestClassNoArgsConstructor.class));\r\n    return deserialized.s;\r\n}",
    "methodIdentifier": {
      "className": "com.example.NoSerializedNameMain",
      "methodName": "runTestNoArgsConstructor",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Main entrypoint, called by {@code ShrinkingIT.testNoSerializedName_NoArgsConstructorNoJdkUnsafe()}.\r\n */\r\npublic static String runTestNoJdkUnsafe() {\r\n    Gson gson \u003d new GsonBuilder().disableJdkUnsafe().create();\r\n    TestClassNotAbstract deserialized \u003d gson.fromJson(\"{\\\"s\\\": \\\"value\\\"}\", same(TestClassNotAbstract.class));\r\n    return deserialized.s;\r\n}",
    "methodIdentifier": {
      "className": "com.example.NoSerializedNameMain",
      "methodName": "runTestNoJdkUnsafe",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Main entrypoint, called by {@code ShrinkingIT.testNoSerializedName_HasArgsConstructor()}.\r\n */\r\npublic static String runTestHasArgsConstructor() {\r\n    TestClassHasArgsConstructor deserialized \u003d new Gson().fromJson(\"{\\\"s\\\":\\\"value\\\"}\", same(TestClassHasArgsConstructor.class));\r\n    return deserialized.s;\r\n}",
    "methodIdentifier": {
      "className": "com.example.NoSerializedNameMain",
      "methodName": "runTestHasArgsConstructor",
      "parameterTypes": [],
      "returnType": "String"
    }
  },
  {
    "sourceCode": "/**\r\n * Helper method for running individual tests. In case of an exception wraps it and\r\n * includes the {@code name} of the test to make debugging issues with the obfuscated\r\n * JARs a bit easier.\r\n */\r\npublic static void run(BiConsumer\u003cString, String\u003e outputConsumer, String name, Supplier\u003cString\u003e resultSupplier) {\r\n    String result;\r\n    try {\r\n        result \u003d resultSupplier.get();\r\n    } catch (Throwable t) {\r\n        throw new RuntimeException(\"Test failed: \" + name, t);\r\n    }\r\n    outputConsumer.accept(name, result);\r\n}",
    "methodIdentifier": {
      "className": "com.example.TestExecutor",
      "methodName": "run",
      "parameterTypes": [
        "BiConsumer\u003cString, String\u003e",
        "String",
        "Supplier\u003cString\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "/**\r\n * Returns {@code t}, but in a way which (hopefully) prevents code shrinkers from\r\n * simplifying this.\r\n */\r\npublic static \u003cT\u003e T same(T t) {\r\n    // This is essentially `return t`, but contains some redundant code to try\r\n    // prevent the code shrinkers from simplifying this\r\n    return Optional.of(t).map(v -\u003e Optional.of(v).get()).orElseThrow(() -\u003e new AssertionError(\"unreachable\"));\r\n}",
    "methodIdentifier": {
      "className": "com.example.TestExecutor",
      "methodName": "same",
      "parameterTypes": [
        "T"
      ],
      "returnType": "T"
    }
  },
  {
    "sourceCode": "@Parameters(name \u003d \"{index}: {0}\")\r\npublic static List\u003cPath\u003e jarsToTest() {\r\n    return Arrays.asList(PROGUARD_RESULT_PATH, R8_RESULT_PATH);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.it.ShrinkingIT",
      "methodName": "jarsToTest",
      "parameterTypes": [],
      "returnType": "List\u003cPath\u003e"
    }
  },
  {
    "sourceCode": "@Before\r\npublic void verifyJarExists() {\r\n    if (!Files.isRegularFile(jarToTest)) {\r\n        fail(\"JAR file \" + jarToTest + \" does not exist; run this test with `mvn clean verify`\");\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.it.ShrinkingIT",
      "methodName": "verifyJarExists",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "void run(Class\u003c?\u003e c) throws Exception;",
    "methodIdentifier": {
      "className": "com.google.gson.it.ShrinkingIT.TestAction",
      "methodName": "run",
      "parameterTypes": [
        "Class\u003c?\u003e"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "private void runTest(String className, TestAction testAction) throws Exception {\r\n    // Use bootstrap class loader; load all custom classes from JAR and not\r\n    // from dependencies of this test\r\n    ClassLoader classLoader \u003d null;\r\n    // Load the shrunken and obfuscated JARs with a separate class loader, then load\r\n    // the main test class from it and let the test action invoke its test methods\r\n    try (URLClassLoader loader \u003d new URLClassLoader(new URL[] { jarToTest.toUri().toURL() }, classLoader)) {\r\n        Class\u003c?\u003e c \u003d loader.loadClass(className);\r\n        testAction.run(c);\r\n    }\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.it.ShrinkingIT",
      "methodName": "runTest",
      "parameterTypes": [
        "String",
        "TestAction"
      ],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void test() throws Exception {\r\n    StringBuilder output \u003d new StringBuilder();\r\n    runTest(\"com.example.Main\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTests\", BiConsumer.class);\r\n        m.invoke(null, (BiConsumer\u003cString, String\u003e) (name, content) -\u003e output.append(name + \"\\n\" + content + \"\\n\u003d\u003d\u003d\\n\"));\r\n    });\r\n    assertThat(output.toString()).isEqualTo(String.join(\"\\n\", \"Write: TypeToken anonymous\", \"[\", \"  {\", \"    \\\"custom\\\": 1\", \"  }\", \"]\", \"\u003d\u003d\u003d\", \"Read: TypeToken anonymous\", \"[ClassWithAdapter[3]]\", \"\u003d\u003d\u003d\", \"Write: TypeToken manual\", \"[\", \"  {\", \"    \\\"custom\\\": 1\", \"  }\", \"]\", \"\u003d\u003d\u003d\", \"Read: TypeToken manual\", \"[ClassWithAdapter[3]]\", \"\u003d\u003d\u003d\", \"Write: Named fields\", \"{\", \"  \\\"myField\\\": 2,\", \"  \\\"notAccessedField\\\": -1\", \"}\", \"\u003d\u003d\u003d\", \"Read: Named fields\", \"3\", \"\u003d\u003d\u003d\", \"Write: SerializedName\", \"{\", \"  \\\"myField\\\": 2,\", \"  \\\"notAccessed\\\": -1\", \"}\", \"\u003d\u003d\u003d\", \"Read: SerializedName\", \"3\", \"\u003d\u003d\u003d\", \"Write: No args constructor\", \"{\", \"  \\\"myField\\\": -3\", \"}\", \"\u003d\u003d\u003d\", \"Read: No args constructor; initial constructor value\", \"-3\", \"\u003d\u003d\u003d\", \"Read: No args constructor; custom value\", \"3\", \"\u003d\u003d\u003d\", \"Write: Constructor with args\", \"{\", \"  \\\"myField\\\": 2\", \"}\", \"\u003d\u003d\u003d\", \"Read: Constructor with args\", \"3\", \"\u003d\u003d\u003d\", \"Read: Unreferenced no args constructor; initial constructor value\", \"-3\", \"\u003d\u003d\u003d\", \"Read: Unreferenced no args constructor; custom value\", \"3\", \"\u003d\u003d\u003d\", \"Read: Unreferenced constructor with args\", \"3\", \"\u003d\u003d\u003d\", \"Read: No JDK Unsafe; initial constructor value\", \"-3\", \"\u003d\u003d\u003d\", \"Read: No JDK Unsafe; custom value\", \"3\", \"\u003d\u003d\u003d\", \"Write: Enum\", \"\\\"FIRST\\\"\", \"\u003d\u003d\u003d\", \"Read: Enum\", \"SECOND\", \"\u003d\u003d\u003d\", \"Write: Enum SerializedName\", \"\\\"one\\\"\", \"\u003d\u003d\u003d\", \"Read: Enum SerializedName\", \"SECOND\", \"\u003d\u003d\u003d\", \"Write: @Expose\", \"{\\\"i\\\":0}\", \"\u003d\u003d\u003d\", \"Write: Version annotations\", \"{\\\"i1\\\":0,\\\"i4\\\":0}\", \"\u003d\u003d\u003d\", \"Write: JsonAdapter on fields\", \"{\", \"  \\\"f\\\": \\\"adapter-null\\\",\", \"  \\\"f1\\\": \\\"adapter-1\\\",\", \"  \\\"f2\\\": \\\"factory-2\\\",\", \"  \\\"f3\\\": \\\"serializer-3\\\",\", // For f4 only a JsonDeserializer is registered, so serialization falls back to reflection\r\n    \"  \\\"f4\\\": {\", \"    \\\"s\\\": \\\"4\\\"\", \"  }\", \"}\", \"\u003d\u003d\u003d\", \"Read: JsonAdapter on fields\", // For f3 only a JsonSerializer is registered, so for deserialization value is read as is using reflection\r\n    \"ClassWithJsonAdapterAnnotation[f1\u003dadapter-1, f2\u003dfactory-2, f3\u003d3, f4\u003ddeserializer-4]\", \"\u003d\u003d\u003d\", \"Read: Generic TypeToken\", \"{t\u003dread-1}\", \"\u003d\u003d\u003d\", \"Read: Using Generic\", \"{g\u003d{t\u003dread-1}}\", \"\u003d\u003d\u003d\", \"Read: Using Generic TypeToken\", \"{g\u003d{t\u003dread-1}}\", \"\u003d\u003d\u003d\", \"\"));\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.it.ShrinkingIT",
      "methodName": "test",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNoSerializedName_NoArgsConstructor() throws Exception {\r\n    runTest(\"com.example.NoSerializedNameMain\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTestNoArgsConstructor\");\r\n        if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\r\n            Object result \u003d m.invoke(null);\r\n            assertThat(result).isEqualTo(\"value\");\r\n        } else {\r\n            // R8 performs more aggressive optimizations\r\n            Exception e \u003d assertThrows(InvocationTargetException.class, () -\u003e m.invoke(null));\r\n            assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Abstract classes can\u0027t be instantiated! Adjust the R8 configuration or register an InstanceCreator\" + \" or a TypeAdapter for this type. Class name: com.example.NoSerializedNameMain$TestClassNoArgsConstructor\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#r8-abstract-class\");\r\n        }\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.it.ShrinkingIT",
      "methodName": "testNoSerializedName_NoArgsConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNoSerializedName_NoArgsConstructorNoJdkUnsafe() throws Exception {\r\n    runTest(\"com.example.NoSerializedNameMain\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTestNoJdkUnsafe\");\r\n        if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\r\n            Object result \u003d m.invoke(null);\r\n            assertThat(result).isEqualTo(\"value\");\r\n        } else {\r\n            // R8 performs more aggressive optimizations\r\n            Exception e \u003d assertThrows(InvocationTargetException.class, () -\u003e m.invoke(null));\r\n            assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Unable to create instance of class com.example.NoSerializedNameMain$TestClassNotAbstract;\" + \" usage of JDK Unsafe is disabled. Registering an InstanceCreator or a TypeAdapter for this type,\" + \" adding a no-args constructor, or enabling usage of JDK Unsafe may fix this problem. Or adjust\" + \" your R8 configuration to keep the no-args constructor of the class.\");\r\n        }\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.it.ShrinkingIT",
      "methodName": "testNoSerializedName_NoArgsConstructorNoJdkUnsafe",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testNoSerializedName_HasArgsConstructor() throws Exception {\r\n    runTest(\"com.example.NoSerializedNameMain\", c -\u003e {\r\n        Method m \u003d c.getMethod(\"runTestHasArgsConstructor\");\r\n        if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\r\n            Object result \u003d m.invoke(null);\r\n            assertThat(result).isEqualTo(\"value\");\r\n        } else {\r\n            // R8 performs more aggressive optimizations\r\n            Exception e \u003d assertThrows(InvocationTargetException.class, () -\u003e m.invoke(null));\r\n            assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(\"Abstract classes can\u0027t be instantiated! Adjust the R8 configuration or register an InstanceCreator\" + \" or a TypeAdapter for this type. Class name: com.example.NoSerializedNameMain$TestClassHasArgsConstructor\" + \"\\nSee https://github.com/google/gson/blob/main/Troubleshooting.md#r8-abstract-class\");\r\n        }\r\n    });\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.it.ShrinkingIT",
      "methodName": "testNoSerializedName_HasArgsConstructor",
      "parameterTypes": [],
      "returnType": "void"
    }
  },
  {
    "sourceCode": "@Test\r\npublic void testUnusedClassRemoved() throws Exception {\r\n    // For some reason this test only works for R8 but not for ProGuard; ProGuard keeps the unused class\r\n    assumeTrue(jarToTest.equals(R8_RESULT_PATH));\r\n    String className \u003d UnusedClass.class.getName();\r\n    ClassNotFoundException e \u003d assertThrows(ClassNotFoundException.class, () -\u003e {\r\n        runTest(className, c -\u003e {\r\n            fail(\"Class should have been removed during shrinking: \" + c);\r\n        });\r\n    });\r\n    assertThat(e).hasMessageThat().contains(className);\r\n}",
    "methodIdentifier": {
      "className": "com.google.gson.it.ShrinkingIT",
      "methodName": "testUnusedClassRemoved",
      "parameterTypes": [],
      "returnType": "void"
    }
  }
]